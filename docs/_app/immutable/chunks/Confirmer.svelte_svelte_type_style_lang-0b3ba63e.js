import { b as base64Js, a as buffer$3 } from "./index-d12ac42e.js";
import { a as events$1 } from "./events-9be93652.js";
import "./preload-helper-6b8a655d.js";
import { S as SvelteComponent, i as init$1, s as safe_not_equal, F as create_slot, l as element, m as claim_element, n as children, h as detach, p as attr, b as insert_hydration, M as listen, G as update_slot_base, H as get_all_dirty_from_scope, I as get_slot_changes, f as transition_in, t as transition_out, a1 as prevent_default, N as is_function, a as space, r as text, c as claim_space, u as claim_text, J as append_hydration, a2 as run_all, v as set_data, w as create_component, x as claim_component, y as mount_component, B as destroy_component, T as binding_callbacks, a0 as bubble, e as empty, Y as destroy_each, a3 as null_to_empty, E as noop$2 } from "./index-644ae64b.js";
let wasm$1;
const heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
let WASM_VECTOR_LEN = 0;
let cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm$1.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
  }
  return cachegetUint8Memory0;
}
let cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127)
      break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
let cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm$1.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
  }
  return cachegetInt32Memory0;
}
let cachedTextDecoder = new TextDecoder("utf-8", {
  ignoreBOM: true,
  fatal: true
});
cachedTextDecoder.decode();
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function addHeapObject(obj2) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj2;
  return idx;
}
let cachegetFloat64Memory0 = null;
function getFloat64Memory0() {
  if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm$1.memory.buffer) {
    cachegetFloat64Memory0 = new Float64Array(wasm$1.memory.buffer);
  }
  return cachegetFloat64Memory0;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description2 = val.description;
    if (description2 == null) {
      return "Symbol";
    } else {
      return `Symbol(${description2})`;
    }
  }
  if (type == "function") {
    const name2 = val.name;
    if (typeof name2 == "string" && name2.length > 0) {
      return `Function(${name2})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length2 = val.length;
    let debug2 = "[";
    if (length2 > 0) {
      debug2 += debugString(val[0]);
    }
    for (let i = 1; i < length2; i++) {
      debug2 += ", " + debugString(val[i]);
    }
    debug2 += "]";
    return debug2;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function generate_mnemonic() {
  var ret = wasm$1.generate_mnemonic();
  return takeObject(ret);
}
function seed_to_proxcryptor(seed) {
  var ret = wasm$1.seed_to_proxcryptor(addHeapObject(seed));
  return Proxcryptor.__wrap(ret);
}
function mnemonic_to_proxcryptor(mnemonic_str) {
  var ptr0 = passStringToWasm0(
    mnemonic_str,
    wasm$1.__wbindgen_malloc,
    wasm$1.__wbindgen_realloc
  );
  var len0 = WASM_VECTOR_LEN;
  var ret = wasm$1.mnemonic_to_proxcryptor(ptr0, len0);
  return Proxcryptor.__wrap(ret);
}
function generate_ed25519_keypair() {
  var ret = wasm$1.generate_ed25519_keypair();
  return SimpleKeypair.__wrap(ret);
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function sign$1(secret_key_bytes, message) {
  try {
    const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
    var ptr0 = passArray8ToWasm0(message, wasm$1.__wbindgen_malloc);
    var len0 = WASM_VECTOR_LEN;
    wasm$1.sign(retptr, addHeapObject(secret_key_bytes), ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var v1 = getArrayU8FromWasm0(r0, r1).slice();
    wasm$1.__wbindgen_free(r0, r1 * 1);
    return v1;
  } finally {
    wasm$1.__wbindgen_add_to_stack_pointer(16);
  }
}
function verify(public_key, message, signature2) {
  var ret = wasm$1.verify(
    addHeapObject(public_key),
    addHeapObject(message),
    addHeapObject(signature2)
  );
  return ret !== 0;
}
function generate_ed25519_keypair_from_seed(secret2) {
  var ret = wasm$1.generate_ed25519_keypair_from_seed(addHeapObject(secret2));
  return SimpleKeypair.__wrap(ret);
}
function re_encrypt(target_keypair, encrypted_message, re_key) {
  var ret = wasm$1.re_encrypt(
    addHeapObject(target_keypair),
    addHeapObject(encrypted_message),
    addHeapObject(re_key)
  );
  return takeObject(ret);
}
function handleError(f2, args) {
  try {
    return f2.apply(this, args);
  } catch (e) {
    wasm$1.__wbindgen_exn_store(addHeapObject(e));
  }
}
class Proxcryptor {
  static __wrap(ptr) {
    const obj2 = Object.create(Proxcryptor.prototype);
    obj2.ptr = ptr;
    return obj2;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_proxcryptor_free(ptr);
  }
  static new(secret2) {
    var ret = wasm$1.proxcryptor_new(addHeapObject(secret2));
    return Proxcryptor.__wrap(ret);
  }
  public_key() {
    var ret = wasm$1.proxcryptor_public_key(this.ptr);
    return takeObject(ret);
  }
  public_key_base58() {
    var ret = wasm$1.proxcryptor_public_key_base58(this.ptr);
    return takeObject(ret);
  }
  public_key_jwk() {
    var ret = wasm$1.proxcryptor_public_key_jwk(this.ptr);
    return takeObject(ret);
  }
  self_encrypt(data2, tag) {
    var ptr0 = passArray8ToWasm0(data2, wasm$1.__wbindgen_malloc);
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = passStringToWasm0(
      tag,
      wasm$1.__wbindgen_malloc,
      wasm$1.__wbindgen_realloc
    );
    var len1 = WASM_VECTOR_LEN;
    var ret = wasm$1.proxcryptor_self_encrypt(
      this.ptr,
      ptr0,
      len0,
      ptr1,
      len1
    );
    return takeObject(ret);
  }
  self_decrypt(encrypted_message) {
    var ret = wasm$1.proxcryptor_self_decrypt(
      this.ptr,
      addHeapObject(encrypted_message)
    );
    return takeObject(ret);
  }
  generate_re_key(public_key, tag) {
    var ptr0 = passStringToWasm0(
      tag,
      wasm$1.__wbindgen_malloc,
      wasm$1.__wbindgen_realloc
    );
    var len0 = WASM_VECTOR_LEN;
    var ret = wasm$1.proxcryptor_generate_re_key(
      this.ptr,
      addHeapObject(public_key),
      ptr0,
      len0
    );
    return takeObject(ret);
  }
  re_decrypt(rem) {
    var ret = wasm$1.proxcryptor_re_decrypt(this.ptr, addHeapObject(rem));
    return takeObject(ret);
  }
  sign(msg) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = passArray8ToWasm0(msg, wasm$1.__wbindgen_malloc);
      var len0 = WASM_VECTOR_LEN;
      wasm$1.proxcryptor_sign(retptr, this.ptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
class SimpleKeypair {
  static __wrap(ptr) {
    const obj2 = Object.create(SimpleKeypair.prototype);
    obj2.ptr = ptr;
    return obj2;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_simplekeypair_free(ptr);
  }
  public() {
    var ret = wasm$1.simplekeypair_public(this.ptr);
    return takeObject(ret);
  }
  secret() {
    var ret = wasm$1.simplekeypair_secret(this.ptr);
    return takeObject(ret);
  }
}
async function load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e
          );
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance2 = await WebAssembly.instantiate(module, imports);
    if (instance2 instanceof WebAssembly.Instance) {
      return { instance: instance2, module };
    } else {
      return instance2;
    }
  }
}
async function init(input) {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbg_log_2d3255d249750bce = function(arg0, arg1) {
    console.log(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj2 = getObject(arg1);
    var ret = typeof obj2 === "string" ? obj2 : void 0;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(
      ret,
      wasm$1.__wbindgen_malloc,
      wasm$1.__wbindgen_realloc
    );
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    var ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_json_parse = function(arg0, arg1) {
    var ret = JSON.parse(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_null = function(arg0) {
    var ret = getObject(arg0) === null;
    return ret;
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    var ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    var ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj2 = getObject(arg1);
    var ret = typeof obj2 === "number" ? obj2 : void 0;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    var ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_2d1407dba3452350 = function(arg0, arg1) {
    var ret = getObject(arg0)[takeObject(arg1)];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getRandomValues_98117e9a7e993920 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_randomFillSync_64cc7d048f228ca8 = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_process_2f24d6544ea7b200 = function(arg0) {
    var ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_versions_6164651e75405d4a = function(arg0) {
    var ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_node_4b517d861cbcb3bc = function(arg0) {
    var ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    var ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg_modulerequire_3440a4bcf44437db = function() {
    return handleError(function(arg0, arg1) {
      var ret = module.require(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_crypto_98fc271021c7d2ad = function(arg0) {
    var ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_msCrypto_a2cdb043d2bfe57f = function(arg0) {
    var ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    var ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg_newnoargs_be86524d73f67598 = function(arg0, arg1) {
    var ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_c4151d46d5fa7097 = function(arg0) {
    var ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_7720502039b96d00 = function() {
    return handleError(function(arg0) {
      var ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_done_b06cf0578e89ff68 = function(arg0) {
    var ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_value_e74a542443d92451 = function(arg0) {
    var ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_iterator_4fc4ce93e6b92958 = function() {
    var ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_4d0f21c2f823742e = function() {
    return handleError(function(arg0, arg1) {
      var ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_888d259a5fefc347 = function() {
    return handleError(function(arg0, arg1) {
      var ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    var ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_isArray_eb7ad55f2da67dde = function(arg0) {
    var ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_764b6d4119231cb3 = function(arg0) {
    var ret = getObject(arg0) instanceof ArrayBuffer;
    return ret;
  };
  imports.wbg.__wbg_values_364ae56c608e6824 = function(arg0) {
    var ret = getObject(arg0).values();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_342a24ca698edd87 = function(arg0, arg1) {
    var ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_isSafeInteger_0dfc6d38b7184f06 = function(arg0) {
    var ret = Number.isSafeInteger(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_self_c6fbdfc2918d5e58 = function() {
    return handleError(function() {
      var ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_baec038b5ab35c54 = function() {
    return handleError(function() {
      var ret = window.window;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_3f735a5746d41fbd = function() {
    return handleError(function() {
      var ret = globalThis.globalThis;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_1bc0b39582740e95 = function() {
    return handleError(function() {
      var ret = global.global;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_buffer_397eaa4d72ee94dd = function(arg0) {
    var ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_a7ce447f15ff496f = function(arg0) {
    var ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_969ad0a60e51d320 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_length_1eb8fc608a0d4cdb = function(arg0) {
    var ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Uint8Array_08a1f3a179095e76 = function(arg0) {
    var ret = getObject(arg0) instanceof Uint8Array;
    return ret;
  };
  imports.wbg.__wbg_newwithlength_929232475839a482 = function(arg0) {
    var ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_subarray_8b658422a224f479 = function(arg0, arg1, arg2) {
    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    var ret = debugString(getObject(arg1));
    var ptr0 = passStringToWasm0(
      ret,
      wasm$1.__wbindgen_malloc,
      wasm$1.__wbindgen_realloc
    );
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_memory = function() {
    var ret = wasm$1.memory;
    return addHeapObject(ret);
  };
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  const { instance: instance2, module } = await load(await input, imports);
  wasm$1 = instance2.exports;
  init.__wbindgen_wasm_module = module;
  return wasm$1;
}
var exports$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate_mnemonic,
  seed_to_proxcryptor,
  mnemonic_to_proxcryptor,
  generate_ed25519_keypair,
  sign: sign$1,
  verify,
  generate_ed25519_keypair_from_seed,
  re_encrypt,
  Proxcryptor,
  SimpleKeypair,
  default: init
});
const base64codes = [
  62,
  0,
  0,
  0,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  0,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
function getBase64Code(charCode) {
  return base64codes[charCode - 43];
}
function base64_decode(str) {
  let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0;
  let n = str.length;
  let result = new Uint8Array(3 * (n / 4));
  let buffer2;
  for (let i = 0, j = 0; i < n; i += 4, j += 3) {
    buffer2 = getBase64Code(str.charCodeAt(i)) << 18 | getBase64Code(str.charCodeAt(i + 1)) << 12 | getBase64Code(str.charCodeAt(i + 2)) << 6 | getBase64Code(str.charCodeAt(i + 3));
    result[j] = buffer2 >> 16;
    result[j + 1] = buffer2 >> 8 & 255;
    result[j + 2] = buffer2 & 255;
  }
  return result.subarray(0, result.length - missingOctets);
}
const wasm_code = base64_decode(
  "AGFzbQEAAAABsAIpYAJ/fwBgAn9/AX9gA39/fwBgAX8AYAF/AX9gA39/fwF/YAR/f39/AGAFf39/f38AYAZ/f39/f38AYAABf2ABfwF+YAR/f39/AX9gA39/fwF+YAV/f39/fwF/YAJ/fwF+YAd/f39/f39/AGAAAGAJf39/f39/f39/AX9gA39/fgBgBH9+f38AYAZ/f39/f38Bf2AIf39/f39/f38Bf2ADf3x/AX9gBH98f38Bf2AIf39/f39/f38AYAl/f39/f39/f38AYAl/f39/f39+fn4AYAR/f39+AGAEf39+fwBgBX9/fX9/AGAFf398f38AYAJ/fgBgA39+fgBgBH99f38AYAR/fH9/AGAHf39/f39/fwF/YAN/fn8Bf2ABfgF/YAN+f38Bf2ABfAF/YAJ/fAF+AqcNMQN3YmcaX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAwN3YmcaX193YmdfbG9nXzJkMzI1NWQyNDk3NTBiY2UAAAN3YmcVX193YmluZGdlbl9zdHJpbmdfZ2V0AAADd2JnFF9fd2JpbmRnZW5faXNfb2JqZWN0AAQDd2JnFV9fd2JpbmRnZW5fanNvbl9wYXJzZQABA3diZxJfX3diaW5kZ2VuX2lzX251bGwABAN3YmcXX193YmluZGdlbl9pc191bmRlZmluZWQABAN3YmcWX193YmluZGdlbl9ib29sZWFuX2dldAAEA3diZxVfX3diaW5kZ2VuX251bWJlcl9nZXQAAAN3YmcbX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmAAQDd2JnGl9fd2JnX2dldF8yZDE0MDdkYmEzNDUyMzUwAAEDd2JnJl9fd2JnX2dldFJhbmRvbVZhbHVlc185ODExN2U5YTdlOTkzOTIwAAADd2JnJV9fd2JnX3JhbmRvbUZpbGxTeW5jXzY0Y2M3ZDA0OGYyMjhjYTgAAgN3YmceX193YmdfcHJvY2Vzc18yZjI0ZDY1NDRlYTdiMjAwAAQDd2JnH19fd2JnX3ZlcnNpb25zXzYxNjQ2NTFlNzU0MDVkNGEABAN3YmcbX193Ymdfbm9kZV80YjUxN2Q4NjFjYmNiM2JjAAQDd2JnFF9fd2JpbmRnZW5faXNfc3RyaW5nAAQDd2JnJF9fd2JnX21vZHVsZXJlcXVpcmVfMzQ0MGE0YmNmNDQ0MzdkYgABA3diZx1fX3diZ19jcnlwdG9fOThmYzI3MTAyMWM3ZDJhZAAEA3diZx9fX3diZ19tc0NyeXB0b19hMmNkYjA0M2QyYmZlNTdmAAQDd2JnFl9fd2JpbmRnZW5faXNfZnVuY3Rpb24ABAN3YmcgX193YmdfbmV3bm9hcmdzX2JlODY1MjRkNzNmNjc1OTgAAQN3YmcbX193YmdfbmV4dF9jNDE1MWQ0NmQ1ZmE3MDk3AAQDd2JnG19fd2JnX25leHRfNzcyMDUwMjAzOWI5NmQwMAAEA3diZxtfX3diZ19kb25lX2IwNmNmMDU3OGU4OWZmNjgABAN3YmccX193YmdfdmFsdWVfZTc0YTU0MjQ0M2Q5MjQ1MQAEA3diZx9fX3diZ19pdGVyYXRvcl80ZmM0Y2U5M2U2YjkyOTU4AAkDd2JnGl9fd2JnX2dldF80ZDBmMjFjMmY4MjM3NDJlAAEDd2JnG19fd2JnX2NhbGxfODg4ZDI1OWE1ZmVmYzM0NwABA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAAQN3YmceX193YmdfaXNBcnJheV9lYjdhZDU1ZjJkYTY3ZGRlAAQDd2JnLV9fd2JnX2luc3RhbmNlb2ZfQXJyYXlCdWZmZXJfNzY0YjZkNDExOTIzMWNiMwAEA3diZx1fX3diZ192YWx1ZXNfMzY0YWU1NmM2MDhlNjgyNAAEA3diZxpfX3diZ19uZXdfMzQyYTI0Y2E2OThlZGQ4NwABA3diZyRfX3diZ19pc1NhZmVJbnRlZ2VyXzBkZmM2ZDM4YjcxODRmMDYABAN3YmcbX193Ymdfc2VsZl9jNmZiZGZjMjkxOGQ1ZTU4AAkDd2JnHV9fd2JnX3dpbmRvd19iYWVjMDM4YjVhYjM1YzU0AAkDd2JnIV9fd2JnX2dsb2JhbFRoaXNfM2Y3MzVhNTc0NmQ0MWZiZAAJA3diZx1fX3diZ19nbG9iYWxfMWJjMGIzOTU4Mjc0MGU5NQAJA3diZx1fX3diZ19idWZmZXJfMzk3ZWFhNGQ3MmVlOTRkZAAEA3diZxpfX3diZ19uZXdfYTdjZTQ0N2YxNWZmNDk2ZgAEA3diZxpfX3diZ19zZXRfOTY5YWQwYTYwZTUxZDMyMAACA3diZx1fX3diZ19sZW5ndGhfMWViOGZjNjA4YTBkNGNkYgAEA3diZyxfX3diZ19pbnN0YW5jZW9mX1VpbnQ4QXJyYXlfMDhhMWYzYTE3OTA5NWU3NgAEA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzkyOTIzMjQ3NTgzOWE0ODIABAN3YmcfX193Ymdfc3ViYXJyYXlfOGI2NTg0MjJhMjI0ZjQ3OQAFA3diZxdfX3diaW5kZ2VuX2RlYnVnX3N0cmluZwAAA3diZxBfX3diaW5kZ2VuX3Rocm93AAADd2JnEV9fd2JpbmRnZW5fbWVtb3J5AAkDzwzNDAgAAgACAgIHAgICBgAAAAQCAAAAAAACAgIAAgYCABgHBQAAAAgGAAIAAgAAAgAGBggAAgYAAgACAQMAABUCEQICAAIADAABAQgBAgEGAAcBBwgABwAAAwADAQcHBQEHBwACDwICAQYHBgAFAwAXAAAFFAAFAgICFwABBgsDARUCAgMDBgYAAgYCAAMICBEFAgQCAgEHAAYWAAYGAwYGAgAAABYFAwICAQYGBwACAwYCAgANCAIFAgMIAAECAAECAgAFDAACAAAAAgIDAwMAAAICBwAAAAYIBwYOAgEMAAcHAA8AAAEABgECAAAOAgYaBgAMBBsGAQAGCA0CAgEAABMEAgIACAIGEwIDBQYGAAADAAMDAwICAgEGAwMBAwcAAgIIAgIBAgIDAwMDAwIADwUCAiMGDQICDgYCBg4GAgINBgAACAMRBAQBAAECBw8CAAAABgAGAwQCBQkGAAAEEgIGAAACAgAmAAEAAgAGAQYDAAYDAgYAAAABAgAAAAQFAQEDAAIBAQcCABIGAgEJAAMAAAACAQIBAQABHAAAAAQBBgICAgwAAgAGAgcGAgYGBgcCAAADAQAAAAMDAQEAAAMAAgICJAYCAAYABgABAAIDBgIGAgYDAQMABAYCAgYMAwYCBgYCAgICAgICAQIBAgADAwYGBgUGAgoHAAIAAwYAAgcCAgoBAgMGAAIEAQYGAAAKBAACAAYCBgYBBgUCAAEAKAMAAAECCAMDAwAACgEBAQ4NBQEAAAABCwMDAAIAAggCAgEGAAYABggAAAICAgAAAAAAAAAGAgIAAAAHBwAGBQcMAgMCAwAAAQYEAAEBCwoCAAEHAQIKAwIECgoKCgMDAAMDAQAGBgULBAcBAgEZAQYDAwAAAgACAAAAAAIDAwIBAAICBAQCAgAAAAAAAAYCAAECAQEBAQEKCgoCAgACAAECAQEAAgEAAggBAQEIAgAAAgIDAwMAAAAAAQIAAAIIAAMAAAMABgAHBAMBCAUDAQsDAwUJBwcIAwEBAAADAwIEAAECAAABAgQBCAUAAAICAQMDBgMDAQAAAgYDAAYCAwICAgIgAAEFCQAAAwADAQABAQEAAQEGAAMAAQIABgIDBgcDAwADAgQBAgYEAAEBAAAAAAMDBwAEAwMCBAAAAAMAAgMAAAQAAgABCwcDAAABAwAABgMBBg0AAwIDAAICAgICAQECAwYGBgIAAQACAgIGAQICBgYAAgABAQMAAAEAAgMBAAEAAQEEAwEDAAYAAgABAQAAAAMFAQEBAQEBAQUFBAQfAQEFBQABAgQEAAAEBQUFAgUODgECAgAAAQENAAEDAAQAAAMCAAMAAwMEAAIBAwEBBQMBAQUJAwAGAwgAAAMAAAQDAgMABgAGAAAAAAICBgwAAAUFAgMAAAAAAgIDBQEFAAMCAAQEAgAEAgACAAICAgICAgAAAAAAAAADAgUBBAEAAAAAAAADBgICAgACAgICAAAAAAAAAAAAAAAAAAADAwUBAQAAAAAAAAAAAQYDCwQEBAQEBAcCAgACJwsAAgcBBwADAAMEAwMAAAkDAwIABQEBAQEBAQEBBAYAAgABCQMDAwMDAwMJAgMAAAQEBAAJAwMAAAIEAQkEAQEBAQACAAABDgIDAAADAwABAQMDBAQEAwADBAMDAwAQCQAAAwMDBAQDAwAAAAAAAAYAAwABAwEDAgIDBAEAAAEBAQMDBQABAQAAAAEBBgYAJQABAwEAAAMDAwMDAwMDAwIAAQMDAwIAAgAABAEBAwMEBAIBAAMEAgIDBAACAwQBDAADAwMDAwMDAwMDAwMDAwMCAAUDAwQABwACDAoDABQCAgEABw0eHQsJAwkJBgMJAAABAwMFAAAQAwMJCQkJAwQDAgQAAQEFAQEDAwIAAwMDAwEBAQQLAgsABQEBAAEBAQEBBAEBAQEBAwQBAQEEAAMFAAEBAQICAAMBAAEBBAQBAAEAAQQBBAQFBAMEAQQBAQAEBAAEAQEBAgIFAQEEBQUDAQEBAQEBARAQAAEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQQEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQICAgICAgQEBAQAAQUMAQEBAQEBAQEEAAEBBAQDCQQECgoKCgMABAcBcAHyA/IDBQMBABkGCQF/AUGAgMAACweDBRsGbWVtb3J5AgARZ2VuZXJhdGVfbW5lbW9uaWMA9QwTc2VlZF90b19wcm94Y3J5cHRvcgCEChdtbmVtb25pY190b19wcm94Y3J5cHRvcgDnBhhfX3diZ19zaW1wbGVrZXlwYWlyX2ZyZWUAowsUc2ltcGxla2V5cGFpcl9wdWJsaWMApgkUc2ltcGxla2V5cGFpcl9zZWNyZXQApwkYZ2VuZXJhdGVfZWQyNTUxOV9rZXlwYWlyAJAKBHNpZ24AmAYGdmVyaWZ5AI8MImdlbmVyYXRlX2VkMjU1MTlfa2V5cGFpcl9mcm9tX3NlZWQAhQoKcmVfZW5jcnlwdACQDBZfX3diZ19wcm94Y3J5cHRvcl9mcmVlAKwID3Byb3hjcnlwdG9yX25ldwCGChZwcm94Y3J5cHRvcl9wdWJsaWNfa2V5AKgJHXByb3hjcnlwdG9yX3B1YmxpY19rZXlfYmFzZTU4AKkJGnByb3hjcnlwdG9yX3B1YmxpY19rZXlfandrAKoJGHByb3hjcnlwdG9yX3NlbGZfZW5jcnlwdADjBBhwcm94Y3J5cHRvcl9zZWxmX2RlY3J5cHQAlwkbcHJveGNyeXB0b3JfZ2VuZXJhdGVfcmVfa2V5AKIGFnByb3hjcnlwdG9yX3JlX2RlY3J5cHQAmAkQcHJveGNyeXB0b3Jfc2lnbgD1BBFfX3diaW5kZ2VuX21hbGxvYwCXChJfX3diaW5kZ2VuX3JlYWxsb2MAgwsfX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcgCODA9fX3diaW5kZ2VuX2ZyZWUAyQsUX193YmluZGdlbl9leG5fc3RvcmUA6QsJ6QcBAEEBC/EDugvsCc0GtgT8DOsM/AzsDPwM7Qz8DJIM/AzqDPwMkwyRDPsH/AyUDJYB4wuIDOwL+AX8DJgMkQz5C8UD3Af8DLgL/AzECvwMtgvaBvwMyAKaC7sG/AzUC/wMsQr8DLsK/AzbC/wMlgz8DPwMkQyuCq4K5grbCuELvQv8DNYM/AzWBI0L+gbgC4wGmAj8DNwL/AyXDJMK/AzVDPwM/AzLBJEM/AzdCvwM8gv8DNwK/AzKApsLigOcC/wM/AyxCrwGlQuUC5YLnQuUC50LlAuUC5QLlAuUC5ULlAuUC5QLlAuPC6ULlwuvCtMJrwr0BfwMnAz8DJ0MkQz5C8UD/AyqC5UC/AzKC7UD0AewCqQL4Qu9A/wMngzsC+UE5Qn8DLEK/AyfDPwMpAz8DLcK/AzLC/wMvwz8DKUMrwrVC/wM3QrcCfQMwgr8DKAM/AzlCfwMqAz8DKMM/AyhDPwMogz8DKcM/AymDPwM/Az8DPwMzAv8DPwM/AyvDPwMsQr8DPwM/Ay5C+UJ/AzQBPwMyAn8DMgMhQuFBeIFkQz5C8gD4wf8DPwM/Az8DMcJngajCvcM9gz3DPwM4wb/BbEI9wz2DPcM/AzwB5EG6Qn3DPYM9wz8DO8H+wXoCfcM9gz2DMYG7wmwCKEC7gn3DPcM/AziBvoEuQn3DPYM9gz8DPwF8QS8CPcM9gz2DPYK6gv8DLMM/AyqDPwM/AyrDPwMsAz8DNAL/Az9C/wMtgr8DM8L/AyyDPwM/AyxDPwM/Az8DPwM/Ay0DPwMrAz8DK0M/Ay1DPwMuAz8DLcM/Ay2DPwM/AyuDPwMzgv8DPwM/Az8DNIL/AzRC/wM/Az8DLwM/Az+AvwM/Ay2A/wMtQv8DPwMmgX8DK8M/Az4DPwMxAz8DMYM/Az8DNYL/AzYC/wMwAykC+0Lpgq+DKQL4Qu9A/wMvwimC/wM/AyxCvwM8gn8DPwMygu1A9QH9QWkC/AL/AytAvwM4wr8DNQL/AzLDPwMzwz8DNcL/AzHDPwM0gz8DMUM/AzODPwMzAz8DNMM/Ay3CvwM/AzNDPwM0Qz8DMIM/AzDDPwM0Az8DP8L/AyxCvwMygz8DPwMyQz8DLYK/AzxCZ4E/AzUDPwM/Az8DPwMwQz8DPwM7AvsC/wM1wz8DPwM6wH7Au8M+Qz3DPEL7wyTCvwM+Az8DPwMtAinC/wMtwrDC6ILjQySC/cJ/Ay3Cu8K3QvsC/0M/wr6DPwM+AyAC8EDtgX2CfML1Qj0C9YH/AyhB+MMtwrVCIYM2AeHDPYL4wu0B5sH/Az7DOcMvwGcBOQH6AyLDIcE2QfmDOkMwgbtAwrouiHNDJ+vAgIWfwN+IwBB8A5rIgYkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA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KAIAIgdB/////wFNBEAgCEEDai0AACECIAZB0AFqIAYoAtAOQZwEahDNCyAKQQRqIQogCygCOCAHIAIgBigC0AFqLQAAakECdGooAgAiAkH/////AUsEQCAHIQgMAwsgByEIIAogBEkNAQwCCwsgAiEIIAchAiAJIQoLAkACQAJAAkAgAkGAgICAAnFFBEAgAkGAgICABHENASACQQBIDQIgAiEIIAohCQwECyAKQX9qIQ5BACELIAYtAOgODR0gBiACQf////99cSIINgLcDiAGKALQDiIHQYQEaigCAEEBTQ0CIAZB0A5qIAgQ8wgiAigCBCIHRQ0jIAZBADYCwA4gBiAHQX9qNgLIDiAGIAIoAgBBCWo2AsQOA0AgBkHIAWogBkHADmoQwgMgBigCyAFBAUcNHiAGKALQDiIHQfgDaigCACIJIAYoAswBIgJNDSUgBygC8AMgAkEEdGooAgBFDQALDAILIAZBuAFqIAZB0A5qIAMgBCAKENsBIAYoArgBRQRAQQEhCyAEIQ4MHQsgBigCvAEhCSACQf////97cSIIIQIMAgtBAiELIAJBgoCAgHhGDRsgCkF/aiIOIARPDSMgBiAKNgLYDiAGQbABaiAGQdAOaiAQIBMgCEH/////AXEgAyAOai0AABBhIAYoArABRQ0bIAYoArQBIghBgYCAgHhGBEAgCiAPIA1BAUYbIQ4gDSELDBwLIAhBgICAgAJxRQRAIAghAiAKIQkMAgsgBi0A6A4EQEEAIQsMHAsgBiAIQf////99cSIINgLcDkEAIQ0gCCECIAohCSAOIQ8MAQsgCCECAkAgCiIJQQJqIARPDQAgB0GcBGohCyAGKALkDiEPIAohBwNAIAMgB2otAAAhAiAGQcABaiALEM0LIAdBAWohCSAPKAI4IAggAiAGKALAAWotAABqQQJ0aigCACICQf////99cSAIRw0BIAdBA2ogCSEHIARJDQALCyAJQX5qIA4gCSAKSxshD0EAIQ0LIAkgBEkNAAsMFgsMIAsMIAsMIAtBAiAEQazyywAQsAcAC0EBIAdBnPLLABCwBwALQQEgBEHM8ssAELAHAAsMIwsgASgCACgCAEEIaiADIAQQuQVFBEAgAEEANgIADBYLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCACgCACICQfQTai0AAEEB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B0GAgICAAnFFBEAgB0EASA0BIAchCCAHIQIMAgsgCUEBaiEKIAYtAOgOBEBBACEIIAohDwwRCyAGIAdB/////31xIgI2AtwOIAIhCAJAIAkiB0ECSQ0AIAYoAtAOQZwEaiELIAYoAuQOIRADQCAHIBRqLQAAIQggBkHwBmogCxDNCyAHQX9qIQcgECgCOCACIAggBigC8AZqLQAAakECdGooAgAiCEH/////fXEgAkcNASAHQQFLDQALCyAHQQJqIAogByAJSRshEEEAIQsgByEJDAELQQIhCCAHQYKAgIB4Rg0PAkAgCSAPSQRAIAYgCTYC2A4gBkHoBmogBkHQDmogDiASIAJB/////wFxIAkgDWotAAAQYSAGKALoBkUNESAGKALsBiIIQYGAgIB4RgRAIAkgECALQQFGGyEPIAshCAwSCyAIQYCAgIACcUUNASAJQQFqIRAgBi0A6A4EQEEAIQggECEPDBILIAYgCEH/////fXEiCDYC3A5BACELDAELIAkgD0H86ssAELAHAAsgCCECCyAJDQALDAwLDDELDDELDDELDDELQQIgB0Gs8ssAELAHAAtBASAIQZzyywAQsAcAC0EBIAdBzPLLABCwBwALIAJBuARqLQAABEAgACABQQAgEyARIAMgBCAFIAQQwAUMHQsCQAJAAkAgAUEIaigCACIHIAEoAgQgBxsiCygCAEUEQCALQX8Q3wsgBkEAOgDoDiAGIAU2AtgOIAZBADYC1A4gBiACQcAEajYC0A4gBiALQQhqIgk2AuQOIAYgBTYC4A4gBkGAgICAeDYC3A4gAyAEIAUQjwQhHEEBIQogBigC5A4iCEHQAGooAgAiDCAcQv//////////AIMiHUIriKdBwABxIBxC////////P4MiHkIciKdBEHEgHKciAkEHdkECcSACQQFxciACQQ52QQRxciACQRV2QQhxcnIgHkIjiKdBIHFyciIHSwRAIAtB+ABqIQ4CQAJAAkAgCCgCSCAHQQJ0aigCACICQYCAgIB4ag4CAAYBCyAJQQA2AnggBkHQDmogBigC0A4oApgEIA4gHBCkAiAGQdgGaiAGQdAOaiAOIB1CMIinQQAQmAEgBigC2AZFBEBBAiEKDAYLIAYoAtwGIQICQCAGKALQDiIILQCvBA0AIAgQ9AhFDQAgAiACQYCAgIAEciAILQCw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BBshAgsgBigC5A4iCkHQAGooAgAiCyAHTQ0BIAooAkggB0ECdGogAjYCACACQYGAgIB4Rg0HCyAGIAI2AtQOIAlBnAJqIRQgBigC2A4iDEUEQEEBIQtBACEMDAYLIA1Bf2ohFSANQXxqIRZBASELIAwhCSACIQgDQAJAIAgiB0H/////AUsNAANAIAkgFmoiB0EDai0AACECIAZBgAZqIAYoAtAOQZwEahDNCwJAIAlBf2oiCkEFSSAGKALkDiIXKAI4IAggAiAGKAKABmotAABqQQJ0aigCACICQf////8BS3JFBEAgB0ECai0AACEIIAZB+AVqIAYoAtAOQZwEahDNCyAXKAI4IAIgCCAGKAL4BWotAABqQQJ0aigCACIIQYCAgIACSQ0BIAlBfmohCSAIIQcMAwsgAiEHIAghAiAKIQkMAgsgB0EBai0AACECIAZB8AVqIAYoAtAOQZwEahDNCyAGKALkDiIKKAI4IAggAiAGKALwBWotAABqQQJ0aigCACICQf////8BTQRAIActAAAhByAGQegFaiAGKALQDkGcBGoQzQsgCUF8aiEJIAooAjggAiAHIAYoAugFai0AAGpBAnRqKAIAIgghByAIQYCAgIACSQ0BDAILCyAJQX1qIQkgAiEHIAghAgsCQAJAIAdBgICAgAJxRQRAIAdBAEgNASAHIQggByECDAILIAlBAWohDCAGLQDoDg0HIAYgB0H/////fXEiAjYC3A4gAiEIAkAgCSIHQQJJDQAgBigC0A5BnARqIQogBigC5A4hCwNAIAcgFWotAAAhCCAGQeAFaiAKEM0LIAdBf2ohByALKAI4IAIgCCAGKALgBWotAABqQQJ0aigCACIIQf////99cSACRw0BIAdBAUsNAAsLIAdBAmogDCAHIAlJGyEMQQAhCyAHIQkMAQtBAiEIIAdBgoCAgHhGDQgCQCAJIBJJBEAgBiAJNgLYDiAGQdgFaiAGQdAOaiAQIBQgAkH/////AXEgCSANai0AABBhIAYoAtgFRQ0KIAYoAtwFIghBgYCAgHhGBEAgCSAMIAtBAUYbIQwgCyEIDAsLIAhBgICAgAJxRQ0BIAlBAWohDCAGLQDoDg0IIAYgCEH/////fXEiCDYC3A5BACELDAELIAkgEkH86ssAELAHAAsgCCECCyAJDQALDAULDDMLDDMLDDML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IQcgAiEJIAghAgwCCyAJQQJqLQAAIQggBkGQCGogBigC0A5BnARqEM0LIAYoAuQOIhIoAjggAiAIIAYoApAIai0AAGpBAnRqKAIAIghB/////wFNBEAgCUEDai0AACECIAZBiAhqIAYoAtAOQZwEahDNCyAHQQRqIQcgEigCOCAIIAIgBigCiAhqLQAAakECdGooAgAiAkH/////AUsEQCAIIQkMAwsgCCEJIAcgBEkNAQwCCwsgAiEJIAghAiAKIQcLAkACQAJAAkACQCACQYCAgIACcUUEQCACQYCAgIAEcQ0BIAJBAEgNAiACIQkgByEKDAULIAdBf2ohD0EAIQogBi0A6A4NDCAGIAJB/////31xIgk2AtwOIAYoAtAOIghBhARqKAIAQQFNDQMgBkHQDmogCRDzCCICKAIEIghFDSkgBkEANgLADiAGIAhBf2o2AsgOIAYgAigCAEEJajYCxA4DQCAGQYAIaiAGQcAOahDCAyAGKAKACEEBRw0NIAYoAtAOIghB+ANqKAIAIgwgBigChAgiAk0NAyAIKALwAyACQQR0aigCAEUNAAsMAwsgBkHwB2ogBkHQDmogAyAEIAcQ2wEgBigC8AdFBEBBASEKIAQhDwwMCyAGKAL0ByEKIAJB/////3txIgkhAgwDC0ECIQogAkGCgICAeEYNCiAHQX9qIg8gBE8NOSAGIAc2AtgOIAZB6AdqIAZB0A5qIA4gECAJQf////8BcSADIA9qLQAAEGEgBigC6AdFDQogBigC7AciCUGBgICAeEYEQCAHIA0gDEEBRhshDyAMIQoMCwsgCUGAgICAAnFFBEAgCSECIAchCgwDCyAGLQDoDgRAQQAhCgwLCyAGIAlB/////31xIgk2AtwOQQAhDCAJIQIgByEKIA8hDQwCCyACIAxB7OrLABCwBwALIAkhAiAHIQoCQCAHQQJqIARPDQAgCEGcBGohDCAGKALkDiENIAchCANAIAMgCGotAAAhAiAGQfgHaiAMEM0LIAhBAWohCiANKAI4IAkgAiAGKAL4B2otAABqQQJ0aigCACICQf////99cSAJRw0BIAhBA2ogCiEIIARJDQALCyAKQX5qIA8gCiAHSxshDUEAIQwLIAogBEkNAAsMBAsgByAMQZzrywAQsAcACyAHIAxBjOvLABCwBwALDCULAkACQAJAIAEoAggiAiABKAIEIAIbIg4oAgBFBEAgASgCACgCACECIA5BfxDfCyAGQQA6AOgOIAYgDyAQaiIQNgLYDiAGQQA2AtQOIAYgAkHABGo2AtAOIAYgDkEIaiIJNgLkDiAGIBA2AuAOIAZBgICAgHg2AtwOIAMgBCAQEI8EIRxBASEKIAYoAuQOIghB0ABqKAIAIgsgHEL//////////wCDIh1CK4inQcAAcSAcQv///////z+DIh5CHIinQRBxIBynIgJBB3ZBAnEgAkEBcXIgAkEOdkEEcXIgAkEVdkEIcXJyIB5CI4inQSBxcnIiB0sEQCAOQfgAaiENAkACQAJAIAgoAkggB0ECdGooAgAiAkGAgICAeGoOAgAGAQsgCUEANgJ4IAZB0A5qIAYoAtAOKAKYBCANIBwQpAIgBkH4CGogBkHQDmogDSAdQjCIp0EAEJgBIAYoAvgIRQRAQQIhCgwGCyAGKAL8CCECAkAgBigC0A4iCC0ArwQNACAIEPQIRQ0AIAIgAkGAgICABHIgCC0AsAQbIQILIAYoAuQOIghB0ABqKAIAIgsgB00NASAIKAJIIAdBAnRqIAI2AgAgAkGBgICAeEYNBQsgBiACNgLUDiAJQYQBaiESQQEhDCAGKALYDiILIARPBEAgAiEJDAQLIAshCiACIQkDQAJAIAJB/////wFLBEAgCiEHDAELIAoiByAETw0AA0AgAyAHaiIJLQAAIQggBkHwCGogBigC0A5BnARqEM0LAkACQCAGKALkDiIUKAI4IAIgCCAGKALwCGotAABqQQJ0aigCACIIQf////8BSw0AIAdBA2oiCiAETw0AIAlBAWotAAAhAiAGQegIaiAGKALQDkGcBGoQzQsgFCgCOCAIIAIgBigC6AhqLQAAakECdGooAgAiAkH/////AU0NASAHQQJqIQcgCCEJDAMLIAdBAWohByACIQkgCCECDAILIAlBAmotAAAhCCAGQeAIaiAGKALQDkGcBGoQzQsgBigC5A4iFCgCOCACIAggBigC4AhqLQAAakECdGooAgAiCEH/////AU0EQCAJQQNqLQAAIQIgBkHYCGogBigC0A5BnARqEM0LIAdBBGohByAUKAI4IAggAiAGKALYCGotAABqQQJ0aigCACICQf////8BSwRAIAghCQwDCyAIIQkgByAESQ0BDAILCyACIQkg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BkGgC2ogBigC0A5BnARqEM0LIAdBBGohByALKAI4IAggAiAGKAKgC2otAABqQQJ0aigCACICQf////8BSwRAIAghCQwDCyAIIQkgByAESQ0BDAILCyACIQkgCCECIAohBwsCQAJAAkACQCACQYCAgIACcUUEQCACQYCAgIAEcQ0BIAJBAEgNAiACIQkgByELDAQLIAdBf2ohDEEAIQogBi0A6A4NEiAGIAJB/////31xIgk2AtwOIAYoAtAOIghBhARqKAIAQQFNDQIgBkHQDmogCRDzCCICKAIEIghFDS0gBkEANgLADiAGIAhBf2o2AsgOIAYgAigCAEEJajYCxA4DQCAGQZgLaiAGQcAOahDCAyAGKAKYC0EBRw0TIAYoAtAOIghB+ANqKAIAIgsgBigCnAsiAk0NRSAIKALwAyACQQR0aigCAEUNAAsMAgsgBkGIC2ogBkHQDmogAyAEIAcQ2wEgBigCiAtFBEBBASEKIAQhDAwSCyAGKAKMCyELIAJB/////3txIgkhAgwCC0ECIQogAkGCgICAeEYNECAHQX9qIgwgBE8NRSAGIAc2AtgOIAZBgAtqIAZB0A5qIA0gESAJQf////8BcSADIAxqLQAAEGEgBigCgAtFDRAgBigChAsiCUGBgICAeEYEQCAHIBAgDkEBRhshDCAOIQoMEQsgCUGAgICAAnFFBEAgCSECIAchCwwCCyAGLQDoDgRAQQAhCgwRCyAGIAlB/////31xIgk2AtwOQQAhDiAJIQIgByELIAwhEAwBCyAJIQIgByELAkAgB0ECaiAETw0AIAhBnARqIQogBigC5A4hDiAHIQgDQCADIAhqLQAAIQIgBkGQC2ogChDNCyAIQQFqIQsgDigCOCAJIAIgBigCkAtqLQAAakECdGooAgAiAkH/////fXEgCUcNASAIQQNqIAshCCAESQ0ACwsgC0F+aiAMIAsgB0sbIRBBACEOCyALIARJDQALDAsLDDQLDD4LDCoLQQIgBEGs8ssAELAHAAtBASAHQZzyywAQsAcAC0EBIARBzPLLABCwBwALIAZBADYCwA4MCwsgBkHADmogASACQfUTai0AACADIAQgBRCpBgwKCyAGQbgOakGU7csAQYwBEOYLIAZB5A5qQQE2AgAgBkIBNwLUDiAGQeTsywA2AtAOIAYgBikDuA43A8AODDoL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0ABqKAIAIgsgHEL//////////wCDIh1CK4inQcAAcSAcQv///////z+DIh5CHIinQRBxIBynIgJBB3ZBAnEgAkEBcXIgAkEOdkEEcXIgAkEVdkEIcXJyIB5CI4inQSBxcnIiB0sEQCAPQfgAaiENAkACQAJAIAgoAkggB0ECdGooAgAiAkGAgICAeGoOAgAHAQsgCUEANgJ4IAZB0A5qIAYoAtAOKAKYBCANIBwQpAIgBkGQDWogBkHQDmogDSAdQjCIp0EAEJgBIAYoApANRQRAQQIhCgwHCyAGKAKUDSECAkAgBigC0A4iCC0ArwQNACAIEPQIRQ0AIAIgAkGAgICABHIgCC0AsAQbIQILIAYoAuQOIghB0ABqKAIAIgsgB00NASAIKAJIIAdBAnRqIAI2AgAgAkGBgICAeEYNBgsgBiACNgLUDiAJQYQBaiERQQEhDiAGKALYDiIQIARPBEAgAiEJDAULIBAhCyACIQkDQAJAIAJB/////wFLBEAgCyEHDAELIAsiByAETw0AA0AgAyAHaiIJLQAAIQggBkGIDWogBigC0A5BnARqEM0LAkACQCAGKALkDiILKAI4IAIgCCAGKAKIDWotAABqQQJ0aigCACIIQf////8BSw0AIAdBA2oiCiAETw0AIAlBAWotAAAhAiAGQYANaiAGKALQDkGcBGoQzQsgCygCOCAIIAIgBigCgA1qLQAAakECdGooAgAiAkH/////AU0NASAHQQJqIQcgCCEJDAMLIAdBAWohByACIQkgCCECDAILIAlBAmotAAAhCCAGQfgMaiAGKALQDkGcBGoQzQsgBigC5A4iCygCOCACIAggBigC+AxqLQAAakECdGooAgAiCEH/////AU0EQCAJQQNqLQAAIQIgBkHwDGogBigC0A5BnARqEM0LIAdBBGohByALKAI4IAggAiAGKALwDGotAABqQQJ0aigCACICQf////8BSwRAIAghCQwDCyAIIQkgByAESQ0BDAILCyACIQkgCCECIAohBwsCQAJAAkACQCACQYCAgIACcUUEQCACQYCAgIAEcQ0BIAJBAEgNAiACIQkgByELDAQLIAdBf2ohDEEAIQogBi0A6A4NCyAGIAJB/////31xIgk2AtwOIAYoAtAOIghBhARqKAIAQQFNDQIgBkHQDmogCRDzCCICKAIEIghFDS0gBkEANgLADiAGIAhBf2o2AsgOIAYgAigCAEEJajYCxA4DQCAGQegMaiAGQcAOahDCAyAGKALoDEEBRw0MIAYoAtAOIghB+ANqKAIAIgsgBigC7AwiAk0NRSAIKALwAyACQQR0aigCAEUNAAsMAgsgBkHYDGogBkHQDmogAyAEIAcQ2wEgBigC2AxFBEBBASEKIAQhDAwLCyAGKALcDCELIAJB/////3txIgkhAgwCC0ECIQogAkGCgICAeEYNCSAHQX9qIgwgBE8NRSAGIAc2AtgOIAZB0AxqIAZB0A5qIA0gESAJQf////8BcSADIAxqLQAAEGEgBigC0AxFDQkgBigC1AwiCUGBgICAeEYEQCAHIBAgDkEBRhshDCAOIQoMCgsgCUGAgICAAnFFBEAgCSECIAchCwwCCyAGLQDoDgRAQQAhCgwKCyAGIAlB/////31xIgk2AtwOQQAhDiAJIQIgByELIAwhEAwBCyAJIQIgByELAkAgB0ECaiAETw0AIAhBnARqIQogBigC5A4hDiAHIQgDQCADIAhqLQAAIQIgBkHgDGogChDNCyAIQQFqIQsgDigCOCAJIAIgBigC4AxqLQAAakECdGooAgAiAkH/////fXEgCUcNASAIQQNqIAshCCAESQ0ACwsgC0F+aiAMIAsgB0sbIRBBACEOCyALIARJDQALDAQLDDQLDD4LDCoLAkACQAJAIAEoAggiAiABKAIEIAIbIhAoAgBFBEAgASgCACgCACECIBBBfxDfCyAGQQA6AOgOIAYgDCAPaiIPNgLYDiAGQQA2AtQOIAYgAkHABGo2AtAOIAYgEEEIaiIJNgLkDiAGIA82AuAOIAZBgICAgHg2AtwOIAMgBCAPEI8EIRxBASEKIAYoAuQOIghB0ABqKAIAIgsgHEL//////////wCDIh1CK4inQcAAcSAcQv///////z+DIh5CHIinQRBxIBynIgJBB3ZBAnEgAkEBcXIgAkEOdkEEcXIgAkEVdkEIcXJyIB5CI4inQSBxcnIiB0sEQCAQQfgAaiERAkACQAJAIAgoAkggB0ECdGooAgAiAkGAgICAeGoOAgAGAQsgCUEANgJ4IAZB0A5qIAYoAtAOKAKYBCARIBwQpAIgBkHgDWogBkHQDmogESAdQjCIp0EAEJgBIAYoAuANRQRAQQIhCgwGCyAGKALkDSECAkAgBigC0A4iCC0ArwQNACAIEPQIRQ0AIAIgAkGAgICABHIgCC0AsAQbIQILIAYoAuQOIghB0ABqKAIAIgsgB00NASAIKAJIIAdBAnRqIAI2AgAgAkGBgICAeEYNBQsgBiACNgLUDiAJQYQBaiESQQEhDiAGKALYDiINIARPBEAgAiEJDAQLIA0hCyACIQkDQAJAIAJB/////wFLBEAgCyEHDAELIAsiByAETw0AA0AgAyAHaiIJLQAAIQggBkHYDWogBigC0A5BnARqEM0LAkACQCAGKALkDiILKAI4IAIgCCAGKALYDWotAABqQQJ0aigCACIIQf////8BSw0AIAdBA2oiCiAETw0AIAlBAWotAAAhAiAGQdANaiAGKALQDkGcBGoQzQsgCygCOCAIIAIgBigC0A1qLQAAakECdGooAgAiAkH/////AU0NASAHQQJqIQcgCCEJDAMLIAdBAWohByACIQkgCCECDAILIAlBAmotAAAhCCAGQcgNaiAGKALQDkGcBGoQzQsgBigC5A4iCygCOCACIAggBigCyA1qLQAAakECdGooAgAiCEH/////AU0EQCAJQQNqLQAAIQIgBkHADWogBigC0A5BnARqEM0LIAdBBGohByALKAI4IAggAiAGKALADWotAABqQQJ0aigCACICQf////8BSwRAIAghCQwDCyAIIQkgByAESQ0BDAILCyACIQkgCCECIAohBwsCQAJAAkACQCACQYCAgIACcUUEQCACQYCAgIAEcQ0BIAJBAEgNAiACIQkgByELDAQLIAdBf2ohDEEAIQogBi0A6A4NCiAGIAJB/////31xIgk2AtwOIAYoAtAOIghBhARqKAIAQQFNDQIgBkHQDmogCRDzCCICKAIEIghFDS8gBkEANgLADiAGIAhBf2o2AsgOIAYgAigCAEEJajYCxA4DQCAGQbgNaiAGQcAOahDCAyAGKAK4DUEBRw0LIAYoAtAOIghB+ANqKAIAIgsgBigCvA0iAk0NRyAIKALwAyACQQR0aigCAEUNAAsMAgsgBkGoDWogBkHQDmogAyAEIAcQ2wEgBigCqA1FBEBBASEKIAQhDAwKCyAGKAKsDSELIAJB/////3txIgkhAgwCC0ECIQogAkGCgICAeEYNCCAHQX9qIgwgBE8NRyAGIAc2AtgOIAZBoA1qIAZB0A5qIBEg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AANAIAkgFGoiB0EDai0AACECIAZB+AtqIAYoAtAOQZwEahDNCwJAIAlBf2oiCkEFSSAGKALkDiIVKAI4IAggAiAGKAL4C2otAABqQQJ0aigCACICQf////8BS3JFBEAgB0ECai0AACEIIAZB8AtqIAYoAtAOQZwEahDNCyAVKAI4IAIgCCAGKALwC2otAABqQQJ0aigCACIIQYCAgIACSQ0BIAlBfmohCSAIIQcMAwsgAiEHIAghAiAKIQkMAgsgB0EBai0AACECIAZB6AtqIAYoAtAOQZwEahDNCyAGKALkDiIKKAI4IAggAiAGKALoC2otAABqQQJ0aigCACICQf////8BTQRAIActAAAhByAGQeALaiAGKALQDkGcBGoQzQsgCUF8aiEJIAooAjggAiAHIAYoAuALai0AAGpBAnRqKAIAIgghByAIQYCAgIACSQ0BDAILCyAJQX1qIQkgAiEHIAghAgsCQAJAIAdBgICAgAJxRQRAIAdBAEgNASAHIQggByECDAILIAlBAWohCiAGLQDoDgRAQQAhCCAKIQwMCQsgBiAHQf////99cSICNgLcDiACIQgCQCAJIgdBAkkNACAGKALQDkGcBGohDyAGKALkDiENA0AgByASai0AACEIIAZB2AtqIA8QzQsgB0F/aiEHIA0oAjggAiAIIAYoAtgLai0AAGpBAnRqKAIAIghB/////31xIAJHDQEgB0EBSw0ACwsgB0ECaiAKIAcgCUkbIQ9BACENIAchCQwBC0ECIQggB0GCgICAeEYNBwJAIAkgDEkEQCAGIAk2AtgOIAZB0AtqIAZB0A5qIA4gESACQf////8BcSAJIBBqLQAAEGEgBigC0AtFDQkgBigC1AsiCEGBgICAeEYEQCAJIA8gDUEBRhshDCANIQgMCgsgCEGAgICAAnFFDQEgCUEBaiEPIAYtAOgOBEBBACEIIA8hDAwKCyAGIAhB/////31xIgg2AtwOQQAhDQwBCyAJIAxB/OrLABCwBwALIAghAgsgCQ0ACwwECyAHIA9BnOvLABCwBwALDC8LDC8LDC8LIAZByAtqIAZB0A5qIA4gESACQYACEGEgBigCyAtFBEBBAiEIDAELIAYoAswLIgJBgYCAgHhGBEBBACAPIA1BAUYbIQwgDSEIDAELQQAgDSACQYCAgIACcSICGyEIQQAgDyACGyEMCyALIAsoAgBBAWoQ3wsCQAJAAkAgCEEBaw4CAQIACyAGQcgOaiAENgIAIAZBATYCwA4gBiAFIAxqNgLEDgwJCyAGQQA2AsAODAgLIAZBwA5qIAFBACADIAQgBRCpBgwHCyAGQfgKaiAGQdAOaiANIBEgCUH/////AXFBgAIQYSAGKAL4CkUEQEECIQoMAgsgBigC/AoiAkGBgICAeEYEQCAEIBAgDkEBRhshDCAOIQoMAgtBACAOIAJBgICAgAJxIgIbIQogBCAQIAIbIQwMAQsgBSEMCyAPIA8oAgBBAWoQ3wsCQAJAAkAgCkEBaw4CAQIACwJAIAUgDEYEQCAFIQwMAQsCQAJAAkAgBCAFTwRAIAEoAggiAiABKAIEIAIbIgsoAgBFBEAgASgCACgCACECIAtBfxDfCyAGQQA6AOgOIAYgDCAFayIONgLYDiAGQQA2AtQOIAYgAkH4CGo2AtAOIAYgC0GgAWo2AuQOIAYgDjYC4A4gBkGAgICAeDYC3A4gAyAFaiIQIAQgBWsiESAOENUDIRxBASEIIAYoAuQOIgpB0ABqKAIAIgkgHEL//////////wCDIh1CK4inQcAAcSAcQv///////z+DIh5CHIinQRBxIBynIgJBB3ZBAnEgAkEBcXIgAkEOdkEEcXIgAkEVdkEIcXJyIB5CI4inQSBxcnIiB0sEQCALQZACaiEPIAtBCGohCQJAAkACQCAKKAJIIAdBAnRqKAIAIgJBgICAgHhqDgIACAELIAlBADYCkAIgBkHQDmogBigC0A4oApgEIA8gHBCkAiAGQfAKaiAGQdAOaiAPIB1CMIinQQAQmAEgBigC8ApFBEBBAiEIDAgLIAYoAvQKIQICQCAGKALQDiIKLQCvBA0AIAoQ9AhFDQAgAiACQYCAgIAEciAKLQCwBBshAgsgBigC5A4iCkHQAGooAgAiDSAHTQ0BIAooAkggB0ECdGogAjYCACACQYGAgIB4Rg0HCyAGIAI2AtQOIAlBnAJqIRIgBigC2A4iDkUEQEEBIQ1BACEODAYLIBBBf2ohFCAQQXxqIRVBASENIA4hCSACIQgDQAJAIAgiB0H/////AUsNAANAIAkgFWoiB0EDai0AACECIAZB6ApqIAYoAtAOQZwEahDNCwJAIAlBf2oiCkEFSSAGKALkDiIWKAI4IAggAiAGKALoCmotAABqQQJ0aigCACICQf////8BS3JFBEAgB0ECai0AACEIIAZB4ApqIAYoAtAOQZwEahDNCyAWKAI4IAIgCCAGKALgCmotAABqQQJ0aigCACIIQYCAgIACSQ0BIAlBfmohCSAIIQcMAwsgAiEHIAghAiAKIQkMAgsgB0EBai0AACECIAZB2ApqIAYoAtAOQZwEahDNCyAGKALkDiIKKAI4IAggAiAGKALYCmotAABqQQJ0aigCACICQf////8BTQRAIActAAAhByAGQdAKaiAGKALQDkGcBGoQzQsgCUF8aiEJIAooAjggAiAHIAYoAtAKai0AAGpBAnRqKAIAIgghByAIQYCAgIACSQ0BDAILCyAJQX1qIQkgAiEHIAghAgsCQAJAIAdBgICAgAJxRQRAIAdBAEgNASAHIQggByECDAILIAlBAWohDiAGLQDoDg0HIAYgB0H/////fXEiAjYC3A4gAiEIAkAgCSIHQQJJDQAgBigC0A5BnARqIQogBigC5A4hDQNAIAcgFGotAAAhCCAGQcgKaiAKEM0LIAdBf2ohByANKAI4IAIgCCAGKALICmotAABqQQJ0aigCACIIQf////99cSACRw0BIAdBAUsNAAsLIAdBAmogDiAHIAlJGyEOQQAhDSAHIQkMAQtBAiEIIAdBgoCAgHhGDQgCQCAJIBFJBEAgBiAJNgLYDiAGQcAKaiAGQdAOaiAPIBIgAkH/////AXEgCSAQai0AABBhIAYoAsAKRQ0KIAYoAsQKIghBgYCAgHhGBEAgCSAOIA1BAUYbIQ4gDSEIDAsLIAhBgICAgAJxRQ0BIAlBAWohDiAGLQDoDg0IIAYgCEH/////fXEiCDYC3A5BACENDAELIAkgEUH86ssAELAHAAsgCCECCyAJDQALDAULDDcLDDALDDALDDMLQQAhCAwBCyAGQbgKaiAGQdAOaiAPIBIgAkGAAhBhIAYoArgKRQRAQQIhCAwBCyAGKAK8CiICQYGAgIB4RgRAQQAgDiANQQFGGyEOIA0hCAwBC0EAIA0gAkGAgICAAnEiAhshCEEAIA4gAhshDgsgCyALKAIAQQFqEN8LAkAgCEEBaw4CAgMACyAFIA5qIQULIAZByA5qIAw2AgAgBiAFNgLEDiAGQQE2AsAODAYLIAZBADYCwA4MBQsgBkHADmogAUEAIAMgBCAFEKkGDAQLIAJBuARqLQAAQQFHDQAgBkEANgLADgwDCyAEIAVPBEAgBkHQDmogAkEIaiADIAVqIAQgBWsQuAVBACECIAYgBigC0A5BAUYEfyAGQcgOaiAGQdgOaigCACAFajYCACAGIAYoAtQOIAVqNgLEDkEBBSACCzYCwA4MAwsMKQtBACEJCyAGIAk2AsAOC0EAIQIgACAGKALADkEBRgR/IBNBATYCCCATIAYoAsQOIgE2AgQgE0EBNgIAIAAgATYCBCATQQxqIAZByA5qKAIAIgE2AgAgAEEIaiABNgIAQQEFIAILNgIADBQLIABBADYCAAwTCyAAIAEgAkH1E2otAAAgAyAEIAUQqQYMEgsgBkHoBGpBlO3LAEGMARDmCyAGQeQOakEBNgIAIAZCATcC1A4gBkHk7MsANgLQDiAGIAYpA+gENwPADgwtCyAEIAVJDQYgAkH4DWohEyADQX9qIRIgA0F8aiEUIAUiAiEMAkACQANAIAZB4ARqIBMgAiADaiAEIAJrEK8EIAYoAuAERQ0JIAYoAuQEIQcgBkHYBGogExDrCwJAAkAgAiAHaiIVIAYoAtwEaiICIAxPBEAgAiAETQRAIAEoAggiByABKAIEIAcbIgsoAgBFBEAgASgCACgCACEHIAtBfxDfCyAGQQA6AOgOIAYgAiAMayIONgLYDiAGQQA2AtQOIAYgB0H4CGo2AtAOIAYgC0GgAWo2AuQOIAYgDjYC4A4gBkGAgICAeDYC3A4gAyAMaiIWIA4gDhDVAyEcIAYoAuQOIgpB0ABqKAIAIgcgHEL//////////wCDIh1CK4inQcAAcSAcQv///////z+DIh5CHIinQRBxIBynIgJBB3ZBAnEgAkEBcXIgAkEOdkEEcXIgAkEVdkEIcXJyIB5CI4inQSBxcnIiCUsEQCALQZACaiEQIAtBCGohCEEBIQcCQAJAAkAgCUECdCIPIAooAkhqKAIAIgJBgICAgHhqDgIACAELIAhBADYCkAIgBkHQDmogBigC0A4oApgEIBAgHBCkAiAGQdAEaiAGQdAOaiAQIB1CMIinQQAQmAEgBigC0ARFBEBBAiEHDAgLIAYoAtQEIQICQCAGKALQDiIKLQCvBA0AIAoQ9AhFDQAgAiACQYCAgIAEciAKLQCwBBshAgsgBigC5A4iCkHQAGooAgAiDSAJTQ0BIAooAkggD2ogAjYCACACQYGAgIB4Rg0HCyAGIAI2AtQOIAhBnAJqIREgBigC2A4iD0UEQEEBIQ1BACEPDAYLIAwgEmohFyAMIBRqIRhBASENIA8hCCACIQcDQCAHIQoCQCAHQf////8BSw0AA0AgCCAYaiIKQQNqLQAAIQIgBkHIBGogBigC0A5BnARqEM0LAkAgCEF/aiIJQQVJIAYoAuQOIhkoAjggByACIAYoAsgEai0AAGpBAnRqKAIAIgJB/////wFLckUEQCAKQQJqLQAAIQcgBkHABGogBigC0A5BnARqEM0LIBkoAjggAiAHIAYoAsAEai0AAGpBAnRqKAIAIgdBgICAgAJJDQEgCEF+aiEIIAchCgwDCyACIQogByECIAkhCAwCCyAKQQFqLQAAIQIgBkG4BGogBigC0A5BnARqEM0LIAYoAuQOIgkoAjggByACIAYoArgEai0AAGpBAnRqKAIAIgJB/////wFNBEAgCi0AACEHIAZBsARqIAYoAtAOQZwEahDNCyAIQXxqIQggCSgCOCACIAcgBigCsARqLQAAakECdGooAgAiByEKIAdBgICAgAJJDQEMAgsLIAhBfWohCCACIQogByECCwJAAkAgCkGAgICAAnFFBEAgCkEASA0BIAoiByECDAILIAhBAWohCSAGLQDoDgRAQQAhByAJIQ4MCgsgBiAKQf////99cSICNgLcDiACIQcgCCEKAkAgCEECSQ0AIAYoAtAOQZwEaiEPIAYoAuQOIQ0DQCAKIBdqLQAAIQcgBkGoBGogDxDNCyAKQX9qIQogDSgCOCACIAcgBigCqARqLQAAakECdGooAgAiB0H/////fXEgAkcNASAKQQFLDQALCyAKQQJqIAkgCiAISRshD0EAIQ0gCiEIDAELQQIhByAKQYKAgIB4Rg0IAkAgCCAOSQRAIAYgCDYC2A4gBkGgBGogBkHQDmogECARIAJB/////wFxIAggFmotAAAQYSAGKAKgBEUNCiAGKAKkBCIHQYGAgIB4RgRAIAggDyANQQFGGyEOIA0hBwwLCyAHQYCAgIACcUUNASAIQQFqIQ8gBi0A6A4EQEEAIQcgDyEODAsLIAYgB0H/////fXEiBzYC3A5BACENDAELIAggDkH86ssAELAHAAsgByECCyAIDQALDAULIAkgDUGc68sAELAHAAsg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KAIAIQIgD0F/EN8LIAZBADoA6A4gBiAMIA5qIgw2AtgOIAZBADYC1A4gBiACQcAEajYC0A4gBiAPQQhqIgk2AuQOIAYgDDYC4A4gBkGAgICAeDYC3A4gAyAEIAwQjwQhHEEBIQsgBigC5A4iCEHQAGooAgAiCiAcQv//////////AIMiHUIriKdBwABxIBxC////////P4MiHkIciKdBEHEgHKciAkEHdkECcSACQQFxciACQQ52QQRxciACQRV2QQhxcnIgHkIjiKdBIHFyciIHSwRAIA9B+ABqIRMCQAJAAkAgCCgCSCAHQQJ0aigCACICQYCAgIB4ag4CAAYBCyAJQQA2AnggBkHQDmogBigC0A4oApgEIBMgHBCkAiAGQZAEaiAGQdAOaiATIB1CMIinQQAQmAEgBigCkARFBEBBAiELDAYLIAYoApQEIQICQCAGKALQDiIILQCvBA0AIAgQ9AhFDQAgAiACQYCAgIAEciAILQCwBBshAgsgBigC5A4iCEHQAGooAgAiCiAHTQ0BIAgoAkggB0ECdGogAjYCACACQYGAgIB4Rg0FCyAGIAI2AtQOIAlBhAFqIRFBASENIAYoAtgOIhAgBE8EQCACIQgMBAsgECEJIAIhCANAAkAgAkH/////AUsEQCAJIQoMAQsgCSEKIAkgBE8NAANAIAMgCmoiCC0AACEHIAZBiARqIAYoAtAOQZwEahDNCwJAAkAgBigC5A4iCygCOCACIAcgBigCiARqLQAAakECdGooAgAiB0H/////AUsNACAKQQNqIgkgBE8NACAIQQFqLQAAIQIgBkGABGogBigC0A5BnARqEM0LIAsoAjggByACIAYoAoAEai0AAGpBAnRqKAIAIgJB/////wFNDQEgCkECaiEKIAchCAwDCyAKQQFqIQogAiEIIAchAgwCCyAIQQJqLQAAIQcgBkH4A2ogBigC0A5BnARqEM0LIAYoAuQOIgsoAjggAiAHIAYoAvgDai0AAGpBAnRqKAIAIgdB/////wFNBEAgCEEDai0AACECIAZB8ANqIAYoAtAOQZwEahDNCyAKQQRqIQogCygCOCAHIAIgBigC8ANqLQAAakECdGooAgAiAkH/////AUsEQCAHIQgMAwsgByEIIAogBEkNAQwCCwsgAiEIIAchAiAJIQoLAkACQAJAAkAgAkGAgICA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BigCcEUNCiAGKAJ0IgdBgYCAgHhGBEAgCCANIBBBAUYbIQ0gECEHDAsLIAdBgICAgAJxRQ0BIAhBAWohDSAGLQDoDg0IIAYgB0H/////fXEiBzYC3A5BACEQDAELIAggE0H86ssAELAHAAsgByECCyAIDQALDAULIAkgEEGc68sAELAHAAsMKQsMGwsMHgtBACEHDAELIAZB6ABqIAZB0A5qIAwgESACQYACEGEgBigCaEUEQEECIQcMAQsgBigCbCICQYGAgIB4RgRAQQAgDSAQQQFGGyENIBAhBwwBC0EAIBAgAkGAgICAAnEiAhshB0EAIA0gAhshDQsgCyALKAIAQQFqEN8LAkAgB0EBaw4CAgMACyAFIA1qIQULIAAgBTYCBCAAQQE2AgAgAEEIaiAONgIADAYLIABBADYCAAwFCyAAIAFBACADIAQgBRCpBgwECyACQbgEai0AAEEBRw0AIABBADYCAAwDCyAEIAVPBEAgBkHQDmogAkEIaiADIAVqIAQgBWsQuAVBACECIAAgBigC0A5BAUYEfyAAIAYoAtQOIAVqNgIEIABBCGogBkHYDmooAgAgBWo2AgBBAQUgAgs2AgAMAwsMFAtBACEICyAAIAg2AgALIAZB8A5qJAAPC0EBQQBB7NPLABCxBwALIAIgCUHs6ssAELAHAAsgDiAEQdzqywAQsAcACyAHIApBnOvLABCwBwALIAcgCkGM68sAELAHAAtB/PLLAEEQIAZB0A5qQZT1ywBBvOrLABDzBgALIAUgBEGA7ssAELEHAAtByPTLAEErQfDtywAQ0QkACyAFIARBkO7LABCxBwALQQBBAEGM8ssAELAHAAtBAEEAQbzyywAQsAcAC0EAQQBB3PLLABCwBwALIAUgBEGw7ssAELEHAAsgByALQZzrywAQsAcACyAHIAlBjOvLABCwBwALQfzyywBBECAGQdAOakGU9csAQczqywAQ8wYACyAFIARB0O7LABCxBwALIAUgBEGg7ssAELEHAAsgDyAEQdzqywAQsAcACyAFIARBwO7LABCxBwALIAcgDUGc68sAELAHAAsgAiAEQfDuywAQsgcACyACIARB4O7LABCxBwALIAIgC0Hs6ssAELAHAAsgByALQYzrywAQsAcAC0GA78sAQShBqO/LABDoCgALIAwgBEHc6ssAELAHAAsgBiAGQcAOajYC4A4gBkHQDmpBnO3LABDXCgALIAkgCEGM68sAELAHAAuAZwIYfwN+IwBBsAVrIgIkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEQaigCACILIAEoAhQiDU8EQAJAAkACQAJAAkACQAJAAkACQCABKAIAIgMoAgBBCGogASgCDCIPIAsQuQUEQCADKAIAIgNB9BNqLQAAQQFrDgYCDw4NDAsBCyACQQA2AvAEDBYLAkACQAJAAkAgA0H1E2otAABBAWsOAwMBAgALIAsgDWshByANIA9qIQogA0GYAWooAgAiBCEFAkACfwJAAkACQAJAIARBAWsOBAABAgMFCyADQagBaiEEAn8CQAJAAkACQCADQbABaigCACIGDgQhAQIDAAsgAkEIaiADQZwBaiAKIAcQmwUgAigCDCEFIAIoAggMAwsgAkEYaiAEEM0LIAIoAhxFDRIgB0UNHiACQRBqIAIoAhgtAAAgCiAHEL0CIAIoAhQhBSACKAIQDAILIAJBMGogBBDNCyACKAI0RQ0QIAIoAjAtAAAhAyACQShqIAQQzQsgAigCLCIEQQFNDQ8gB0UNHSACQSBqIAMgAigCKC0AASAKIAcQiAIgAigCJCEFIAIoAiAMAQsgAkHQAGogBBDNCyACKAJURQ0NIAIoAlAtAAAhAyACQcgAaiAEEM0LIAIoAkwiBkEBTQ0MIAIoAkgtAAEhBiACQUBrIAQQzQsgAigCRCIEQQJNDQsgB0UNHCACQThqIAMgBiACKAJALQACIAogBxDkASACKAI8IQUgAigCOAtFDRsgBUEBaiEEDAQLIAJB4ABqIANBoAFqIgMgCiAHEK8EIAIoAmBFDRogAigCZCEFIAJB2ABqIAMQ6wsgBSACKAJcaiEEDAMLIAJBgAVqIANBnAFqIAogBxA8IAJBjAVqKAIAIgQgAkGIBWooAgBrDAELIAJBgAVqIANBnAFqIAogB0EAEIcHIAJBjAVqKAIAIgQgAkGIBWooAgBrCyEFIAIoAoAFRQ0YCyACQfgEaiAEIA1qNgIAIAIgBSANajYC9ARBASEGDBcLIAJBgAVqIANBsA1qIA0gD2ogCyANaxCQBUEAIQMgAiACKAKABUEBRgR/IAJB+ARqIAJBiAVqKAIAIA1qNgIAIAIgAigChAUgDWo2AvQEQQEFIAMLNgLwBAwXCyADQawRaiIDKAIAQQJGDQIgAkGABWogAyANIA9qIAsgDWsQPEEAIQMgAiACKAKABUEBRgR/IAJB+ARqIAJBjAVqKAIAIA1qIgM2AgAgAiADIAJBiAVqKAIAazYC9ARBAQUgAws2AvAEDBYLIA0NEQwSCyABQQhqKAIAIgQgASgCBCAEGyIMKAIARQRAIAxBfxDfCyACQQA6AJgFIAIgDTYCiAUgAkEANgKEBSACIANBwARqNgKABSACIAxBCGoiBjYClAUgAiANNgKQBSACQYCAgIB4NgKMBSAPIAsgDRCPBCEaQQEhByACKAKUBSIFQdAAaigCACIIIBpC//////////8AgyIbQiuIp0HAAHEgGkL///////8/gyIcQhyIp0EQcSAapyIDQQd2QQJxIANBAXFyIANBDnZBBHFyIANBFXZBCHFyciAcQiOIp0EgcXJyIgRLBEAgDEH4AGohDgJAAkACQCAFKAJIIARBAnRqKAIAIgNBgICAgHhqDgIAEwELIAZBADYCeCACQYAFaiACKAKABSgCmAQgDiAaEKQCIAJB8AFqIAJBgAVqIA4gG0IwiKdBABCYASACKALwAUUEQEECIQcMEwsgAigC9AEhAwJAIAIoAoAFIgUtAK8EDQAgBRD0CEUNACADIANBgICAgARyIAUtALAEGyEDCyACKAKUBSIFQdAAaigCACIIIARNDQEgBSgCSCAEQQJ0aiADNgIAIANBgYCAgHhGDRILIAIgAzYChAUgBkGEAWohEEEBIQggAigCiAUiCSALTwRAIAMhBgwRCyAJIQcgAyEGA0ACQCADQf////8BSwRAIAchBAwBCyAHIgQgC08NAANAIAQgD2oiBi0AACEFIAJB6AFqIAIoAoAFQZwEahDNCwJAAkAgAigClAUiESgCOCADIAUgAigC6AFqLQAAakECdGooAgAiBUH/////AUsNACAEQQNqIgcgC08NACAGQQFqLQAAIQMgAkHgAWogAigCgAVBnARqEM0LIBEoAjggBSADIAIoAuABai0AAGpBAnRqKAIAIgNB/////wFNDQEgBEECaiEEIAUhBgwDCyAEQQFqIQQgAyEGIAUhAwwCCyAGQQJqLQAAIQUgAkHYAWogAigCgAVBnARqEM0LIAIoApQFIhEoAjggAyAFIAIoAtgBai0AAGpBAnRqKAIAIgVB/////wFNBEAgBkEDai0AACEDIAJB0AFqIAIoAoAFQZwEahDNCyAEQQRqIQQgESgCOCAFIAMgAigC0AFqLQAAakECdGooAgAiA0H/////AUsEQCAFIQYMAwsgBSEGIAQgC0kNAQwCCwsgAyEGIAUhAyAHIQQLAkACQAJAAkAgA0GAgICAAnFFBEAgA0GAgICABHENASADQQBIDQIgAyEGIAQhBwwECyAEQX9qIQpBACEHIAItAJgFDRcgAiADQf////99cSIGNgKMBSACKAKABSIFQYQEaigCAEEBTQ0CIAJBgAVqIAYQ8wgiAygCBCIFRQ0eIAJBADYCoAUgAiAFQX9qNgKoBSACIAMoAgBBCWo2AqQFA0AgAkHIAWogAkGgBWoQwgMgAigCyAFBAUcNGCACKAKABSIFQfgDaigCACIIIAIoAswBIgNNDSAgBSgC8AMgA0EEdGooAgBFDQALDAILIAJBuAFqIAJBgAVqIA8gCyAEENsBIAIoArgBRQRAQQEhByALIQoMFwsgAigCvAEhByADQf////97cSIGIQMMAgtBAiEHIANBgoCAgHhGDRUgBEF/aiIKIAtPDR4gAiAENgKIBSACQbABaiACQYAFaiAOIBAgBkH/////AXEgCiAPai0AABBhIAIoArABRQ0VIAIoArQBIgZBgYCAgHhGBEAgBCAJIAhBAUYbIQogCCEHDBYLIAZBgICAgAJxRQRAIAYhAyAEIQcMAgsgAi0AmAUEQEEAIQcMFgsgAiAGQf////99cSIGNgKMBUEAIQggBiEDIAQhByAKIQkMAQsgBiEDIAQhBwJAIARBAmogC08NACAFQZwEaiEIIAIoApQFIQkgBCEFA0AgBSAPai0AACEDIAJBwAFqIAgQzQsgBUEBaiEHIAkoAjggBiADIAIoAsABai0AAGpBAnRqKAIAIgNB/////31xIAZHDQEgBUEDaiAHIQUgC0kNAAsLIAdBfmogCiAHIARLGyEJQQAhCAsgByALSQ0ACwwQCwwbCwwbCwwbC0GLvssAQStBpLfLABDRCQALQQIgBEGMucsAELAHAAtBASAGQfy4ywAQsAcAC0EAQQBB7LjLABCwBwALQQEgBEGsucsAELAHAAtBAEEAQZy5ywAQsAcAC0EAQQBBvLnLABCwBwALIABBADYCAAwNCyACQQA2AvAEDAsLIAJB8ARqIAEgA0H1E2otAAAgDyALIA0QqQYMCgsgAkHoBGpBtLbLAEGMARDmCyACQZQFakEBNgIAIAJCATcChAUgAkGEtssANgKABSACIAIpA+gENwOgBSACIAJBoAVqNgKQBSACQYAFakGUt8sAENcKAAsgD0F/aiETIA9BfGohFCADQfgNaiERIA0iAyEMAkACQAJAAkACQAJAAkACQAJAA0AgAkHgBGogESADIA9qIAsgA2sQrwQgAigC4ARFDQggAigC5AQhBCACQdgEaiAREOsLAkACQCADIARqIhUgAigC3ARqIgMgDE8EQCADIAtNBEAgASgCCCIEIAEoAgQgBBsiDigCAEUEQCABKAIAKAIAIQQgDkF/EN8LIAJBADoAmAUgAiADIAxrIgo2AogFIAJBADYChAUgAiAEQfgIajYCgAUgAiAOQaABajYClAUgAiAKNgKQBSACQYCAgIB4NgKMBSAMIA9qIhYgCiAKENUDIRogAigClAUiB0HQAGooAgAiBiAaQv//////////AIMiG0IriKdBwABxIBpC////////P4MiHEIciKdBEHEgGqciA0EHdkECcSADQQFxciADQQ52QQRxciADQRV2QQhxcnIgHEIjiKdBIHFyciIESwRAIA5BkAJqIRAgDkEIaiEGQQEhBQJAAkACQCAEQQJ0IgggBygCSGooAgAiA0GAgICAeGoOAgAIAQsgBkEANgKQAiACQYAFaiACKAKABSgCmAQgECAaEKQCIAJB0ARqIAJBgAVqIBAgG0IwiKdBABCYASACKALQBEUEQEECIQUMCAsgAigC1AQhAwJAIAIoAoAFIgctAK8EDQAgBxD0CEUNACADIANBgICAgARyIActALAEGyEDCyACKAKUBSIHQdAAaigCACIJIARNDQEgBygCSCAIaiADNgIAIANBgYCAgHhGDQcLIAIgAzYChAUgBkGcAmohEiACKAKIBSIJRQRAQQEhB0EAIQkMBgsgDCATaiEXIAwgFGohGEEBIQcgCSEGIAMhBQNAAkAgBSIEQf////8BSw0AA0AgBiAYaiIEQQNqLQAAIQMgAkHIBGogAigCgAVBnARqEM0LAkAgBkF/aiIIQQVJIAIoApQFIhkoAjggBSADIAIoAsgEai0AAGpBAnRqKAIAIgNB/////wFLckUEQCAEQQJqLQAAIQUgAkHABGogAigCgAVBnARqEM0LIBkoAjggAyAFIAIoAsAEai0AAGpBAnRqKAIAIgVBgICAgAJJDQEgBkF+aiEGIAUhBAwDCyADIQQgBSEDIAghBgwCCyAEQQFqLQAAIQMgAkG4BGogAigCgAVBnARqEM0LIAIoApQFIggoAjggBSADIAIoArgEai0AAGpBAnRqKAIAIgNB/////wFNBEAgBC0AACEEIAJBsARqIAIoAoAFQZwEahDNCyAGQXxqIQYgCCgCOCADIAQgAigCsARqLQAAakECdGooAgAiBSEEIAVBgICAgAJJDQEMAgsLIAZBfWohBiADIQQgBSEDCwJAAkAgBEGAgICAAnFFBEAgBEEASA0BIAQhBSAEIQMMAgsgBkEBaiEHIAItAJgFBEBBACEFIAchCgwKCyACIARB/////31xIgM2AowFIAMhBQJAIAYiBEECSQ0AIAIoAoAFQZwEaiEIIAIoApQFIQkDQCAEIBdqLQAAIQUgAkGoBGogCBDNCyAEQX9qIQQgCSgCOCADIAUgAigCqARqLQAAakECdGooAgAiBUH/////fXEgA0cNASAEQQFLDQALCyAEQQJqIAcgBCAGSRshCUEAIQcgBCEGDAELQQIhBSAEQYKAgIB4Rg0IAkAgBiAKSQRAIAIgBjYCiAUgAkGgBGogAkGABWogECASIANB/////wFxIAYgFmotAAAQYSACKAKgBEUNCiACKAKkBCIFQYGAgIB4RgRAIAYgCSAHQQFGGyEKIAchBQwLCyAFQYCAgIACcUUNASAGQQFqIQkgAi0AmAUEQEEAIQUgCSEKDAsLIAIgBUH/////fXEiBTYCjAVBACEHDAELIAYgCkGotcsAELAHAAsgBSEDCyAGDQALDAULDCALDCALDCALIAMgC0HEt8sAELIHAAsgDCADQcS3ywAQswcACyACQZgEaiACQYAFaiAQIBIgA0GAAhBhIAIoApgERQRAQQIhBQwBCyACKAKcBCIDQYGAgIB4RgRAQQAgCSAHQQFGGyEKIAchBQwBC0EAIAcgA0GAgICAAnEiAxshBUEAIAkgAxshCgsgDiAOKAIAQQFqEN8LIAVBAUcEQAJAIAVBAWsOAgALAwsACyAKRQ0CIAogDGohDCAVQQFqIgMgC00NAAsgAyALQbS3ywAQsQcACyAKDQELIAEoAggiAyABKAIEIAMbIgwoAgBFBEAgASgCACgCACEDIAxBfxDfCyACQQA6AJgFIAIgDTYCiAUgAkEANgKEBSACIANBwARqNgKABSACIAxBCGoiBjYClAUgAiANNgKQBSACQYCAgIB4NgKMBSAPIAsgDRCPBCEaQQEhByACKAKUBSIFQdAAaigCACIIIBpC//////////8AgyIbQiuIp0HAAHEgGkL///////8/gyIcQhyIp0EQcSAapyIDQQd2QQJxIANBAXFyIANBDnZBBHFyIANBFXZBCHFyciAcQiOIp0EgcXJyIgRLBEAgDEH4AGohDgJAAkACQCAFKAJIIARBAnRqKAIAIgNBgICAgHhqDgIABwELIAZBADYCeCACQYAFaiACKAKABSgCmAQgDiAaEKQCIAJBwANqIAJBgAVqIA4gG0IwiKdBABCYASACKALAA0UEQEECIQcMBwsgAigCxAMhAwJAIAIoAoAFIgUtAK8EDQAgBRD0CEUNACADIANBgICAgARyIAUtALAEGyEDCyACKAKUBSIFQdAAaigCACIIIARNDQEgBSgCSCAEQQJ0aiADNgIAIANBgYCAgHhGDQYLIAIgAzYChAUgBkGEAWohEEEBIQggAigCiAUiCSALTwRAIAMhBgwFCyAJIQcgAyEGA0ACQCADQf////8BSwRAIAchBAwBCyAHIgQgC08NAANAIAQgD2oiBi0AACEFIAJBuANqIAIoAoAFQZwEahDNCwJAAkAgAigClAUiESgCOCADIAUgAigCuANqLQAAakECdGooAgAiBUH/////AUsNACAEQQNqIgcgC08NACAGQQFqLQAAIQMgAkGwA2ogAigCgAVBnARqEM0LIBEoAjggBSADIAIoArADai0AAGpBAnRqKAIAIgNB/////wFNDQEgBEECaiEEIAUhBgwDCyAEQQFqIQQgAyEGIAUhAwwCCyAGQQJqLQAAIQUgAkGoA2ogAigCgAVBnARqEM0LIAIoApQFIhEoAjggAyAFIAIoAqgDai0AAGpBAnRqKAIAIgVB/////wFNBEAgBkEDai0AACEDIAJBoANqIAIoAoAFQZwEahDNCyAEQQRqIQQgESgCOCAFIAMgAigCoANqLQAAakECdGooAgAiA0H/////AUsEQCAFIQYMAwsgBSEGIAQgC0kNAQwCCwsgAyEGIAUhAyAHIQQLAkACQAJAAkAgA0GAgICAAnFFBEAgA0GAgICABHENASADQQBIDQIgAyEGIAQhBwwECyAEQX9qIQpBACEHIAItAJgFDQsgAiADQf////99cSIGNgKMBSACKAKABSIFQYQEaigCAEEBTQ0CIAJBgAVqIAYQ8wgiAygCBCIFRQ0ZIAJBADYCoAUgAiAFQX9qNgKoBSACIAMoAgBBCWo2AqQFA0AgAkGYA2ogAkGgBWoQwgMgAigCmANBAUcNDCACKAKABSIFQfgDaigCACIIIAIoApwDIgNNDRsgBSgC8AMgA0EEdGooAgBFDQALDAILIAJBiANqIAJBgAVqIA8gCyAEENsBIAIoAogDRQRAQQEhByALIQoMCwsgAigCjAMhByADQf////97cSIGIQMMAgtBAiEHIANBgoCAgHhGDQkgBEF/aiIKIAtPDRkgAiAENgKIBSACQYADaiACQYAFaiAOIBAgBkH/////AXEgCiAPai0AABBhIAIoAoADRQ0JIAIoAoQDIgZBgYCAgHhGBEAgBCAJIAhBAUYbIQogCCEHDAoLIAZBgICAgAJxRQRAIAYhAyAEIQcMAgsgAi0AmAUEQEEAIQcMCgsgAiAGQf////99cSIGNgKMBUEAIQggBiEDIAQhByAKIQkMAQsgBiEDIAQhBwJAIARBAmogC08NACAFQZwEaiEIIAIoApQFIQkgBCEFA0AgBSAPai0AACEDIAJBkANqIAgQzQsgBUEBaiEHIAkoAjggBiADIAIoApADai0AAGpBAnRqKAIAIgNB/////31xIAZHDQEgBUEDaiAHIQUgC0kNAAsLIAdBfmogCiAHIARLGyEJQQAhCAsgByALSQ0ACwwECwwWCwwWCwwWCwJAAkACQCABKAIIIgMgASgCBCADGyIOKAIARQRAIAEoAgAoAgAhAyAOQX8Q3wsgAkEAOgCYBSACIAogDGoiDDYCiAUgAkEANgKEBSACIANBwARqNgKABSACIA5BCGoiBjYClAUgAiAMNgKQBSACQYCAgIB4NgKMBSAPIAsgDBCPBCEaQQEhByACKAKUBSIFQdAAaigCACIIIBpC//////////8AgyIbQiuIp0HAAHEgGkL///////8/gyIcQhyIp0EQcSAapyIDQQd2QQJxIANBAXFyIANBDnZBBHFyIANBFXZBCHFyciAcQiOIp0EgcXJyIgRLBEAgDkH4AGohEAJAAkACQCAFKAJIIARBAnRqKAIAIgNBgICAgHhqDgIABgELIAZBADYCeCACQYAFaiACKAKABSgCmAQgECAaEKQCIAJBkARqIAJBgAVqIBAgG0IwiKdBABCYASACKAKQBEUEQEECIQcMBgsgAigClAQhAwJAIAIoAoAFIgUtAK8EDQAgBRD0CEUNACADIANBgICAgARyIAUtALAEGyEDCyACKAKUBSIFQdAAaigCACIIIARNDQEgBSgCSCAEQQJ0aiADNgIAIANBgYCAgHhGDQULIAIgAzYChAUgBkGEAWohEUEBIQggAigCiAUiCSALTwRAIAMhBgwECyAJIQcgAyEGA0ACQCADQf////8BSwRAIAchBAwBCyAHIgQgC08NAANAIAQgD2oiBi0AACEFIAJBiARqIAIoAoAFQZwEahDNCwJAAkAgAigClAUiEigCOCADIAUgAigCiARqLQAAakECdGooAgAiBUH/////AUsNACAEQQNqIgcgC08NACAGQQFqLQAAIQMgAkGABGogAigCgAVBnARqEM0LIBIoAjggBSADIAIoAoAEai0AAGpBAnRqKAIAIgNB/////wFNDQEgBEECaiEEIAUhBgwDCyAEQQFqIQQgAyEGIAUhAwwCCyAGQQJqLQAAIQUgAkH4A2ogAigCgAVBnARqEM0LIAIoApQFIhIoAjggAyAFIAIoAvgDai0AAGpBAnRqKAIAIgVB/////wFNBEAgBkEDai0AACEDIAJB8ANqIAIoAoAFQZwEahDNCyAEQQRqIQQgEigCOCAFIAMgAigC8ANqLQAAakECdGooAgAiA0H/////AUsEQCAFIQYMAwsgBSEGIAQgC0kNAQwCCwsgAyEGIAUhAyAHIQQLAkACQAJAAkAgA0GAgICAAnFFBEAgA0GAgICABHENASADQQBIDQIgAyEGIAQhBwwECyAEQX9qIQpBACEHIAItAJgFDQogAiADQf////99cSIGNgKMBSACKAKABSIFQYQEaigCAEEBTQ0CIAJBgAVqIAYQ8wgiAygCBCIFRQ0bIAJBADYCoAUgAiAFQX9qNgKoBSACIAMoAgBBCWo2AqQFA0AgAkHoA2ogAkGgBWoQwgMgAigC6ANBAUcNCyACKAKABSIFQfgDaigCACIIIAIoAuwDIgNNDR0gBSgC8AMgA0EEdGooAgBFDQALDAILIAJB2ANqIAJBgAVqIA8gCyAEENsBIAIoAtgDRQRAQQEhByALIQoMCgsgAigC3AMhByADQf////97cSIGIQMMAgtBAiEHIANBgoCAgHhGDQggBEF/aiIKIAtPDRsgAiAENgKIBSACQdADaiACQYAFaiAQIBEgBkH/////AXEgCiAPai0AABBhIAIoAtADRQ0IIAIoAtQDIgZBgYCAgHhGBEAgBCAJIAhBAUYbIQogCCEHDAkLIAZBgICAgAJxRQRAIAYhAyAEIQcMAgsgAi0AmAUEQEEAIQcMCQsgAiAGQf////99cSIGNgKMBUEAIQggBiEDIAQhByAKIQkMAQsgBiEDIAQhBwJAIARBAmogC08NACAFQZwEaiEIIAIoApQFIQkgBCEFA0AgBSAPai0AACEDIAJB4ANqIAgQzQsgBUEBaiEHIAkoAjggBiADIAIoAuADai0AAGpBAnRqKAIAIgNB/////31xIAZHDQEgBUEDaiAHIQUgC0kNAAsLIAdBfmogCiAHIARLGyEJQQAhCAsgByALSQ0ACwwDCwwYCwwYCwwYCyACQcgDaiACQYAFaiAQIBEgBkH/////AXFBgAIQYSACKALIA0UEQEECIQcMAgsgAigCzAMiA0GBgICAeEYEQCALIAkgCEEBRhshCiAIIQcMAgtBACAIIANBgICAgAJxIgMbIQcgCyAJIAMbIQoMAQsgDCEKCyAOIA4oAgBBAWoQ3wsCQCAHQQFrDgIABgQLQdS3ywBBKEH8t8sAEOgKAAsgAkH4AmogAkGABWogDiAQIAZB/////wFxQYACEGEgAigC+AJFBEBBAiEHDAILIAIoAvwCIgNBgYCAgHhGBEAgCyAJIAhBAUYbIQogCCEHDAILQQAgCCADQYCAgIACcSIDGyEHIAsgCSADGyEKDAELIA0hCgsgDCAMKAIAQQFqEN8LAkAgB0EBaw4CAgMACyAKIA1GBEAgDSEMIA0hCgwBCwJAAkACQCABKAIIIgMgASgCBCADGyIMKAIARQRAIAEoAgAoAgAhAyAMQX8Q3wsgAkEAOgCYBSACIAogDWsiCDYCiAUgAkEANgKEBSACIANB+AhqNgKABSACIAxBoAFqNgKUBSACIAg2ApAFIAJBgICAgHg2AowFIA0gD2oiECALIA1rIhEgCBDVAyEaQQEhBSACKAKUBSIHQdAAaigCACIGIBpC//////////8AgyIbQiuIp0HAAHEgGkL///////8/gyIcQhyIp0EQcSAapyIDQQd2QQJxIANBAXFyIANBDnZBBHFyIANBFXZBCHFyciAcQiOIp0EgcXJyIgRLBEAgDEGQAmohDiAMQQhqIQYCQAJAAkAgBygCSCAEQQJ0aigCACIDQYCAgIB4ag4CAAcBCyAGQQA2ApACIAJBgAVqIAIoAoAFKAKYBCAOIBoQpAIgAkHwAmogAkGABWogDiAbQjCIp0EAEJgBIAIoAvACRQRAQQIhBQwHCyACKAL0AiEDAkAgAigCgAUiBy0ArwQNACAHEPQIRQ0AIAMgA0GAgICABHIgBy0AsAQbIQMLIAIoApQFIgdB0ABqKAIAIgkgBE0NASAHKAJIIARBAnRqIAM2AgAgA0GBgICAeEYNBgsgAiADNgKEBSAGQZwCaiESIAIoAogFIghFBEBBASEJQQAhCAwFCyAQQX9qIRMgEEF8aiEUQQEhCSAIIQYgAyEFA0ACQCAFIgRB/////wFLDQADQCAGIBRqIgRBA2otAAAhAyACQegCaiACKAKABUGcBGoQzQsCQCAGQX9qIgdBBUkgAigClAUiFSgCOCAFIAMgAigC6AJqLQAAakECdGooAgAiA0H/////AUtyRQRAIARBAmotAAAhBSACQeACaiACKAKABUGcBGoQzQsgFSgCOCADIAUgAigC4AJqLQAAakECdGooAgAiBUGAgICAAkkNASAGQX5qIQYgBSEEDAMLIAMhBCAFIQMgByEGDAILIARBAWotAAAhAyACQdgCaiACKAKABUGcBGoQzQsgAigClAUiBygCOCAFIAMgAigC2AJqLQAAakECdGooAgAiA0H/////AU0EQCAELQAAIQQgAkHQAmogAigCgAVBnARqEM0LIAZBfGohBiAHKAI4IAMgBCACKALQAmotAABqQQJ0aigCACIFIQQgBUGAgICAAkkNAQwCCwsgBkF9aiEGIAMhBCAFIQMLAkACQCAEQYCAgIACcUUEQCAEQQBIDQEgBCEFIAQhAwwCCyAGQQFqIQggAi0AmAUNBiACIARB/////31xIgM2AowFIAMhBQJAIAYiBEECSQ0AIAIoAoAFQZwEaiEHIAIoApQFIQkDQCAEIBNqLQAAIQUgAkHIAmogBxDNCyAEQX9qIQQgCSgCOCADIAUgAigCyAJqLQAAakECdGooAgAiBUH/////fXEgA0cNASAEQQFLDQALCyAEQQJqIAggBCAGSRshCEEAIQkgBCEGDAELQQIhBSAEQYKAgIB4Rg0HAkAgBiARSQRAIAIgBjYCiAUgAkHAAmogAkGABWogDiASIANB/////wFxIAYgEGotAAAQYSACKALAAkUNCSACKALEAiIFQYGAgIB4RgRAIAYgCCAJQQFGGyEIIAkhBQwKCyAFQYCAgIACcUUNASAGQQFqIQggAi0AmAUNByACIAVB/////31xIgU2AowFQQAhCQwBCyAGIBFBqLXLABCwBwALIAUhAwsgBg0ACwwECwwYCwwYCwwYC0EAIQUMAQsgAkG4AmogAkGABWogDiASIANBgAIQYSACKAK4AkUEQEECIQUMAQsgAigCvAIiA0GBgICAeEYEQEEAIAggCUEBRhshCCAJIQUMAQtBACAJIANBgICAgAJxIgMbIQVBACAIIAMbIQgLIAwgDCgCAEEBahDfCwJAIAVBAWsOAgIDAAsgCCANaiEMCyACQfgEaiAKNgIAIAIgDDYC9AQgAkEBNgLwBAwKCyACQQA2AvAEDAkLIAJB8ARqIAFBACAPIAsgDRCpBgwICwJAAkAgAUEIaigCACIEIAEoAgQgBBsiCCgCAEUEQCAIQX8Q3wsgAkEAOgCYBSACIAsgDWsiCjYCiAUgAkEANgKEBSACIANB+AhqNgKABSACIAhBoAFqNgKUBSACIAo2ApAFIAJBgICAgHg2AowFIA0gD2oiECAKIAoQ1QMhGkEBIQUgAigClAUiB0HQAGooAgAiBiAaQv//////////AIMiG0IriKdBwABxIBpC////////P4MiHEIciKdBEHEgGqciA0EHdkECcSADQQFxciADQQ52QQRxciADQRV2QQhxcnIgHEIjiKdBIHFyciIESwRAIAhBkAJqIQ4gCEEIaiEGAkACQAJAIAcoAkggBEECdGooAgAiA0GAgICAeGoOAgAGAQsgBkEANgKQAiACQYAFaiACKAKABSgCmAQgDiAaEKQCIAJBsAJqIAJBgAVqIA4gG0IwiKdBABCYASACKAKwAkUEQEECIQUMBgsgAigCtAIhAwJAIAIoAoAFIgctAK8EDQAgBxD0CEUNACADIANBgICAgARyIActALAEGyEDCyACKAKUBSIHQdAAaigCACIJIARNDQEgBygCSCAEQQJ0aiADNgIAIANBgYCAgHhGDQULIAIgAzYChAUgBkGcAmohESACKAKIBSIMRQRAQQEhCUEAIQwMBAsgEEF/aiESIBBBfGohE0EBIQkgDCEGIAMhBQNAAkAgBSIEQf////8BSw0AA0AgBiATaiIEQQNqLQAAIQMgAkGoAmogAigCgAVBnARqEM0LAkAgBkF/aiIHQQVJIAIoApQFIhQoAjggBSADIAIoAqgCai0AAGpBAnRqKAIAIgNB/////wFLckUEQCAEQQJqLQAAIQUgAkGgAmogAigCgAVBnARqEM0LIBQoAjggAyAFIAIoAqACai0AAGpBAnRqKAIAIgVBgICAgAJJDQEgBkF+aiEGIAUhBAwDCyADIQQgBSEDIAchBgwCCyAEQQFqLQAAIQMgAkGYAmogAigCgAVBnARqEM0LIAIoApQFIgcoAjggBSADIAIoApgCai0AAGpBAnRqKAIAIgNB/////wFNBEAgBC0AACEEIAJBkAJqIAIoAoAFQZwEahDNCyAGQXxqIQYgBygCOCADIAQgAigCkAJqLQAAakECdGooAgAiBSEEIAVBgICAgAJJDQEMAgsLIAZBfWohBiADIQQgBSEDCwJAAkAgBEGAgICAAnFFBEAgBEEASA0BIAQhBSAEIQMMAgsgBkEBaiEHIAItAJgFBEBBACEFIAchCgwICyACIARB/////31xIgM2AowFIAMhBQJAIAYiBEECSQ0AIAIoAoAFQZwEaiEJIAIoApQFIQwDQCAEIBJqLQAAIQUgAkGIAmogCRDNCyAEQX9qIQQgDCgCOCADIAUgAigCiAJqLQAAakECdGooAgAiBUH/////fXEgA0cNASAEQQFLDQALCyAEQQJqIAcgBCAGSRshDEEAIQkgBCEGDAELQQIhBSAEQYKAgIB4Rg0GAkAgBiAKSQRAIAIgBjYCiAUgAkGAAmogAkGABWogDiARIANB/////wFxIAYgEGotAAAQYSACKAKAAkUNCCACKAKEAiIFQYGAgIB4RgRAIAYgDCAJQQFGGyEKIAkhBQwJCyAFQYCAgIACcUUNASAGQQFqIQwgAi0AmAUEQEEAIQUgDCEKDAkLIAIgBUH/////fXEiBTYCjAVBACEJDAELIAYgCkGotcsAELAHAAsgBSEDCyAGDQALDAMLDBMLDBMLDBMLIAJB+AFqIAJBgAVqIA4gESADQYACEGEgAigC+AFFBEBBAiEFDAELIAIoAvwBIgNBgYCAgHhGBEBBACAMIAlBAUYbIQogCSEFDAELQQAgCSADQYCAgIACcSIDGyEFQQAgDCADGyEKCyAIIAgoAgBBAWoQ3wsCQAJAAkAgBUEBaw4CAQIACyACQfgEaiALNgIAIAJBATYC8AQgAiAKIA1qNgL0BAwJCyACQQA2AvAEDAgLIAJB8ARqIAFBACAPIAsgDRCpBgwHCyACQagBaiACQYAFaiAOIBAgBkH/////AXFBgAIQYSACKAKoAUUEQEECIQcMAgsgAigCrAEiA0GBgICAeEYEQCALIAkgCEEBRhshCiAIIQcMAgtBACAIIANBgICAgAJxIgMbIQcgCyAJIAMbIQoMAQsgDSEKCyAMIAwoAgBBAWoQ3wsCQAJAAkAgB0EBaw4CAQIACwJAIAogDUYEQCANIQoMAQsCQAJAAkAgASgCCCIDIAEoAgQgAxsiDCgCAEUEQCABKAIAKAIAIQMgDEF/EN8LIAJBADoAmAUgAiAKIA1rIgg2AogFIAJBADYChAUgAiADQfgIajYCgAUgAiAMQaABajYClAUgAiAINgKQBSACQYCAgIB4NgKMBSANIA9qIhAgCyANayIRIAgQ1QMhGkEBIQUgAigClAUiB0HQAGooAgAiBiAaQv//////////AIMiG0IriKdBwABxIBpC////////P4MiHEIciKdBEHEgGqciA0EHdkECcSADQQFxciADQQ52QQRxciADQRV2QQhxcnIgHEIjiKdBIHFyciIESwRAIAxBkAJqIQ4gDEEIaiEGAkACQAJAIAcoAkggBEECdGooAgAiA0GAgICAeGoOAgAHAQsgBkEANgKQAiACQYAFaiACKAKABSgCmAQgDiAaEKQCIAJBoAFqIAJBgAVqIA4gG0IwiKdBABCYASACKAKgAUUEQEECIQUMBwsgAigCpAEhAwJAIAIoAoAFIgctAK8EDQAgBxD0CEUNACADIANBgICAgARyIActALAEGyEDCyACKAKUBSIHQdAAaigCACIJIARNDQEgBygCSCAEQQJ0aiADNgIAIANBgYCAgHhGDQYLIAIgAzYChAUgBkGcAmohEiACKAKIBSIIRQRAQQEhCUEAIQgMBQsgEEF/aiETIBBBfGohFEEBIQkgCCEGIAMhBQNAAkAgBSIEQf////8BSw0AA0AgBiAUaiIEQQNqLQAAIQMgAkGYAWogAigCgAVBnARqEM0LAkAgBkF/aiIHQQVJIAIoApQFIhUoAjggBSADIAIoApgBai0AAGpBAnRqKAIAIgNB/////wFLckUEQCAEQQJqLQAAIQUgAkGQAWogAigCgAVBnARqEM0LIBUoAjggAyAFIAIoApABai0AAGpBAnRqKAIAIgVBgICAgAJJDQEgBkF+aiEGIAUhBAwDCyADIQQgBSEDIAchBgwCCyAEQQFqLQAAIQMgAkGIAWogAigCgAVBnARqEM0LIAIoApQFIgcoAjggBSADIAIoAogBai0AAGpBAnRqKAIAIgNB/////wFNBEAgBC0AACEEIAJBgAFqIAIoAoAFQZwEahDNCyAGQXxqIQYgBygCOCADIAQgAigCgAFqLQAAakECdGooAgAiBSEEIAVBgICAgAJJDQEMAgsLIAZBfWohBiADIQQgBSEDCwJAAkAgBEGAgICAAnFFBEAgBEEASA0BIAQhBSAEIQMMAgsgBkEBaiEIIAItAJgFDQYgAiAEQf////99cSIDNgKMBSADIQUCQCAGIgRBAkkNACACKAKABUGcBGohByACKAKUBSEJA0AgBCATai0AACEFIAJB+ABqIAcQzQsgBEF/aiEEIAkoAjggAyAFIAIoAnhqLQAAakECdGooAgAiBUH/////fXEgA0cNASAEQQFLDQALCyAEQQJqIAggBCAGSRshCEEAIQkgBCEGDAELQQIhBSAEQYKAgIB4Rg0HAkAgBiARSQRAIAIgBjYCiAUgAkHwAGogAkGABWogDiASIANB/////wFxIAYgEGotAAAQYSACKAJwRQ0JIAIoAnQiBUGBgICAeEYEQCAGIAggCUEBRhshCCAJIQUMCgsgBUGAgICAAnFFDQEgBkEBaiEIIAItAJgFDQcgAiAFQf////99cSIFNgKMBUEAIQkMAQsgBiARQai1ywAQsAcACyAFIQMLIAYNAAsMBAsMFAsMFAsMFAtBACEFDAELIAJB6ABqIAJBgAVqIA4gEiADQYACEGEgAigCaEUEQEECIQUMAQsgAigCbCIDQYGAgIB4RgRAQQAgCCAJQQFGGyEIIAkhBQwBC0EAIAkgA0GAgICAAnEiAxshBUEAIAggAxshCAsgDCAMKAIAQQFqEN8LAkAgBUEBaw4CAgMACyAIIA1qIQ0LIAJB+ARqIAo2AgAgAiANNgL0BCACQQE2AvAEDAYLIAJBADYC8AQMBQsgAkHwBGogAUEAIA8gCyANEKkGDAQLIANBuARqLQAAQQFHDQAgAkEANgLwBAwDCyACQYAFaiADQQhqIA0gD2ogCyANaxC4BUEAIQMgAiACKAKABUEBRgR/IAJB+ARqIAJBiAVqKAIAIA1qNgIAIAIgAigChAUgDWo2AvQEQQEFIAMLNgLwBAwCC0EAIQYLIAIgBjYC8AQLIAIoAvAEQQFHBEAgAEEANgIADAELAkAgAigC9AQiAyACQfgEaigCACIERwRAIAEgBDYCFAwBCyABAn8gA0EBaiADIAEoAhBPDQAaAn9BASABKAIMIANqLAAAIgZBf0oNABpBAiAGQf8BcSIGQd8BTQ0AGkEDQQQgBkHwAUkbCyADags2AhQgASgCGEEBRw0AIAMgAUEcaigCAEcNACAAIAEQMgwBCyABQQE2AhggACADNgIEIABBATYCACABQRxqIAQ2AgAgAEEIaiAENgIACyACQbAFaiQADwtBAUEAQezTywAQsQcACyADIAhBmLXLABCwBwALIAogC0GItcsAELAHAAsgBCAIQci1ywAQsAcACyAEIAhBuLXLABCwBwALQee9ywBBECACQYAFakG4vssAQei0ywAQ8wYACyAEIAlByLXLABCwBwALIAQgBkG4tcsAELAHAAtB573LAEEQIAJBgAVqQbi+ywBB+LTLABDzBgAL9lYCBn9YfiMAQfABayIDJAAgA0EAQYABEJEFIQMgACkDOCFGIAApAzAhFiAAKQMoIRQgACkDICESIAApAxghRyAAKQMQIRcgACkDCCETIAApAwAhDiACBEAgASACQQd0aiEIA0BBACECA0AgAiADaiABIAJqKQAAIg1COIYgDUIohkKAgICAgIDA/wCDhCANQhiGQoCAgICA4D+DIA1CCIZCgICAgPAfg4SEIA1CCIhCgICA+A+DIA1CGIhCgID8B4OEIA1CKIhCgP4DgyANQjiIhISENwMAIAJBCGoiAkGAAUcNAAsgAykDQCEdIAMpA2ghGCADKQM4IR4gAykDMCEfIAMpA2AhGSADKQNYIRogAykDKCEgIAMpAyAhISADKQN4IQwgAykDcCEVIAMpA1AhGyADKQNIIRwgAykDGCERIAMpAxAhDyADKQMIIRAgAyADKQMAIg03A7gBIAMgEDcDsAEgAyAPNwPIASADIBE3A8ABIAMgHDcD2AEgAyAbNwPQASADIBU3A+gBIAMgDDcD4AEgA0GAAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAyAPNwO4ASADIBE3A7ABIAMgITcDyAEgAyAgNwPAASADIBo3A9gBIAMgGTcD0AEgA0HoAWoiBSADQYgBaiICKQMANwMAIAMgAykDgAE3A+ABIANBkAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIANBmAFqIgQpAwAhUSACKQMAIVIgAykDkAEhUyADKQOAASFUIAMgITcDuAEgAyAgNwOwASADIB83A8gBIAMgHjcDwAEgAyAYNwPYASADIBU3A9ABIAUgBCkDADcDACADIAMpA5ABNwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASEiIAMpA6gBISMgAyAfNwO4ASADIB43A7ABIAMgHTcDyAEgAyAcNwPAASADIAw3A9gBIAMgUjcD0AEgAyAjNwPoASADICI3A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABISQgAykDqAEhJSADIB03A7gBIAMgHDcDsAEgAyAbNwPIASADIBo3A8ABIAMgVDcD2AEgAyBRNwPQASADICU3A+gBIAMgJDcD4AEgA0GgAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAykDoAEhJiADKQOoASEnIAMgGzcDuAEgAyAaNwOwASADIBk3A8gBIAMgGDcDwAEgAyBTNwPYASADICM3A9ABIAMgJzcD6AEgAyAmNwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASEoIAMpA6gBISkgAyAZNwO4ASADIBg3A7ABIAMgFTcDyAEgAyAMNwPAASADICI3A9gBIAMgJTcD0AEgAyApNwPoASADICg3A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABISogAykDqAEhKyADIBU3A7gBIAMgDDcDsAEgA0HIAWoiBiACKQMANwMAIAMgAykDgAE3A8ABIAMgJDcD2AEgAyAnNwPQASADICs3A+gBIAMgKjcD4AEgA0GgAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAykDoAEhLCADKQOoASEtIANBuAFqIgcgAikDADcDACADIAMpA4ABNwOwASAGIAQpAwA3AwAgAyADKQOQATcDwAEgAyAmNwPYASADICk3A9ABIAMgLTcD6AEgAyAsNwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASEuIAMpA6gBIS8gByAEKQMANwMAIAMgAykDkAE3A7ABIAMgIzcDyAEgAyAiNwPAASADICg3A9gBIAMgKzcD0AEgAyAvNwPoASADIC43A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABITAgAykDqAEhMSADICM3A7gBIAMgIjcDsAEgAyAlNwPIASADICQ3A8ABIAMgKjcD2AEgAyAtNwPQASADIDE3A+gBIAMgMDcD4AEgA0GAAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAyAlNwO4ASADICQ3A7ABIAMgJzcDyAEgAyAmNwPAASADICw3A9gBIAMgLzcD0AEgBSACKQMANwMAIAMgAykDgAE3A+ABIANBkAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAQpAwAhVSACKQMAIVYgAykDkAEhVyADKQOAASFYIAMgJzcDuAEgAyAmNwOwASADICk3A8gBIAMgKDcDwAEgAyAuNwPYASADIDE3A9ABIAUgBCkDADcDACADIAMpA5ABNwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASEyIAMpA6gBITMgAyApNwO4ASADICg3A7ABIAMgKzcDyAEgAyAqNwPAASADIDA3A9gBIAMgVjcD0AEgAyAzNwPoASADIDI3A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABITQgAykDqAEhNSADICs3A7gBIAMgKjcDsAEgAyAtNwPIASADICw3A8ABIAMgWDcD2AEgAyBVNwPQASADIDU3A+gBIAMgNDcD4AEgA0GgAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAykDoAEhNiADKQOoASE3IAMgLTcDuAEgAyAsNwOwASADIC83A8gBIAMgLjcDwAEgAyBXNwPYASADIDM3A9ABIAMgNzcD6AEgAyA2NwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASE4IAMpA6gBITkgAyAvNwO4ASADIC43A7ABIAMgMTcDyAEgAyAwNwPAASADIDI3A9gBIAMgNTcD0AEgAyA5NwPoASADIDg3A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABITogAykDqAEhOyADIDE3A7gBIAMgMDcDsAEgBiACKQMANwMAIAMgAykDgAE3A8ABIAMgNDcD2AEgAyA3NwPQASADIDs3A+gBIAMgOjcD4AEgA0GgAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAykDoAEhPCADKQOoASE9IAcgAikDADcDACADIAMpA4ABNwOwASAGIAQpAwA3AwAgAyADKQOQATcDwAEgAyA2NwPYASADIDk3A9ABIAMgPTcD6AEgAyA8NwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASE+IAMpA6gBIT8gByAEKQMANwMAIAMgAykDkAE3A7ABIAMgMzcDyAEgAyAyNwPAASADIDg3A9gBIAMgOzcD0AEgAyA/NwPoASADID43A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABIUAgAykDqAEhQSADIDM3A7gBIAMgMjcDsAEgAyA1NwPIASADIDQ3A8ABIAMgOjcD2AEgAyA9NwPQASADIEE3A+gBIAMgQDcD4AEgA0GAAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAyA1NwO4ASADIDQ3A7ABIAMgNzcDyAEgAyA2NwPAASADIDw3A9gBIAMgPzcD0AEgBSACKQMANwMAIAMgAykDgAE3A+ABIANBkAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAQpAwAhWSACKQMAIVogAykDkAEhWyADKQOAASFcIAMgNzcDuAEgAyA2NwOwASADIDk3A8gBIAMgODcDwAEgAyA+NwPYASADIEE3A9ABIAUgBCkDADcDACADIAMpA5ABNwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASFCIAMpA6gBIUMgAyA5NwO4ASADIDg3A7ABIAMgOzcDyAEgAyA6NwPAASADIEA3A9gBIAMgWjcD0AEgAyBDNwPoASADIEI3A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABIUQgAykDqAEhRSADIDs3A7gBIAMgOjcDsAEgAyA9NwPIASADIDw3A8ABIAMgXDcD2AEgAyBZNwPQASADIEU3A+gBIAMgRDcD4AEgA0GgAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAykDoAEhSCADKQOoASFJIAMgPTcDuAEgAyA8NwOwASADID83A8gBIAMgPjcDwAEgAyBbNwPYASADIEM3A9ABIAMgSTcD6AEgAyBINwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASFKIAMpA6gBIUsgAyA/NwO4ASADID43A7ABIAMgQTcDyAEgAyBANwPAASADIEI3A9gBIAMgRTcD0AEgAyBLNwPoASADIEo3A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABIUwgAykDqAEhTSADIEE3A7gBIAMgQDcDsAEgBiACKQMANwMAIAMgAykDgAE3A8ABIAMgRDcD2AEgAyBJNwPQASADIE03A+gBIAMgTDcD4AEgA0GgAWogA0GwAWogA0HAAWogA0HQAWogA0HgAWoQmgYgAykDoAEhTiADKQOoASFPIAcgAikDADcDACADIAMpA4ABNwOwASAGIAQpAwA3AwAgAyADKQOQATcDwAEgAyBINwPYASADIEs3A9ABIAMgTzcD6AEgAyBONwPgASADQaABaiADQbABaiADQcABaiADQdABaiADQeABahCaBiADKQOgASFdIAMpA6gBIVAgByAEKQMANwMAIAMgAykDkAE3A7ABIAMgQzcDyAEgAyBCNwPAASADIEo3A9gBIAMgTTcD0AEgAyBQNwPoASADIF03A+ABIANBoAFqIANBsAFqIANBwAFqIANB0AFqIANB4AFqEJoGIAMpA6ABIV4gAykDqAEhXyADIEM3A7gBIAMgQjcD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JSEDCyACKAKQJSADQQxsaiIDIAIpA9gBNwIAIANBCGogBCgCADYCACACIAIoApglQQFqNgKYJSAGIAxHDQALIAIoApAlIgRFDQELIAIpApQlITIgAiAENgKgNiACIDI3AqQ2IDJCIIinQSFPBEAgAkGQJWoQwQsgAkGQJWpBARC5DCEDIAJBiAFqIAJBoDZqEM0LIAIoAowBQYgnTQRAIAMQugwaCyACQdgBaiADIAJBoDZqENECIAIoAtgBQQFGDQQgAigC3AEhFyACQdAgaiACQeABakHEAhCJAxogAkGgNmoQ/AggAkGgNmoQ9woMAQsgAkGgNmoQ/AggAkGgNmoQ9woLIAJB4ClqIAVBEGooAgA2AgAgAkHYKWogBUEIaikCADcDACACIAUpAgA3A9ApIAJB2AFqIAJB0ClqEPcBIAJBqBNqEPUCIAJBqBNqIAJB2AFqQfADEIkDGkEBIRUgAi0AkBchHQJ/IAIoAsgTQQFHBEBBACEVIAIoAswTIRYgAkHQE2ooAgAMAQsgAigCzBMhBCACQYABaiACQdATaigCACIDQQAQhQggAiACKAKEATYC3AEgAiACKAKAASINNgLYASANIAQgAxCJAxogAiADNgLgASACQfgAaiACQdgBahCMCCACKAJ4IRYgAigCfAshHkEAIRICQAJAAkAgAi0AqBNBAWsOAgABAgtBASESIAItAKkTIRQMAQsgAkHuAWogAkHAE2opAwA3AQAgAkHmAWogAkG4E2opAwA3AQAgAiACQbATaikDADcB3gFBAiESCyACKALgEyEfIAJBtjFqIAJB7gFqKQEANwEAIAJBsDFqIAJB6AFqKQEANwMAIAJBqDFqIAJB4AFqKQEANwMAIAJBmDZqIAJB3BNqKAIANgIAIAIgAikB2AE3A6AxIAIgAikC1BM3A5A2QQEhGSACKALoEyEYAn8gAkGQFGooAgBBAUcEQEEAIRkgAigClBQhGiACQZgUaigCAAwBCyACKAKUFCEEIAJB8ABqIAJBmBRqKAIAIgNBABCFCCACIAIoAnQ2AtwBIAIgAigCcCIFNgLYASAFIAQgAxCJAxogAiADNgLgASACQegAaiACQdgBahCMCCACKAJoIRogAigCbAshIAJAAkACQCACLQDwE0EBaw4CAAECCyACQfETai0AACEhQQEhGwwBCyACQe4B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AwAgAkGoNWogAkHwM2ooAgA2AgAgAkHwOWogAkGoOGooAgA2AgAgAkHgNWogAkGoM2ooAgA2AgAgAiACKQPYMzcDkDUgAiACKQOgODcD6DkgAiACKQOgMzcD2DUgAkGAF2otAAAhCiACQdgBaiACQZAlakHwARCJAxogAkGgOGogDRCgBCACQa46aiACQdIpai0AADoAACACIAIvANApOwGsOiAJQYB+cSEOIARBgIB8cSENIARBCHYhBkEDIQMMAQsgAkH/FGotAAAhAyACQfwUai0AACEKIAJB/RRqLQAAIQYgAkH+FGotAAAhDSACQd4Uai0AACEEIAJB2AFqIAJBvBRqEIYFIAJB5AFqIAJByBRqELIIIAJB+AFqIgsgAkHcFGovAQA7AQAgAkHwAWoiBSACQdQUaikCADcDACACIAQ6APoBIAJB0ClqIAJB4BRqEPgEIAJB5ClqIgwgAkH0FGovAQA7AQAgAkGYNWogECkDADcDACACQaA1aiAFKQMANwMAIAJBqDVqIAsoAgA2AgAgAiACQewUaikCACIyNwLcKSACIAIpA+ABNwOQNSACQYAVai0AACEJIAJB+BRqKAIAIQsgAigC2AEhDyACKALQKSEFIAIoAtQpIQggAigC2CkhByACKALcASEEIAJB8DlqIAwoAgA2AgAgAiAyNwPoOSACQdg1aiACQYQVahCgBEEAIQ4gCkGABCAGQQFGQQh0IAZBAkYbckGAgAggDUEAR0EQdCANQQJGG3JBgICAECADQQBHQRh0IANBAkYbciEMIARBgIB8cSENIARBCHYhBkEEIQMLIAJBpiVqIhAgAkG2MWopAQA3AQAgAkGgJWoiESACQbAxaiITKQMANwMAIAJBmCVqIhwgAkGoMWoiKSkDADcDACACQagzaiIqIAJBmDZqKAIANgIAIAJB4DhqIisgJSkDADcDACACQeg4aiIlICQpAwA3AwAgAkHuOGoiJCAjKQEANwEAIAIgAikDoDE3A5AlIAIgAikDkDY3A6AzIAIgAikDoDY3A9g4IAJBmDFqIiMgJigCADYCACACQeAzaiImIAJBmDVqKQMANwMAIAJB6DNqIiwgAkGgNWopAwA3AwAgAkHwM2oiLSACQag1aigCADYCACACQYgxaiIuIAJB8DlqKAIANgIAIAJB+DBqIi8gAkHgNWooAgA2AgAgAiACKQPgNDcDkDEgAiACKQOQNTcD2DMgAiACKQPoOTcDgDEgAiACKQPYNTcD8DAgAkHQKWogAkHYAWpB8AEQiQMaIAJB7jBqIjAgAkGuOmotAAA6AAAgAkHoMGoiMSACQag4aigCADYCACACIAIvAaw6OwHsMCACIAIpAqA4NwPgMCACQeAXahD1AiACQYgYaiAeNgIAIAJBhBhqIBY2AgAgAkGpGGogIToAACACQeoXaiAcKQMANwEAIAJB8hdqIBEpAwA3AQAgAkH4F2ogECkBADcBACACQZQYaiAqKAIANgIAIAIgFDoA4RcgAiASOgDgFyACIBU2AoAYIAIgGzoAqBggAiAYNgKgGCACIB82ApgYIAIgAikDkCU3AeIXIAIgAikDoDM3AowYIAJByBhqIBk2AgAgAkHMGGogGjYCACACQdAYaiAgNgIAIAJB4BhqICI2AgAgAkHoGGogKDYCACACQfQYaiAPNgIAIAJB+BhqIARB/wFxIAZB/wFxQQh0IA1ycjYCACACQcAYaiAkKQEANwEAIAJBuhhqICUpAwA3AQAgAkGyGGogKykDADcBACACQaoYaiACKQPYODcBACACQdQYaiACKQOQMTcCACACQdwYaiAjKAIANgIAIAIgAzYC8BggAkGgGWogBzYCACACQZwZaiAINgIAIAJBmBlqIAU2AgAgAkG4GWogDiAJQf8BcXI2AgAgAkG0GWogDDYCACACQbAZaiALNgIAIAJBlBlqIC0oAgA2AgAgAkGMGWogLCkDADcCACACQYQZaiAmKQMANwIAIAJB/BhqIAIpA9gzNwIAIAJBpBlqIAIpA4AxNwIAIAJBrBlqIC4oAgA2AgAgAkHEGWogLygCADYCACACQbwZaiACKQPwMDcCACACQcgZaiACQdApakHwARCJAxogAkG4G2ogCjoAACACQbsbaiAwLQAAOgAAIAJBvBtqIAIpA+AwNwIAIAJBxBtqIDEoAgA2AgAgAkHMG2ogAkHbAWooAAA2AAAgAiAdOgDIGyACIAIvAewwOwC5GyACIAIoANgBNgDJGyACIAEoAhAiCDYCiBwgASgCCCEMIAEpAgAhMiACQdg4aiACQagTakGQARCJAxogAkHQFGooAgAhFCACQcwUaigCACEZIAJByBRqKAIAIRogAkHAFGopAwAhMyACQbwUaigCACEbIAIoArgUIRAgAkGgOGogAkHUFGpBOBCJAxogAkGMFWooAgAhBSACQaA2aiACQZAVakGAAhCJAxogAiACKQCRFzcDkDYgAiACQZgXaikAADcAlzYgAkGgF2ooAgAhHSACLQCQFyEeIAJB2DVqIAJBpBdqQTQQiQMaIAJBlDVqIAJB3hdqLwEAOwEAIAIgAigB2hc2ApA1IAItANkXIQogAi0A2BchDSACQeg5aiACQeAXakHAABCJAxogAkGQJWogAkGkGGpBrAMQiQMaIAJB2BtqKAIAIQ8gAkHUG2ooAgAhICACKALQGyEJIAJB4DRqIAJB3BtqQSwQiQMaICcgAkGUHGooAgA2AgAgAiACKQKMHDcD2AEgEyACQaATaigCADYCACApIAJBmBNqKQMANwMAIAIgAikDkBM3A6AxIAJB0ClqIAJBoDFqEO0BQQYhAyACQZY1aiACQeg5akHAABCJAxogAkHkAWogAkGoHGpBqAQQiQMaIAJB2DNqIAJB0ClqQYgBEIkDGiACQfgqaigCACEEIAJB9CpqKAIAIQ4gAkHwKmooAgAhEiACQegqaikDACE0IAJB5CpqKAIAIRUgAkHcKmooAgAhISACQdgqaigCACEHIAIoAuAqIRYgAkGgM2ogAkH8KmpBOBCJAxogAkG0K2ooAgAhBiACQaAxaiACQbgrakGAAhCJAxogAiACKAC5LTYCkDEgAiACQbwtaigAADYAkzEgAi0AuC0hHyABLQAgQQVGBEAgAUEhai0AACELDAULIB1FDQUCQCAMQQFHDQBBAyELQQAhAyAXQQJHDQYCQCAeRQ0AIBQhASANIQsCQAJAAkAgEEEBaw4EAgoAAQMLIBkgGiAbQQFGGyEBDAELIAUhAQsgAQ0HCyAfRQ0AIAQhAQJAAkACQAJAIBZBAWsOBAIDAAEECyAOIBIgFUEBRhshAQwBCyAGIQELIAFFDQELIApBAEdBAXQhCwwGC0EAIQsgCEUgD0EASHINBCAPQQR0IQEgCSEDA0AgAQRAIAFBcGohASADKAIAIANBEGohA0EGcUEERw0BDAYLC0EEIQMgDEEBSw0FIA1FBEBBAiEDIAoNBgtBASEDIAQhAQJAAkACQAJAAkAgFkEBaw4EAgMAAQoLIA4gEiAVQQFGGyEBDAELIAYhAQsgAUUNByAHQQJLDQEMBwsgB0EDSQ0GC0EDQQEgByAYSxshAwwFC0EAQQBBhOzLABCwBwALIAJB7AFqQQE2AgAgAkIBNwLcASACQZTxywA2AtgBIAJByQE2AtQgIAIgAkHQIGo2AugBIAIgAkGgMWo2AtAgIAJB2AFqQZzxywAQ1woACyACQdgpaiACQeQBaigCADYCACACIAIpAtwBNwPQKUGU7MsAQRQgAkHQKWpBhPXLAEGo7MsAEPMGAAsgAkHYIGogAkGcJWopAgAiMjcDACACIAIpApQlIjM3A9AgIABBDGogMjcCACAAIDM3AgQgAEEBNgIAIAJB4BdqEIcGDAMLQQUhAwtB+BNBCBDkCyIBBEAgAUEIaiACQdg4akGQARCJAxogASAUNgKwASABIBk2AqwBIAEgGjYCqAEgASAzNwOgASABIBs2ApwBIAEgEDYCmAEgAUG0AWogAkGgOGpBOBCJAxogASAFNgLsASABQfABaiACQaA2akGAAhCJAxogASAeOgDwAyABIB02AoAEIAEgAikDkDY3APEDIAFB+ANqIAIpAJc2NwAAIAFBhARqIAJB2DVqQTQQiQMaIAEgCjoAuQQgASANOgC4BCABQboEaiACQZA1akHGABCJAxogASAYNgKABSABQYQFaiACQZAlakGsAxCJAxogASAPNgK4CCABICA2ArQIIAEgCTYCsAggAUG8CGogAkHgNGpBLBCJAxogASAINgLoCCABQewIaiACQdgBakG0BBCJAxogASAINgKgDSABIAIpA5gcNwKkDSABQawNaiACQaAcaigCADYCACABQbANaiACQdgzakGIARCJAxogASAENgLYDiABIA42AtQOIAEgEjYC0A4gASA0NwPIDiABIBU2AsQOIAEgFjYCwA4gASAhNgK8DiABIAc2ArgOIAFB3A5qIAJBoDNqQTgQiQMaIAEgBjYClA8gAUGYD2ogAkGgMWpBgAIQiQMaIAEgHzoAmBEgASAXNgKsESABIAw2AqgRIAEgMjcAoBEgASACKAKQMTYAmREgAUGcEWogAigAkzE2AAAgAUGwEWogAkHQIGpBxAIQiQMaIAEgCzoA9RMgASADOgD0EyABQoGAgIAQNwMAIAIgATYC0CkgAEEIaiACQdApahCyBjYCACAAIAE2AgQgAEEANgIAIAJB8BJqEIsKIAJB8BJqEPsKDAYLQfgTQQgQ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RQ0QIApCIIinIQIgASgCACIFNQAQIgqnIgZB/wFxQQJHQQAgBkEBcRtFBEAgA0HwAWogBEEQaikCADcDACADQegBaiAEQQhqKQIANwMAIAMgBCkCADcD4AEgA0GQAWogASADQeABaiACEL8EDBsLIAVBFGoxAAAhCyADQdABaiAEQRBqKQIANwMAIANByAFqIARBCGopAgA3AwAgAyAEKQIANwPAAQJAAkAgCiALQiCGhEKAgICA8B+DQiCIpyIFQQJGIAVBAXFyRQRAIAJBgAFPDQEgAkHf//8AcUG/f2pBGkkNAiADQfABaiAEQRBqKQIANwMAIANB6AFqIARBCGopAgA3AwAgAyAEKQIANwPgASADQZABaiABIANB4AFqIAIQvwQMHQsCQCACIAIQ5QVB/wFxIgRBA0YNAAJAIARBAWsOAgEAEgsgASgCBCEEIANBEGogAUEIaigCACICQQAQhQggAygCFCEFIAMoAhAgBCACEIkDIQQgA0GcAWogAjYCACADQZgBaiAFNgIAIANBuAFqQQU6AAAgA0GgAWogAykDwAE3AwAgA0GoAWogA0HIAWopAwA3AwAgA0GwAWogA0HQAWopAwA3AwAgAyAENgKUASADQQE2ApABDB0LQQhBBBDkCyIERQ0RIAQgAjYCBCAEIAI2AgAgA0KBgICAEDcC5AEgAyAENgLgASADQZACaiADQeABahDOCCADQZACahDWBUUEQCADQbABakEBOwEAIANBpAFqIAMoApgCNgIAIANBnAFqIAMpA5ACNwIAIANBmAFqQQA2AgAgA0ECOgCUASADQQA2ApABDB0LIAEoAgQhBCADQQhqIAFBCGooAgAiAkEAEIUIIAMoAgwhBSADKAIIIAQgAhCJAyEEIANBjgJqIANB4gFqLQAAIgY6AAAgA0GcAWogAjYCACADQZgBaiAFNgIAIANBuAFqQQU6AAAgA0GgAWogAykDwAE3AwAgA0GoAWogA0HIAWopAwA3AwAgA0GwAWogA0HQAWopAwA3AwAgA0G5AWogAy8A4AEiAjsAACADQbsBaiAGOgAAIAMgAjsBjAIgAyAENgKUASADQQE2ApABIAMoApQCIgJFIAJBA3RFcg0cIAMoApACEIkBDBwLIAEoAgQhBCADQRhqIAFBCGooAgAiAkEAEIUIIAMoAhwhBSADKAIYIAQg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DSAIIARBCGoiCCkCADcCACAIIA03AgAgByAMNwIAIAYgCzcCACAEIAo3AgAgBEFgaiEEIAJBIGohAiAFQX9qIgUNAAsLIANBmAFqIANByABqKAIANgIAIAMgAykDQDcDkAEgA0HgAWpBBHIgA0GQAWoQkQEgA0EAOgDgASABIANB4AFqEJUGDBcLIANBgAFqIAJBGGoiBCkCADcDACADQfgAaiACQRBqIgUpAgA3AwAgA0HwAGogAkEIaiIGKQIANwMAIAMgAikCACIKNwNoAkAgCqdB/wFxBEAgA0GoAWoiByAEKQIANwMAIANBoAFqIgggBSkCADcDACADQZgBaiIJIAYpAgA3AwAgAyACKQIANwOQASADKAJIIgQgAygCREYEQCADQUBrIAQQjgkgAygCSCEECyADKAJAIARBBXRqIgUgAykDkAE3AgAgBUEIaiAJKQMANwIAIAVBEGogCCkDADcCACAFQRhqIAcpAwA3AgAgAyAEQQFqNgJIDAELIANB6ABqENsCCyADLQDgASIEQQdxRSAEQQZGcg0AIANB4AFqEKsHDAALAAtBIEEEEOIMAAsgA0H0AWpBATYCACADQgE3AuQBIANB5OrdADYC4AEgA0GhAzYCRCADIANBQGs2AvABIAMgA0GQAWo2AkAgA0HgAWpB7OrdABDXCgALQczz3QBBK0HA690AENEJAAtBzPPdAEErQbDr3QAQ0QkAC0EgQQQQ4gwAC0HM890AQStB0OvdABDRCQALIAEoAgQhAiADQSBqIAFBCGooAgAiAUEAEIUIIAMoAiQhBCADKAIgIAIgARCJAyECIANB0AFqIANB+ABqKQMAIgs3AwAgA0HIAWogA0HwAGopAwAiDDcDACADIAMpA2giCjcDQCADIAo3A8ABIAAgATYCCCAAIAQ2AgQgACACNgIAIAAgCjcCDCAAQRRqIAw3AgAgAEEcaiALNwIAIABBAToAJAwQC0ECQQEQ4gwACyADQfABaiADQdABaikDADcDACADQegBaiADQcgBaikDADcDACADIAMpA8ABNwPgASADQZABaiABIANB4AFqIAIQvwQMCwtBCEEEEOIMAAsgA0GQAWpBBHIgChD1ByADQQA2ApABDAkLIANB2AFqIANBhAJqKQIAIgs3AwAgA0HQAWogA0H8AWopAgAiDDcDACADQcgBaiADQfQBaikCACINNwMAIANBnAFqIANB7AFqKQIAIg43AgAgA0GkAWogDTcCACADQawBaiAMNwIAIANBtAFqIAs3AgAgAyAONwPAASADIAo3ApQBIANBATYCkAEMCAsgASgCBCEFIANBKGogAUEIaigCACIEQQAQhQggAygCLCEGIAMoAiggBSAEEIkDIQEgACAENgIIIAAgBjYCBCAAIAFBEHY7AQIgACABQQh2OgABIAAgAToAACAAIAJBBGoiASkCADcCDCAAQRRqIAFBCGopAgA3AgAgACACQRRqKAIANgIcIAAgAkEYajUCAEKAgICAEIQ3AiAMCgtBkwJB1wIgBxshBEEAQQIgBxshBQsgA0GAAmogBDsBACADIAU6AOUBIAMgBjoA5AEgA0EAOgDgASABIANB4AFqEJUGDAYLIANB4AFqIAEgAkEIahCnASADQewBaiIGKAIAIQIgA0HoAWoiBygCACEEIAMoAuQBIQUgAygC4AFBAUcEQCADQYACakEBOwEAIANB9AFqIAI2AgAgA0HwAWogBDYCACAGIAU2AgAgB0EANgIAIANBAjoA5AEgA0EAOgDgASABIANB4AFqEJUGDAYLIANBqAFqIANBiAJqKAIAIgE2AgAgA0GgAWogA0GAAmopAwAiCjcDACADQZgBaiADQfgBaikDACILNwMAIAMgA0HwAWopAwAiDDcDkAEgACACNgIIIAAgBDYCBCAAIAU2AgAgACAMNwIMIABBFGogCzcCACAAQRxqIAo3AgAgAEEkaiABNgIADAcLIAJBCGohBAJAAkACQAJAAkACQCABKAIAQRRqLQAAIgVBAkYgBUEBcXJFBEAgA0HgAWogARDlBiADLQDgAUEGRg0DIANBkAFqIANB4AFqQSQQiQMaIANB6ABqIANBkAFqEIQHIANB4AFqIAEgBCACQYABai0AACADQegAahCyBCADLQCEAiICQQhHDQEgAygCcCICRQ0CIAMoAmgiBCACQQF0akF/ai0AACEFIAMoAmwhBiADQfQBaiACNgIAIANB8AFqIAY2AgAgA0HsAWogBDYCACADQegBakEBNgIAIANBgAJqIAVBf3NBgAFxQQd2OwEAIANBAjoA5AEgA0EAOgDgASABIANB4AFqEJUGDAsLIANB4AFqIAEQ5QYgAy0A4AFBBkYNAyADQZABaiADQeABakEkEIkDGiADQegAaiADQZABahCDByADQeABaiABIAQgAkGAAWotAAAgA0HoAGoQjQUCQCADLQCEAiICQQhGBEAgAygCcCICRQ0BIAMpA2ghCiADQYACakEBOwEAIANB9AFqIAI2AgAgA0HsAWogCjcCACADQegBakEANgIAIANBAjoA5AEgA0EAOgDgASABIANB4AFqEJUGDAwLIANBkAFqIANB4AFqQSQQiQMaIABBJ2ogA0GHAmotAAA6AAAgACADLwCFAjsAJSAAIANBkAFqQSQQiQMgAjoAJAwGCyADQfABaiICIARBEGopAgA3AwAgA0HoAWoiBSAEQQhqKQIANwMAIAMgBCkCADcD4AEgASgCBCEEIANBMGogAUEIaigCACIBQQAQhQggAygCNCEGIAMoAjAgBCABEIkDIQQgA0GgAWogAikDACIKNwMAIANBmAFqIAUpAwAiCzcDACADIAMpA+ABIgw3A5ABIAAgATYCCCAAIAY2AgQgACAENgIAIAAgDDcCDCAAQRRqIAs3AgAgAEEcaiAKNwIAIABBBjoAJCAAIAMvAOABOwAlIABBJ2ogA0HiAWotAAA6AAAMBQsgA0GQAWogA0HgAWpBJBCJAxogAEEnaiADQYcCai0AADoAACAAIAMvAIUCOwAlIAAgA0GQAWpBJBCJAyACOgAkDAMLIANB8AFqIgIgBEEQaikCADcDACADQegBaiIFIARBCGopAgA3AwAgAyAEKQIANwPgASABKAIEIQQgA0E4aiABQQhqKAIAIgFBABCFCCADKAI8IQYgAygCOCAEIAEQiQMhBCADQaABaiACKQMAIgo3AwAgA0GYAWogBSkDACILNwMAIAMgAykD4AEiDDcDkAEgACABNgIIIAAgBjYCBCAAIAQ2AgAgACAMNwIMIABBFGogCzcCACAAQRxqIAo3AgAgAEEGOgAkIAAgAy8A4AE7ACUgAEEnaiADQeIBai0AADoAAAwCC0HM890AQStB8OvdABDRCQALQczz3QBBK0Hg690AENEJAAsgAygCbCIARSAAQQF0RXINByADKAJoEIkBDAcLIAMoAmwiAEUgAEEDdEVyDQYgAygCaBCJAQwGCyACQQhqIQIgASgCAEEUai0AACIEQQJGIARBAXFyRQRAIANBkAFqIAEgAhDOBCADKAKUASEGIAMoApABIQJBASEEIAMoApgBIgUEQCAFQQF0IAJqQX9qLAAAQX9KIQQLIANB9AFqIAU2AgAgA0HwAWogBjYCACADQewBaiACNgIAIANB6AFqQQE2AgAgAyAEOwGAAiADQQI6AOQBIANBADoA4AEgASADQeABahCVBgwECyADQeABaiABIAIQiAMgA0HsAWoiBigCACECIANB6AFqKAIAIQQgAygC5AEhBSADKALgAUEBRwRAIANBgAJqQQE7AQAgA0H0AWogAjYCACADQfABaiAENgIAIAYgBTYCACADQegBakEANgIAIANBAjoA5AEgA0EAOgDgASABIANB4AFqEJUGDAQLIANBqAFqIANBiAJqKAIAIgE2AgAgA0GgAWogA0GAAmopAwAiCjcDACADQZgBaiADQfgBaikDACILNwMAIAMgA0HwAWopAwAiDDcDkAEgACACNgIIIAAgBDYCBCAAIAU2AgAgACAMNwIMIABBFGogCzcCACAAQRxqIAo3AgAgAEEkaiABNgIADAULIANCADcCbCADQcTz3QAoAgA2AmggA0HgAWpBBHIhAgNAIANB4AFqIAEQ5QYgAy0A4AEiBEEHcQRAIARBBkcEQCADQeABahCrBwsgAygCcCIEQQJPBEAgBEEBdiEFIAMoAmgiAiAEQQV0akFgaiEEA0AgAikCACEKIAIgBCkCADcCACACQRhqIgYpAgAhCyAGIARBGGoiBikCADcCACACQRBqIgcpAgAhDCAHIARBEGoiBykCADcCACACQQhqIggpAgAhDSAIIARBCGoiCCkCADcCACAIIA03AgAgByAMNwIAIAYgCzcCACAEIAo3AgAgBEFgaiEEIAJBIGohAiAFQX9qIgUNAAsLIANBmAFqIANB8ABqKAIANgIAIAMgAykDaDcDkAEgA0HgAWpBBHIgA0GQAWoQxgEgA0EAOgDgASABIANB4AFqEJUGDAQLIANBqAFqIgYgAkEYaikCADcDACADQaABaiIHIAJBEGopAgA3AwAgA0GYAWoiCCACQQhqKQIANwMAIAMgAikCADcDkAEgAygCcCIEIAMoAmxGBEAgA0HoAGogBBCOCSADKAJwIQQLIAMoAmggBEEFdGoiBSADKQOQATcCACAFQRhqIAYpAwA3AgAgBUEQaiAHKQMANwIAIAVBCGogCCkDADcCACADIARBAWo2AnAgAy0A4AEiBEEHcUEGRiAERXINACADQeABahCrBwwACwALIANBgAJqQYMCOwEAIANBADoA5AEgA0EAOgDgASABIANB4AFqEJUGDAELIANBkAFqQQRyIQIgAygCkAFBAUYNASADQYABaiACQRhqKQIAIgo3AwAgA0H4AGogAkEQaikCACILNwMAIANB8ABqIAJBCGopAgAiDDcDACADQcwAaiAMNwIAIANB1ABqIAs3AgAgA0HcAGogCjcCACADIAIpAgAiCjcDaCADQQA6AEAgAyAKNwJEIAEgA0FAaxCVBgsgAEEIOgAkDAELIANB6ABqIAJBKBCJAxogACADQegAakEoEIkDGgsgA0GgAmokAAvtOwElfyMAQZABayIDJAAgA0EAQcAAEJEFIQMgACgCHCEjIAAoAhghJCAAKAIUIR8gACgCECEgIAAoAgwhJSAAKAIIISYgACgCBCEhIAAoAgAhIiACBEAgASACQQZ0aiEnA0BBACECA0AgAiADaiABIAJqKAAAIhBBGHQgEEEIdEGAgPwHcXIgEEEIdkGA/gNxIBBBGHZycjYCACACQQRqIgJBwABHDQALIAMoAjwhAiADKAI4IRAgAygCNCERIAMoAjAhEiADKAIsIRcgAygCKCEYIAMoAiQhGSADKAIgIRogAygCHCEbIAMoAhghHCADKAIUIR0gAygCECEeIAMoAgwhEyADKAIIIRQgAygCBCEVIAMoAgAhFiADICY2AmAgAyAlNgJkIAMgJDYCaCADICM2AmwgAyAfNgJ8IAMgIDYCeCADICE2AnQgAyAiNgJwIAMgFkGY36iUBGoiBDYCjAEgAyAVQZGJ3YkHaiIFNgKIASADIBRBz/eDrntqIgY2AoQBIAMgE0Glt9fNfmoiBzYCgAEgA0HQAGogA0HgAGogA0HwAGogA0GAAWoQ+wMgAygCUCEIIAMoAlQhCSADKAJYIQogAygCXCELIAMgHzYCbCADICA2AmggAyAhNgJkIAMgIjYCYCADIAs2AnwgAyAKNgJ4IAMgCTYCdCADIAg2AnAgAyAGNgKMASADIAc2AogBIAMgBDYChAEgAyAFNgKAASADQdAAaiADQeAAaiADQfAAaiADQYABahD7AyADKAJQIQQgAygCVCEFIAMoAlghBiADKAJcIQcgAyALNgJsIAMgCjYCaCADIAk2AmQgAyAINgJg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IAMgCzYCfCADIAo2AnggAyAJNgJ0IAMgCDYCcCADIA42AowBIAMgDzYCiAEgAyAMNgKEASADIA02AoABIANB0ABqIANB4ABqIANB8ABqIANBgAFqEPsDIAMoAlAhBCADKAJUIQUgAygCWCEGIAMoAlwhByADIBI2AlwgAyARNgJYIAMgEDYCVCADIAI2AlAgAyAWNgJsIAMgFTYCaCADIBQ2AmQgAyATNgJgIAMgHjYCfCADIB02AnggAyAcNgJ0IAMgGzYCcCADIBo2AowBIAMgGTYCiAEgAyAYNgKEASADIBc2AoABIANBQGsgA0HQAGogA0HgAGogA0HwAGogA0GAAWoQ4QMgAygCQCECIAMoAkQhECADKAJIIREgAygCTCESIAMgCzYCbCADIAo2AmggAyAJNgJkIAMgCDYCYCADIAc2AnwgAyAGNgJ4IAMgBTYCdCADIAQ2AnAgAyASQfr/+4V5aiITNgKMASADIBFB69nBonpqIhQ2AogBIAMgEEH3x+b3e2oiFTYChAEgAyACQfLxxbN8aiIWNgKAASADQdAAaiADQeAAaiADQfAAaiADQYABahD7AyADKAJQIQIgAygCVCEQIAMoAlghESADKAJcIRIgAyAHNgJsIAMgBjYCaCADIAU2AmQgAyAENgJgIAMgEjYCfCADIBE2AnggAyAQNgJ0IAMgAjYCcCADIBU2AowBIAMgFjYCiAEgAyATNgKEASADIBQ2AoABIBIgI2ohIyARICRqISQgECAlaiElIAIgJmohJiADQdAAaiADQeAAaiADQfAAaiADQYABahD7AyADKAJcIB9qIR8gAygCWCAgaiEgIAMoAlQgIWohISADKAJQICJqISIgAUFAayIBICdHDQALCyAAICM2AhwgACAkNgIYIAAgHzYCFCAAICA2AhAgACAlNgIMIAAgJjYCCCAAICE2AgQgACAiNgIAIANBkAFqJAALySYCHX8DfiMAQdAGayIHJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASkDACIiUEUEQCABKQMIIiNQDQEgASkDECIkUA0CICIgJHwgIlQNAyAiICN9ICJWDQQgAS8BGCEBIAcgIj4CDCAHQRBqQQAgIkIgiKcgIkKAgICAEFQiBRs2AgAgB0EBQQIgBRs2AgggB0EUakEAQZgBEJEFGiAH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QTlGDQALIAwgDWoiBCAELQAAQQFqOgAAIA0gDSABa0EBak0NAiAEQQFqQTAgAUF/ahCRBRoMAgsCf0ExIAsNABogAkExOgAAQTAgDUEBRg0AGiACQQFqQTAgDUF/ahCRBRpBMAsgEUEQdEGAgARqQRB1IhEgBEEQdEEQdUwgDSADT3INAToAACANQQFqIQ0MAQsgDSADQfDb4AAQsgcACyANIANNDQAgDSADQYDc4AAQsgcACyAAIBE7AQggACANNgIEIAAgAjYCACAHQdAGaiQADwsgAUEoQeSK4QAQsgcACyAJQShB5IrhABCyBwALQfSK4QBBGkHkiuEAENEJAAsgCEEoQeSK4QAQsgcAC6okAgF/GH4jAEGAC2siAyQAIANB2ApqIAEQ6AMgA0H4BmogAykD2AoiBELtzYe51pfSBxDWBiADQYgHaiAEQtrIn+Pa1u4BENYGIANByAdqIAMpA+AKIgVC7c2HudaX0gcQ1gYgA0GYB2ogBEKbytfZ/v//BxDWBiADQdgHaiAFQtrIn+Pa1u4BENYGIANBmAhqIAMpA+gKIgZC7c2HudaX0gcQ1gYgA0GoB2ogBEL/////////BxDWBiADQegHaiAFQpvK19n+//8HENYGIANBqAhqIAZC2sif49rW7gEQ1gYgA0HoCGogAykD8AoiB0LtzYe51pfSBxDWBiADQbgHaiAEQv///////wMQ1gYgA0H4B2ogBUL/////////BxDWBiADQbgIaiAGQpvK19n+//8HENYGIANB+AhqIAdC2sif49rW7gEQ1gYgA0G4CWogAykD+AoiBELtzYe51pfSBxDWBiADQYgIaiAFQv///////wMQ1gYgA0HICGogBkL/////////BxDWBiADQYgJaiAHQpvK19n+//8HENYGIANByAlqIARC2sif49rW7gEQ1gYgA0HYCGogBkL///////8DENYGIANBmAlqIAdC/////////wcQ1gYgA0HYCWogBEKbytfZ/v//BxDWBiADQagJaiAHQv///////wMQ1gYgA0HoCWogBEL/////////BxDWBiADQfgJaiAEQv///////wMQ1gYgA0HoBmogAykD+AYiBUKb/NGSsbTHAn5C/////////weDIgRC7afX56XjmAEQ1gYgA0HYBmogBEKBy7XO98X6BhDWBiADQcgGaiADKQPIByIKIAMpA4gHfCIGIAMpA9gGfCIHIAUgAykD6AYiCXwiBUI0iCAFIAlUrSADQfAGaikDACADQYAHaikDAHx8IgxCDIaEfCIJQpv80ZKxtMcCfkL/////////B4MiBULtp9fnpeOYARDWBiADQZgGaiAEQvm90wAQ1gYgA0G4BmogBUKBy7XO98X6BhDWBiADQYgGaiADKQPYByIRIAMpA5gHfCIIIAMpA5gIfCILIAMpA5gGfCIOIAMpA7gGfCIPIAMpA8gGIg0gCXwiEEI0iCAQIA1UrSADQdAGaikDACAJIAdUrSAHIAZUrSADQeAGaikDACAGIApUrSADQdAHaikDACADQZAHaikDAHx8fHwgDEI0iHx8fHwiEkIMhoR8IgdCm/zRkrG0xwJ+Qv////////8HgyIGQu2n1+el45gBENYGIANBqAZqIAVC+b3TABDWBiADQfgFaiAGQoHLtc73xfoGENYGIANB6AVqIAMpA+gHIhMgAykDqAd8IgkgAykDqAh8IgogAykD6Ah8IgwgAykDqAZ8Ig0gAykD+AV8IhAgAykDiAYiFCAHfCIVQjSIIBUgFFStIANBkAZqKQMAIAcgD1StIA8gDlStIANBwAZqKQMAIA4gC1StIANBoAZqKQMAIAsgCFStIANBoAhqKQMAIAggEVStIANB4AdqKQMAIANBoAdqKQMAfHx8fHx8fHwgEkI0iHx8fHwiFkIMhoR8IghCm/zRkrG0xwJ+Qv////////8HgyIHQu2n1+el45gBENYGIANBuAVqIAZC+b3TABDWBiADQdgFaiAHQoHLtc73xfoGENYGIANBqAVqIAMpA/gHIhkgAykDuAd8IgsgAykDuAh8Ig4gAykD+Ah8Ig8gAykDuAl8IhEgBEIshnwiEiADKQO4BXwiFCADKQPYBXwiFSADKQPoBSIXIAh8IhhCNIggGCAXVK0gA0HwBWopAwAgCCAQVK0gECANVK0gA0GABmopAwAgDSAMVK0gA0GwBmopAwAgDCAKVK0gA0HwCGopAwAgCiAJVK0gA0GwCGopAwAgCSATVK0gA0HwB2opAwAgA0GwB2opAwB8fHx8fHx8fHx8IBZCNIh8fHx8IhdCDIaEfCIIQpv80ZKxtMcCfkL/////////B4MiCULtp9fnpeOYARDWBiADQcgFaiAHQvm90wAQ1gYgA0GYBWogCUKBy7XO98X6BhDWBiADQYgFaiAJQvm90wAQ1gYgAyADKQPICCIYIAMpA4gIfCIKIAMpA4gJfCIMIAMpA8gJfCINIAVCLIZ8IhAgAykDyAV8IhMgAykDmAV8IhYgAykDqAUiGiAIfCIbQjSIIBsgGlStIANBsAVqKQMAIAggFVStIBUgFFStIANB4AVqKQMAIBQgElStIANBwAVqKQMAIBIgEVStIBEgD1StIANBwAlqKQMAIA8gDlStIANBgAlqKQMAIA4gC1StIANBwAhqKQMAIAsgGVStIANBgAhqKQMAIANBwAdqKQMAfHx8fHx8fHwgBEIUiHx8fHx8fCAXQjSIfHx8fCIRQgyGhHwiBEL/////////B4M3A9gKIAMgAykDmAkiEiADKQPYCHwiCCADKQPYCXwiCyAGQiyGfCIOIAMpA4gFfCIPIAQgFlStIBYgE1StIANBoAVqKQMAIBMgEFStIANB0AVqKQMAIBAgDVStIA0gDFStIANB0AlqKQMAIAwgClStIANBkAlqKQMAIAogGFStIANB0AhqKQMAIANBkAhqKQMAfHx8fHx8IAVCFIh8fHx8fHwgEUI0iHx8IgxCDIYgBEI0iIR8IgRC/////////weDNwPgCiADIAMpA+gJIg0gAykDqAl8IgUgB0IshnwiCiAEIA9UrSAPIA5UrSADQZAFaikDACAOIAtUrSALIAhUrSADQeAJaikDACAIIBJUrSADQaAJaikDACADQeAIaikDAHx8fHwgBkIUiHx8fHwgDEI0iHx8IghCDIYgBEI0iIR8IgRC/////////weDNwPoCiADIAlCLIYiCyADKQP4CXwiBiAEIApUrSAKIAVUrSAFIA1UrSADQfAJaikDACADQbAJaikDAHx8IAdCFIh8fCAIQjSIfHwiBUIMhiAEQjSIhHwiBEL/////////B4M3A/AKIAMgBCAGVK0gBiALVK0gA0GACmopAwAgCUIUiHx8IAVCNIh8fEIMhiAEQjSIhDcD+AogA0GICmogA0HYCmpBuMLgABCABiADQdgKaiACEOgDIANB+AFqIAMpA9gKIgRC7c2HudaX0gcQ1gYgA0GIAmogBELayJ/j2tbuARDWBiADQcgCaiADKQPgCiIFQu3Nh7nWl9IHENYGIANBmAJqIARCm8rX2f7//wcQ1gYgA0HYAmogBULayJ/j2tbuARDWBiADQZgDaiADKQPoCiIGQu3Nh7nWl9IHENYGIANBqAJqIARC/////////wcQ1gYgA0HoAmogBUKbytfZ/v//BxDWBiADQagDaiAGQtrIn+Pa1u4BENYGIANB6ANqIAMpA/AKIgdC7c2HudaX0gcQ1gYgA0G4AmogBEL///////8DENYGIANB+AJqIAVC/////////wcQ1gYgA0G4A2ogBkKbytfZ/v//BxDWBiADQfgDaiAHQtrIn+Pa1u4BENYGIANBuARqIAMpA/gKIgRC7c2HudaX0gcQ1gYgA0GIA2ogBUL///////8DENYGIANByANqIAZC/////////wcQ1gYgA0GIBGogB0KbytfZ/v//BxDWBiADQcgEaiAEQtrIn+Pa1u4BENYGIANB2ANqIAZC////////AxDWBiADQZgEaiAHQv////////8HENYGIANB2ARqIARCm8rX2f7//wcQ1gYgA0GoBGogB0L///////8DENYGIANB6ARqIARC/////////wcQ1gYgA0H4BGogBEL///////8DENYGIANB6AFqIAMpA/gBIgVCm/zRkrG0xwJ+Qv////////8HgyIEQu2n1+el45gBENYGIANB2AFqIARCgcu1zvfF+gYQ1gYgA0HIAWogAykDyAIiCiADKQOIAnwiBiADKQPYAXwiByAFIAMpA+gBIgl8IgVCNIggBSAJVK0gA0HwAWopAwAgA0GAAmopAwB8fCIMQgyGhHwiCUKb/NGSsbTHAn5C/////////weDIgVC7afX56XjmAEQ1gYgA0GYAWogBEL5vdMAENYGIANBuAFqIAVCgcu1zvfF+gYQ1gYgA0GIAWogAykD2AIiESADKQOYAnwiCCADKQOYA3wiCyADKQOYAXwiDiADKQO4AXwiDyADKQPIASINIAl8IhBCNIggECANVK0gA0HQAWopAwAgCSAHVK0gByAGVK0gA0HgAWopAwAgBiAKVK0gA0HQAmopAwAgA0GQAmopAwB8fHx8IAxCNIh8fHx8IhJCDIaEfCIHQpv80ZKxtMcCfkL/////////B4MiBkLtp9fnpeOYARDWBiADQagBaiAFQvm90wAQ1gYgA0H4AGogBkKBy7XO98X6BhDWBiADQegAaiADKQPoAiITIAMpA6gCfCIJIAMpA6gDfCIKIAMpA+gDfCIMIAMpA6gBfCINIAMpA3h8IhAgAykDiAEiFCAHfCIVQjSIIBUgFFStIANBkAFqKQMAIAcgD1StIA8gDlStIANBwAFqKQMAIA4gC1StIANBoAFqKQMAIAsgCFStIANBoANqKQMAIAggEVStIANB4AJqKQMAIANBoAJqKQMAfHx8fHx8fHwgEkI0iHx8fHwiFkIMhoR8IghCm/zRkrG0xwJ+Qv////////8HgyIHQu2n1+el45gBENYGIANBOGogBkL5vdMAENYGIANB2ABqIAdCgcu1zvfF+gYQ1gYgA0EoaiADKQP4AiIZIAMpA7gCfCILIAMpA7gDfCIOIAMpA/gDfCIPIAMpA7gEfCIRIARCLIZ8IhIgAykDOHwiFCADKQNYfCIVIAMpA2giFyAIfCIYQjSIIBggF1StIANB8ABqKQMAIAggEFStIBAgDVStIANBgAFqKQMAIA0gDFStIANBsAFqKQMAIAwgClStIANB8ANqKQMAIAogCVStIANBsANqKQMAIAkgE1StIANB8AJqKQMAIANBsAJqKQMAfHx8fHx8fHx8fCAWQjSIfHx8fCIXQgyGhHwiCEKb/NGSsbTHAn5C/////////weDIglC7afX56XjmAEQ1gYgA0HIAGogB0L5vdMAENYGIANBGGogCUKBy7XO98X6BhDWBiADQQhqIAlC+b3TABDWBiADIAMpA8gDIhggAykDiAN8IgogAykDiAR8IgwgAykDyAR8Ig0gBUIshnwiECADKQNIfCITIAMpAxh8IhYgAykDKCIaIAh8IhtCNIggGyAaVK0gA0EwaikDACAIIBVUrSAVIBRUrSADQeAAaikDACAUIBJUrSADQUBrKQMAIBIgEVStIBEgD1StIANBwARqKQMAIA8gDlStIANBgARqKQMAIA4gC1StIANBwANqKQMAIAsgGVStIANBgANqKQMAIANBwAJqKQMAfHx8fHx8fHwgBEIUiHx8fHx8fCAXQjSIfHx8fCIRQgyGhHwiBEL/////////B4M3A9gKIAMgAykDmAQiEiADKQPYA3wiCCADKQPYBHwiCyAGQiyGfCIOIAMpAwh8Ig8gBCAWVK0gFiATVK0gA0EgaikDACATIBBUrSADQdAAaikDACAQIA1UrSANIAxUrSADQdAEaikDACAMIApUrSADQZAEaikDACAKIBhUrSADQdADaikDACADQZADaikDAHx8fHx8fCAFQhSIfHx8fHx8IBFCNIh8fCIMQgyGIARCNIiEfCIEQv////////8HgzcD4AogAyADKQPoBCINIAMpA6gEfCIFIAdCLIZ8IgogBCAPVK0gDyAOVK0gA0EQaikDACAOIAtUrSALIAhUrSADQeAEaikDACAIIBJUrSADQaAEaikDACADQeADaikDAHx8fHwgBkIUiHx8fHwgDEI0iHx8IghCDIYgBEI0iIR8IgRC/////////weDNwPoCiADIAlCLIYiCyADKQP4BHwiBiAEIApUrSAKIAVUrSAFIA1UrSADQfAEaikDACADQbAEaikDAHx8IAdCFIh8fCAIQjSIfHwiBUIMhiAEQjSIhHwiBEL/////////B4M3A/AKIAMgBCAGVK0gBiALVK0gA0GABWopAwAgCUIUiHx8IAVCNIh8fEIMhiAEQjSIhDcD+AogA0GwCmogA0HYCmpBuMLgABCABiADQdgKaiADQYgKaiADQbAKahCABiAAIANB2ApqEIEDIANBgAtqJAAL1iICAX8YfiMAQdAKayIDJAAgA0HwBmogAikDACIEIAEpAwAiBRDWBiADQYAHaiACKQMIIgcgBRDWBiADQcAHaiABKQMIIgggBBDWBiADQZAHaiACKQMQIgkgBRDWBiADQYAIaiAIIAcQ1gYgA0HQB2ogASkDECIGIAQQ1gYgA0GgB2ogAikDGCIKIAUQ1gYgA0HACGogCSAIENYGIANBkAhqIAYgBxDWBiADQeAHaiABKQMYIgsgBBDWBiADQbAHaiACKQMgIgwgBRDWBiADQdAIaiAKIAgQ1gYgA0HwCGogBiAJENYGIANBoAhqIAsgBxDWBiADQfAHaiABKQMgIgUgBBDWBiADQeAIaiAMIAgQ1gYgA0GgCWogCiAGENYGIANBgAlqIAsgCRDWBiADQbAIaiAFIAcQ1gYgA0GwCWogDCAGENYGIANBwAlqIAsgChDWBiADQZAJaiAFIAkQ1gYgA0HgCWogDCALENYGIANB0AlqIAUgChDWBiADQfAJaiAFIAwQ1gYgA0HgBmogAykD8AYiBUKb/NGSsbTHAn5C/////////weDIgRC7afX56XjmAEQ1gYgA0HQBmogBEKBy7XO98X6BhDWBiADQcAGaiADKQPAByINIAMpA4AHfCIHIAMpA9AGfCIIIAUgAykD4AYiCXwiBUI0iCAFIAlUrSADQegGaikDACADQfgGaikDAHx8Ig5CDIaEfCIJQpv80ZKxtMcCfkL/////////B4MiBULtp9fnpeOYARDWBiADQZAGaiAEQvm90wAQ1gYgA0GwBmogBUKBy7XO98X6BhDWBiADQYAGaiADKQOQByIRIAMpA4AIfCIGIAMpA9AHfCIKIAMpA5AGfCILIAMpA7AGfCIMIAMpA8AGIg8gCXwiEEI0iCAQIA9UrSADQcgGaikDACAJIAhUrSAIIAdUrSADQdgGaikDACAHIA1UrSADQcgHaikDACADQYgHaikDAHx8fHwgDkI0iHx8fHwiEkIMhoR8IghCm/zRkrG0xwJ+Qv////////8HgyIHQu2n1+el45gBENYGIANBoAZqIAVC+b3TABDWBiADQfAFaiAHQoHLtc73xfoGENYGIANB4AVqIAMpA5AIIhMgAykDwAh8IgkgAykDoAd8Ig0gAykD4Ad8Ig4gAykDoAZ8Ig8gAykD8AV8IhAgAykDgAYiFCAIfCIVQjSIIBUgFFStIANBiAZqKQMAIAggDFStIAwgC1StIANBuAZqKQMAIAsgClStIANBmAZqKQMAIAogBlStIANB2AdqKQMAIAYgEVStIANBmAdqKQMAIANBiAhqKQMAfHx8fHx8fHwgEkI0iHx8fHwiFkIMhoR8IgZCm/zRkrG0xwJ+Qv////////8HgyIIQu2n1+el45gBENYGIANBsAVqIAdC+b3TABDWBiADQdAFaiAIQoHLtc73xfoGENYGIANBoAVqIAMpA9AIIhkgAykD8Ah8IgogBEIshnwiCyADKQOgCHwiDCADKQOwB3wiESADKQPwB3wiEiADKQOwBXwiFCADKQPQBXwiFSADKQPgBSIXIAZ8IhhCNIggGCAXVK0gA0HoBWopAwAgBiAQVK0gECAPVK0gA0H4BWopAwAgDyAOVK0gA0GoBmopAwAgDiANVK0gA0HoB2opAwAgDSAJVK0gA0GoB2opAwAgCSATVK0gA0GYCGopAwAgA0HICGopAwB8fHx8fHx8fHx8IBZCNIh8fHx8IhdCDIaEfCIGQpv80ZKxtMcCfkL/////////B4MiCULtp9fnpeOYARDWBiADQcAFaiAIQvm90wAQ1gYgA0GQBWogCUKBy7XO98X6BhDWBiADQYAFaiAJQvm90wAQ1gYgAyADKQOACSIYIAMpA6AJfCINIAMpA+AIfCIOIAMpA7AIfCIPIAVCLIZ8IhAgAykDwAV8IhMgAykDkAV8IhYgAykDoAUiGiAGfCIbQjSIIBsgGlStIANBqAVqKQMAIAYgFVStIBUgFFStIANB2AVqKQMAIBQgElStIANBuAVqKQMAIBIgEVStIANB+AdqKQMAIBEgDFStIANBuAdqKQMAIAwgC1StIANBqAhqKQMAIAsgClStIAogGVStIANB2AhqKQMAIANB+AhqKQMAfHwgBEIUiHx8fHx8fHx8fHx8fCAXQjSIfHx8fCIRQgyGhHwiBEL/////////B4M3A6gKIAMgAykDsAkiEiADKQPACXwiBiADKQOQCXwiCiAHQiyGfCILIAMpA4AFfCIMIAQgFlStIBYgE1StIANBmAVqKQMAIBMgEFStIANByAVqKQMAIBAgD1StIA8gDlStIANBuAhqKQMAIA4gDVStIANB6AhqKQMAIA0gGFStIANBiAlqKQMAIANBqAlqKQMAfHx8fHx8IAVCFIh8fHx8fHwgEUI0iHx8Ig5CDIYgBEI0iIR8IgRC/////////weDNwOwCiADIAMpA9AJIg8gAykD4Al8IgUgCEIshnwiDSAEIAxUrSAMIAtUrSADQYgFaikDACALIApUrSAKIAZUrSADQZgJaikDACAGIBJUrSADQbgJaikDACADQcgJaikDAHx8fHwgB0IUiHx8fHwgDkI0iHx8IgZCDIYgBEI0iIR8IgRC/////////weDNwO4CiADIAlCLIYiCiADKQPwCXwiByAEIA1UrSANIAVUrSAFIA9UrSADQdgJaikDACADQegJaikDAHx8IAhCFIh8fCAGQjSIfHwiBUIMhiAEQjSIhHwiBEL/////////B4M3A8AKIAMgBCAHVK0gByAKVK0gA0H4CWopAwAgCUIUiHx8IAVCNIh8fEIMhiAEQjSIhDcDyAogA0GACmogA0GoCmpBkMLgABCABiADQbACaiADKQOACiIEQruiy8rezPQEENYGIANBoAJqIARCn836rfH42AYQ1gYgA0GAA2ogAykDiAoiBUK7osvK3sz0BBDWBiADQZACaiAEQoTsodvczO8CENYGIANB8AJqIAVCn836rfH42AYQ1gYgA0HQA2ogAykDkAoiB0K7osvK3sz0BBDWBiADQYACaiAEQv/C9LnsnfcBENYGIANB4AJqIAVChOyh29zM7wIQ1gYgA0HAA2ogB0Kfzfqt8fjYBhDWBiADQaAEaiADKQOYCiIIQruiy8rezPQEENYGIANB8AFqIARCmuHw25GoAhDWBiADQdACaiAFQv/C9LnsnfcBENYGIANBsANqIAdChOyh29zM7wIQ1gYgA0GQBGogCEKfzfqt8fjYBhDWBiADQfAEaiADKQOgCiIEQruiy8rezPQEENYGIANBwAJqIAVCmuHw25GoAhDWBiADQaADaiAHQv/C9LnsnfcBENYGIANBgARqIAhChOyh29zM7wIQ1gYgA0HgBGogBEKfzfqt8fjYBhDWBiADQZADaiAHQprh8NuRqAIQ1gYgA0HwA2ogCEL/wvS57J33ARDWBiADQdAEaiAEQoTsodvczO8CENYGIANB4ANqIAhCmuHw25GoAhDWBiADQcAEaiAEQv/C9LnsnfcBENYGIANBsARqIARCmuHw25GoAhDWBiADQeABaiADKQOwAiIFQpv80ZKxtMcCfkL/////////B4MiBELtp9fnpeOYARDWBiADQdABaiAEQoHLtc73xfoGENYGIANBsAFqIAMpA4ADIg0gAykDoAJ8IgcgAykD0AF8IgggBSADKQPgASIJfCIFQjSIIAUgCVStIANB6AFqKQMAIANBuAJqKQMAfHwiDkIMhoR8IglCm/zRkrG0xwJ+Qv////////8HgyIFQu2n1+el45gBENYGIANBwAFqIARC+b3TABDWBiADQaABaiAFQoHLtc73xfoGENYGIANBgAFqIAMpA/ACIhEgAykDkAJ8IgYgAykD0AN8IgogAykDwAF8IgsgAykDoAF8IgwgAykDsAEiDyAJfCIQQjSIIBAgD1StIANBuAFqKQMAIAkgCFStIAggB1StIANB2AFqKQMAIAcgDVStIANBiANqKQMAIANBqAJqKQMAfHx8fCAOQjSIfHx8fCISQgyGhHwiCEKb/NGSsbTHAn5C/////////weDIgdC7afX56XjmAEQ1gYgA0GQAWogBUL5vdMAENYGIANB8ABqIAdCgcu1zvfF+gYQ1gYgA0HQAGogAykD4AIiEyADKQOAAnwiCSADKQPAA3wiDSADKQOgBHwiDiADKQOQAXwiDyADKQNwfCIQIAMpA4ABIhQgCHwiFUI0iCAVIBRUrSADQYgBaikDACAIIAxUrSAMIAtUrSADQagBaikDACALIApUrSADQcgBaikDACAKIAZUrSADQdgDaikDACAGIBFUrSADQfgCaikDACADQZgCaikDAHx8fHx8fHx8IBJCNIh8fHx8IhZCDIaEfCIGQpv80ZKxtMcCfkL/////////B4MiCELtp9fnpeOYARDWBiADQeAAaiAHQvm90wAQ1gYgA0FAayAIQoHLtc73xfoGENYGIANBIGogAykD0AIiGSADKQPwAXwiCiADKQOwA3wiCyADKQOQBHwiDCADKQPwBHwiESAEQiyGfCISIAMpA2B8IhQgAykDQHwiFSADKQNQIhcgBnwiGEI0iCAYIBdUrSADQdgAaikDACAGIBBUrSAQIA9UrSADQfgAaikDACAPIA5UrSADQZgBaikDACAOIA1UrSADQagEaikDACANIAlUrSADQcgDaikDACAJIBNUrSADQegCaikDACADQYgCaikDAHx8fHx8fHx8fHwgFkI0iHx8fHwiF0IMhoR8IgZCm/zRkrG0xwJ+Qv////////8HgyIJQu2n1+el45gBENYGIANBMGogCEL5vdMAENYGIANBEGogCUKBy7XO98X6BhDWBiADIAlC+b3TABDWBiADIAMpA6ADIhggAykDwAJ8Ig0gAykDgAR8Ig4gAykD4AR8Ig8gBUIshnwiECADKQMwfCITIAMpAxB8IhYgAykDICIaIAZ8IhtCNIggGyAaVK0gA0EoaikDACAGIBVUrSAVIBRUrSADQcgAaikDACAUIBJUrSADQegAaikDACASIBFUrSARIAxUrSADQfgEaikDACAMIAtUrSADQZgEaikDACALIApUrSADQbgDaikDACAKIBlUrSADQdgCaikDACADQfgBaikDAHx8fHx8fHx8IARCFIh8fHx8fHwgF0I0iHx8fHwiEUIMhoR8IgRC/////////weDNwOoCiADIAMpA/ADIhIgAykDkAN8IgYgAykD0AR8IgogB0IshnwiCyADKQMAfCIMIAQgFlStIBYgE1StIANBGGopAwAgEyAQVK0gA0E4aikDACAQIA9UrSAPIA5UrSADQegEaikDACAOIA1UrSADQYgEaikDACANIBhUrSADQagDaikDACADQcgCaikDAHx8fHx8fCAFQhSIfHx8fHx8IBFCNIh8fCIOQgyGIARCNIiEfCIEQv////////8HgzcDsAogAyADKQPABCIPIAMpA+ADfCIFIAhCLIZ8Ig0gBCAMVK0gDCALVK0gA0EIaikDACALIApUrSAKIAZUrSADQdgEaikDACAGIBJUrSADQfgDaikDACADQZgDaikDAHx8fHwgB0IUiHx8fHwgDkI0iHx8IgZCDIYgBEI0iIR8IgRC/////////weDNwO4CiADIAlCLIYiCiADKQOwBHwiByAEIA1UrSANIAVUrSAFIA9UrSADQcgEaikDACADQegDaikDAHx8IAhCFIh8fCAGQjSIfHwiBUIMhiAEQjSIhHwiBEL/////////B4M3A8AKIAMgBCAHVK0gByAKVK0gA0G4BGopAwAgCUIUiHx8IAVCNIh8fEIMhiAEQjSIhDcDyAogACADQagKakGQwuAAEIAGIANB0ApqJAAL3SUCC38BfiMAQfABayIDJAACQCABKAKMBSABQeAEaigCAEEEdGogASgC6AQiBU0EQANAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAItAAAiBUEGRwRAAkACQAJAAkACQCAFQQFrDggTEgIDBAAHBgELAAsgAEKAgICAMDcCAAwhCyACLQABQQFrDgMNDAsOCyACLQABQQFrDgMHCAkGCwJAAkACQAJAIAJBBGooAgAiBUF9aiIEQQMgBEEDSRtBAWsOAwECAwALIAAgASACQRBqKAIAIAJBFGotAAAQlwIMIQsgACABIAJBEGooAgAgAkEUai0AABC3AgwgCyAAIAEgAkEQaigCACACQRRqLQAAELwCDB8LAkACQAJAIAVBAWsOAgECAAsgACABIAJBEGooAgAgAkEUai0AACACQQhqKAIAIgAgABCCAQwgCyAAIAEgAkEQaigCACACQRRqLQAAIAJBCGooAgAQggIMHwsgACABIAJBEGooAgAgAkEUai0AACACQQhqKAIAIAJBDGooAgAQggEMHgsgAkEEaigCACIFQQJGDRogBUEBaw0DDAILIANB8ABqIAJBBGoQzQsgASgC4AQhCSADKAJwIQYgAygCdCECIANCADcCfCADQaCrywAoAgA2AnggA0EAOgCYASADQQA2AogBIAJBf2ohByACRQ0NIANB6ABqIgIgBjYCACACIAYgB0EFdGo2AgQCQAJAAkACQAJAIAMoAmgiBSADKAJsIgpHBEAgA0HYAWohAgNAAkAgBEH/AXFFBEAgASgC4AQhBCACIANBkAFqKQMANwMAIAMgAykDiAE3A9ABIAEgA0HQAWogBBDDAQwBCyABKALgBCEEIAIgA0GQAWopAwA3AwAgAyADKQOIATcD0AEgA0HAAWogASADQdABakEAIANBASAEEJMBIANBwAFqEJ4LCyADQaABaiABEJoIIANB0AFqIAEgBRA7IAMoAtABQQFGDQIgA0G4AWoiCyACQQhqKAIANgIAIAMgAikCADcDsAECfyADKALUASIMQQNHBEAgAygC5AEhDSADKAKAASIEIAMoAnxGBEAgA0H4AGogBBDpCCADKAKAASEECyADKAJ4IARBBHRqIgggAykDsAE3AgQgCCAMNgIAIAhBDGogCygCADYCACADIARBAWo2AoABIAIgA0GoAWopAwA3AwAgAyADKQOgATcD0AEgA0GIAWogASADQdABakEBIA1BACADEJMBIANBADoAmAFBAAwBCyADQcgBaiADQagBaikDADcDACADIAMpA6ABIg43A8ABIA6nQQFHDRYgAygCxAEhCCADQcABahCeCyADKAKAASIEIAMoAnxGBEAgA0H4AGogBBDpCCADKAKAASEECyADKAJ4IARBBHRqIgQgCDYCBCAEQQE2AgAgA0EBOgCYASADIAg2AowBIANBATYCiAEgAyADKAKAAUEBajYCgAFBAQshBCAFQSBqIgUgCkcNAAsLIANB0AFqIAEgBiAHQQV0ahA7IANBqAFqIgUgA0HgAWooAgA2AgAgAyADQdgBaikDADcDoAEgAygC1AEhAiADKALQAUEBRg0BIAJBA0YNAiADQeQBaigCACEFIANB3AFqIANBqAFqKAIANgIAIAMgAjYC0AEgAyADKQOgATcC1AEgA0H4AGogA0HQAWoQxwggBA0DIANB2AFqIANBkAFqKQMANwMAIAMgAykDiAE3A9ABIAEgA0HQAWogBRDDAQwECyADQbgBaiADQeABaigCACIBNgIAIAMgA0HYAWopAwAiDjcDsAEgAygC1AEhAiAAQRBqIAE2AgAgAEEIaiAONwIAIAAgAjYCBCAAQQE2AgAgA0GgAWoQngsMHAsgACACNgIEIABBATYCACAAQQhqIAMpA6ABNwIAIABBEGogBSgCADYCACADQYgBahCeCwwbCyADQdgBaiADQZABaikDADcDACADIAMpA4gBNwPQASADQfgAaiADQdABahDHCAwBCyADQdgBaiADQZABaikDADcDACADIAMpA4gBNwPQASADQcABaiABIANB0AFqQQAgA0EBIAUQkwEgA0HAAWoQngsLIABCgICAgCA3AgAgAEEIaiADKQN4NwIAIABBFGogCTYCACAAQRBqIANBgAFqKAIANgIADBwLIAJBBGohAiABLQCvBEUNFiADQdgAaiACEM0LIANB0ABqIAMoAlgiAiACIAMoAlxBBXRqEOYLIAMoAlAiBCADKAJUIgVHBEAgA0HYAWohBwNAIANB0AFqIAEgBUFgaiICEDsgA0GQAWogB0EIaigCADYCACADIAcpAgA3A4gBIAMoAtQBIQYgAygC0AFBAUYNECAGQQNHBEAgAygC5AEhCiADQcgBaiIHIANBkAFqIggoAgAiAjYCACADIAMpA4gBIg43A8ABIANBlAFqIAI2AgAgAyAGNgKIASADIA43AowBIAQgBUFgaiICRwRAIANBiAFqQQRyIQkgA0HYAWohBQNAIANB0AFqIAEgAkFgaiICEDsgByAFQQhqKAIANgIAIAMgBSkCADcDwAEgAygC1AEhBiADKALQAUEBRg0UIAZBA0cEQCADKALkASELIAUgCCkDADcDACADIAMpA4gBNwPQASABIANB0AFqIAsQwwEgCSADKQPAATcCACAJQQhqIAcoAgA2AgAgAyAGNgKIAQsgAiAERw0ACwsgACADKQOIATcCBCAAQQA2AgAgAEEUaiAKNgIAIABBDGogCCkDADcCAAweCyACIgUgBEcNAAsLIABCgICAgDA3AgAMGwsgAkEUaigCACIFIAFBkARqKAIASQ0UIANBiAFqIAJBCGoQ1wcgA0HQAWogA0GIAWoQ1wcgASgCkAQiBCABQYwEaigCAEYEQCABQYgEaiAEEO8IIAEoApAEIQQLIAEoAogEIARBDGxqIgQgAykD0AE3AgAgBEEIaiADQdgBaiIEKAIANgIAIAEgASgCkARBAWo2ApAEIAQgA0GQAWooAgA2AgAgAyADKQOIATcD0AEgA0FAayABQbgEaiADQdABaiAFEIsDDBQLIAJBCGooAgAiBCABQZAEaigCACIFSQ0SIAFBjARqKAIAIAVGBEAgAUGIBGogBRDvCCABKAKQBCEFCyABKAKIBCAFQQxsakEANgIAIAEgASgCkARBAWo2ApAEDBILIAFBAToAsgQgAUGQBWoQogcgAUGPBmpBAToAACADQYEIOwHQASAAQQRqIAEgA0HQAWoQ+wYgAEEANgIAIABBFGogASgC4ARBf2o2AgAMGAsgAUEBOgCyBCABQZAFahCiByABQY8GakEBOgAAIANBgQo7AdABIABBBGogASADQdABahD7BiAAQQA2AgAgAEEUaiABKALgBEF/ajYCAAwXCyABQZAFahCiByADQYEMOwHQASAAQQRqIAEgA0HQAWoQ+wYgAEEANgIAIABBFGogASgC4ARBf2o2AgAMFgsgAUGQBWoQogcgA0GBDjsB0AEgAEEEaiABIANB0AFqEPsGIABBADYCACAAQRRqIAEoAuAEQX9qNgIADBULIAEtAK8ERQRAIANBgQY7AdABIABBBGogASADQdABahD7BiAAQQA2AgAgAEEUaiABKALgBEF/ajYCAAwVCyADQYEEOwHQASAAQQRqIAEgA0HQAWoQ+wYgAEEANgIAIABBFGogASgC4ARBf2o2AgAMFAsgAS0ArwRFDQsgA0GBBjsB0AEgAEEEaiABIANB0AFqEPsGIABBADYCACAAQRRqIAEoAuAEQX9qNgIADBMLIAFBmQVqQYECOwAAIAEtAK8ERQ0JIANBATsB0AEgAEEEaiABIANB0AFqEPsGIABBADYCACAAQRRqIAEoAuAEQX9qNgIADBILIAFBmQVqQYECOwAAIAEtAK8ERQ0HIANBgQI7AdABIABBBGogASADQdABahD7BiAAQQA2AgAgAEEUaiABKALgBEF/ajYCAAwRCyACQQhqIQUgAkEEaigCAEEBRwRAIANBOGogBRDNCyAAIAEgAygCOCADKAI8EGQMEQsgAS0ArQQgAS0ArgRyDQUgBRDqCgRAIANCADcC1AEgA0Ggq8sAKAIANgLQASADQTBqIgIgBSgCACIENgIAIAIgBCAFKAIIQQF0ajYCBCADIAMpAzA3A4gBIANBiAFqEIYLIgIEQANAIANBKGogAi0AACACLQABEJELIAMoAiwhBSADKAIoIQQgAygC2AEiAiADKALUAUYEQCADQdABaiACEI8JIAMoAtgBIQILIAMoAtABIAJBA3RqIgIgBTYCBCACIAQ2AgAgAyADKALYAUEBajYC2AEgA0GIAWoQhgsiAg0ACwsgA0EgaiADQdABahDNCyAAIAEgAygCICADKAIkEGQgA0HQAWoQ+QoMEQtBmKHLAEEkQbyhywAQ0QkACyACQQRqLQAAQQFHBEAgAkEIaigCACECIAEtAK0EIAEtAK4EckUEQCADQQI6ANABIAMgAjYC1AEgA0GIAWogASADQdABahD7BiAAIAMpA4gBNwIEIABBDGogA0GQAWopAwA3AgAgAEEANgIAIABBFGogASgC4ARBf2o2AgAMEQsgAkGAAU8EQCADQRBqIAIgAhCRCyADIAMpAxA3A9ABIAAgASADQdABakEBEGQMEQsgAyACOgDSASADIAI6ANEBIANBBDoA0AEgA0GIAWogASADQdABahD7BiACQf8BcQRAIAEgAmpBjwVqQQE6AAALIAAgAykDiAE3AgQgAEEANgIAIAEgAmpBkAVqQQE6AAAgAEEMaiADQZABaikDADcCACAAQRRqIAEoAuAEQX9qNgIADBALIAEtAK0EIAEtAK4EcgRAIANBCGogAkEFai0AACICIAIQ4gogAyADLwEIOwHQASAAIAEgA0HQAWpBARC4AQwQC0HMocsAQSxB+KHLABDRCQALIAdBAEHsossAELIHAAsgA0HgAGpB6KTLAEGMARDmCyADQeQBakEBNgIAIANCATcC1AEgA0H4o8sANgLQASADIAMpA2A3A+gBIAMgA0HoAWo2AuABIANB0AFqQfCkywAQ1woACyAAIAY2AgQgAEEBNgIAIABBCGogAykDiAE3AgAgAEEQaiADQZABaigCADYCAAwMCyAAIAY2AgQgAEEBNgIAIABBCGogAykDwAE3AgAgAEEQaiADQcgBaigCADYCACADQYgBahCeCwwLCyADQRhqIAUQzQsgACABIAMoAhggAygCHBC4AQwKCyADQQE7AdABIABBBGogASADQdABahD7BiAAQQA2AgAgAEEUaiABKALgBEF/ajYCAAwJCyADQYECOwHQASAAQQRqIAEgA0HQAWoQ+wYgAEEANgIAIABBFGogASgC4ARBf2o2AgAMCAsgA0GBBDsB0AEgAEEEaiABIANB0AFqEPsGIABBADYCACAAQRRqIAEo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dEVyDQwgAigCCBCJAQwMCyABKAIIIgBFDQcgAEEEdCEDIAEoAgBBDGohAANAIABBAToAACAAQRBqIQAgA0FwaiIDDQALDAcLIABBEGooAgAgAkHYAGogARCgBCACQegAaiABKAIQIgA2AgAgAkHIAGogADYCACACIAEoAgwiBDYCZCACQUBrIAJB4ABqKQMAIg03AwAgAiACKQNYIg43AzggAkEYaiAANgIAIAJBEGogDTcDACACIA43AwggAiAANgIwIAJCADcCJCACQejn3QAoAgA2AiAgAiAEQQF2NgIsIAJBIGoQPQJAAkAgAigCKCIARQ0AIABBBHQhACACKAIgIQMDQCAARQ0BIABBcGohACADKAIIIANBEGohA0UNAAsgAkEIaiACQSBqEIoBRQ0AIAIoAhAiAARAIABBBHQhAyACKAIIQQxqIQADQCAAQQE6AAAgAEEQaiEAIANBcGoiAw0ACwsgAkHkAGpBADoAACACQgA3AlwgAkHw590AKAIANgJYIAJBCGogAkHYAGoQ5gQgAkHoAGogAkEYaigCADYCACACQeAAaiACQRBqKQMANwMAIAIgAikDCDcDWCABIAJB2ABqEKYCRQ0BDAcLIAEoAggiAARAIABBBHQhAyABKAIAQQxqIQADQCAAQQE6AAAgAEEQaiEAIANBcGoiAw0ACwsgAkEgahCUCSACKAIkIgBFIABBBHRFckUEQCACKAIgEIkBCyACQQhqEJQJIAIoAgwiAEUgAEEEdEVyDQsgAigCCBCJAQwLCyABKAIIIgBFDQUgAEEEdCEDIAEoAgBBDGohAANAIABBAToAACAAQRBqIQAgA0FwaiIDDQALDAULIABBEGooAgAgARA9IAEoAggiAEUNCSAAQQR0IQMgASgCAEEMaiEAA0AgAEEBOgAAIABBEGohACADQXBqIgMNAAsMCQsCfwJAAkACQCADQQFrDgIBAgALIABBCGooAgAiBiEEQQAMAgsgAEEIaigCACEEQQEMAQsgAEEMaigCACEGIABBCGooAgAhBEEACyAAQRBqKAIAIQMgBEUEQCAAQRRqLQAAIQQgAkHYAGogAxCfAUEgQQQQ5AsiAEUNAyAAIAIpA1g3AgAgAEEYaiACQfAAaikDADcCACAAQRBqIAJB6ABqKQMANwIAIABBCGogAkHgAGopAwA3AgAgAiAE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AgwCCyAPIANBAXJGDQMgBUEEaiILIBAgCzUCAHwgAjUCACARfnwiED4CACAQQiCIIRAgAkEEaiECIARBAmohBCAFQQhqIQUgCEECaiEIIANBAmohAwwACwALAAsgAUEoQeSK4QAQsgcACyAEQShB5IrhABCwBwALIABBBGogB0GgARCJAxogACAJNgIACyAMQaABaiQADwsgAkEoQeSK4QAQsgcACyACQShB5IrhABCwBwAL5RsCC38CfiMAQYABayICJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQANAAkACQAJAAkACQAJAAkAgAC0AAEF/ag4IDQwAAAECAwQACyABKAIIIgBFDRMgAEEEdCEDIAEoAgBBDGohAANAIABBAToAACAAQRBqIQAgA0FwaiIDDQALDBMLIABBBGooAgAiBUF9aiIDQQMgA0EDSRtBAWsOAwcICQYLIABBGGooAgAhAAwECyAAQQxqKAIAIgNBAUYNASADDQIMEAsgAEEEaigCACEDIABBDGooAgAhACACQgA3AiQgAkHo590AKAIAIgU2AiAgAiABKAIMIgQ2AiwgAiABKAIQIgY2AjACQCAAQQV0IgdFDQAgAiAGNgJIIAJCADcCPCACIAU2AjggAiAEQQVuNgJEIAMgAkE4ahA/IAIoAkAiAEUNDiADIAdqIQYgA0EgaiEEA0AgAEEEdCEAIAIoAjghAwNAIABFDRAgAEFwaiEAIAMoAgggA0EQaiEDRQ0ACyACQegAaiACQcgAaigCADYCACACQeAAaiACQUBrKQMANwMAIAIgAikDODcDWCACQSBqIAJB2ABqEKYCRQRAIAEoAggiAEUNESAAQQR0IQMgASgCAEEMaiEAA0AgAEEBOgAAIABBEGohACADQXBqIgMNAAsMEQsgBCAGRg0BIAEoAgwhACACIAEoAhA2AkggAkIANwI8IAIgBTYCOCACIABBBW42AkQgBCACQThqED8gBEEgaiEEIAIoAkAiAA0ACwwOCyABIAJBIGoQigENDCABKAIIIgBFDQwgAEEEdCEDIAEoAgBBDGohAANAIABBAToAACAAQRBqIQAgA0FwaiIDDQALDAwLIAAoAgQhAAwBCwsgACgCBCIEIANBBXRqIQZB8OfdACgCACEHQejn3QAoAgAhCCACQdgAakEEciIJQQhqIQoDQAJAAkACQAJAIAQtAABBA0YEQCAELQABQQJGDQELIAJCADcCXCACIAg2AlggAiABKQIMNwJkIAQgAkHYAGoQPyABIAJB2ABqEIoBRQ0BIAIoAmBBBHQhACACKAJYIQMDQCAARQ0CIABBcGohACADLQAMIANBEGohAw0ACyACQdgAahCUCSACKAJcIgBFIABBBHRFcg0DIAIoAlgQiQEMAwsgASgCCCIFRQ0BIAVBBHQhACABKAIAIgshAwNAIABFDQIgAEFwaiEAIAMoAgggA0EQaiEDRQ0ACyAFQQR0IQMgC0EMaiEAA0AgAEEBOgAAIABBEGohACADQXBqIgMNAAsMEAsgASgCCCIABEAgAEEEdCEDIAEoAgBBDGohAANAIABBAToAACAAQRBqIQAgA0FwaiIDDQALCyACQdgAahCUCSACKAJcIgBFIABBBHRFcg0PIAIoAlgQiQEMDwsgCUIANwIAIApBADoAACACIAc2AlggASACQdgAahDmBAsgBiAEQSBqIgRHDQALDAwLIABBEGooAgAgAkHYAGogARCgBCACQegAaiABKAIQIgA2AgAgAkHIAGogADYCACACIAEoAgwiBDYCZCACQUBrIAJB4ABqKQMAIg03AwAgAiACKQNYIg43AzggAkEYaiAANgIAIAJBEGogDTcDACACIA43AwggAiAANgIwIAJCADcCJCACQejn3QAoAgA2AiAgAiAEQQF2NgIsIAJBIGoQPwJAAkAgAigCKCIARQ0AIABBBHQhACACKAIgIQMDQCAARQ0BIABBcGohACADKAIIIANBEGohA0UNAAsgAkEIaiACQSBqEIoBRQ0AIAJB5ABqQQA6AAAgAkIANwJcIAJB8OfdACgCADYCWCACQQhqIAJB2ABqEOYEIAJB6ABqIAJBGGooAgA2AgAgAkHgAGogAkEQaikDADcDACACIAIpAwg3A1ggASACQdgAahCmAkUNAQwJCyABKAIIIgAEQCAAQQR0IQMgASgCAEEMaiEAA0AgAEEBOgAAIABBEGohACADQXBqIgMNAAsLIAJBIGoQlAkgAigCJCIARSAAQQR0RXJFBEAgAigCIBCJAQsgAkEIahCUCSACKAIMIgBFIABBBHRFcg0MIAIoAggQiQEMDAsgASgCCCIARQ0HIABBBHQhAyABKAIAQQxqIQADQCAAQQE6AAAgAEEQaiEAIANBcGoiAw0ACwwHCyAAQRBqKAIAIAJB2ABqIAEQoAQgAkHoAGogASgCECIANgIAIAJByABqIAA2AgAgAiABKAIMIgQ2AmQgAkFAayACQeAAaikDACINNwMAIAIgAikDWCIONwM4IAJBGGogADYCACACQRBqIA03AwAgAiAONwMIIAIgADYCMCACQgA3AiQgAkHo590AKAIANgIgIAIgBEEBdjYCLCACQSBqED8CQAJAIAIoAigiAEUNACAAQQR0IQAgAigCICEDA0AgAEUNASAAQXBqIQAgAygCCCADQRBqIQNFDQALIAJBCGogAkEgahCKAUUNACACKAIQIgAEQCAAQQR0IQMgAigCCEEMaiEAA0AgAEEBOgAAIABBEGohACADQXBqIgMNAAsLIAJB5ABqQQA6AAAgAkIANwJcIAJB8OfdACgCADYCWCACQQhqIAJB2ABqEOYEIAJB6ABqIAJBGGooAgA2AgAgAkHgAGogAkEQaikDADcDACACIAIpAwg3A1ggASACQdgAahCmAkUNAQwHCyABKAIIIgAEQCAAQQR0IQMgASgCAEEMaiEAA0AgAEEBOgAAIABBEGohACADQXBqIgMNAAsLIAJBIGoQlAkgAigCJCIARSAAQQR0RXJFBEAgAigCIBCJAQsgAkEIahCUCSACKAIMIgBFIABBBHRFcg0LIAIoAggQiQEMCwsgASgCCCIARQ0FIABBBHQhAyABKAIAQQxqIQADQCAAQQE6AAAgAEEQaiEAIANBcGoiAw0ACwwFCyAAQRBqKAIAIAEQPyABKAIIIgBFDQkgAEEEdCEDIAEoAgBBDGohAANAIABBAToAACAAQRBqIQAgA0FwaiIDDQALDAkLIABBEGooAgAhAwJ/AkACQAJAIAVBAWsOAgECAAsgAEEIaigCACIHDAILQQEhBCAAQQhqKAIADAELIABBDGooAgAhByAAQQhqKAIACyIFRQRAIABBFGotAAAhBCACQdgAaiADEJ8BQSBBBBDkCyIARQ0DIAAgAikDWDcCACAAQRhqIAJB8ABqKQMANwIAIABBEGogAkHoAGopAwA3AgAgAEEIaiACQeAAaikDADcCACACIAQ6AEggAkEENgI4IAIgADYCRCACQdgAaiACQThqEO0EIAJB2ABqIAEQPyACQdgAahDaAgwJCyABKAIMIQAgAkE4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aiADLQBBIgIgAhCsCSADQcwAaiADQYgBaigCADYCACADIAMpA4ABNwJEIANBAjoAQCABIANBQGsQlQYMGQsgASgCAEEUai0AACIEQQJGIARBAXFyDQcgA0FAayABEOUGIAMtAEBBBkYNEyADQRBqIANBQGtBJBCJAxogA0GAAWogA0EQahCEByADQUBrIAEgAkEcahCsAiADLQBAQQFGDRcgAy0AQSEEIANBQGsgASACQTxqEKwCIAMtAEBBAUYNFyADQYABaiADLQBBIgIgBCAEIAJLIgUbIAQgAiAFGxCsCSADQcwAaiADQYgBaigCADYCACADIAMpA4ABNwJEIANBAjoAQCABIANBQGsQlQYMGAsgAkEEaiEEIAEoAgBBFGotAAAiBUECRiAFQQFxcg0EIANBQGsgARDlBiADLQBAQQZGDRAgA0EQaiADQUBrQSQQiQMaIANBgAFqIANBEGoQhAcgA0EIaiACQRxqEJ0FIAMoAgwiBQRAIAMoAggiAiAFQQN0aiEHA0AgA0GAAWogAkEEai0AACIFIAItAAAiBiAGIAVLIggbIAYgBSAIGxCsCSACQQhqIgIgB0cNAAsLIANBQGsgASAEIAQtABkgA0GAAWoQsgQgAy0AZCICQQhHDQUgA0HMAGogA0GIAWooAgA2AgAgAyADKQOAATcCRCADQQI6AEAgASADQUBrEJUGDBcLIAJBBGohAiABKAIAQRRqLQAAIgRBAkYgBEEBcXINASADQfAAaiABIAIQzgQgA0FAayABEOUGIAMtAEBBBkYNDCADQRBqIANBQGtBJBCJAxogA0GAAWogA0EQahCEByADQYABaiADKAJwIgIgAiADKAJ4QQF0ahDRCCADQYABahDNAiADQcwAaiADQYgBaigCADYCACADIAMpA4ABNwJEIANBAjoAQCABIANBQGsQlQYgAygCdCIBRSABQQF0RXINFiACEIkBDBYLAkAgASgCAEEUai0AACIEQQJGIARBAXFyRQRAIANBQGsgARDlBiADLQBAQQZGDQkgA0EQaiADQUBrQSQQiQMaIANB8ABqIANBEGoQhAcgA0FAayABIAIoAgQiAiACLQB4IANB8ABqELIEIAMtAGQiAkEIRg0BIANBEGogA0FAa0EkEIkDGiAAQSdqIANB5wBqLQAAOgAAIAAgAy8AZTsAJSAAIANBEGpBJBCJAyACOgAkIAMoAnQiAEUgAEEBdEVyDRggAygCcBCJAQwYCyADQUBrIAEQ5QYgAy0AQEEGRg0JIANBEGogA0FAa0EkEIkDGiADQfAAaiADQRBqEIMHIANBQGsgASACKAIEIgIgAi0AeCADQfAAahCNBSADLQBkIgJBCEYEQCADQUBrIAEQ5QYgAy0AQEEGRg0LIANBEGogA0FAa0EkEIkDGiADQYABaiADQRBqEIMHIANBgAFqIAMoAnAiAiACIAMoAnhBA3RqENAIIANBgAFqEMsCIANBzABqIANBiAFqKAIANgIAIAMgAykDgAE3AkQgA0EBOgBAIAEgA0FAaxCVBiADKAJ0IgFFIAFBA3RFcg0XIAMoAnAQiQEMFwsgA0EQaiADQUBrQSQQiQMaIABBJ2ogA0HnAGotAAA6AAAgACADLwBlOwAlIAAgA0EQakEkEIkDIAI6ACQgAygCdCIARSAAQQN0RXINFyADKAJwEIkBDBcLIANBQGsgARDlBiADLQBAQQZGDQogA0EQaiADQUBrQSQQiQMaIANBgAFqIANBEGoQhAcgA0GAAWogAygCcCICIAIgAygCeEEBdGoQ0QggA0GAAWoQzQIgA0HMAGogA0GIAWooAgA2AgAgAyADKQOAATcCRCADQQI6AEAgASADQUBrEJUGIAMoAnQiAUUgAUEBdEVyDRUgAygCcBCJAQwVCyADQUBrIAEgAhCIAyADQcwAaigCACEFIANByABqKAIAIQQgAygCRCECIAMoAkBBAUcEQCADQUBrIAEQ5QYgAy0AQEEGRg0MIANBEGogA0FAa0EkEIkDGiADQYABaiADQRBqEIMHIANBgAFqIAIgAiAFQQN0ahDQCCADQYABahDLAiADQcwAaiADQYgBaigCADYCACADIAMpA4ABNwJEIANBAToAQCABIANBQGsQlQYgBEUgBEEDdEVyDRUgAhCJAQwVCyADQShqIANB6ABqKAIAIgE2AgAgA0EgaiADQeAAaikDACIJNwMAIANBGGogA0HYAGopAwAiCjcDACADIANB0ABqKQMAIgs3AxAgACAFNgIIIAAgBDYCBCAAIAI2AgAgACALNwIMIABBFGogCjcCACAAQRxqIAk3AgAgAEEkaiABNgIADBULIANBQGsgASACQQRqEKcBIANBzABqKAIAIQUgA0HIAGooAgAhBCADKAJEIQIgAygCQEEBRwRAIANBQGsgARDlBiADLQBAQQZGDQwgA0EQaiADQUBrQSQQiQMaIANBgAFqIANBEGoQgwcgA0GAAWogAiACIAVBA3RqENAIIANBgAFqEMsCIANBzABqIANBiAFqKAIANgIAIAMgAykDgAE3AkQgA0EBOgBAIAEgA0FAaxCVBiAERSAEQQN0RXINFCACEIkBDBQLIANBKGogA0HoAGooAgAiATYCACADQSBqIANB4ABqKQMAIgk3AwAgA0EYaiADQdgAaikDACIKNwMAIAMgA0HQAGopAwAiCzcDECAAIAU2AgggACAENgIEIAAgAjYCACAAIAs3AgwgAEEUaiAKNwIAIABBHGogCTcCACAAQSRqIAE2AgAMFAsgA0FAayABEOUGIAMtAEBBBkYNDCADQRBqIANBQGtBJBCJAxogA0GAAWogA0EQahCDByADIAJBHGoQnQUgAygCBCIFBEAgAygCACICIAVBA3RqIQcDQCADQYABaiACQQRqKAIAIgUgAigCACIGIAYgBUsiCBsgBiAFIAgbEK0JIAJBCGoiAiAHRw0ACwsgA0FAayABIAQgBC0AGSADQYABahCNBSADLQBkIgJBCEYEQCADQcwAaiADQYgBaigCADYCACADIAMpA4ABNwJEIANBAToAQCABIANBQGsQlQYMEwsgA0EQaiADQUBrQSQQiQMaIABBJ2ogA0HnAGotAAA6AAAgACADLwBlOwAlIAAgA0EQakEkEIkDIAI6ACQgAygChAEiAEUgAEEDdEVyDRMgAygCgAEQiQEMEwsgA0EQaiADQUBrQSQQiQMaIABBJ2ogA0HnAGotAAA6AAAgACADLwBlOwAlIAAgA0EQakEkEIkDIAI6ACQgAygChAEiAEUgAEEBdEVyDRIgAygCgAEQiQEMEgsgA0FAayABEOUGIAMtAEBBBkYNDCADQRBqIANBQGtBJBCJAxogA0GAAWogA0EQahCDByADQYABaiACQdQAaigCACIEIAJBNGooAgAiAiACIARLIgUbIAIgBCAFGxCtCSADQcwAaiADQYgBaigCADYCACADIAMpA4ABNwJEIANBAToAQCABIANBQGsQlQYMEAsgA0FAayABEOUGIAMtAEBBBkYNDSADQRBqIANBQGtBJBCJAxogA0GAAWogA0EQahCDByADQYABaiACQRxqKAIAIgIgAhCtCSADQcwAaiADQYgBaigCADYCACADIAMpA4ABNwJEIANBAToAQCABIANBQGsQlQYMDwsgACADQRJqIANBQGtBBHJBKBCJA0EoEIkDGiADKAKEASIARSAAQQF0RXINDyADKAKAARCJAQwPC0HM890AQStBoOzdABDRCQALQczz3QBBK0GA7N0AENEJAAtBzPPdAEErQZDs3QAQ0QkAC0HM890AQStBsOzdABDRCQALQczz3QBBK0HQ7N0AENEJAAtBzPPdAEErQcDs3QAQ0QkAC0HM890AQStB4OzdABDRCQALQczz3QBBK0GA7d0AENEJAAtBzPPdAEErQfDs3QAQ0QkAC0HM890AQStBoO3dABDRCQALQczz3QBBK0GQ7d0AENEJAAtBzPPdAEErQcDt3QAQ0QkAC0HM890AQStBsO3dABDRCQALIAAgA0ESaiADQUBrQQRyQSgQiQNBKBCJAxogAygChAEiAEUgAEEBdEVyDQEgAygCgAEQiQEMAQsgAEEIOgAkCyADQZABaiQAC/wYAg1/A34jAEHwAWsiAiQAAkACQAJAAkACQAJAIAEQhwNB8ABHBEAgARCHA0HQAEcNAQsgASgCACIJKAJUDQEgCUF/NgJUIAlB4ABqQQA2AgAgARCHAyEOIAEQ4QoEQCABEIcDQfsARw0DIAJBsAFqIAEQgwUgAkGQAWogAkHEAWooAgA2AgAgAiACKQK8ATcDiAEgARDhCkUNBCAJQdgAaiEGA0AgARCHA0H9AEYNBQJAIAEQhwMiA0H/AE0EQCAJKAJgIgUgCSgCXEYEfyAGIAUQ4gggCSgCYAUgBQsgCSgCWGogAzoAACAJIAkoAmBBAWo2AmAMAQsgAkEANgKwASAGIAJBsAFqAn8gA0GAEE8EQCADQYCABEkEQCACIANBP3FBgAFyOgCyASACIANBDHZB4AFyOgCwASACIANBBnZBP3FBgAFyOgCxAUEDDAILIAIgA0E/cUGAAXI6ALMBIAIgA0ESdkHwAXI6ALABIAIgA0EGdkE/cUGAAXI6ALIBIAIgA0EMdkE/cUGAAXI6ALEBQQQMAQsgAiADQT9xQYABcjoAsQEgAiADQQZ2QcABcjoAsAFBAgsgAkGwAWpqEOQICyABEOEKDQALDAQLIAJBxAFqIAEoAgAiA0EIaigCACIFNgIAIAJBuAFqIgYgBTYCACACIAMpAgAiDzcCvAEgAiAPNwOwASABKAIEIQMgAkHwAGogAUEIaigCACIEQQAQhQggAigCdCEFIAIoAnAgAyAEEIkDIQEgAkGoAWogAkHAAWopAwAiEDcDACACQaABaiAGKQMAIhE3AwAgAiACKQOwASIPNwOYASAAQShqIAQ2AgAgAEEkaiAFNgIAIABBIGogATYCACAAQoGAgICgATcCACAAQSxqIA83AgAgAEE0aiARNwIAIABBPGogEDcCAAwFC0GKuMwAQT5ByLjMABDRCQALQci6zABBECACQbABakGku8wAQdi4zAAQ8wYACyACQaABaiIEIAEoAgAiA0EIaigCADYCACACIAMpAgA3A5gBIAEQhwMiBUHcAEYEQCACQbABaiABEIMFIAEoAgQhAyACQegAaiABQQhqKAIAIgZBABCFCCACKAJsIQUgAigCaCADIAYQiQMhASAAQShqIAY2AgAgAEEkaiAFNgIAIABBIGogATYCACAAQoGAgIDAAzcCACAAQSxqIAIpA7ABNwIAIABBNGogAkG4AWopAwA3AgAgAEE8aiACQcABaikDADcCAAwDCyABEOEKGiACQYABaiAEKAIANgIAIAIgAikDmAE3A3gMAQsCQCABKAIAIgMoAgAiBCABQQhqKAIARwRAIAIgARCHAyIFNgKYASAFQf0ARg0BIAJBADYCsAEgAkGYAWpB7LXMACACQbABakHouMwAEMYHAAsgASgCBCEFIAJBxAFqIANBCGooAgAiATYCACACQbgBaiIGIAE2AgAgAiADKQIAIg83ArwBIAIgDzcDsAEgAkEIaiAEQQAQhQggAigCDCEDIAIoAgggBSAEEIkDIQUgAkGoAWogAkHAAWoiASkDACIQNwMAIAJBoAFqIAYpAwAiETcDACACIAIpA7ABIg83A5gBIABCgYCAgKABNwIAIABBCGogAikCsAE3AgAgAEEQaiAGKQIANwIAIABBGGogASkCADcCACAAQShqIAQ2AgAgAEEkaiADNgIAIABBIGogBTYCACAAQSxqIA83AgAgAEE0aiARNwIAIABBPGogEDcCAAwCCyABELECGiACQbABaiAJKAJYIgggCSgCYCIGQfi4zAAQXwJAAkAgAigCsAFBAUYEQCACQbgBaiEHIAJB7AFqKAIA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VEEBajYCVCACQfABaiQAC8AZAhV/AX4jAEGABGsiAiQAIAIgASgCACIDKAIAIgQ2AvgCAkACQAJAAkACQCAERQRAIANBATYCCCADQoCAgIAQNwIAIAMgAy0AZToAZiADKAIUDQMgA0F/NgIUIANBGGoQkQcgAyADKAIUQQFqNgIUIAMoAiQNAiADQX82AiQgA0EoahC4BCADIAMoAiRBAWo2AiQgAygCNA0BIANBfzYCNCADQThqENMEIAMgAygCNEEBajYCNCACQfABaiIIIAEoAgAiA0EIaigCACIENgIAIAJB/AFqIAQ2AgAgAykCACEXIAJBHGpCADcCACACIBc3AvQBIAJBCGogCCkDADcDACACQRBqIAJB+AFqKQMANwMAIAJB2LrMACgCACIUNgIYIAIgFzcDACABEMwBIAJB6AFqQQRyIQYgASgCACgCACABQQhqKAIARg0EIAJBkAJqIQogAkEYaiESA0ACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABEIcDIgRBPkwEQCAEQVhqDgQJCAQDAQsCQCAEQYV/ag4CAgcACyAEQT9GDQQgBEHbAEYNBQsCQAJAAkACQAJAAkACQCABEIcDIgRBpH9qDgMGAQQACyAEQSRGDQIgBEEuRg0BCyACQfgCaiABEIMFIAEQsQIaIAhBEGogAkGIA2opAwA3AgAgCEEIaiACQYADaikDADcCACAIIAIpA/gCNwIAIAJBADoAjAIgAiAENgKIAiACKQOIAiEXIAIoAvABIQUgAigC9AEhCyACKAL4ASEMIAIoAvwBIQ0gAigCgAIhByACKAKEAiEJDBALIAggARCDBSABELECGiACQUBrIApBCGopAgA3AwAgAkHIAGogCkEQaikCADcDACACIAopAgA3AzggAigC8AEhDiACKAL0ASEPIAIoAvgBIRAgAigC/AEhAyACKAKAAiEEIAIoAoQCIQlBAyERDBELIAJB+AJqIAEQgwUgARCxAhogCEEQaiACQYgDaikDADcCACAIQQhqIAJBgANqKQMANwIAIAggAikD+AI3AgAgAkEBOgCIAgwBCyACQfgCaiABEIMFIAEQsQIaIAhBEGogAkGIA2opAwA3AgAgCEEIaiACQYADaikDADcCACAIIAIpA/gCNwIAIAJBADoAiAILIAJBATYC7AEgAikDiAIhFyACKAKEAiEJIAIoAoACIQcgAigC/AEhDSACKAL4ASEMIAIoAvQBIQsgAigC8AEhBQwLCyACQegBaiABEEUgAkFAayIVIApBCGopAgA3AwAgAkHIAGoiFiAKQRBqKQIANwMAIAIgCikCADcDOCACKQOIAiEXIAIoAoQCIQkgAigCgAIhByACKAL8ASENIAIoAvgBIQwgAigC9AEhCyACKALwASEFIAIoAuwBIRMgAigC6AFBAUYNCEEDIREgBSEOIAshDyAMIRAgDSEDIAchBAJ/AkACQCATQQFrDgQNEAABDgsgAiAXPgIsIAIgCTYCKEEBDAELIAJByAFqIBUpAwA3AwAgAkHQAWogFikDADcDACACIBc3AiwgAiAJNgIoIAIgAikDODcDwAFBAAshDkEFIREgBSEPIAshECAMIQMgDSEEIAchCQwNCyACQThqIAJBJBCJAxogAkHoAWogASACQThqEEggAigC6AFBAUcEQCACQfgCaiAGQSQQiQMaIAIgAkH4AmpBJBCJAxoMDgsgAkH4AmogBkHAABCJAxogAEEEaiACQfgCakHAABCJAxogAEEBNgIADBQLIAJBOGogAkEkEIkDGiACQQU2AsABIAJB6AFqIAEgAkE4aiACQcABahB9IAIoAugBQQFHBEAgAkH4AmogBkEkEIkDGiACIAJB+AJqQSQQiQMaDA0LIAJB+AJqIAZBwAAQiQMaIABBBGogAkH4AmpBwAAQiQMaIABBATYCAAwTCyACQThqIAJBJBCJAxogAkEENgLAASACQegBaiABIAJBOGogAkHAAWoQfSACKALoAUEBRwRAIAJB+AJqIAZBJBCJAxogAiACQfgCakEkEIkDGgwMCyACQfgCaiAGQcAAEIkDGiAAQQRqIAJB+AJqQcAAEIkDGiAAQQE2AgAMEgsgAkE4aiACQSQQiQMaIAJBAzYCwAEgAkHoAWogASACQThqIAJBwAFqEH0gAigC6AFBAUcEQCACQfgCaiAGQSQQiQMaIAIgAkH4AmpBJBCJAxoMCwsgAkH4AmogBkHAABCJAxogAEEEaiACQfgCakHAABCJAxogAEEBNgIADBELIAJB6AFqIAEQfiACKALoAUEBRwRAIAJB+AJqIAZBgAEQiQMaIAJBOGogAkH4AmpBgAEQiQMaIAIoAiAiBSACKAIcRgRA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BQAFAwUAAwULIAJBmAFqIAEQ7gMgAkGgAWoiASACQTBqKAIANgIAIABCgICAgDA3AgAgAEEIaiACKQMoNwIAIABBGGogAkGoAWopAwA3AgAgAEEgaiACQbABaigCADYCACAAQRBqIAEpAwA3AgAMBQsgAkGgAWoiBCADKAIANgIAIAJBrAFqIAEoAgAiA0EIaigCADYCACACIAIpAyg3A5gBIAIgAykCADcCpAEgASgCBCEDIAJBIGogAUEIaigCACIBQQAQhQggAigCJCEFIAIoAiAgAyABEIkDIQMgAkHoAGogAkGoAWopAwAiBjcDACACQeAAaiAEKQMAIgc3AwAgAiACKQOYASIINwNYIABBKGogATYCACAAQSRqIAU2AgAgAEEgaiADNgIAIABCgYCAgKABNwIAIABBLGogCDcCACAAQTRqIAc3AgAgAEE8aiAGNwIADAQLIAJBmAFqIAEQQkEBIQEgAkGYAWpBBHIhAwJAIAIoApgBQQFHBEAgAkHYAGogA0E4EIkDGiACQZgBaiACQdgAakE4EIkDGiACQaABaiACQTBqKAIANgIAIAIgAikDKDcDmAEgAEEIaiACQZgBakE4EIkDGiAAQQQ2AgRBACEBDAELIAJB2ABqIANBwAAQiQMaIABBBGogAkHYAGpBwAAQiQMaCyAAIAE2AgAMAwsgAkGYAWogARDzAkEBIQMgAkGYAWpBBHIhAQJAIAIoApgBQQFHBEAgAkFAayIDIAFBCGopAgA3AwAgAkHwAGogAUEYaikCACIGNwMAIAJByABqIAFBEGopAgAiBzcDACACQdAAaiAGNwMAIAMgAkEwaigCADYCACACIAEpAgA3AzggAEEIaiACKQMoIgg3AgAgAEEQaiADKQMANwIAIABBGGogBzcCACAAQSBqIAY3AgBBACEDIABBADYCBCACIAg3AzgMAQsgAkHYAGogAUHAABCJAxogAEEEaiACQdgAakHAABCJAxoLIAAgAzYCAAwCCyACQQA2ApgBIAJB2ABqQfCyzAAgAkGYAWpB9LLMABDGBwALIAEQsQIaIAJBoAFqIgUgAkEwaigCADYCACACQawBaiABKAIAIgRBCGooAgA2AgAgAiACKQMoNwOYASACIAQpAgA3AqQBIAMQ4QkEQCAAQgA3AgAgAEEIaiACKQOYATcCACAAQSRqQQE6AAAgAEEgaiADNgIAIABBEGogBSkDADcCACAAQRhqIAJBqAFqKQMANwIADAELIAACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgA0HtAEwEQAJAIANBn39qDgYDCw8PDwQACyADQb9/ag4CCAsBCyADQY5/ag4JBQ0DDQYNDQ0IBAsgA0EgRg0LDAwLIABBADYCBCAAQQhqIAIpA5gBNwIAIABBJGpBBTsBACAAQSBqQQc2AgAgAEEQaiACQaABaikDADcCACAAQRhqIAJBqAFqKQMANwIAQQAMDAsgAEEANgIEIABBCGogAikDmAE3AgAgAEEkakGFAjsBACAAQSBqQQw2AgAgAEEQaiACQaABaikDADcCACAAQRhqIAJBqAFqKQMANwIAQQAMCwsgAEEANgIEIABBCGogAikDmAE3AgAgAEEkakGFBDsBACAAQSBqQQk2AgAgAEEQaiACQaABaikDADcCACAAQRhqIAJBqAFqKQMANwIAQQAMCgsgA0HuAEcNCCAAQQA2AgQgAEEIaiACKQOYATcCACAAQSRqQYUGOwEAIABBIGpBCjYCACAAQRBqIAJBoAFqKQMANwIAIABBGGogAkGoAWopAwA3AgBBAAwJCyAAQQA2AgQgAEEIaiACKQOYATcCACAAQSRqQYUIOwEAIABBIGpBDTYCACAAQRBqIAJBoAFqKQMANwIAIABBGGogAkGoAWopAwA3AgBBAAwICyAAQQA2AgQgAEEIaiACKQOYATcCACAAQSRqQYUKOwEAIABBIGpBCzYCACAAQRBqIAJBoAFqKQMANwIAIABBGGogAkGoAWopAwA3AgBBAAwHCyAAQQE2AgQgAEEIaiACKQOYATcCACAAQSBqQQI6AAAMAwsgAEEBNgIEIABBCGogAikDmAE3AgAgAEEgakEDOgAADAILIABBATYCBCAAQQhqIAIpA5gBNwIAIABBIGpBBDoAAAwBCyAAQQE2AgQgAEEIaiACKQOYATcCACAAQSBqQQU6AAALIABBEGogAkGgAWopAwA3AgAgAEEYaiACQagBaikDADcCAEEADAILIAQtAGZFDQAgAEEANgIEIABBCGogAikDmAE3AgAgAEEkakGFDDsBACAAQSBqQSA2AgAgAEEQaiACQaABaikDADcCACAAQRhqIAJBqAFqKQMANwIAQQAMAQsg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KAIANgIAIANB7AJqIAEoAgAiBUEIaigCADYCACADIAMpAzg3A9gCIAMgBSkCADcC5AIgASgCBCEFIANBMGogAUEIaigCACIBQQAQhQggAygCNCEGIAMoAjAgBSABEIkDIQUgA0HgAWogA0HoAmopAwAiDTcDACADQdgBaiAEKQMAIg43AwAgAyADKQPYAiIPNwPQASAAQShqIAE2AgAgAEEkaiAGNgIAIABBIGogBTYCACAAQoGAgICgAzcCACAAQSxqIA83AgAgAEE0aiAONwIAIABBPGogDTcCAAwKCyAAQQhqIANB2AFqQTwQiQMaIABBATYCACAAIAc2AgQMCQsgASgCBCEBIANB4AJqIgYgA0FAaygCADYCACADQewCaiAFQQhqKAIANgIAIAMgAykDODcD2AIgAyAFKQIANwLkAiADQRBqIARBABCFCCADKAIUIQUgAygCECABIAQQiQMhASADQeABaiADQegCaikDACINNwMAIANB2AFqIAYpAwAiDjcDACADIAMpA9gCIg83A9ABIABBKGogBDYCACAAQSRqIAU2AgAgAEEgaiABNgIAIABCgYCAgKADNwIAIABBLGogDzcCACAAQTRqIA43AgAgAEE8aiANNwIADAgLIAEQ4QoNAiADQeACaiIFIANBQGsoAgA2AgAgASgCACIEQQhqKAIAIQYgBCkCACENIABBGjYCBCADQewCaiAGNgIAIAMgAykDODcD2AIgAyANNwLkAiABKAIEIQYgA0EoaiABKAIIIgFBABCFCCADKAIoIQQgAEEkaiADKAIsNgIAIABBIGogBDYCACAEIAYgARCJAxogAEEoaiABNgIAIABBLGogAykD2AI3AgAgAEE0aiAFKQMANwIAIABBPGogA0HoAmopAwA3AgAgAEEBNgIADAcLQcyxzABBJkH0scwAENEJAAsgA0HsAmogBEEIaigCACIFNgIAIANB4AJqIgYgBTYCACADIAQpAgAiDTcC5AIgAyANNwPYAiABKAIEIQQgA0EIaiABQQhqKAIAIgFBABCFCCADKAIMIQUgAygCCCAEIAEQiQMhBCADQeABaiADQegCaikDACINNwMAIANB2AFqIAYpAwAiDjcDACADIAMpA9gCIg83A9ABIABBKGogATYCACAAQSRqIAU2AgAgAEEgaiAENgIAIABCgYCAgLADNwIAIABBLGogDzcCACAAQTRqIA43AgAgAEE8aiANNwIADAULIAEQhwNB/QBGBEBBASEJQQEMAQsgA0HYAmogARCIASADQQU2ApgCIANBGTYCuAIgA0HQAWogA0HYAmogA0GYAmogA0G4AmoQzQEgAygC1AEhCCADKALQAUEBRg0BQQILIQsCQCABKAIAIgQoAgAiBSABKAIIRwRAIAEQhwNB/QBGDQEgASgCCCEFIAEoAgAhBAsgA0HgAmoiBiADQUBrKAIANgIAIARBCGooAgAhByAEKQIAIQ0gAEEaNgIEIANB7AJqIAc2AgAgAyADKQM4NwPYAiADIA03AuQCIAEoAgQhBCADQRhqIAVBABCFCCADKAIYIQEgAEEkaiADKAIcNgIAIABBIGogATYCACABIAQgBRCJAxogAEEoaiAFNgIAIABBLGogAykD2AI3AgAgAEE0aiAGKQMANwIAIABBPGogA0HoAmopAwA3AgAgAEEBNgIADAQLQQEhBCABEOEKRQ0CIAEQhwNBP0YNAQwCCyAAQQhqIANB2AFqQTwQiQMaIABBATYCACAAIAg2AgQMAgsgARCxAhpBACEECyADQcACaiIMIANBQGsoAgA2AgAgA0HMAmogASgCACIFQQhqKAIANgIAIAMgAykDODcDuAIgAyAFKQIANwLEAiAJIAcgCE1yBEAgA0HsAmogBUEIaigCADYCACADQeACaiIBIAogA0HQAGogBkF7ahsiBkEIaigCADYCACADIAUpAgA3AuQCIAMgBikCADcD2AJBhAFBBBDkCyIFBEAgBSADQcgAakGEARCJAyEFIANB4AFqIANB6AJqKQMANwMAIANB2AFqIAEpAwA3AwAgA0HwAWogA0HAAmopAwA3AwAgA0H4AWogA0HIAmopAwA3AwAgAyADKQPYAjcD0AEgAyADKQO4AjcD6AEgA0HYAmpBBHIgA0HQAWpBMBCJAxogA0GcA2ogBDoAACADQZgDaiAFNgIAIANBlANqIAg2AgAgA0GQA2ogBzYCACADQYwDaiALNgIAIANBBjYC2AIgAkEYaiADQdgCahDgCSAAQQRqIAJBJBCJAxogAEEANgIADAQLQYQBQQQQ4gwACyAAQRg2AgQgAEEsaiADKQO4AjcCACAAQTxqIANByAJqKQMANwIAIABBNGogDCkDADcCACABKAIEIQUgA0EgaiABKAIIIgFBABCFCCADKAIgIQQgAEEkaiADKAIkNgIAIABBIGogBDYCACAEIAUgARCJAxogAEEBNgIAIABBKGogATYCAAsgA0HIAGoQoAMLIAIoAhghBCACKAIgIgAEQCAAQYQBbCEBIAQhAANAIAAQhgMgAEGEAWohACABQfx+aiIBDQALCyACQRxqKAIAIgBFIABBhAFsRXINACAEEIkBCyADQeADaiQAC7QSAgF/GH4jAEGABmsiAyQAIANBsAVqIAEQ6AMgA0HYBWogAhDoAyADQYgFaiADQbAFaiADQdgFahD4BiADQbgCaiADKQOIBSIEQu3Nh7nWl9IHENYGIANBqAJqIARC2sif49rW7gEQ1gYgA0GIA2ogAykDkAUiBULtzYe51pfSBxDWBiADQZgCaiAEQpvK19n+//8HENYGIANB+AJqIAVC2sif49rW7gEQ1gYgA0HYA2ogAykDmAUiBkLtzYe51pfSBxDWBiADQYgCaiAEQv////////8HENYGIANB6AJqIAVCm8rX2f7//wcQ1gYgA0HIA2ogBkLayJ/j2tbuARDWBiADQagEaiADKQOgBSIHQu3Nh7nWl9IHENYGIANB+AFqIARC////////AxDWBiADQdgCaiAFQv////////8HENYGIANBuANqIAZCm8rX2f7//wcQ1gYgA0GYBGogB0LayJ/j2tbuARDWBiADQfgEaiADKQOoBSIEQu3Nh7nWl9IHENYGIANByAJqIAVC////////AxDWBiADQagDaiAGQv////////8HENYGIANBiARqIAdCm8rX2f7//wcQ1gYgA0HoBGogBELayJ/j2tbuARDWBiADQZgDaiAGQv///////wMQ1gYgA0H4A2ogB0L/////////BxDWBiADQdgEaiAEQpvK19n+//8HENYGIANB6ANqIAdC////////AxDWBiADQcgEaiAEQv////////8HENYGIANBuARqIARC////////AxDWBiADQegBaiADKQO4AiIFQpv80ZKxtMcCfkL/////////B4MiBELtp9fnpeOYARDWBiADQdgBaiAEQoHLtc73xfoGENYGIANBuAFqIAMpA4gDIgogAykDqAJ8IgYgAykD2AF8IgcgBSADKQPoASIJfCIFQjSIIAUgCVStIANB8AFqKQMAIANBwAJqKQMAfHwiDEIMhoR8IglCm/zRkrG0xwJ+Qv////////8HgyIFQu2n1+el45gBENYGIANByAFqIARC+b3TABDWBiADQagBaiAFQoHLtc73xfoGENYGIANBiAFqIAMpA/gCIhEgAykDmAJ8IgggAykD2AN8IgsgAykDyAF8Ig4gAykDqAF8Ig8gAykDuAEiDSAJfCIQQjSIIBAgDVStIANBwAFqKQMAIAkgB1StIAcgBlStIANB4AFqKQMAIAYgClStIANBkANqKQMAIANBsAJqKQMAfHx8fCAMQjSIfHx8fCISQgyGhHwiB0Kb/NGSsbTHAn5C/////////weDIgZC7afX56XjmAEQ1gYgA0GYAWogBUL5vdMAENYGIANB+ABqIAZCgcu1zvfF+gYQ1gYgA0HYAGogAykD6AIiEyADKQOIAnwiCSADKQPIA3wiCiADKQOoBHwiDCADKQOYAXwiDSADKQN4fCIQIAMpA4gBIhQgB3wiFUI0iCAVIBRUrSADQZABaikDACAHIA9UrSAPIA5UrSADQbABaikDACAOIAtUrSADQdABaikDACALIAhUrSADQeADaikDACAIIBFUrSADQYADaikDACADQaACaikDAHx8fHx8fHx8IBJCNIh8fHx8IhZCDIaEfCIIQpv80ZKxtMcCfkL/////////B4MiB0Ltp9fnpeOYARDWBiADQegAaiAGQvm90wAQ1gYgA0HIAGogB0KBy7XO98X6BhDWBiADQShqIAMpA9gCIhkgAykD+AF8IgsgAykDuAN8Ig4gAykDmAR8Ig8gAykD+AR8IhEgBEIshnwiEiADKQNofCIUIAMpA0h8IhUgAykDWCIXIAh8IhhCNIggGCAXVK0gA0HgAGopAwAgCCAQVK0gECANVK0gA0GAAWopAwAgDSAMVK0gA0GgAWopAwAgDCAKVK0gA0GwBGopAwAgCiAJVK0gA0HQA2opAwAgCSATVK0gA0HwAmopAwAgA0GQAmopAwB8fHx8fHx8fHx8IBZCNIh8fHx8IhdCDIaEfCIIQpv80ZKxtMcCfkL/////////B4MiCULtp9fnpeOYARDWBiADQThqIAdC+b3TABDWBiADQRhqIAlCgcu1zvfF+gYQ1gYgA0EIaiAJQvm90wAQ1gYgAyADKQOoAyIYIAMpA8gCfCIKIAMpA4gEfCIMIAMpA+gEfCINIAVCLIZ8IhAgAykDOHwiEyADKQMYfCIWIAMpAygiGiAIfCIbQjSIIBsgGlStIANBMGopAwAgCCAVVK0gFSAUVK0gA0HQAGopAwAgFCASVK0gA0HwAGopAwAgEiARVK0gESAPVK0gA0GABWopAwAgDyAOVK0gA0GgBGopAwAgDiALVK0gA0HAA2opAwAgCyAZVK0gA0HgAmopAwAgA0GAAmopAwB8fHx8fHx8fCAEQhSIfHx8fHx8IBdCNIh8fHx8IhFCDIaEfCIEQv////////8HgzcD2AUgAyADKQP4AyISIAMpA5gDfCIIIAMpA9gEfCILIAZCLIZ8Ig4gAykDCHwiDyAEIBZUrSAWIBNUrSADQSBqKQMAIBMgEFStIANBQGspAwAgECANVK0gDSAMVK0gA0HwBGopAwAgDCAKVK0gA0GQBGopAwAgCiAYVK0gA0GwA2opAwAgA0HQAmopAwB8fHx8fHwgBUIUiHx8fHx8fCARQjSIfHwiDEIMhiAEQjSIhHwiBEL/////////B4M3A+AFIAMgAykDyAQiDSADKQPoA3wiBSAHQiyGfCIKIAQgD1StIA8gDlStIANBEGopAwAgDiALVK0gCyAIVK0gA0HgBGopAwAgCCASVK0gA0GABGopAwAgA0GgA2opAwB8fHx8IAZCFIh8fHx8IAxCNIh8fCIIQgyGIARCNIiEfCIEQv////////8HgzcD6AUgAyAJQiyGIgsgAykDuAR8IgYgBCAKVK0gCiAFVK0gBSANVK0gA0HQBGopAwAgA0HwA2opAwB8fCAHQhSIfHwgCEI0iHx8IgVCDIYgBEI0iIR8IgRC/////////weDNwPwBSADIAQgBlStIAYgC1StIANBwARqKQMAIAlCFIh8fCAFQjSIfHxCDIYgBEI0iIQ3A/gFIANBsAVqIANB2AVqQbjC4AAQgAYgACADQbAFahCBAyADQYAGaiQAC5QSAgF/GH4jAEGABmsiAiQAIAJBiAVqIAEQ6AMgAkH4AWogAikDiAUiA0LtzYe51pfSBxDWBiACQYgCaiADQtrIn+Pa1u4BENYGIAJByAJqIAIpA5AFIgRC7c2HudaX0gcQ1gYgAkGYAmogA0KbytfZ/v//BxDWBiACQdgCaiAEQtrIn+Pa1u4BENYGIAJBmANqIAIpA5gFIgVC7c2HudaX0gcQ1gYgAkGoAmogA0L/////////BxDWBiACQegCaiAEQpvK19n+//8HENYGIAJBqANqIAVC2sif49rW7gEQ1gYgAkHoA2ogAikDoAUiBkLtzYe51pfSBxDWBiACQbgCaiADQv///////wMQ1gYgAkH4AmogBEL/////////BxDWBiACQbgDaiAFQpvK19n+//8HENYGIAJB+ANqIAZC2sif49rW7gEQ1gYgAkG4BGogAikDqAUiA0LtzYe51pfSBxDWBiACQYgDaiAEQv///////wMQ1gYgAkHIA2ogBUL/////////BxDWBiACQYgEaiAGQpvK19n+//8HENYGIAJByARqIANC2sif49rW7gEQ1gYgAkHYA2ogBUL///////8DENYGIAJBmARqIAZC/////////wcQ1gYgAkHYBGogA0KbytfZ/v//BxDWBiACQagEaiAGQv///////wMQ1gYgAkHoBGogA0L/////////BxDWBiACQfgEaiADQv///////wMQ1gYgAkHoAWogAikD+AEiBEKb/NGSsbTHAn5C/////////weDIgNC7afX56XjmAEQ1gYgAkHYAWogA0KBy7XO98X6BhDWBiACQcgBaiACKQPIAiIJIAIpA4gCfCIFIAIpA9gBfCIGIAQgAikD6AEiCHwiBEI0iCAEIAhUrSACQfABaikDACACQYACaikDAHx8IgtCDIaEfCIIQpv80ZKxtMcCfkL/////////B4MiBELtp9fnpeOYARDWBiACQZgBaiADQvm90wAQ1gYgAkG4AWogBEKBy7XO98X6BhDWBiACQYgBaiACKQPYAiIQIAIpA5gCfCIHIAIpA5gDfCIKIAIpA5gBfCINIAIpA7gBfCIOIAIpA8gBIgwgCHwiD0I0iCAPIAxUrSACQdABaikDACAIIAZUrSAGIAVUrSACQeABaikDACAFIAlUrSACQdACaikDACACQZACaikDAHx8fHwgC0I0iHx8fHwiEUIMhoR8IgZCm/zRkrG0xwJ+Qv////////8HgyIFQu2n1+el45gBENYGIAJBqAFqIARC+b3TABDWBiACQfgAaiAFQoHLtc73xfoGENYGIAJB6ABqIAIpA+gCIhIgAikDqAJ8IgggAikDqAN8IgkgAikD6AN8IgsgAikDqAF8IgwgAikDeHwiDyACKQOIASITIAZ8IhRCNIggFCATVK0gAkGQAWopAwAgBiAOVK0gDiANVK0gAkHAAWopAwAgDSAKVK0gAkGgAWopAwAgCiAHVK0gAkGgA2opAwAgByAQVK0gAkHgAmopAwAgAkGgAmopAwB8fHx8fHx8fCARQjSIfHx8fCIVQgyGhHwiB0Kb/NGSsbTHAn5C/////////weDIgZC7afX56XjmAEQ1gYgAkE4aiAFQvm90wAQ1gYgAkHYAGogBkKBy7XO98X6BhDWBiACQShqIAIpA/gCIhggAikDuAJ8IgogAikDuAN8Ig0gAikD+AN8Ig4gAikDuAR8IhAgA0IshnwiESACKQM4fCITIAIpA1h8IhQgAikDaCIWIAd8IhdCNIggFyAWVK0gAkHwAGopAwAgByAPVK0gDyAMVK0gAkGAAWopAwAgDCALVK0gAkGwAWopAwAgCyAJVK0gAkHwA2opAwAgCSAIVK0gAkGwA2opAwAgCCASVK0gAkHwAmopAwAgAkGwAmopAwB8fHx8fHx8fHx8IBVCNIh8fHx8IhZCDIaEfCIHQpv80ZKxtMcCfkL/////////B4MiCELtp9fnpeOYARDWBiACQcgAaiAGQvm90wAQ1gYgAkEYaiAIQoHLtc73xfoGENYGIAJBCGogCEL5vdMAENYGIAIgAikDyAMiFyACKQOIA3wiCSACKQOIBHwiCyACKQPIBHwiDCAEQiyGfCIPIAIpA0h8IhIgAikDGHwiFSACKQMoIhkgB3wiGkI0iCAaIBlUrSACQTBqKQMAIAcgFFStIBQgE1StIAJB4ABqKQMAIBMgEVStIAJBQGspAwAgESAQVK0gECAOVK0gAkHABGopAwAgDiANVK0gAkGABGopAwAgDSAKVK0gAkHAA2opAwAgCiAYVK0gAkGAA2opAwAgAkHAAmopAwB8fHx8fHx8fCADQhSIfHx8fHx8IBZCNIh8fHx8IhBCDIaEfCIDQv////////8HgzcD2AUgAiACKQOYBCIRIAIpA9gDfCIHIAIpA9gEfCIKIAVCLIZ8Ig0gAikDCHwiDiADIBVUrSAVIBJUrSACQSBqKQMAIBIgD1StIAJB0ABqKQMAIA8gDFStIAwgC1StIAJB0ARqKQMAIAsgCVStIAJBkARqKQMAIAkgF1StIAJB0ANqKQMAIAJBkANqKQMAfHx8fHx8IARCFIh8fHx8fHwgEEI0iHx8IgtCDIYgA0I0iIR8IgNC/////////weDNwPgBSACIAIpA+gEIgwgAikDqAR8IgQgBkIshnwiCSADIA5UrSAOIA1UrSACQRBqKQMAIA0gClStIAogB1StIAJB4ARqKQMAIAcgEVStIAJBoARqKQMAIAJB4ANqKQMAfHx8fCAFQhSIfHx8fCALQjSIfHwiB0IMhiADQjSIhHwiA0L/////////B4M3A+gFIAIgCEIshiIKIAIpA/gEfCIFIAMgCVStIAkgBFStIAQgDFStIAJB8ARqKQMAIAJBsARqKQMAfHwgBkIUiHx8IAdCNIh8fCIEQgyGIANCNIiEfCIDQv////////8HgzcD8AUgAiADIAVUrSAFIApUrSACQYAFaikDACAIQhSIfHwgBEI0iHx8QgyGIANCNIiENwP4BSACQbAFaiACQdgFakG4wuAAEIAGIAAgAkGwBWoQgQMgAkGABmokAAvkEAIBfxh+IwBBsAVrIgMkACADQfgBaiACKQMAIgUgASkDACIEENYGIANBiAJqIAIpAwgiCCAEENYGIANByAJqIAEpAwgiCSAFENYGIANBmAJqIAIpAxAiByAEENYGIANBiANqIAkgCBDWBiADQdgCaiABKQMQIgYgBRDWBiADQagCaiACKQMYIgogBBDWBiADQcgDaiAHIAkQ1gYgA0GYA2ogBiAIENYGIANB6AJqIAEpAxgiCyAFENYGIANBuAJqIAIpAyAiDCAEENYGIANB2ANqIAogCRDWBiADQfgDaiAGIAcQ1gYgA0GoA2ogCyAIENYGIANB+AJqIAEpAyAiBCAFENYGIANB6ANqIAwgCRDWBiADQagEaiAKIAYQ1gYgA0GIBGogCyAHENYGIANBuANqIAQgCBDWBiADQbgEaiAMIAYQ1gYgA0HIBGogCyAKENYGIANBmARqIAQgBxDWBiADQegEaiAMIAsQ1gYgA0HYBGogBCAKENYGIANB+ARqIAQgDBDWBiADQegBaiADKQP4ASIEQpv80ZKxtMcCfkL/////////B4MiBULtp9fnpeOYARDWBiADQdgBaiAFQoHLtc73xfoGENYGIANByAFqIAMpA8gCIg0gAykDiAJ8IgggAykD2AF8IgkgBCADKQPoASIHfCIEQjSIIAQgB1StIANB8AFqKQMAIANBgAJqKQMAfHwiDkIMhoR8IgdCm/zRkrG0xwJ+Qv////////8HgyIEQu2n1+el45gBENYGIANBmAFqIAVC+b3TABDWBiADQbgBaiAEQoHLtc73xfoGENYGIANBiAFqIAMpA5gCIhEgAykDiAN8IgYgAykD2AJ8IgogAykDmAF8IgsgAykDuAF8IgwgAykDyAEiDyAHfCIQQjSIIBAgD1StIANB0AFqKQMAIAcgCVStIAkgCFStIANB4AFqKQMAIAggDVStIANB0AJqKQMAIANBkAJqKQMAfHx8fCAOQjSIfHx8fCISQgyGhHwiCUKb/NGSsbTHAn5C/////////weDIghC7afX56XjmAEQ1gYgA0GoAWogBEL5vdMAENYGIANB+ABqIAhCgcu1zvfF+gYQ1gYgA0HoAGogAykDmAMiEyADKQPIA3wiByADKQOoAnwiDSADKQPoAnwiDiADKQOoAXwiDyADKQN4fCIQIAMpA4gBIhQgCXwiFUI0iCAVIBRUrSADQZABaikDACAJIAxUrSAMIAtUrSADQcABaikDACALIApUrSADQaABaikDACAKIAZUrSADQeACaikDACAGIBFUrSADQaACaikDACADQZADaikDAHx8fHx8fHx8IBJCNIh8fHx8IhZCDIaEfCIGQpv80ZKxtMcCfkL/////////B4MiCULtp9fnpeOYARDWBiADQThqIAhC+b3TABDWBiADQdgAaiAJQoHLtc73xfoGENYGIANBKGogAykD2AMiGSADKQP4A3wiCiAFQiyGfCILIAMpA6gDfCIMIAMpA7gCfCIRIAMpA/gCfCISIAMpAzh8IhQgAykDWHwiFSADKQNoIhcgBnwiGEI0iCAYIBdUrSADQfAAaikDACAGIBBUrSAQIA9UrSADQYABaikDACAPIA5UrSADQbABaikDACAOIA1UrSADQfACaikDACANIAdUrSADQbACaikDACAHIBNUrSADQaADaikDACADQdADaikDAHx8fHx8fHx8fHwgFkI0iHx8fHwiF0IMhoR8IgZCm/zRkrG0xwJ+Qv////////8HgyIHQu2n1+el45gBENYGIANByABqIAlC+b3TABDWBiADQRhqIAdCgcu1zvfF+gYQ1gYgA0EIaiAHQvm90wAQ1gYgAyADKQOIBCIYIAMpA6gEfCINIAMpA+gDfCIOIAMpA7gDfCIPIARCLIZ8IhAgAykDSHwiEyADKQMYfCIWIAMpAygiGiAGfCIbQjSIIBsgGlStIANBMGopAwAgBiAVVK0gFSAUVK0gA0HgAGopAwAgFCASVK0gA0FAaykDACASIBFUrSADQYADaikDACARIAxUrSADQcACaikDACAMIAtUrSADQbADaikDACALIApUrSAKIBlUrSADQeADaikDACADQYAEaikDAHx8IAVCFIh8fHx8fHx8fHx8fHwgF0I0iHx8fHwiEUIMhoR8IgVC/////////weDNwOIBSADIAMpA7gEIhIgAykDyAR8IgYgAykDmAR8IgogCEIshnwiCyADKQMIfCIMIAUgFlStIBYgE1StIANBIGopAwAgEyAQVK0gA0HQAGopAwAgECAPVK0gDyAOVK0gA0HAA2opAwAgDiANVK0gA0HwA2opAwAgDSAYVK0gA0GQBGopAwAgA0GwBGopAwB8fHx8fHwgBEIUiHx8fHx8fCARQjSIfHwiDkIMhiAFQjSIhHwiBUL/////////B4M3A5AFIAMgAykD2AQiDyADKQPoBHwiBCAJQiyGfCINIAUgDFStIAwgC1StIANBEGopAwAgCyAKVK0gCiAGVK0gA0GgBGopAwAgBiASVK0gA0HABGopAwAgA0HQBGopAwB8fHx8IAhCFIh8fHx8IA5CNIh8fCIGQgyGIAVCNIiEfCIFQv////////8HgzcDmAUgAyAHQiyGIgogAykD+AR8IgggBSANVK0gDSAEVK0gBCAPVK0gA0HgBGopAwAgA0HwBGopAwB8fCAJQhSIfHwgBkI0iHx8IgRCDIYgBUI0iIR8IgVC/////////weDNwOgBSADIAUgCFStIAggClStIANBgAVqKQMAIAdCFIh8fCAEQjSIfHxCDIYgBUI0iIQ3A6gFIAAgA0GIBWpBkMLgABCABiADQbAFaiQAC/ESAg5/An4jAEGQD2siCCQAIAEgAzYC5AQCQAJAAkACQCADQQFGBEAgCCABQZAHEIkDIgVBADYCoAcgBUEANgKQByAFIAIQ7gsiAToAsAQgBSACEO8LOgCxBCAFLQCuBEUNASAFLQCvBCABcg0BIAVBgAhqIAUQugEgBUGACGpBBHIhASAFKAKACEEBRwRAIAVBuAdqIgMgAUEQaigCADYCACAFQbAHaiIGIAFBCGopAgA3AwAgBSABKQIA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NwJUIAIgBjcDSAJAAkAgAUGUsswAQQMQzQRFBEAgAUGXsswAQQEQzQQNASABKAIAIgQoAgwiBUEBaiIDIAVPDQIgASgCBCEDIAJBKGogAUEIaigCACIBQQAQhQggAigCLCEEIAIoAiggAyABEIkDIQMgAEEoaiABNgIAIABBJGogBDYCACAAQSBqIAM2AgAgAEIBNwIAIABBLGogAikDMDcCACAAQTRqIAJBOGopAwA3AgAgAEE8aiACQUBrKQMANwIADAgLIAEoAgAiBCgCDCIFQQFqIgMgBUkNBCAEIAM2AgwgAkHIAWogASADEF0gAkHIAWpBBHIhAyACKALIAUEBRwRAIAJBiAFqIANBKBCJAxogAkHgAGogAkGIAWpBKBCJAxogAkHcAWogASgCACIBQQhqKAIAIgM2AgAgAkHQAWoiBCADNgIAIAIgASkCACIGNwLUASACIAY3A8gBQYQBQQQQ5AsiAUUNCSABQQA2AgAgASACKQPIATcCBCABQQxqIAQpAwA3AgAgAUEUaiACQdgBaikDADcCACAAQSRqIAJB4ABqQSgQiQMaIABCgICAgBA3AgAgAEHMAGogATYCACAAQSBqQQE2AgAgAEEIaiACKQMwNwIAIABBEGogAkE4aikDADcCACAAQRhqIAJBQGspAwA3AgAMCAsgAkGIAWogA0HAABCJAxogAEEEaiACQYgBakHAABCJAxogAEEBNgIADAcLIAEoAgAoAgAiAyABQQhqKAIARg0EIAJByAFqIAEQXiACQcgBakEEciEDAkACQCACKALIAUEBRwRAIAJBiAFqIANBJBCJAxogAkHgAGogAkGIAWpBJBCJAxogAiABEIcDIgM2AowCIAEQsQIaIANBKUYNAiADQTpGDQEgAkEANgLIASACQYwCakGYsswAIAJByAFqQZyyzAAQxgcACyACQYgBaiADQcAAEIkDGiAAQQRqIAJBiAFqQcAAEIkDGiAAQQE2AgAMCAsgAkHcAWogASgCACIBQQhqKAIAIgM2AgAgAkHQAWoiBCADNgIAIAIgASkCACIGNwLUASACIAY3A8gBQYQBQQQQ5AsiAUUNCCABQQA2AgAgASACKQPIATcCBCABQQxqIAQpAwA3AgAgAUEUaiACQdgBaikDADcCACAAQSRqIAJB4ABqQSQQiQMaIABBATYCBCAAQcwAaiABNgIAIABBIGpBAjYCACAAQQhqIAIpAzA3AgAgAEEQaiACQThqKQMANwIAIABBGGogAkFAaykDADcCAAwGCyACQYABaigCAARAIAJBkAFqIgMgAkE4aigCADYCACACQZwBaiABKAIAIgFBCGooAgA2AgAgAiACKQMwNwOIASACIAEpAgA3ApQBIAJB4AFqIAJB4ABqQSQQiQMaIAJB2AFqIAJBmAFqKQMANwMAIAJB0AFqIAMpAwA3AwAgAiACKQOIATcDyAEgAEEIaiACQcgBakE8EIkDGiAAQQA2AgQMBgsgASgCBCEDIAJBIGogASgCCCIBQQAQhQggAigCJCEEIAIoAiAgAyABEIkDIQMgAEEoaiABNgIAIABBJGogBDYCACAAQSBqIAM2AgAgAEKBgICAsAM3AgAgAEEsaiACKQNINwIAIABBNGogAkHQAGopAwA3AgAgAEE8aiACQdgAaikDADcCACACQfgAahD8CgwGCyAEIAM2AgwgAkHcAWogASgCACIBQQhqKAIAIgQ2AgAgAkHQAWoiBSAENgIAIAIgASkCACIGNwLUASACIAY3A8gBQYQBQQQQ5AsiAUUNBiABQQA2AgAgASACKQPIATcCBCABQQxqIAUpAwA3AgAgAUEUaiACQdgBaikDADcCACAAQoCAgIAQNwIAIABBCGogAikDMDcCACAAQRBqIAJBOGopAwA3AgAgAEEYaiACQUBrKQMANwIAIABBzABqIAE2AgAgAEEkaiADNgIAIABBIGpBADYCAAwFCyACQQA2AsgBIAJBiAFqQfCszAAgAkHIAWpBhLLMABDGBwALIAJB0AFqIgMgAkE4aigCADYCACACQdwBaiABKAIAIgRBCGooAgA2AgAgAiACKQMwNwPIASACIAQpAgA3AtQBIAEoAgQhBCACQQhqIAFBCGooAgAiAUEAEIUIIAIoAgwhBSACKAIIIAQgARCJAyEEIAJBmAFqIAJB2AFqKQMAIgY3AwAgAkGQAWogAykDACIHNwMAIAIgAikDyAEiCDcDiAEgAEEoaiABNgIAIABBJGogBTYCACAAQSBqIAQ2AgAgAEKBgICA4AM3AgAgAEEsaiAINwIAIABBNGogBzcCACAAQTxqIAY3AgAMAwsgASgCBCEDIAJBEGogAUEIaigCACIBQQAQhQggAigCFCEEIAIoAhAg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6AFqKAIANgIAIANBOGoiBCADQdgBaikDADcDACADIAMpA9ABNwMwIA+nIgIgAygCREkEQANAIAMgAkEBajYCQCADQTBqIAIQvQwhASAEIAIQvQwhAiABIAEtAAAgAi0AAHM6AAAgAygCQCICIAMoAkRJDQALCyAHQQFqIQcMAgsgBA0DIAAoAhQhBwsgAiEIIAEhBQsgCEGAf3EiBiAFaiEBIABBBGohDCADQTBqEJQHIAYEQCADQdgBaiELIANBsAFqIQ0DQCAFIgRBgAFqIQUgBkGAf2ohBiADQTBqIQkDQCADQdABahDZC0EAIQIDQCADAn8gAkEMRgRAIAAoAhAgB2oiCkEYdCAKQQh0QYCA/AdxciAKQQh2QYD+A3EgCkEYdnJyDAELIAIgDGooAgALNgKwASADQdABaiACakEEIANBsAFqQQRB5OrKABCICyACQQRqIgJBEEcNAAsgCSADKQPQATcAACAJQQhqIAspAwA3AAAgB0EBaiEHIAlBEGoiCSANRw0ACyAAKAIAIQ5BCCECIANBMGohCQNAIA4gCSACQQIgAkECSRsiChD1ASAJIApBBHRqIQkgAiAKayICDQALIANBGGogA0EwakGAARDHCyADQbABaiAEIAUgAygCGCADKAIcEJ0HIANB4AFqIANBwAFqKQMAIg83AwAgA0HoAWogA0HIAWooAgA2AgAgCyADQbgBaikDADcDACADIAMpA7ABNwPQASAPpyICIAMoAuQBSQRAA0AgAyACQQFqNgLgASADQdABaiACEL0MIQQgCyACEL0MIQIgBCAELQAAIAItAABzOgAAIAMoAuABIgIgAygC5AFJDQALCyAGDQALCyAIQfAAcSIEIAFqIQkgCEEPcSEIIAQEQCADQThqIQsgAEEEaiEKA0AgASEFIAFBEGohASAEQXBqIQQgA0GwAWoQ2QtBACECA0AgAwJ/IAJBDEYEQCAAKAIQIAdqIgZBGHQgBkEIdEGAgPwHcXIgBkEIdkGA/gNxIAZBGHZycgwBCyACIApqKAIACzYCMCADQbABaiACakEEIANBMGpBBEHk6soAEIgLIAJBBGoiAkEQRw0ACyAAIANBsAFqEIEGIANBEGogA0GwAWpBEBDHCyADQdABaiAFIAEgAygCECADKAIUEJ0HIANBQGsgA0HgAWopAwAiDzcDACADQcgAaiADQegBaigCADYCACADQThqIANB2AFqKQMANwMAIAMgAykD0AE3AzAgD6ciAiADKAJESQRAA0AgAyACQQFqNgJAIANBMGogAhC9DCEFIAsgAhC9DCECIAUgBS0AACACLQAAczoAACADKAJAIgIgAygCREkNAAsLIAdBAWohByAEDQALCyAIRQ0CIABBBGohBSADQTBqENkLQQAhAgNAIAMCfyACQQxGBEAgACgCECAHaiIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnIMAQsgAiAFaigCAAs2AtABIANBMGogAmpBBCADQdABakEEQeTqygAQiAsgAkEEaiICQRBHDQALIAAgAykDMDcAGCAAQSBqIANBOGoiASkDADcAACAAIABBGGoiAhCBBiADQQhqIAIgCBDHCyADQdABaiAJIAggCWogAygCCCADKAIMEJ0HIANBQGsgA0HgAWopAwAiDzcDACADQcgAaiADQegBaigCADYCACABIANB2AFqKQMANwMAIAMgAykD0AE3AzAgD6ciAiADKAJETw0CA0AgAyACQQFqNgJAIANBMGogAhC9DCEFIAEgAhC9DCECIAUgBS0AACACLQAAczoAACADKAJAIgIgAygCREkNAAsMAgsgBEEQQajtygAQsQcACwJAIAIgBGoiBSAETwRAIAVBEEsNASADQSBqIAAgBGpBGGogAhDHCyADQdABaiABIAEgAmogAygCICADKAIkEJ0HIANBQGsgA0HgAWopAwAiDzcDACADQcgAaiADQegBaigCADYCACADQThqIgggA0HYAWopAwA3AwAgAyADKQPQATcDMCAPpyICIAMoAkRJBEADQCADIAJBAWo2AkAgA0EwaiACEL0MIQEgCCACEL0MIQIgASABLQAAIAItAABzOgAAIAMoAkAiAiADKAJESQ0ACwsgACAFOgAoDAMLIAQgBUGY7coAELMHAAsgBUEQQZjtygAQsgcACyAAIAc2AhQgACAIOgAoC0EACyADQfABaiQAC70QAQJ/IwBB8AJrIgIkACACQQhqIAEQVCACQTBqIAJBCGoQVCACQdgAaiACQQhqIAEQSyACQYABaiACQQhqIAJB2ABqEEsgAkGoAWogAkEIaiACQYABahBLIAJB0AFqIAJBCGogAkGoAWoQSyACQfgBaiACQQhqIAJB0AFqEEsgAkGgAmogAkEwaiACQfgBahBLIAAgAkGgAmogARBLQf4AIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGAAWoQSyADIAJByAJqQSgQiQMhAEEEIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHYAGoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGgAmoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGgAmoQSyADIAJByAJqQSgQiQMhAEEEIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHQAWoQSyADIAJByAJqQSgQiQMhAEECIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHYAGoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGgAmoQSyADIAJByAJqQSgQiQMhAEEEIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGAAWoQSyADIAJByAJqQSgQiQMhAEEGIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGAAWoQSyADIAJByAJqQSgQiQMhAEEDIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGoAWoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGgAmoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGoAWoQSyADIAJByAJqQSgQiQMhAEEEIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHYAGoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkH4AWoQSyADIAJByAJqQSgQiQMhAEEGIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkH4AWoQSyADIAJByAJqQSgQiQMhAEEKIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHQAWoQSyADIAJByAJqQSgQiQMhAEEEIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHYAGoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHYAGoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHYAGoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHQAWoQSyADIAJByAJqQSgQiQMhAEEEIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGoAWoQSyADIAJByAJqQSgQiQMhAEEGIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGgAmoQSyADIAJByAJqQSgQiQMhAEEFIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkH4AWoQSyADIAJByAJqQSgQiQMhAEEDIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGAAWoQSyADIAJByAJqQSgQiQMhAEEGIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGgAmoQSyADIAJByAJqQSgQiQMhAEEDIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkGAAWoQSyADIAJByAJqQSgQiQMhAEEDIQEDQCACQcgCaiAAEFQgACACQcgCakEoEIkDIQMgAUF/aiIBDQALIAJByAJqIAMgAkHYAGoQSyADIAJByAJqQSgQiQMaIAJB8AJqJAALmQ4CCn8BfiMAQfABayICJAAgAiABNgIUAkAgARADQQFHBEAgAkEUaiACQagBakHAhcAAEPIBIQEgAEEBNgIAIAAgATYCBCACKAIUIgBBJEkNASAAEAAMAQsgAkEgakEFNgIAIAJBmIvAADYCHCACIAE2AhggAkEANgJIIAJBADYCWAJAAkACfwJAIAJBGGoQ6wUiDKdBAXFFBEAgAkGwAWohASACQagBakEBciEDIAJBqAFqQQRyIQQDQAJAAkACQAJAAkACQAJAAkACQAJAIAynQQh2Qf8BcQ4HBgUEAwIBAAELQQEhASAFQQFGBEACfwJAAkAgAigCSCIDBEAgAkHYAWogAkHQAGooAgA2AgAgAiACKQNINwPQASACKAJYIgFFDQEgAkHoAWogAkHgAGooAgA2AgAgAiACKQNYNwPgASAGQQFGDQJBsIbAAAwDC0GqhsAAQQMQywchASAAQQE2AgAgACABNgIEQQEMEAtBrYbAAEEDEMsHIQQgAEEBNgIAIAAgBDYCBAwOCyAHQQFGDQhBs4bAAAtBAxDLByEEIABBATYCACAAIAQ2AgQgAkHgAWoQpAsMDAtBp4bAAEEDEMsHIQMgAEEBNgIAIAAgAzYCBAwNCyACQQhqIAJBGGoQ5QcMBwsgBwRAQQEhAUGzhsAAQQMQzAchAyAAQQE2AgAgACADNgIEDAwLIAJBqAFqIAJBGGoQmQkgAi0AqAFBAUcEQCACQaYBaiADQQJqLQAAOgAAIAJBkAFqIAFBCGopAAA3AwAgAkGYAWogAUEQaikAADcDACACQaABaiABQRhqLQAAOgAAIAIgAy8AADsBpAEgAiABKQAANwOIASACKAKsASEIQQEhBwwHCwwFCyAGBEBBASEBQbCGwABBAxDMByEDIABBATYCACAAIAM2AgQMCwsgAkGoAWogAkEYahCZCSACLQCoAUEBRwRAIAJBhgFqIANBAmotAAA6AAAgAkHwAGogAUEIaikAADcDACACQfgAaiABQRBqKQAANwMAIAJBgAFqIAFBGGotAAA6AAAgAiADLwAAOwGEASACIAEpAAA3A2ggAigCrAEhCUEBIQYMBgsMBAsgAigCWARAQQEhAUGthsAAQQMQzAchAyAAQQE2AgAgACADNgIEDAoLIAJBqAFqIAJBGGoQmgkgAigCqAFBAUcEQCACQdgAahC7CyACQeAAaiAEQQhqKAIANgIAIAIgBCkCADcDWAwFCwwDCyACKAJIBEBBASEBQaqGwABBAxDMByEDIABBATYCACAAIAM2AgQMCQsgAkGoAWogAkEYahCaCSACKAKoAUEBRwRAIAJByABqELsLIAJB0ABqIARBCGooAgA2AgAgAiAEKQIANwNIDAQLDAILIAUEQEEBIQFBp4bAAEEDEMwHIQMgAEEBNgIAIAAgAzYCBAwICyACQagBaiACQRhqEJkJIAItAKgBQQFHBEAgAkHGAGogA0ECai0AADoAACACQTBqIAFBCGopAAA3AwAgAkE4aiABQRBqKQAANwMAIAJBQGsgAUEYai0AADoAACACIAMvAAA7AUQgAiABKQAANwMoIAIoAqwBIQpBASEFDAMLDAELIABBPGogAi8BhAE7AAAgAEHcAGogAi8BpAE7AAAgAkHCAWogAkHGAGotAAA6AAAgAkGwAWoiASACQdAAaigCADYCACACQbwBaiACQeAAaigCADYCACAAQT5qIAJBhgFqLQAAOgAAIABB3gBqIAJBpgFqLQAAOgAAIAIgAi8BRDsBwAEgAiACKQNINwOoASACIAIpA1g3ArQBIABBH2ogCjYAACAAQT9qIAk2AAAgAEEbaiACQb8BaigAADYAACAAQRRqIAJBuAFqKQMANwIAIABBDGogASkDADcCACAAIAIpA6gBNwIEIAAgAikDKDcAIyAAQStqIAJBMGopAwA3AAAgAEEzaiACQThqKQMANwAAIABBO2ogAkFAay0AADoAACAAQd8AaiAINgAAIABBADYCACAAQdsAaiACQYABai0AADoAACAAQdMAaiACQfgAaikDADcAACAAQcsAaiACQfAAaikDADcAACAAIAIpA2g3AEMgAEH7AGogAkGgAWotAAA6AAAgAEHzAGogAkGYAWopAwA3AAAgAEHrAGogAkGQAWopAwA3AAAgACACKQOIATcAYyACKAIYIgFBI0sNBwwICyAAIAIoAqwBNgIEQQEhASAAQQE2AgAMBQsgAkEYahDrBSIMQgGDUA0ACwtBASEBIABBATYCACAAIAxCIIg+AgQMAgsgAkHQAWoQpAsgAUULIQEgA0EARyELCyACKAJYRSABRXJFBEAgAkHYAGoQpAsLIAIoAkhFIAtyRQRAIAJByABqEKQLCyACKAIYIgFBI00NAQsgARAACyACQfABaiQAC9cNAgF/FH4jAEGQBGsiAiQAIAJB2ANqIAEpAwAiAyADENYGIAJBmANqIAEpAwgiBCADQgGGIgYQ1gYgAkHIAmogASkDECIFIAYQ1gYgAkHYAmogBCAEENYGIAJB6AFqIAEpAxgiAyAGENYGIAJBiAJqIAUgBEIBhiIHENYGIAJBOGogASkDICIEIAYQ1gYgAkGoAWogAyAHENYGIAJB+AFqIAUgBRDWBiACQcgAaiAEIAcQ1gYgAkGYAWogAyAFQgGGIgUQ1gYgAkHYAGogBCAFENYGIAJBiAFqIAMgAxDWBiACQegAaiAEIANCAYYQ1gYgAkH4AGogBCAEENYGIAJByANqIAIpA9gDIgRCm/zRkrG0xwJ+Qv////////8HgyIDQu2n1+el45gBENYGIAJBuANqIANCgcu1zvfF+gYQ1gYgAkGIA2ogAikDuAMiCCACKQOYA3wiBSAEIAIpA8gDIgZ8IgRCNIggBCAGVK0gAkHQA2opAwAgAkHgA2opAwB8fCILQgyGhHwiBkKb/NGSsbTHAn5C/////////weDIgRC7afX56XjmAEQ1gYgAkGoA2ogA0L5vdMAENYGIAJB+AJqIARCgcu1zvfF+gYQ1gYgAkG4AmogAikDyAIiDiACKQPYAnwiByACKQOoA3wiCSACKQP4AnwiCiACKQOIAyIMIAZ8Ig1CNIggDSAMVK0gAkGQA2opAwAgBiAFVK0gBSAIVK0gAkHAA2opAwAgAkGgA2opAwB8fCALQjSIfHx8fCINQgyGhHwiBkKb/NGSsbTHAn5C/////////weDIgVC7afX56XjmAEQ1gYgAkHoAmogBEL5vdMAENYGIAJBqAJqIAVCgcu1zvfF+gYQ1gYgAkHYAWogAikD6AEiECACKQOIAnwiCCACKQPoAnwiCyACKQOoAnwiDCACKQO4AiIRIAZ8Ig9CNIggDyARVK0gAkHAAmopAwAgBiAKVK0gCiAJVK0gAkGAA2opAwAgCSAHVK0gAkGwA2opAwAgByAOVK0gAkHQAmopAwAgAkHgAmopAwB8fHx8fHwgDUI0iHx8fHwiD0IMhoR8IgdCm/zRkrG0xwJ+Qv////////8HgyIGQu2n1+el45gBENYGIAJBmAJqIAVC+b3TABDWBiACQcgBaiAGQoHLtc73xfoGENYGIAJBKGogAikDqAEiFCACKQP4AXwiCSACKQM4fCIKIANCLIZ8Ig4gAikDmAJ8Ig0gAikDyAF8IhEgAikD2AEiEiAHfCITQjSIIBMgElStIAJB4AFqKQMAIAcgDFStIAwgC1StIAJBsAJqKQMAIAsgCFStIAJB8AJqKQMAIAggEFStIAJB8AFqKQMAIAJBkAJqKQMAfHx8fHx8IA9CNIh8fHx8IhJCDIaEfCIIQpv80ZKxtMcCfkL/////////B4MiB0Ltp9fnpeOYARDWBiACQbgBaiAGQvm90wAQ1gYgAkEYaiAHQoHLtc73xfoGENYGIAJBCGogB0L5vdMAENYGIAIgAikDSCITIAIpA5gBfCILIARCLIZ8IgwgAikDuAF8IhAgAikDGHwiDyACKQMoIhUgCHwiFkI0iCAWIBVUrSACQTBqKQMAIAggEVStIBEgDVStIAJB0AFqKQMAIA0gDlStIAJBoAJqKQMAIA4gClStIAogCVStIAJBQGspAwAgCSAUVK0gAkGwAWopAwAgAkGAAmopAwB8fHx8IANCFIh8fHx8fHwgEkI0iHx8fHwiDkIMhoR8IgNC/////////weDNwPoAyACIAIpA1giDSACKQOIAXwiCSAFQiyGfCIKIAIpAwh8IgggAyAPVK0gDyAQVK0gAkEgaikDACAQIAxUrSACQcABaikDACAMIAtUrSALIBNUrSACQdAAaikDACACQaABaikDAHx8IARCFIh8fHx8fHwgDkI0iHx8IgtCDIYgA0I0iIR8IgNC/////////weDNwPwAyACIAZCLIYiDCACKQNofCIEIAMgCFStIAggClStIAJBEGopAwAgCiAJVK0gCSANVK0gAkHgAGopAwAgAkGQAWopAwB8fCAFQhSIfHx8fCALQjSIfHwiCUIMhiADQjSIhHwiA0L/////////B4M3A/gDIAIgB0IshiIKIAIpA3h8IgUgAyAEVK0gBCAMVK0gAkHwAGopAwAgBkIUiHx8IAlCNIh8fCIEQgyGIANCNIiEfCIDQv////////8HgzcDgAQgAiADIAVUrSAFIApUrSACQYABaikDACAHQhSIfHwgBEI0iHx8QgyGIANCNIiENwOIBCAAIAJB6ANqQZDC4AAQgAYgAkGQBGokAAvcDQITfwJ+QcAAIQsjAEGgFGsiBiQAIAZBuAVqEKcKIAZBCGoQowYgBkHwD2oiChCnCiAGQZgOaiAGQbgFakHYARCJAxogBkHIEWogBkEIakGAARCJAyEIIAZBwAxqEKQGAkACQCACQYEBTwRAIAZByBJqEKcKIAZByBJqIAEgAhDYDCAGQQhqIAZByBJqQdgBEIkDGiAGQegJahD7CyAGQbgFaiAGQQhqQdgBEIkDGiAGQbgFaiAGQegJahDNBUEAIQIDQCACIAhqIgEgAS0AACAGQegJaiACaiIBLQAAczoAACAGQcAMaiACaiIHIActAAAgAS0AAHM6AAAgAkEBaiICQcAARw0ACwwBCyAGQbgFaiABIAEgAmoQvAsgBigCuAUiAiAGKAK8BSIMRg0AIAYgBigCwAUiB2pByBFqIQEgB0GAASAHQYABSxsiDSAHayEJIAZBwAxqIAdqIQcDQCACLQAAIQ4gCUUNAiABIAEtAAAgDnM6AAAgByAHLQAAIAItAABzOgAAIAlBf2ohCSAHQQFqIQcgAUEBaiEBIAJBAWoiAiAMRw0ACwsgBkGYDmogCEGAARDEAyAKIAZBwAxqQYABEMQDIAZBCGogBkGYDmpBsAQQiQMaIAZBoA5qIQogBkH4BGohEiAGQbgKaiETIAZB+AlqIRQgBkGAEGohDCAGQcgSakEEciENIAZBuAVqIRUgBkHEEWohDiAGQcQQaiEQIAZB+A9qIRFBACEHA0AgC0HAACALQcAASRsiAiAFaiEBIAsgAmshCyAFQQAgAhCRBSEIIAZBuAVqIAZBCGoQ7wMgBkG4BWogAyAEENgMIAYgB0EBaiIHQRh0IAdBCHRBgID8B3FyIAdBCHZBgP4DcSAHQRh2cnI2ApgOIAZBuAVqIAZBmA5qQQQQ2AwgBkGYDmogBkG4BWpBsAQQiQMaIBEpAwAhGSAGKQPwDyEaIA0gECAOELQDIAYgBigCwBA2AsgSIBQgDEHAABCJAyEWIBMgBkHIEmpBhAEQiQMhFyAGIBk3A/AJIAYgGjcD6AkgBkHADGogBkGYDmpB2AEQiQMaIAZBwAtqEPsLIAZByBJqIAZBwAxqQdgBEIkDGiAGQcgSaiAGQcALahDNBSAGQegJaiAGQcALakHAABDEAyAGQcAMaiAGQegJakHYARCJAxogBkGADGoQ+wsgBkHIEmogBkHADGpB2AEQiQMaIAZByBJqIAZBgAxqEM0FIAZB+ARqIAZBgAxqQcAAEIkDGiAGIBU2ApwOIAYgBkH4BGo2ApgOIAZBmA5qEP4LIQUgBikDmA4hGSAGIAI2ArAOIAYgBSACIAIgBUsbIgU2AqwOIAZBADYCqA4gBiAZNwOgDiAGIAE2ApwOIAYgCDYCmA4CQCAFRQ0AIAZBATYCqA4gCkEAEL0MIQUgCCAILQAAIAUtAABzOgAAIAYoAqgOIgUgBigCrA5PDQADQCAGIAVBAWo2AqgOIAYoApgOIQkgCiAFEL0MIQ8gBSAJaiIFIAUtAAAgDy0AAHM6AAAgBigCqA4iBSAGKAKsDkkNAAsLIAZBuARqIAZB+ARqQcAAEIkDGkEBIQkDQCAGQbgFaiAGQQhqEO8DIAZBuAVqIAZBuARqQcAAENgMIAZBmA5qIAZBuAVqQbAEEIkDGiARKQMAIRkgBikD8A8hGiANIBAgDhC0AyAGIAYoAsAQNgLIEiAWIAxBwAAQiQMaIBcgBkHIEmpBhAEQiQMaIAYgGTcD8AkgBiAaNwPoCSAGQcAMaiAGQZgOakHYARCJAxogBkHAC2oQ+wsgBkHIEmogBkHADGpB2AEQiQMaIAZByBJqIAZBwAtqEM0FIAZB6AlqIAZBwAtqQcAAEMQDIAZBwAxqIAZB6AlqQdgBEIkDGiAGQYAMahD7CyAGQcgSaiAGQcAMakHYARCJAxogBkHIEmogBkGADGoQzQUgBkG4BGogBkGADGpBwAAQiQMaIAYgEjYCnA4gBiAGQbgEajYCmA4gBkGYDmoQ/gshBSAGIAYpA5gONwOgDiAGIAE2ApwOIAYgCDYCmA4gBiACNgKwDiAGIAUgAiACIAVLGyIFNgKsDiAJQQFqIQkCQCAFRQ0AIAZBATYCqA4gCkEAEL0MIQUgCCAILQAAIAUtAABzOgAAIAYoAqgOIgUgBigCrA5PDQADQCAGIAVBAWo2AqgOIAYoApgOIQ8gCiAFEL0MIRggBSAPaiIFIAUtAAAgGC0AAHM6AAAgBigCqA4iBSAGKAKsDkkNAAsLIAlBgBBHDQALIAEhBSALDQALIABBBjYCACAGQaAUaiQADwsgDUGAAUGo+8EAELAHAAusDgEFf0HAiMsAIQUjAEGAAmsiBCQAIARBBzYCHCAEQcCIywA2AhggBEHYAWogBEEYahD/BwJAAkACQAJAIAQoAtgBQQJHBEAgBEHIAWogBEHgAWopAwA3AwAgBCAEKQPYATcDwAEgBEH4AGogASACIAMQzwYgBEE4aiAEQZABaikDADcDACAEQTBqIARBiAFqKQMANwMAIARBKGogBEGAAWopAwA3AwAgBEIANwNAIAQgBCkDeDcDICAEQfgAaiAEQSBqEI0IIAQoAngiAQRAIARB8AFqIARBhAFqKAIANgIAIAQgBCkCfDcD6AEgBCAEKAJAIgVBAWo2AkALIARB0ABqIAQpA+gBNwMAIARB2ABqIARB8AFqKAIANgIAIARBzABqIAE2AgAgBEHIAGogBTYCACAEQQE2AkQCQAJAIAEEQCAEQRBqIANBABCFCCAEQQA2AnAgBCAEKQMQNwNoIARB+ABqIARBIGpBPBCJAxpBACEBA0AgBCgCnAEhBSAEQQA2ApwBAkACQAJAAn8gBUEBRwRAIARB6AFqIARB+ABqEI0IIAQoAugBRQ0CIAQgBCgCmAFBAWo2ApgBIAQoAvQBIQcgBCgC8AEMAQsgBCgCpAFFDQEgBCgCsAEhByAEKAKgARogBCgCrAELIgYgAUkNCyABRQ0CIAEgA0kNASABIANGDQIMCwsgBEH4AGoQzwUgAUUEQEEAIQUMBQsCQCABIANPBEAgAyEFIAEgA0cNAQwGCyABIAJqLAAAQb9/TA0AIAEhBQwFCyACIAMgASADQfiDywAQjAEACyABIAJqLAAAQUBIDQkLAkAgBkUEQEEAIQUMAQsgBiADTwRAIAMhBSADIAZHDQoMAQsgAiAGaiwAAEG/f0wNCSAGIQULIARB6ABqIAEgAmogBSABaxDnCyAEQQhqIARBwAFqEIAIIARB6ABqIAQoAgggBCgCDBDnCyAHIQEMAAsACyAAIAI2AgQgAEEANgIAIABBCGogAzYCACAEQSBqEM8FDAELIARB6ABqIAIgBWogAyAFaxDnCyAAQQE2AgAgAEEMaiAEQfAAaigCADYCACAAIAQpA2g3AgQLIAQoAsABRQ0BIARBwAFqQQRyEKQLDAELIARB+ABqIAEgAiADEM8GIARBOGogBEGQAWopAwA3AwAgBEEwaiAEQYgBaikDADcDACAEQShqIARBgAFqKQMANwMAIARCADcDQCAEIAQpA3g3AyAgBEH4AGogBEEgahDxBSAEKAJ4IgEEQCAEQfgBaiAEQYwBaigCADYCACAEQfABaiAEQYQBaikCADcDACAEIAQpAnw3A+gBIAQgBCgCQCIFQQFqNgJACyAEQdAAaiAEKQPoATcDACAEQeAAaiAEQfgBaigCADYCACAEQdgAaiAEQfABaikDADcDACAEQcwAaiABNgIAIARByABqIAU2AgAgBEEBNgJEIAEEQCAEIANBABCFCCAEQQA2AnAgBCAEKQMANwNoIARB+ABqIARBIGpBxAAQiQMaIARB6AFqQQRyIQYgBEGoAWohCEEAIQEDQCAEKAKcASEFIARBADYCnAECQAJAAkAgBUEBRwRAIARB6AFqIARB+ABqEPEFIAQoAugBIgdFDQIgBEHQAWogBkEQaigCADYCACAEQcgBaiAGQQhqKQIANwMAIAQgBikCADcDwAEgBCAEKAKYASIFQQFqNgKYAQwBCyAEQcgBaiAIQQhqKQIANwMAIARB0AFqIAhBEGooAgA2AgAgBCAIKQIANwPAASAEKAKkASIHRQ0BIAQoAqABIQULIAYgBCkDwAE3AgAgBkEIaiAEQcgBaikDADcCACAGQRBqIARB0AFqKAIANgIAIAQgBzYC6AEgBUEASUEBcg0BIARB6AFqEIkKCyAEQfgAahCECyAEQegAagJ/QQAgAUUNABogASADTwRAIAMgASADRg0BGgwHCyABIAJqLAAAQb9/TA0GIAELIgEgAmogAyABaxDnCyAAQQE2AgAgAEEMaiAEQfAAaigCADYCACAAIAQpA2g3AgQMAwsgBEHYAWogBEHoAWpBABDxCCAEKALYAQRAIAQoAuABIgcgAUkNBCAEKALkAQJAIAFFDQAgASADTwRAIAEgA0YNAQwGCyABIAJqLAAAQUBIDQULAkAgB0UNACAHIANPBEAgAyAHRw0GDAELIAIgB2osAABBv39MDQULIARB6ABqIAEgAmogByABaxDnCyAEQegBaiAEQRhqIgEoAgAgASgCBCAEQegAahCrASAEQegBahCJCiEBDAELC0GIhMsAQStBuIPLABDRCQALIAAgAjYCBCAAQQA2AgAgAEEIaiADNgIAIARBIGoQhAsLIARBgAJqJAAPCyACIAMgASAHQciDywAQjAEACyACIAMgASADQdiDywAQjAEACyACIAMgASAGQeiDywAQjAEAC7INAgh/A34jAEGAAmsiAiQAIAIgARCHAyIDNgI4AkACQAJAAkAgA0HbAEYEQCACQTBqIgQgASgCACIDQQhqIgUoAgA2AgAgAiADKQIANwMoIAEQ4QpFDQEgARCHAyIFQd4ARgRAIAEQ4QpFDQMLIAMpAgAhCiACQcwAaiADQQhqKAIAIgQ2AgAgAkFAayAENgIAIAJB1ABqQgA3AgAgAiAKNwM4IAIgCjcCRCACQdi6zAAoAgAiBjYCUCACQeAAakEEciEEAkACQANAIAEQhwNBLUcNASACQdgBaiABEIMFIARBEGogAkHoAWopAwA3AgAgBEEIaiACQeABaikDADcCACAEIAIpA9gBNwIAIAJBADoAgAEgAkEtNgJ8IAJBATYCYCACQThqIAJB4ABqEI0DIAEQ4QoNAAsgAkHoAGoiBCACQTBqKAIANgIAIAJB9ABqIANBCGooAgA2AgAgAiACKQMoNwNgIAIgAykCADcCbCABKAIEIQUgAkEIaiABQQhqKAIAIgFBABCFCCACKAIMIQMgAigCCCAFIAEQiQMhBSACQegBaiACQfAAaiIGKQMAIgo3AwAgAkHgAWogBCkDACILNwMADAELIAIoAlgNBCABEIcDQd0ARw0EIAJB2AFqIAEQgwUgAkGAAWpBADoAACACQfwAakHdADYCACACQfQAaiIHIAJB6AFqIggpAwA3AgAgAkHsAGogAkHgAWoiCSkDADcCACACQQE2AmAgAiACKQPYATcCZCACQThqIAJB4ABqEI0DIAEQ4QoNBCACQegAaiIEIAJBMGooAgA2AgAgByADQQhqKAIANgIAIAIgAikDKDcDYCACIAMpAgA3AmwgASgCBCEFIAJBEGogAUEIaigCACIBQQAQhQggAigCFCEDIAIoAhAgBSABEIkDIQUgCCACQfAAaiIGKQMAIgo3AwAgCSAEKQMAIgs3AwALIAIgAikDYCIMNwPYASAAQoGAgIDAADcCACAAQQhqIAIpAmA3AgAgAEEQaiAEKQIANwIAIABBGGogBikCADcCACAAQShqIAE2AgAgAEEkaiADNgIAIABBIGogBTYCACAAQSxqIAw3AgAgAEE0aiALNwIAIABBPGogCjcCACACKAJYIgAEQCACKAJQIQEgAEHcAGwhAANAIAEQlgYgAUHcAGohASAAQaR/aiIADQALCyACKAJUIgBFIABB3ABsRXINBCACKAJQEIkBDAQLIAJBADYCYCACQThqQYCuzAAgAkHgAGpB2LfMABDGBwALIAJB6ABqIgYgBCgCADYCACACQfQAaiAFKAIANgIAIAIgAikDKDcDYCACIAMpAgA3AmwgASgCBCEDIAJBIGogAUEIaigCACIBQQAQhQggAigCJCEEIAIoAiAgAyABEIkDIQMgAkHIAGogAkHwAGopAwAiCjcDACACQUBrIAYpAwAiCzcDACACIAIpA2AiDDcDOCAAQShqIAE2AgAgAEEkaiAENgIAIABBIGogAzYCACAAQoGAgIDAADcCACAAQSxqIAw3AgAgAEE0aiALNwIAIABBPGogCjcCAAwCCyACQegAaiIEIAJBMGooAgA2AgAgAkH0AGogA0EIaigCADYCACACIAIpAyg3A2AgAiADKQIANwJsIAEoAgQhAyACQRhqIAFBCGooAgAiAUEAEIUIIAIoAhwhBSACKAIYIAMgARCJAyEDIAJByABqIAJB8ABqKQMAIgo3AwAgAkFAayAEKQMAIgs3AwAgAiACKQNgIgw3AzggAEEoaiABNgIAIABBJGogBTYCACAAQSBqIAM2AgAgAEKBgICAwAA3AgAgAEEsaiAMNwIAIABBNGogCzcCACAAQTxqIAo3AgAMAQsgAkHgAWoiASACQTBqKAIANgIAIAJB7AFqIANBCGooAgA2AgAgAiACKQMoNwPYASACIAMpAgA3AuQBIAJB9ABqIAJBQGsoAgAiAzYCACACQegAaiIEIAM2AgAgAiACKQM4Igo3AmwgAkHQAWoiAyACQfAAaikDADcDACACQcgBaiIHIAQpAwA3AwAgAiAKNwPAASAAQRxqQoCAgIDwADcCACAAQRRqIAJB6AFqKQMANwIAIABBDGogASkDADcCACAAIAIpA9gBNwIEIABB/ABqIAVB3gBGOgAAIABBQGtCADcCACAAQTxqIAY2AgAgAEEkaiACKQPAATcCACAAQSxqIAcpAwA3AgAgAEE0aiADKQMANwIAIABBgAFqIAJBOGpBJBCJAxogAEEANgIACyACQYACaiQAC5kOAgd/A34jAEGAAWsiAyQAAkACQCABKAIAIgUoAlRFBEAgBUF/NgJUIAVB4ABqQQA2AgAgA0EoaiAFQQhqKAIANgIAIAMgBSkCADcDICADQegAaiABEIMFIANBOGogA0H8AGooAgA2AgAgAyADKQJ0NwMwIAEQ4QpFDQEgBUHYAGohBgNAIAEQhwNB/QBGDQICQAJ/AkAgARCHAyIEQVBqQQpJIARBn39qQQZJckVBACAEQb9/akEFSxtFBEAgARCHAyIEQf8ATQRAIAUoAmAiByAFKAJcRgR/IAYgBxDiCCAFKAJgBSAHCyAFKAJYaiAEOgAAIAUgBSgCYEEBajYCYAwECyADQQA2AmggBEGAEEkNASAEQYCABEkEQCADIARBP3FBgAFyOgBqIAMgBEEMdkHgAXI6AGggAyAEQQZ2QT9xQYABcjoAaUEDDAMLIAMgBEE/cUGAAXI6AGsgAyAEQRJ2QfABcjoAaCADIARBBnZBP3FBgAFyOgBqIAMgBEEMdkE/cUGAAXI6AGlBBAwCCyADQegAaiABEIMFIAEoAgQhAiADQRhqIAFBCGooAgAiAUEAEIUIIAMoAhwhBCADKAIYIAIgARCJAyECIANB4ABqIANB+ABqIgcpAwAiCjcDACADQdgAaiADQfAAaiIGKQMAIgs3AwAgAyADKQNoIgw3A1AgAEKBgICAkAE3AgAgAEEIaiADKQJoNwIAIABBEGogBikCADcCACAAQRhqIAcpAgA3AgAgAEEoaiABNgIAIABBJGogBDYCACAAQSBqIAI2AgAgAEEsaiAMNwIAIABBNGogCzcCACAAQTxqIAo3AgAMBgsgAyAEQT9xQYABcjoAaSADIARBBnZBwAFyOgBoQQILIQQgBiADQegAaiADQegAaiAEahDkCAsgARDhCg0ACwwBC0HIuswAQRAgA0HoAGpBpLvMAEHctcwAEPMGAAsgASgCBCEHAkACQAJAIAUoAgAiBiABQQhqKAIAIgRHBEAgA0HIAGogBUEIaigCADYCACADIAUpAgA3A0AgBSgCWCEIIAUoAmAhBiADIAEQhwMiCTYCUCAJQf0ARw0BIAEQ4QoaIAZFDQICQCAIIAZBEBDlDCIKp0EBcQ0AIApCIIinIgFB///DAEsNACABQYBwcUGAsANHDQQLIANB8ABqIgEgA0E4aigCADYCACADQfwAaiADQcgAaigCADYCACADIAMpAzA3A2ggAyADKQNANwJ0IANBEGogBEEAEIUIIAMoAhQhAiADKAIQIAcgBBCJAyEHIANB4ABqIANB+ABqIgYpAwAiCjcDACADQdgAaiABKQMAIgs3AwAgAyADKQNoIgw3A1AgAEKBgICAgAE3AgAgAEEIaiADKQJoNwIAIABBEGogASkCADcCACAAQRhqIAYpAgA3AgAgAEEoaiAENgIAIABBJGogAjYCACAAQSBqIAc2AgAgAEEsaiAMNwIAIABBNGogCzcCACAAQTxqIAo3AgAMBAsgA0HwAGoiASADQShqKAIANgIAIANB/ABqIAVBCGooAgA2AgAgAyADKQMgNwNoIAMgBSkCADcCdCADIAZBABCFCCADKAIEIQIgAygCACAHIAYQiQMhBCADQeAAaiADQfgAaiIHKQMAIgo3AwAgA0HYAGogASkDACILNwMAIAMgAykDaCIMNwNQIABCgYCAgKABNwIAIABBCGogAykCaDcCACAAQRBqIAEpAgA3AgAgAEEYaiAHKQIANwIAIABBKGogBjYCACAAQSRqIAI2AgAgAEEgaiAENgIAIABBLGogDDcCACAAQTRqIAs3AgAgAEE8aiAKNwIADAMLIANBADYCaCADQdAAakHstcwAIANB6ABqQfC1zAAQxgcACyADQfAAaiIBIANBKGooAgA2AgAgA0H8AGogBUEIaigCADYCACADIAMpAyA3A2ggAyAFKQIANwJ0IANBCGogBEEAEIUIIAMoAgwhAiADKAIIIAcgBBCJAyEHIANB4ABqIANB+ABqIgYpAwAiCjcDACADQdgAaiABKQMAIgs3AwAgAyADKQNoIgw3A1AgAEKBgICA8AA3AgAgAEEIaiADKQJoNwIAIABBEGogASkCADcCACAAQRhqIAYpAgA3AgAgAEEoaiAENgIAIABBJGogAjYCACAAQSBqIAc2AgAgAEEsaiAMNwIAIABBNGogCzcCACAAQTxqIAo3AgAMAQsgA0HwAGoiBCADQThqKAIANgIAIANB/ABqIAVBCGooAgA2AgAgBSkCACEKIAAgAykDMDcCBCAAQRxq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EJYJDQAgACAFIAQQ1AYMAwsgAEEBOwEADAILIAJB/J7bAEE8IAMgARC8BSAAAn8CQCACKAIAIgEEQCACQShqIAEgAigCBBDBBiACKAIoDQELIABBADoAAUEBDAELIABBBGogAikDKDcCACAAQQxqIAJBMGooAgA2AgBBAAs6AAAMAQsgAEEEakH81M8AQT0QwQYgAEEAOgAACyACQfAAaiQAC+0NAgl/An4jAEHQA2siAyQAIAMgARCHAyIENgKgAQJAAkACQAJAAkACQAJAAkACQAJAIARBKUYEQCABKAIAIgYoAiQNBSAGQX82AiQgBkEwaigCACIIRQ0EIAYgCEF/aiIFNgIwIANBiAJqIAZBKGooAgAiByAFQfAAbGoiCUEKaikBADcDACADQZACaiAJQRJqKQEANwMAIANBmAJqIAlBGmovAQA7AQAgAyAJKQECNwOAAiAJKQEgIQwgCSgBHCEEIAktAABBf2oOAgEEAgsgA0EANgLIAiADQaABakGUrcwAIANByAJqQZitzAAQxgcACyAFRQRAIANBAjoAyAJBASEFDAcLIAYgCEF+aiIFNgIwIANByAJqIAcgBUHwAGxqQfAAEIkDGkEBIQUgAy0AyAIiCEECRg0GQQAhBSAIQQFGDQYgA0HwAWogA0HUAmopAgA3AwAgA0H4AWogA0HcAmopAgA3AwAgAyADKQLMAjcD6AEgA0G0A2ooAgAhCyADQeQCaigCACEFIANB6AJqKQMAIQ0gAy0AyQIhCiADQaABaiADQfACakHEABCJAxogA0GzAmogA0GAAmpBAnIiB0EQaikAADcAACADQasCaiAHQQhqKQAANwAAIAMgBykAADcAowIgCEUNASADQcgCahDRBgwBCyAJLQABIQogA0HwAWogA0GKAmopAQA3AwAgA0H4AWogA0GSAmopAQA3AwAgAyADKQGCAjcD6AEgCSgCbCELIANBoAFqIAlBKGpBxAAQiQMaIAQhBSAMIQ1BACEECyADQTRqIA03AgAgA0EoaiADQfgBaikDADcDACADQSBqIANB8AFqKQMANwMAIAMgAykD6AE3AxggAyAFNgIwIANBQGsgA0GgAWpBxAAQiQMaIANBmAFqIANBswJqKQAANwMAIANBkAFqIgggA0GrAmopAAA3AwAgAyADKQCjAjcDiAEgBiAKQQBHOgBmIAIgBikCADcCDCACQRRqIAZBCGoiBygCADYCACABELECGiADQdQAaiAHKAIANgIAIAMgBikCADcCTAJAIARFBEAgA0GgAWogAkEkEIkDGiADQcgCaiADQaABahCBBUGEAUEEEOQLIgFFDQQMAQsgA0G8AmogDDcCACADQagCaiAIKAIANgIAIANBtAJqIAJBDGoiAUEIaigCADYCACADIAMpA4gBNwOgAiADIAQ2ArgCIAMgASkCADcCrAIgA0GgAWogAkEkEIkDGiADQcgCaiADQaABahCBBSAMQiCIpyIBIAynRgRAIANBuAJqIAEQiAkgAygCuAIhBCADKALAAiEBCyAEIAFBhAFsaiADQcgCakGEARCJAxogAyABQQFqNgLAAiADQaABaiADQaACakEkEIkDGiADQcgCaiADQaABahCABUGEAUEEEOQLIgFFDQQLIAEgA0HIAmpBhAEQiQMaIAsQoAMgCxCJASANQiCIpyICIA2nRgR/IANBMGogAhCICSADKAIwIQUgAygCOAUgAgtBhAFsIAVqIgJBBzYCACACQQRqIANBQGtBxAAQiQMaIAJByABqIAE2AgAgAyADKAI4QQFqNgI4IABBBGogA0EYakEkEIkDGiAAQQA2AgAgBiAGKAIkQQFqNgIkDAYLIANByAJqIAEQgwUgASgCBCEFIANBCGogAUEIaigCACIHQQAQhQggAygCDCEEIAMoAgggBSAHEIkDIQEgAEEoaiAHNgIAIABBJGogBDYCACAAQSBqIAE2AgAgAEKBgICA4AI3AgAgAEEsaiADKQPIAjcCACAAQTRqIANB0AJqKQMANwIAIABBPGogA0HYAmopAwA3AgAMBAtByLrMAEEQIANByAJqQaS7zABBqK3MABDzBgALQYQBQQQQ4gwAC0GEAUEEEOIMAAsgA0FAayABEIMFIAEoAgQhCCADQRBqIAFBCGooAgAiCkEAEIUIIAMoAhQhByADKAIQIAggChCJAyEBIABBKGogCjYCACAAQSRqIAc2AgAgAEEgaiABNgIAIABCgYCAgOACNwIAIABBLGogAykDQDcCACAAQTRqIANByABqKQMANwIAIABBPGogA0HQAGopAwA3AgAgBUUEQCADQcgCahDRBgsgDEIgiKciAARAIABBhAFsIQEgBCEAA0AgABCGAyAAQYQBaiEAIAFB/H5qIgENAAsLIAynIgBFIABBhAFsRXINACAEEIkBCyAGIAYoAiRBAWo2AiQgAigCGCEEIAJBIGooAgAiAARAIABBhAFsIQEgBCEAA0AgABCGAyAAQYQBaiEAIAFB/H5qIgENAAsLIAJBHGooAgAiAEUgAEGEAWxFcg0AIAQQiQELIANB0ANqJAAL6g0BCX8jAEGwA2siAiQAIAJB6AJqIAEQkgYgAkHoAmpBBHIhAwJAAkACQAJAAkACQAJAIAIoAugCQQFHBEAgAkGYAWogA0E8EIkDGiACQRhqIAJBmAFqQTwQiQMaIAEQzAEgASgCACgCACABQQhqKAIARg0FIAEQhwNBLUcNASABEMEBQd0ARg0BIAEQwQFBLUYNASABEOEKRQ0CIAJB6AJqIAEQkgYgAkHoAmpBBHIhAyACKALoAkEBRg0DIAJBmAFqIANBPBCJAxogAkHYAGogAkGYAWpBPBCJAxogAkGoAmogAkEkaigCADYCACACQbQCaiACQfAAaigCADYCACACIAIpAhw3A6ACIAIgAkHoAGopAwA3AqwCIAJBmAFqIAJBGGpBPBCJAxogAkHoAmogAkGYAWogARDzAyACQcACaiIEIAJB9AJqIgUpAgA3AwAgAkHIAmoiBiACQfwCaiIIKQIANwMAIAIgAikC7AI3A7gCIAJBiANqIgkoAgAhByACQYQDaiIKKAIAIQMgAigC6AJBAUcNBCAAQTxqIAJBpANqKQIANwIAIABBNGogAkGcA2opAgA3AgAgAEEsaiACQZQDaikCADcCACAAQSRqIAJBjANqKQIANwIAIABBFGogBikDADcCACAAQQxqIAQpAwA3AgAgACACKQO4AjcCBCAAQSBqIAc2AgAgAEEcaiADNgIAIABBATYCACACKAJYQQRJDQcgAkHYAGpBBHIQpwgMBwsgAkGYAWogA0HAABCJAxogAEEEaiACQZgBakHAABCJAxogAEEBNgIADAYLIAJBGGpBBHIhAwJAAkACQAJAIAIoAhgiBA4FAQAAAgMACyACIAQ2AugCIAJB6AJqQQRyIANBOBCJAyABKAIEIQUgAkEIaiABKAIIIgFBABCFCCACKAIMIQYgAigCCCAFIAEQiQMhBSAAQShqIAE2AgAgAEEkaiAGNgIAIABBIGogBTYCACAAQoGAgIAQNwIAIABBLGogAykCADcCACAAQTRqIANBCGopAgA3AgAgAEE8aiADQRBqKQIANwIAIARBBEkNCBCnCAwICyAAQoCAgIAQNwIAIABBCGogAykCADcCACAAQSBqIANBGGopAgA3AgAgAEEYaiADQRBqKQIANwIAIABBEGogA0EIaikCADcCAAwHCyAAQoCAgIDQADcCACAAQQhqIAMpAgA3AgAgAEEgaiADQRhqKAIANgIAIABBGGogA0EQaikCADcCACAAQRBqIANBCGopAgA3AgAMBgsgAEEIaiADQTgQiQMaIABCgICAgMAANwIADAULIAJB6AJqIAEQoQMgAEEEaiACQegCakHAABCJAxoMAwsgAkGYAWogA0HAABCJAxogAEEEaiACQZgBakHAABCJAxoMAgsgAkGYAWogAkHYAGpBPBCJAxogAkHoAmogAkGYAWogARDzAyACQdgCaiAFKQIANwMAIAJB4AJqIAgpAgA3AwAgAiACKQLsAjcD0AIgCSgCACEFIAooAgAhBCACKALoAkEBRgRAIABBPGogAkGkA2opAgA3AgAgAEE0aiACQZwDaikCADcCACAAQSxqIAJBlANqKQIANwIAIABBJGogAkGMA2opAgA3AgAgAEEUaiACQeACaikDADcCACAAQQxqIAJB2AJqKQMANwIAIAAgAikD0AI3AgQgAEEgaiAFNgIAIABBHGogBDYCACAAQQE2AgAMAwsgAkHgAWoiBiACQdgCaikDADcDACACQegBaiIIIAJB4AJqKQMANwMAIAJB+AFqIgkgAkGoAmopAwA3AwAgAkGAAmoiCiACQbACaikDADcDACACQZACaiACQcACaikDADcDACACQZgCaiACQcgCaikDADcDACACIAIpA9ACNwPYASACIAIpA6ACNwPwASACIAIpA7gCNwOIAiADIARNBEAgAEEIaiACQfABakEwEIkDGiAAQTxqIAc2AgAgAEE4aiADNgIAIABB3ABqIAU2AgAgAEHYAGogBDYCACAAQoCAgIAgNwIAIABBQGsgAikD2AE3AgAgAEHIAGogBikDADcCACAAQdAAaiAIKQMANwIADAMLIAEoAgQhAyACQRBqIAEoAggiAUEAEIUIIAIoAhQhBCACKAIQIAMgARCJAyEDIABBKGogATYCACAAQSRqIAQ2AgAgAEEgaiADNgIAIABCgYCAgCA3AgAgAEEsaiACKQPwATcCACAAQTRqIAkpAwA3AgAgAEE8aiAKKQMANwIADAILIAJB6AJqIAEQoQMgAEEEaiACQegCakHAABCJAxoLIABBATYCACACKAIYQQRJDQAgAkEYakEEchCnCAsgAkGwA2okAAvZDAIGfwF+IwBB4AFrIgIkACACIAE2AhQCQCABEANBAUcEQCACQRRqIAJBuAFqQYCFwAAQ8gEhASAAQQE2AgAgACABNgIEIAIoAhQiAEEkSQ0BIAAQAAwBCyACQSBqQQU2AgAgAkGkisAANgIcIAIgATYCGCACQQA2AiggAkEANgJYIAJBADYCaCACQQA2AngCQAJAAkACQAJAIAJBGGoQ6gUiCKdBAXFFBEAgAkHAAWohAyACQbgBakEBciEFIAJBuAFqQQRyIQEDQAJAAn8CQAJAAkACQAJAAkACQAJAIAinQQh2Qf8BcQ4HBgUEAwIBAAELAkACQAJAAkAgAigCKCIFBEAgAkGQAWogAkEwaigCADYCACACIAIpAyg3A4gBQQEhASAEQQFHDQEgAigCWCIBRSEDIAFFDQIgAkGgAWogAkHgAGooAgA2AgAgAiACKQNYNwOYASACKAJoIgFFDQMgAkGwAWogAkHwAGooAgA2AgAgAiACKQNoNwOoASACKAJ4IgRFDQQgAikCfCEIIABBNGogAi8BVDsAACACQcABaiACQTBqKAIANgIAIABBNmogAkHWAGotAAA6AAAgAkHMAWogAkHgAGooAgA2AgAgAkHYAWogAkHwAGooAgA2AgAgAiACKQMoNwO4ASACIAIpA1g3AsQBIAIgAikDaDcD0AEgAEEEaiACQbgBakEkEIkDGiAAQTdqIAY2AAAgAEEsaiAINwIAIABBKGogBDYCACAAQQA2AgAgACACKQM4NwA7IABBwwBqIAJBQGspAwA3AAAgAEHLAGogAkHIAGopAwA3AAAgAEHTAGogAkHQAGotAAA6AAAMFAtBASEBQeCFwABBAxDLByEDIABBATYCACAAIAM2AgRBASEDDBELQeOFwABBDRDLByEDIABBATYCACAAIAM2AgRBASEDDA8LQQEhAUHwhcAAQQ4QywchBCAAQQE2AgAgACAENgIEDA4LQf6FwABBEBDLByEEIABBATYCACAAIAQ2AgQMDAtBjobAAEEQEMsHIQQgAEEBNgIAIAAgBDYCBCACQagBahCkCwwLCyACQQhqIAJBGGoQ5QcMBwsgAigCeARAQY6GwABBEBDMByEBIABBATYCACAAIAE2AgRBAQwGCyACQbgBaiACQRhqEJoJIAIoArgBQQFHBEAgAkH4AGoQuwsgAkGAAWogAUEIaigCADYCACACIAEpAgA3A3gMBwsMBAsgAigCaARAQf6FwABBEBDMByEBIABBATYCACAAIAE2AgRBAQwFCyACQbgBaiACQRhqEJoJIAIoArgBQQFHBEAgAkHoAGoQuwsgAkHwAGogAUEIaigCADYCACACIAEpAgA3A2gMBgsMAwsgAigCWARAQfCFwABBDhDMByEBIABBATYCACAAIAE2AgRBAQwECyACQbgBaiACQRhqEJoJIAIoArgBQQFHBEAgAkHYAGoQuwsgAkHgAGogAUEIaigCADYCACACIAEpAgA3A1gMBQsMAgsgBARAQeOFwABBDRDMByEBIABBATYCACAAIAE2AgRBAQwDCyACQbgBaiACQRhqEJkJIAItALgBQQFHBEAgAkHWAGogBUECai0AADoAACACQUBrIANBCGopAAA3AwAgAkHIAGogA0EQaikAADcDACACQdAAaiADQRhqLQAAOgAAIAIgBS8AADsBVCACIAMpAAA3AzggAigCvAEhBkEBIQQMBAsMAQsgAigCKARAQeCFwABBAxDMByEBIABBATYCACAAIAE2AgRBAQwCCyACQbgBaiACQRhqEJoJIAIoArgBQQFHBEAgAkEoahC7CyACQTBqIAFBCGooAgA2AgAgAiABKQIANwMoDAMLCyAAIAIoArwBNgIEIABBATYCAEEBCyEBQQEhAwwGCyACQRhqEOoFIghCAYNQDQALC0EBIQEgAEEBNgIAIAAgCEIgiD4CBEEBIQMMAwsgAUUhASACQZgBahCkCwsgAkGIAWoQpAsLIAVBAEchBwsgAigCeARAIAJB+ABqEKQLCyACKAJoRSABQQFzckUEQCACQegAahCkCwsgAigCWEUgA0EBc3JFBEAgAkHYAGoQpAsLIAIoAihFIAdyRQRAIAJBKGoQpAsLCyACKAIYIgBBI00NACAAEAALIAJB4AFqJAALyw0CDH8DfiMAQaABayIDJAAgASgCBCEIAkAgASgCACIFKAIAIgQgAUEIaigCACIHRwRAIAUoAgghCiAFKAIEIQsCQAJAAkACQAJAAkADQCABEIcDQT5HBEAgARCHAyEGAkACQAJAAkAgBSgCACAERw0AIAUoAgQgC0cNACAGQd8ARg0DIAUoAgggCkcNAQwCCyAGQd8ARg0CCyAGQVBqQQpJDQECQCAGQaV/ag4DAgECAAsgBkEuRg0BCyAGQb9/akEaSQ0AIAZBn39qQRlLDQMLIAEQsQINAQsLIAUoAgAiBiAHRg0BIAUpAgQhDyADIAEQhwMiCTYCOCAJQT5HDQMgARCxAhogBiAESQ0CIAQEQCAEIAdPDQMgBCAIaiwAAEFASA0DCyAGBEAgBiAHTw0DIAYgCGosAABBv39MDQMLIAYgBGsiCUUNBUEAIQEgA0EoaiAJQQAQhQggA0HUAGogAygCLCINNgIAIAMgAygCKCIMNgJQIAwgBCAIaiAJEIkDIQwgA0HIAGogDzcDACADQdgAaiAJNgIAIAMgAjYCXCADIAY2AkQgAyAKNgJAIAMgCzYCPCADIAQ2AjggBSgCRA0EIAVBfzYCRCAFQcgAaiEKIAVB0ABqKAIAIgQEQCAKKAIAIQsgBCECA0ACQAJAAkAgCyAEQQF2IAFqIgRBKGxqIgYoAhggDCAJIAZBIGooAgAiBiAGIAlLGxCWCSIORQRAIAYgCUkNAiAGIAlHDQEgA0HwAGoiAiALIARBKGxqIgFBEGopAgA3AwAgA0HoAGoiBCABQQhqKQIANwMAIAMgASkCADcDYCADQSBqIAdBABCFCCADKAIkIQEgAygCICAIIAcQiQMhCCAFIAUoAkRBAWo2AkQgAEEYaiACKQMANwIAIABBEGogBCkDADcCACAAQQhqIAMpA2A3AgAgAEEoaiAHNgIAIABBJGogATYCACAAQSBqIAg2AgAgAEEsaiADKQM4NwIAIABBNGogA0FAaykDADcCACAAQTxqIANByABqKQMANwIAIABCgYCAgJACNwIAIA1FDQ0gDBCJAQwNCyAOQQBIDQELIAQhAgwBCyAEQQFqIQELIAIgAWshBCACIAFLDQALCyADQYgBaiADQcgAaikDADcDACADQYABaiADQUBrKQMANwMAIAMgAykDODcDeCADQZABaiADQdAAahDXByADIAMoAlw2ApwBIAogASADQfgAahCsByAFIAUoAkRBAWo2AkQgAEEEaiADQThqQSgQiQMaIABBADYCAAwHCyADQfgAaiABEIMFIANBMGogB0EAEIUIIAMoAjQhASADKAIwIAggBxCJAyECIABBKGogBzYCACAAQSRqIAE2AgAgAEEgaiACNgIAIABCgYCAgLACNwIAIABBLGogAykDeDcCACAAQTRqIANBgAFqKQMANwIAIABBPGogA0GIAWopAwA3AgAMBgsgA0GMAWogBUEIaigCACIBNgIAIANBgAFqIgIgATYCACADIAUpAgAiDzcChAEgAyAPNwN4IANBEGogB0EAEIUIIAMoAhQhASADKAIQIAggBxCJAyEEIANByABqIANBiAFqKQMAIg83AwAgA0FAayACKQMAIhA3AwAgAyADKQN4IhE3AzggAEEoaiAHNgIAIABBJGogATYCACAAQSBqIAQ2AgAgAEKBgICAwAI3AgAgAEEsaiARNwIAIABBNGogEDcCACAAQTxqIA83AgAMBQsgCCAHIAQgBkHAsswAEIwBAAsgA0EANgJ4IANBOGpBrLLMACADQfgAakGwsswAEMYHAAtByLrMAEEQIANB+ABqQaS7zABB0KrMABDzBgALIANBGGogB0EAEIUIIAMoAhwhASADKAIYIAggBxCJAyECIABBQGsgCjYCACAAQTxqIAs2AgAgAEE4aiAENgIAIABBNGogCjYCACAAQTBqIAs2AgAgAEEsaiAENgIAIABBKGogBzYCACAAQSRqIAE2AgAgAEEgaiACNgIAIABCgYCAgKACNwIADAELIANBjAFqIAVBCGooAgAiATYCACADQYABaiICIAE2AgAgAyAFKQIAIg83AoQBIAMgDzcDeCADQQhqIARBABCFCCADKAIMIQEgAygCCCAIIAQQiQMhBSADQcgAaiADQYgBaikDACIPNwMAIANBQGsgAikDACIQNwMAIAMgAykDeCIRNwM4IABBKGogBDYCACAAQSRqIAE2AgAgAEEgaiAFNgIAIABCgYCAgMACNwIAIABBLGogETcCACAAQTRqIBA3AgAgAEE8aiAPNwIACyADQaABaiQAC5wNAgV/A34jAEHAAmsiAiQAIAEoAgAiAykCACEHIAJBOGogA0EIaiIFKAIAIgQ2AgAgAkHEAGogBDYCACACQcwAakIANwIAIAIgBzcCPCACIAc3AzBBACEEIAJB2LrMACgCADYCSAJAAkAgARCHA0E6Rg0AAkACQCABEIcDQSlGDQADQAJAAkACQAJAAkACfyABEIcDQS1GBEAgAkHYAGogARCDBSACQfAAaiABEIMFIAJB4AFqIAJBgAFqKQMANwMAIAJB2AFqIAJB+ABqKQMANwMAIAIgAikDcDcD0AEgAkEGOgDoASACQRhqIAJBMGogAkHQAWoQqgMgAigCGEEBRg0CQQEMAQsgAkGYAmogARCDBSACQdABaiABEOcDIAItANABQQFGDQIgAkH4AGogAkGgAmopAwAiBzcDACACQYABaiACQagCaikDACIINwMAIAIgAikDmAIiCTcDcCACLQDRASEEIAJB4AFqIAg3AwAgAkHYAWogBzcDACACIAk3A9ABIAIgBDoA6AEgAkEoaiACQTBqIAJB0AFqEKoDIAIoAihBAUYEQCACKAIsIQMgAkHQAWogARCDBSACKAJQIgQgA00NBCACQZABaiIEIAIoAkggA0EcbGoiA0EIaikCADcDACACQZgBaiIFIANBEGopAgA3AwAgAiADKQIANwOIASABKAIEIQMgAkEgaiABQQhqKAIAIgFBABCFCCACKAIkIQYgAigCICADIAEQiQMhAyACQagCaiACQeABaikDACIHNwMAIAJBoAJqIAJB2AFqKQMAIgg3AwAgAiACKQPQASIJNwOYAiAAQoGAgIDQATcCACAAQQhqIAIpA4gBNwIAIABBEGogBCkDADcCACAAQRhqIAUpAwA3AgAgAEEoaiABNgIAIABBJGogBjYCACAAQSBqIAM2AgAgAEEsaiAJNwIAIABBNGogCDcCACAAQTxqIAc3AgAMCQtBAAshBCABELECDQQgAkHkAWogA0EIaigCACIFNgIAIAJB2AFqIgQgBTYCACACIAMpAgAiBzcC3AEgAiAHNwPQASABKAIEIQMgAkEQaiABQQhqKAIAIgFBABCFCCACKAIUIQUgAigCECADIAEQiQMhAyACQZgBaiACQeABaiIGKQMAIgc3AwAgAkGQAWogBCkDACIINwMAIAIgAikD0AEiCTcDiAEgAEKBgICA8AE3AgAgAEEIaiACKQLQATcCACAAQRBqIAQpAgA3AgAgAEEYaiAGKQIANwIAIABBKGogATYCACAAQSRqIAU2AgAgAEEgaiADNgIAIABBLGogCTcCACAAQTRqIAg3AgAgAEE8aiAHNwIADAcLIAIoAhwhAyAC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aiAEQYgHahD7BCAEQYgEaiAEQbAIahDzCSAEQbAIaiAEQagCahD7BCAEQegFaiAEQbAIahDzCSAEQRBqIARByANqEM0LIAQpAxAhDiAEQQhqIARB2ANqEM0LIARBrAdqQSA2AgAgBEGkB2pBIDYCACAEIA43A5AHIARBIDYCjAcgBCAEKQMINwOYByAEIARBiARqNgKoByAEIARB6ANqNgKgByAEIARB6AVqNgKIByAEQcgEaiAEQYgHakEFEMcFIAQgBEHIBGoQzQsgBEGoBGogBCgCACAEKAIEEPkJIARByARqEKQLIAEgA0EYaikAADcDACAFIANBEGopAAA3AwAgBiADQQhqKQAANwMAIAQgAykAADcDsAggBEGIB2ogBEGwCGoQ9AEgBCkDiAdCAVINAiAEQcgEaiAEQZAHaiIBQaABEIkDGiAEQegJaiAHQRhqKQAANwMAIARB4AlqIgMgB0EQaikAADcDACAEQdgJaiIFIAdBCGopAAA3AwAgBCAHKQAANwPQCSAEQYgHaiAEQdAJahD0ASAEKQOIB0IBUg0DIARBsAhqIAFBoAEQiQMaIARBiAdqIARByARqQaABEIkDGiAEQegFaiAEQbAIaiAEQYgHahDaDCAEQYgHaiAEQegFakGgARCJAxogBEHoCWogBEHABGopAwA3AwAgAyAEQbgEaikDADcDACAFIARBsARqKQMANwMAIAQgBCkDqAQ3A9AJIARBsAhqIARBiAdqIARB0AlqENwMIARBiAdqIARBsAhqEPsEIABBGGogBEGIB2oQ8wkgAEEIaiAEQdADaigCADYCACAAIAQpA8gDNwIAIAAgBCkD2AM3AgwgAEEUaiAEQeADaigCADYCACAAIAQpA+gDNwA4IABBQGsgBEHwA2opAwA3AAAgAEHIAGogBEH4A2opAwA3AAAgAEHQAGogBEGABGopAwA3AAAgACAEKQCIBDcAWCAAQeAAaiAEQZAEaikAADcAACAAQegAaiAEQZgEaikAADcAACAAQfAAaiAEQaAEaikAADcAACAEQdgAahCkCyAEQcgAahCkCyACEKQLIAoQpAsgBEGQC2okAA8LQezfygBBGUGI4MoAEOwKAAtBqebKAEErQZjgygAQ0QkAC0Gp5soAQStBqODKABDRCQALQanmygBBK0G44MoAENEJAAubDQIIfwF+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gICAgCA3AgAgAEEIaiATNwIAIABBEGogATYCACAAQRRqIAw2AgALIARBwAFqJAALqgsCA38YfiMAQbADayICJAAgAkH4AWpBAEGQARCRBRogAkH4AWohAwNAIANCADcDCCADIAEgBGopAwA3AwAgA0EQaiEDIARBCGoiBEEoRw0ACyACQegBaiACKQP4ASIGQpv80ZKxtMcCfkL/////////B4MiBULtp9fnpeOYARDWBiACQdgBaiAFQoHLtc73xfoGENYGIAJBuAFqIAIpA9gBIgcgAikDiAJ8IgkgBiACKQPoASIIfCIGQjSIIAYgCFStIAJB8AFqKQMAIAJBgAJqKQMAfHwiDEIMhoR8IghCm/zRkrG0xwJ+Qv////////8HgyIGQu2n1+el45gBENYGIAJByAFqIAVC+b3TABDWBiACQagBaiAGQoHLtc73xfoGENYGIAJBiAFqIAIpA8gBIg0gAikDmAJ8IgogAikDqAF8IgsgAikDuAEiDiAIfCIPQjSIIA8gDlStIAJBwAFqKQMAIAggCVStIAkgB1StIAJB4AFqKQMAIAJBkAJqKQMAfHwgDEI0iHx8fHwiDkIMhoR8IghCm/zRkrG0xwJ+Qv////////8HgyIJQu2n1+el45gBENYGIAJBmAFqIAZC+b3TABDWBiACQfgAaiAJQoHLtc73xfoGENYGIAJB2ABqIAIpA5gBIg8gAikDqAJ8IgcgAikDeHwiDCACKQOIASIQIAh8IhFCNIggESAQVK0gAkGQAWopAwAgCCALVK0gCyAKVK0gAkGwAWopAwAgCiANVK0gAkHQAWopAwAgAkGgAmopAwB8fHx8IA5CNIh8fHx8IhBCDIaEfCIKQpv80ZKxtMcCfkL/////////B4MiCELtp9fnpeOYARDWBiACQegAaiAJQvm90wAQ1gYgAkHIAGogCEKBy7XO98X6BhDWBiACQShqIAVCLIYiESACKQO4AnwiCyACKQNofCINIAIpA0h8Ig4gAikDWCISIAp8IhNCNIggEyASVK0gAkHgAGopAwAgCiAMVK0gDCAHVK0gAkGAAWopAwAgByAPVK0gAkGgAWopAwAgAkGwAmopAwB8fHx8IBBCNIh8fHx8IhJCDIaEfCIHQpv80ZKxtMcCfkL/////////B4MiCkLtp9fnpeOYARDWBiACQThqIAhC+b3TABDWBiACQRhqIApCgcu1zvfF+gYQ1gYgAkEIaiAKQvm90wAQ1gYgAkGAA2opAwAhEyACQfACaikDACEUIAJB4AJqKQMAIRUgAkHQAmopAwAhFiACKQP4AiEXIAIpA+gCIRggAikD2AIhGSACIAZCLIYiGiACKQPIAnwiDCACKQM4fCIPIAIpAxh8IhAgAikDKCIbIAd8IhxCNIggHCAbVK0gAkEwaikDACAHIA5UrSAOIA1UrSACQdAAaikDACANIAtUrSACQfAAaikDACALIBFUrSACQcACaikDACAFQhSIfHx8fHx8IBJCNIh8fHx8Ig1CDIaEfCIFQv////////8HgzcDiAMgAiAZIAlCLIYiDnwiCyACKQMIfCIHIAUgEFStIBAgD1StIAJBIGopAwAgDyAMVK0gAkFAaykDACAMIBpUrSAWIAZCFIh8fHx8fHwgDUI0iHx8IgxCDIYgBUI0iIR8IgVC/////////weDNwOQAyACIBggCEIshiINfCIGIAUgB1StIAcgC1StIAJBEGopAwAgCyAOVK0gFSAJQhSIfHx8fCAMQjSIfHwiC0IMhiAFQjSIhHwiBUL/////////B4M3A5gDIAIgFyAKQiyGIgd8IgkgBSAGVK0gBiANVK0gFCAIQhSIfHwgC0I0iHx8IgZCDIYgBUI0iIR8IgVC/////////weDNwOgAyACIAUgCVStIAkgB1StIBMgCkIUiHx8IAZCNIh8fEIMhiAFQjSIhDcDqAMgACACQYgDakGQwuAAEIAGIAJBsANqJAAL8goCBH8DfiMAQZABayIDJAACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAgAiBEEUai0AACIGQQJGIAZBAXFyRQRAIANB6ABqIAEQ5QYgAy0AaEEGRg0CIANBQGsgA0HoAGpBJBCJAxogA0EQaiADQUBrEIQHIANB6ABqIAEQ5QYgAy0AaEEGRg0DIANBQGsgA0HoAGpBJBCJAxogA0EgaiADQUBrEIQHIANB6ABqIAEQ5QYgAy0AaEEGRg0EIANBQGsgA0HoAGpBJBCJAxogA0EwaiADQUBrEIQHIAQoABAiBEH/AXFBAkYNCSAEQQFxDQEMCQsgA0HoAGogARDlBiADLQBoQQZGDQQgA0FAayADQegAakEkEIkDGiADQRBqIANBQGsQgwcgA0HoAGogARDlBiADLQBoQQZGDQUgA0FAayADQegAakEkEIkDGiADQSBqIANBQGsQgwcgA0HoAGogARDlBiADLQBoQQZGDQYgA0FAayADQegAakEkEIkDGiADQTBqIANBQGsQgwcgBCgAECIEQf8BcUECRiAEQQFxRXINBwJ/IANBEGoQ1gVFBEAgA0EgahDWBUUNCSADQfgAaiIEIAIoAhgQjQciAkEQaikCADcDACADQfAAaiIGIAJBCGopAgA3AwAgAyACKQIANwNoIAEoAgQhBSADQQhqIAFBCGooAgAiAUEAEIUIIAMoAgwhAiADKAIIIAUgARCJAwwBCyADQfgAaiIEIAIoAhwQjQciAkEQaikCADcDACADQfAAaiIGIAJBCGopAgA3AwAgAyACKQIANwNoIAEoAgQhBSADIAFBCGooAgAiAUEAEIUIIAMoAgQhAiADKAIAIAUgARCJAwshBSADQdAAaiAEKQMAIgc3AwAgA0HIAGogBikDACIINwMAIAMgAykDaCIJNwNAIABBJ2ogAy0AazoAACAAIAMvAGk7ACUgACABNgIIIAAgAjYCBCAAIAU2AgAgACAJNwIMIABBFGogCDcCACAAQRxqIAc3AgAgAEEFOgAkIAMoAjQiAEUgAEEDdEVyRQRAIAMoAjAQiQELIAMoAiQiAEUgAEEDdEVyRQRAIAMoAiAQiQELIAMoAhQiAEUgAEEDdEVyDQogAygCEBCJAQwKCyADQRBqEKUKIANBIGoQpQoMBwtBzPPdAEErQYDu3QAQ0QkAC0HM890AQStBkO7dABDRCQALQczz3QBBK0Gg7t0AENEJAAtBzPPdAEErQdDt3QAQ0QkAC0HM890AQStB4O3dABDRCQALQczz3QBBK0Hw7d0AENEJAAsCQAJAAkACQCACLQAgQQFrDgIBAgALIANBIGogA0EQahCOAgwCCyADQSBqIANBEGoQowEMAQsgA0EgaiADQRBqEMwFCyADQTBqIAMoAiAiAiACIAMoAihBA3RqENAIIANBMGoQywIgA0H0AGogA0E4aigCADYCACADIAMpAzA3AmwgA0EBOgBoIAEgA0HoAGoQlQYgAygCJCIBRSABQQN0RXJFBEAgAygCIBCJAQsgAygCFCIBRSABQQN0RXINASADKAIQEIkBDAELAkACQAJAAkAgAi0AIEEBaw4CAQIA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aigCADYCACADQewAaiAGKAIANgIAIAMgAykDIDcDWCADIAMpAzA3AmQgASgCBCEEIANBCGogAUEIaigCACIBQQAQhQggAygCDCEGIAMoAgggBCABEIkDIQQgA0HQAGogA0HoAGoiBykDACIKNwMAIANByABqIAIpAwAiCzcDACADIAMpA1giDDcDQCAAQoGAgICAATcCACAAQQhqIAMpAlg3AgAgAEEQaiACKQIANwIAIABBGGogBykCADcCACAAQShqIAE2AgAgAEEkaiAGNgIAIABBIGogBDYCACAAQSxqIAw3AgAgAEE0aiALNwIAIABBPGogCjcCAAwBCyADQeAAaiIBIANBKGooAgA2AgAgA0HsAGogA0E4aigCADYCACAAIAMpAyA3AgQgAEEANgIAIABBIWogAjoAACAAQSBqQQM6AAAgAEEcaiAENgIAIAMgAykDMDcCZCAAQQxqIAEpAwA3AgAgAEEUaiADQegAaikDADcCAAsgBSAFKAJUQQFqNgJUIANB8ABqJAALxw0BAX8jAEEwayICJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAA4fAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHwALQaiczABBKEHQoMwAENEJAAsgAkEsakEBNgIAIAJCAjcCHCACQYiozAA2AhggAkEXNgIUIAJBmKjMADYCECACIAJBEGo2AiggASACQRhqELUHDB4LIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJBzKfMADYCGCABIAJBGGoQtQcMHQsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkGUp8wANgIYIAEgAkEYahC1BwwcCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQdCmzAA2AhggASACQRhqELUHDBsLIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJByKbMADYCGCABIAJBGGoQtQcMGgsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkHApswANgIYIAEgAkEYahC1BwwZCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQaCmzAA2AhggASACQRhqELUHDBgLIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJBgKbMADYCGCABIAJBGGoQtQcMFwsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkHcpcwANgIYIAEgAkEYahC1BwwWCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQaClzAA2AhggASACQRhqELUHDBULIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJBmKXMADYCGCABIAJBGGoQtQcMFAsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkHQpMwANgIYIAEgAkEYahC1BwwTCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQcikzAA2AhggASACQRhqELUHDBILIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJBwKTMADYCGCABIAJBGGoQtQcMEQsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkG4pMwANgIYIAEgAkEYahC1BwwQCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQZCkzAA2AhggASACQRhqELUHDA8LIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJB5KPMADYCGCABIAJBGGoQtQcMDgsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkHco8wANgIYIAEgAkEYahC1BwwNCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQdSjzAA2AhggASACQRhqELUHDAwLIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJBzKPMADYCGCABIAJBGGoQtQcMCwsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkGko8wANgIYIAEgAkEYahC1BwwKCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQZyjzAA2AhggASACQRhqELUHDAkLIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJBlKPMADYCGCABIAJBGGoQtQcMCAsgAiAAKAIENgIMIAJBLGpBATYCACACQgI3AhwgAkGEo8wANgIYIAJBFzYCFCACIAJBEGo2AiggAiACQQxqNgIQIAEgAkEYahC1BwwHCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQcCizAA2AhggASACQRhqELUHDAYLIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJB/KHMADYCGCABIAJBGGoQtQcMBQsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkHEocwANgIYIAEgAkEYahC1BwwECyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQbyhzAA2AhggASACQRhqELUHDAMLIAJBLGpBADYCACACQaiczAA2AiggAkIBNwIcIAJBtKHMADYCGCABIAJBGGoQtQcMAgsgAkEsakEANgIAIAJBqJzMADYCKCACQgE3AhwgAkGsocwANgIYIAEgAkEYahC1BwwBCyACQSxqQQA2AgAgAkGonMwANgIoIAJCATcCHCACQaShzAA2AhggASACQRhqELUHCyACQTBqJAALugsBDH8jAEGwAWsiASQAIAFBKGpBCBDeBSABQgA3AzAgASABKQMoNwM4IAEgACgCAC0ABwR/IAFByABqQgA3AwBBAQVBAAs2AkACQAJAAkAgAEH0BGooAgAiAiAAKALUBCIHSwRAIABB1ARqIQsgAUHYAGpBADYCACABIAc2AlAgASAAQewEaigCACAHQSRsakEcaigCAEEARzYCVCABQQA7AXAgAUEgaiABQfAAahDRCiABQUBrQQRyIQogAS0AIEEBcQRAIAEtACEhAwNAAkACQCAAKAL0BCIEIAAoAtQEIgJLBEAgACgC7AQgAkEkbGogAxDyBSICIAdGDQIgAUEYaiABQdAAaiALIAIQxQYgASgCHCEDIAEoAhghBCABIAI2AoABAkAgASgCQEEBRw0AIAEoAkgiBUUNACABQZABaiABKAJEIAUgAUGAAWoQ+QQgASgCkAFBAUYNACABKAKYAQ0CCyABIAM2ApgBIAEgBDYClAEgASACNgKQASABQTBqIAFBkAFqEPYGIAEoAkBBAUcNASAKIAIQ3gcMAQsgAiAEQcDGywAQsAcACyAAKAL0BCIDIAJLBEAgACgC7AQgAkEkbGoiAkEcaigCAEUNASACQQE2AhAMAQsgAiADQcDGywAQsAcACyABQRBqIAFB8ABqENEKIAEtABEhAyABLQAQQQFxDQALCyABKAIwIgAgASgCNCIDRg0BIAEgASgCPEF/aiAAQQFqcSICNgIwIAEo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IAMoAtgBIQcgAygC0AEhBgsgBiAHQYQBbGogA0HgAWpBhAEQiQMaIAMgB0EBajYC2AEgA0EYaiADQbgBakEkEIkDGiADQoCAgICAATcDEAwCCyADQeABaiAEQShqIgRByAAQiQMaIANB+AJqIgogBEEQaikCADcDACADQfACaiILIARBCGopAgA3AwAgAyAEKQIANwPoAiABKAIEIQQgA0EIaiABQQhqKAIAIgFBABCFCCADKAIMIQwgAygCCCAEIAEQiQMhBCAAQShqIAE2AgAgAEEkaiAMNgIAIABBIGogBDYCACAAQoGAgIDQAjcCACAAQSxqIAMpA+gCNwIAIABBNGogCykDADcCACAAQTxqIAopAwA3AgAgA0HgAWoQ0wcgCQ0FIAcEQCAHQYQBbCEAIAYhAQNAIAEQhgMgAUGEAWohASAAQfx+aiIADQALCyAIRSAIQYQBbEVyDQUgBhCJAQwFCyADQeABaiACQSQQiQMaIANBEGpBBHIgA0HgAWoQgQUgA0EANgIQCyAFKAIwIgINASADQQI6AOABDAILQci6zABBECADQRBqQaS7zABBuK3MABDzBgALIAUgAkF/aiICNgIwIANB4AFqIAUoAiggAkHwAGxqQfAAEIkDGgJAAkAgAy0A4AEiBEF/ag4CAQIACyADQegCaiADQYgCakHIABCJAxogA0HIAWoiAiADQZgCaikDADcDACADQcABaiIGIANBkAJqKQMANwMAIAMgAykDiAI3A7gBIAEoAgQhByADIAFBCGooAgAiAUEAEIUIIAMoAgQhCCADKAIAIAcgARCJAyEHIANBqAFqIAIpAwAiDTcDACADQaABaiAGKQMAIg43AwAgAyADKQO4ASIPNwOYASAAQoGAgIDQAjcCACAAQQhqIAMpArgBNwIAIABBEGogBikCADcCACAAQRhqIAIpAgA3AgAgAEEoaiABNgIAIABBJGogCDYCACAAQSBqIAc2AgAgAEEsaiAPNwIAIABBNGogDjcCACAAQTxqIA03AgAgA0HoAmoQ0wcgA0EQakEEchCgAyAFIAUoAiRBAWo2AiQCQAJAIARBA3EiAEEDRg0AIABBAWsOAgAFAQsgA0HgAWoQ0QYMBAsgA0H8AWooAgAhAiADQYQCaigCACIABEAgAEGEAWwhASACIQADQCAAEIYDIABBhAFqIQAg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1gYgA0HgAGogCSAEENYGIANB4AJqIAogCBDWBiADQSBqIAYgCxDWBiADQbABaiAHIA4Q1gYgA0HwAWogBSAMENYGIANB8ABqIAUgBBDWBiADQbACaiAJIAgQ1gYgA0HwAmogCiALENYGIANBMGogBiANENYGIANBwAFqIAcgDBDWBiADQYABaiAHIAQQ1gYgA0GAAmogBSAIENYGIANBwAJqIAkgCxDWBiADQYADaiAKIA0Q1gYgA0FAayAGIA8Q1gYgACADKQOwASIPIAMpAyB8IgQgAykD8AF8IgYgAykDYHwiByADKQPgAnwiCCADKQOgASIRIAMpAxB8IgUgAykD4AF8IgkgAykDoAJ8IgogAykDUHwiCyADKQOQASISIAMpAwB8IgwgAykD0AF8Ig0gAykDkAJ8Ig4gAykD0AJ8IhBCM4ggECAOVK0gA0HYAmopAwAgDiANVK0gA0GYAmopAwAgDSAMVK0gA0HYAWopAwAgDCASVK0gA0GYAWopAwAgA0EIaikDAHx8fHx8fHx8Qg2GhHwiDEIziCAMIAtUrSALIApUrSADQdgAaikDACAKIAlUrSADQagCaikDACAJIAVUrSADQegBaikDACAFIBFUrSADQagBaikDACADQRhqKQMAfHx8fHx8fHx8Qg2GhHwiBUL/////////A4M3AxAgACADKQPAASIOIAMpAzB8IgkgAykDcHwiCiADKQOwAnwiCyADKQPwAnwiDSAFIAhUrSAIIAdUrSADQegCaikDACAHIAZUrSADQegAaikDACAGIARUrSADQfgBaikDACAEIA9UrSADQbgBaikDACADQShqKQMAfHx8fHx8fHx8Qg2GIAVCM4iEfCIEQv////////8DgzcDGCAAIAMpA4ABIg8gAykDQHwiBiADKQOAAnwiByADKQPAAnwiCCADKQOAA3wiBSAEIA1UrSANIAtUrSADQfgCaikDACALIApUrSADQbgCaikDACAKIAlUrSADQfgAaikDACAJIA5UrSADQcgBaikDACADQThqKQMAfHx8fHx8fHx8Qg2GIARCM4iEfCIEQv////////8DgzcDICAAIAQgBVStIAUgCFStIANBiANqKQMAIAggB1StIANByAJqKQMAIAcgBlStIANBiAJqKQMAIAYgD1StIANBiAFqKQMAIANByABqKQMAfHx8fHx8fHx8Qg2GIARCM4iEQhN+IBBC/////////wODfCIEQv////////8DgzcDACAAIAxC/////////wODIARCM4h8NwMIIANBkANqJAALxgoCDH8BfiMAQYABayIDJAAgAyABEIcDIgU2AhgCQAJAAkAgBUEoRgRAIANBMGogARBOIANBIGoiByADQUBrKQMANwMAIANBKGoiBCADQcgAaikDADcDACADQQhqIgYgA0HcAGopAgA3AwAgA0EQaiIIIANB5ABqKAIANgIAIAMgA0E4aikDADcDGCADIANB1ABqKQIANwMAIANB8ABqKAIAIQkgA0HsAGooAgAhCiADQegAaigCACELIANB0ABqKAIAIQwgAygCNCEFIAMoAjBBAUYNAgJAAkAgBUUEQCAJRQ0CIAlBHGwhCCALQRhqIQRBACEFA0BBASEHAkACQCAELQAAQXtqDgIEAQALIAUhBwsgBEEcaiEEIAchBSAIQWRqIggNAAsMAgsgA0H0AGooAgAhDQJ/IAEoAgAiBi0AZiIOIAxBAkcNABogDiANRQ0AGiANQRxsIQggCkEYaiEEQQAhBQJAA0BBASEHAkACQCAELQAAQXtqDgIDAQALIAUhBwsgBEEcaiEEIAchBSAIQWRqIggNAAsgDgwBCyAFQX9zQQFxCyEFIAYoAiQNAyADQfgAaikDACEPIAZBfzYCJCADQTJqIAJBJBCJAxogBkEwaigCACIEIAZBLGooAgBGBEAgBkEoaiAEEI0JIAYoAjAhBAsgBigCKCAEQfAAbGoiAiAOOgABIAJBADoAACACQQJqIANBMGpBJhCJAxogAiAMNgJAIAIgDzcCaCACIA02AmQgAiAJNgJgIAIgCjYCXCACIAs2AlggAkE4aiADQShqKQMANwIAIAJBMGogA0EgaikDADcCACACIAMpAxg3AiggAiADKQMANwJEIAJBzABqIANBCGopAwA3AgAgAkHUAGogA0EQaigCADYCACAGIAYoAjBBAWo2AjAgBiAGKAIkQQFqNgIkIAEoAgAgBToAZiADQThqIgIgASgCACIBQQhqKAIAIgU2AgAgA0HEAGogBTYCACAAQSBqQgA3AgAgAEEcakHYuswAKAIANgIAIABBADYCACAAIAEpAgAiDzcCBCADIA83AjwgAEEMaiACKQMANwIAIABBFGogA0FAaykD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IgJJDQALCyAGQTBqJAAPCyACQX9qIAFBpI3MABCxBwAL9QoCCn8CfiMAQZAKayIDJAAgA0G4BGogAUHwAWoQ8wkgA0GAAWpBIEEAEIUIIAMoAoQBIQQgAygCgAEiASADKQC4BDcAACABQQhqIANBwARqIgYpAAA3AAAgAUEQaiADQcgEaiIFKQAANwAAIAFBGGogA0HQBGoiBykAADcAACADQSA2ApABIAMgBDYCjAEgAyABNgKIASADQfgAaiACEM0LIAMpA3ghDSADQfAAaiADQYgBahDNCyADIA03A7gEIAMgAykDcDcDwAQgA0GgB2ogA0G4BGpBAhDHBSADQegAaiADQaAHahDNCyADQZgBaiADKAJoIAMoAmwQ+QkgA0GgB2oQpAsgA0HgAGogAkEMaiIIEM0LIAMpA2AhDSADQdgAaiACQRhqIgQQzQsgAykDWCEOIANBuARqIANBmAFqEPMJIANBvAdqQSA2AgAgAyAONwOwByADIA03A6gHIANBIDYCpAcgAyACQTBqIgE2AqAHIAMgA0G4BGo2ArgHIANBuAFqIANBoAdqQQQQxwUgA0IANwLMASADQZDzygAoAgAiCTYCyAEgA0HQAGogA0G4AWoQzQsgA0G4BGogAygCUCADKAJUEPwHIANByAFqIANBuARqIANB+ARqEOQIIANByABqIANByAFqEM0LIAMoAkwhCiADKAJIIQsgA0FAayACQSRqIgwQzQsCQCALIAogAygCQCADKAJEEJgLBEAgA0E4aiACEM0LIAMpAzghDSADQTBqIANBiAFqEM0LIAMgDTcDuAQgAyADKQMwNwPABCADQaAHaiADQbgEakECEMcFIANBKGogA0GgB2oQzQsgA0HYAWogAygCKCADKAIsEPcFIANBoAdqEKQLIAcgA0HwAWopAwA3AwAgBSADQegBaikDADcDACAGIANB4AFqKQMANwMAIAMgAykD2AE3A7gEIANB8AhqQZDdygBBoAEQiQMaIANB+AFqIANB8AhqIANBuARqENwMIANBuAdqIAFBGGopAAA3AwAgA0GwB2ogAUEQaikAADcDACADQagHaiABQQhqKQAANwMAIAMgASkAADcDoAcgA0G4BGogA0GgB2oQ9AEgAykDuARCAVEEQCADQZgDaiADQcAEaiIBQaABEIkDGiADQaAHaiADQZgD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AAsLIAZBQGskAA8LIAJBf2ogAUHI+cEAELEHAAuuCgIYfwR+IwBBwAFrIgMkACADIAI2AiQgAyABNgIgIANBGGogA0EgakEYEOYLIANBlAFqQQE2AgAgA0IBNwKEASADQfiHywA2AoABIAMgAykDGDcDSCADIANByABqNgKQASADQfAAaiADQYABahD/ASADQRBqIANB8ABqEM0LIAMoAhAhAiADKAIUIQEgA0HIAGoiBUEENgIYIAVBBDYCCCAFIAI2AgAgBSABIAJqNgIEIANCADcCPCADQdyJywAoAgAiATYCOCADQYABaiADQThqQfSJywAQ2AoCQCADQcgAaiADQYABahCAAUUEQCADQQhqIANBOGoQzQsgA0IANwIsIAMgATYCKCADQYABaiADKAIIIhAgAygCDCITQYGIywAQX0EAIANBkAFqKAIAIgxrIRQgA0G8AWooAgAiCkF/aiERIAogA0GYAWooAgAiFWshFiADQYgBaikDACIbQv////8PgyEcIBtCgICAgIBggyEdIBtCgICAgICAwP8AgyEeIBtCIIinIQggA0G0AWooAgAhBCADQaQBaigCACENIANBnAFqKAIAIQcgAygCuAEhEiADKAKwASELIAMoAoQBIQYgAygCgAFBAUchFwNAAkACfyAXRQRAIAcgEWoiASAETw0CIAitQv8Bg0IghiAdhCAchCEbIA0hBSAHIQIDQAJAAkAgGyABIAtqMQAAiEIBg1BFBEAgDCAMIAUgDCAFSxsgDUF/RiIOGyIHIAogByAKSxshGCACIAtqIRkgByEBAkADQCABIBhGBEAgA0EAIAUgDhsgDBDmCyADKAIEIQEgAygCACEHAkACQANAIAcgAU8EQCAFQQAgDhshDSACIApqIgcMDAsgAUF/aiIBIApPDQEgASACaiIJIARPDQIgASASai0AACAJIAtqLQAARg0ACyACIBVqIQIgFiEBIA5FDQYMBwsgASAKQdyMywAQsAcACyAJIARB7IzLABCwBwALIAEgAmogBE8NASABIBlqIRogASASaiABQQFqIQEtAAAgGi0AAEYNAAsgAiAUaiABaiECIA4NA0EAIQEMAgsgBCACIAdqIgAgBCAASxsgBEHMjMsAELAHAAsgAiAKaiECQQAhASANQX9GDQELIAEhBQsgAiARaiIBIARJDQALDAILIB5CAFINAQJAA0ACQCAGRQ0AIAQgBk0EQCAEIAZGDQEMCAsgBiALaiwAAEG/f0wNBwsgBCAGRwRAAn8gBiALaiIJLAAAIgJBf0oEQCACQf8BcQwBCyAJLQABQT9xIgEgAkEfcSIFQQZ0ciACQf8BcSICQd8BTQ0AGiAJLQACQT9xIAFBBnRyIgEgBUEMdHIgAkHwAUkNABogBUESdEGAgPAAcSAJLQADQT9xIAFBBnRycgshASAIQf8BcQ0CIAFBgIDEAEYNBEEBIQgCf0EBIAFBgAFJDQAaQQIgAUGAEEkNABpBA0EEIAFBgIAESRsLIAZqIQYMAQsLIAhB/wFxRQ0CIAhBAXMhCCAEIgIhBiACDAELIAhBAXMhCCAGIgILIANBKGogDyAQaiACIA9rEOcLIANBKGpBgIjLAEEBEOcLIQ8MAQsLIANBKGogDyAQaiATIA9rEOcLIANBOGoQpAsgA0HwAGoQpAsgA0GIAWogA0EwaigCADYCACADIAMpAyg3A4ABIAAgA0GAAWoQRiADQcABaiQAQgQPC0GMissAQTcgA0EoakGgi8sAQZCLywAQ8wYACyALIAQgBiAEQbyMywAQjAEAC/AJAgh/AX4jAEGwAWsiAiQAIAIgATYCFAJAIAEQA0EBRwRAIAJBFGogAkGIAWpBkIXAABDyASEBIABBAToAACAAQQRqIAE2AgAgAigCFCIAQSRJDQEgABAADAELIAJBIGpBAzYCACACQdyKwAA2AhwgAiABNgIYAkACQCACQRhqEOwFIgqnQQFxRQRAIAJBkAFqIQEgAkGIAWpBAXIhAwNAAkACQAJAAkACQAJAAkAgCqdBCHZB/wFxDgUEAwIBAAELIARBAUYEQCAFQQFHBH9BoYbAAAUgBkEBRg0GQaSGwAALQQMQywchASAAQQE6AAAgAEEEaiABNgIADAkLQZ6GwABBAxDLByEBIABBAToAACAAQQRqIAE2AgAMCAsgAkEIaiACQRhqEOUHDAQLIAYEQEGkhsAAQQMQzAchASAAQQE6AAAgAEEEaiABNgIADAcLIAJBiAFqIAJBGGoQmQkgAi0AiAFBAUcEQCACQYYBaiADQQJqLQAAOgAAIAJB8ABqIAFBCGopAAA3AwAgAkH4AGogAUEQaikAADcDACACQYABaiABQRhqLQAAOgAAIAIgAy8AADsBhAEgAiABKQAANwNoIAIoAowBIQdBASEGDAQLIABBAToAACAAQQRqIAIoAowBNgIADAYLIAUEQEGhhsAAQQMQzAchASAAQQE6AAAgAEEEaiABNgIADAYLIAJBiAFqIAJBGGoQmQkgAi0AiAFBAUcEQCACQeYAaiADQQJqLQAAOgAAIAJB0ABqIAFBCGopAAA3AwAgAkHYAGogAUEQaikAADcDACACQeAAaiABQRhqLQAAOgAAIAIgAy8AADsBZCACIAEpAAA3A0ggAigCjAEhCEEBIQUMAwsgAEEBOgAAIABBBGogAigCjAE2AgAMBQsgBARAQZ6GwABBAxDMByEBIABBAToAACAAQQRqIAE2AgAMBQsgAkGIAWogAkEYahCZCSACLQCIAUEBRwRAIAJBxgBqIANBAmotAAA6AAAgAkEwaiABQQhqKQAANwMAIAJBOGogAUEQaikAADcDACACQUBrIAFBGGotAAA6AAAgAiADLwAAOwFEIAIgASkAADcDKCACKAKMASEJQQEhBAwCCyAAQQE6AAAgAEEEaiACKAKMATYCAAwECyAAIAIvAUQ7AAEgAEEIaiACKQMoNwAAIABBIWogAi8BZDsAACAAQShqIAIpA0g3AAAgAEEDaiACQcYAai0AADoAACAAQRBqIAJBMGopAwA3AAAgAEEYaiACQThqKQMANwAAIABBIGogAkFAay0AADoAACAAQSNqIAJB5gBqLQAAOgAAIABBQGsgAkHgAGotAAA6AAAgAEE4aiACQdgAaikDADcAACAAQTBqIAJB0ABqKQMANwAAIABBBGogCTYAACAAQSRqIAg2AAAgAEHEAGogBzYAACAAQQA6AAAgAEHDAGogAkGGAWotAAA6AAAgAEHBAGogAi8BhAE7AAAgAEHIAGogAikDaDcAACAAQdAAaiACQfAAaikDADcAACAAQdgAaiACQfgAaikDADcAACAAQeAAaiACQYABai0AADoAACACKAIYIgFBI0sNBAwFCyACQRhqEOwFIgpCAYNQDQALCyAAQQE6AAAgAEEEaiAKQiCIPgIACyACKAIYIgFBJEkNAQsgARAACyACQbABaiQAC/sKAQV/IwBBwAFrIgIkACACQRBqIAAQgwIgACgCACEGAkAgACgCBCIEQQhPBEAgAkEIakEKIAYgBBCRAyACKAIIIQUMAQsgBARAQQEhBQNAIAMgBmotAABBCkYNAiAEIANBAWoiA0cNAAsLQQAhBQsCfwJAAkACQAJAAkACQCAFQQFHBEAgAkGsAWoiA0EANgIAIAJBqNPdADYCqAEgAkIBNwKcASACQaDT3QA2ApgBIAEgAkGYAWoQtQdFDQEMBgsgAkIANwI8IAJBsNfdACgCADYCOCACQThqQf4AQc8AEP8CIAJBrAFqIgNBADYCACACQajT3QA2AqgBIAJCATcCnAEgAkGg090ANgKYASABIAJBmAFqELUHDQQgA0EBNgIAIAJCAjcCnAEgAkGs090ANgKYASACQdkCNgJ8IAIgAkH4AGo2AqgBIAIgAkE4ajYCeCABIAJBmAFqELUHDQQgAkHIAGogAkEQahCDASACQawBaiIDQQE2AgAgAkIBNwKcASACQbzT3QA2ApgBIAJB2QI2AnwgAiACQfgAajYCqAEgAiACQcgAajYCeCABIAJBmAFqELUHDQMgA0EBNgIAIAJCAjcCnAEgAkGs090ANgKYASACQdkCNgJ8IAIgAkH4AGo2AqgBIAIgAkE4ajYCeCABIAJBmAFqELUHDQMgAkEwaigCACIDRQ0BIAJCADcCXCACQajX3QAoAgA2AlggA0EYbCEFIAIoAihBFGohAwNAIAJBBDYCjAEgAkIFNwJ8IAJB6NPdADYCeCADKAIAIQQgAkEXNgK0ASACQRc2AqwBIAIgA0F8ajYCqAEgAkEXNgKkASACIANBdGo2AqABIAJBFzYCnAEgAiADQXBqNgKYASACIARBf2o2ApQBIAIgAkGYAWo2AogBIAIgAkGUAWo2ArABIAJB6ABqIAJB+ABqEP8BIAIoAmAiBCACKAJcRgRAIAJB2ABqIAQQkAkgAigCYCEECyACKAJYIARBDGxqIgQgAikDaDcCACAEQQhqIAJB8ABqKAIANgIAIAIgAigCYEEBaiIENgJgIANBGGohAyAFQWhqIgUNAAsgAkH4AGogAigCWCAEEJIBIAJBrAFqQQE2AgAgAkHZAjYCbCACQgI3ApwBIAJBrNPdADYCmAEgAiACQfgAajYCaCACIAJB6ABqNgKoASABIAJBmAFqELUHRQRAIAIoAnwEQCACKAJ4EIkBCyACQdgAahD8CCACKAJcIgNFIANBDGxFcg0CIAIoAlgQiQEMAgsgAigCfARAIAIoAngQiQELIAJB2ABqEPwIIAIoAlwiAEUgAEEMbEVyDQMgAigCWBCJAQwDCyACQZgBaiAAEIMCIAJB+ABqIAJBmAFqEIMBIAJBmAFqEJMIIANBATYCACACQgE3ApwBIAJBvNPdADYCmAEgAkHZAjYCbCACIAJB6ABqNgKoASACIAJB+ABqNgJoAkAgASACQZgBahC1B0UEQCACQawBakEBNgIAIAJCATcCnAEgAkGY1N0ANgKYASACQdoCNgJsIAIgAEEIajYCaCACIAJB6ABqNgKoASABIAJBmAFqELUHRQ0BCyACKAJ8RQ0FIAIoAngQiQEMBQsgAigCfEUNASACKAJ4EIkBDAELIAJBrAFqQQE2AgAgAkIBNwKcASACQZjU3QA2ApgBIAJB2gI2AnwgAiAAQQhqNgJ4IAIgAkH4AGo2AqgBIAEgAkGYAWoQtQcNASACKAJMBEAgAigCSBCJAQsgAigCPEUNACACKAI4EIkBCyACQRBqEJMIQQAMAwsgAigCTEUNACACKAJIEIkBCyACKAI8RQ0AIAIoAjgQiQELIAJBEGoQkwhBAQsgAkHAAWokAAv7CgEFfyMAQcABayICJAAgAkEQaiAAEIMCIAAoAgAhBgJAIAAoAgQiBEEITwRAIAJBCGpBCiAGIAQQkQMgAigCCCEFDAELIAQEQEEBIQUDQCADIAZqLQAAQQpGDQIgBCADQQFqIgNHDQALC0EAIQULAn8CQAJAAkACQAJAAkAgBUEBRwRAIAJBrAFqIgNBADYCACACQajT3QA2AqgBIAJCATcCnAEgAkGg090ANgKYASABIAJBmAFqELUHRQ0BDAYLIAJCADcCPCACQbDX3QAoAgA2AjggAkE4akH+AEHPABD/AiACQawBaiIDQQA2AgAgAkGo090ANgKoASACQgE3ApwBIAJBoNPdADYCmAEgASACQZgBahC1Bw0EIANBATYCACACQgI3ApwBIAJBrNPdADYCmAEgAkHZAjYCfCACIAJB+ABqNgKoASACIAJBOGo2AnggASACQZgBahC1Bw0EIAJByABqIAJBEGoQgwEgAkGsAWoiA0EBNgIAIAJCATcCnAEgAkG8090ANgKYASACQdkCNgJ8IAIgAkH4AGo2AqgBIAIgAkHIAGo2AnggASACQZgBahC1Bw0DIANBATYCACACQgI3ApwBIAJBrNPdADYCmAEgAkHZAjYCfCACIAJB+ABqNgKoASACIAJBOGo2AnggASACQZgBahC1Bw0DIAJBMGooAgAiA0UNASACQgA3AlwgAkGo190AKAIANgJYIANBGGwhBSACKAIoQRRqIQMDQCACQQQ2AowBIAJCBTcCfCACQejT3QA2AnggAygCACEEIAJBFzYCtAEgAkEXNgKsASACIANBfGo2AqgBIAJBFzYCpAEgAiADQXRqNgKgASACQRc2ApwBIAIgA0FwajYCmAEgAiAEQX9qNgKUASACIAJBmAFqNgKIASACIAJBlAFqNgKwASACQegAaiACQfgAahD/ASACKAJgIgQgAigCXEYEQCACQdgAaiAEEJAJIAIoAmAhBAsgAigCWCAEQQxsaiIEIAIpA2g3AgAgBEEIaiACQfAAaigCADYCACACIAIoAmBBAWoiBDYCYCADQRhqIQMgBUFoaiIFDQALIAJB+ABqIAIoAlggBBCSASACQawBakEBNgIAIAJB2QI2AmwgAkICNwKcASACQazT3QA2ApgBIAIgAkH4AGo2AmggAiACQegAajYCqAEgASACQZgBahC1B0UEQCACKAJ8BEAgAigCeBCJAQsgAkHYAGoQ/AggAigCXCIDRSADQQxsRXINAiACKAJYEIkBDAILIAIoAnwEQCACKAJ4EIkBCyACQdgAahD8CCACKAJcIgBFIABBDGxFcg0DIAIoAlgQiQEMAwsgAkGYAWogABCDAiACQfgAaiACQZgBahCDASACQZgBahCTCCADQQE2AgAgAkIBNwKcASACQbzT3QA2ApgBIAJB2QI2AmwgAiACQegAajYCqAEgAiACQfgAajYCaAJAIAEgAkGYAWoQtQdFBEAgAkGsAWpBATYCACACQgE3ApwBIAJBmNTdADYCmAEgAkHbAjYCbCACIABBCGo2AmggAiACQegAajYCqAEgASACQZgBahC1B0UNAQsgAigCfEUNBSACKAJ4EIkBDAULIAIoAnxFDQEgAigCeBCJAQwBCyACQawBakEBNgIAIAJCATcCnAEgAkGY1N0ANgKYASACQdsCNgJ8IAIgAEEIajYCeCACIAJB+ABqNgKoASABIAJBmAFqELUHDQEgAigCTARAIAIoAkgQiQELIAIoAjxFDQAgAigCOBCJAQsgAkEQahCTCEEADAMLIAIoAkxFDQAgAigCSBCJAQsgAigC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A0HAC2oiBSACQShqKQAANwMAIANBuAtqIgYgAkEgaikAADcDACADIAIpABg3A7ALIANBqARqIANBsAtqEPQBAkACQAJAIAMpA6gEQgFRBEAgA0HIAGogA0GwBGpBoAEQiQMaIAQgAkHQAGopAAA3AwAgBSACQcgAaikAADcDACAGIAJBQGspAAA3AwAgAyACKQA4NwOwCyADQagEaiADQbALahD0ASADKQOoBEIBUg0BIANB6AFqIANBsARqIgdBoAEQiQMaIANByAtqIgQgAkHwAGopAAA3AwAgA0HAC2oiBSACQegAaikAADcDACADQbgLaiIGIAJB4ABqKQAANwMAIAMgAikAWDcDsAsgA0GoBGogA0GwC2oQ9AEgAykDqARCAVINAiADQYgDaiAHQaABEIkDGiADQagEaiADQYgDakGgARCJAxogBCABQYgCaikAADcDACAFIAFBgAJqKQAANwMAIAYgAUH4AWopAAA3AwAgAyABKQDwATcDsAsgA0HQBWogA0GoBGogA0GwC2oQ3AwgA0GwC2ogA0HQBWoQ+wQgA0GQCmogA0GwC2oQ8wkgA0FAayACEM0LIAMpA0AhCCADQThqIAJBDGoiBxDNCyADQcwEakEgNgIAIANBxARqQSA2AgAgAyACQdgAajYCyAQgAyACQThqNgLABCADIAg3A7AEIANBIDYCrAQgAyADKQM4NwO4BCADIANBkApqNgKoBCADQbAHaiADQagEakEFEMcFIANBMGogA0GwB2oQzQsgA0HQCGogAygCMCADKAI0EPkJIANB8AZqIANB0AhqELoKIANBsAdqEKQLIANBkAdqIAFB8AFqELoKIANBqARqIANByABqQaABEIkDGiAEIANBiAdqKQMANwMAIAUgA0GAB2opAwA3AwAgBiADQfgGaikDADcDACADIAMpA/AGNwOwCyADQbAHaiADQagEaiADQbALahDcDCADQagEaiADQegBakGgARCJAxogBCADQagHaikDADcDACAFIANBoAdqKQMANwMAIAYgA0GYB2opAwA3AwAgAyADKQOQBzcDsAsgA0HQCGogA0GoBGogA0GwC2oQ3AwgA0GwC2ogA0GwB2pBoAEQiQMaIANBqARqIANB0AhqQaABEIkDGiADQZAKaiADQbALaiADQagEahDbDCADQagEaiADQZAKahD7BCADQfAJaiADQagEahDzCSADQbALaiADQfAJakEgEPwHIANBKGogAhDNCyAAIAMoAiggAygCLCADQbALahCFBCADQSBqIAAQzQsgA0GcCmpBIDYCACADIAMpAyA3A5AKIAMgA0HwCWo2ApgKIANB4AxqIANBkApqQQIQxwUgA0EYaiADQeAMahDNCyADQagEaiADKAIYIAMoAhwQ/AcgA0EQakHAAEEAEIUIIAMgAygCFDYC1AwgAyADKAIQIgA2AtAMIAAgA0GoBGpBwAAQiQMaIANBwAA2AtgMIANB4AxqEKQLIANBCGogA0HQDGoQzQsgAygCDCEAIAMoAgggAyAHEM0LIAAgAygCACADKAIEEJgLDQNB7N/KAEEZQfjgygAQ7AoAC0Gp5soAQStByODKABDRCQALQanmygBBK0HY4MoAENEJAAtBqebKAEErQejgygAQ0QkACyADQdAMahCkCyADQfAMaiQAC6IJAQd/AkAgAUH/CU0EQCABQQV2IQUCQAJAAkAgACgCACIEBEAgACAEQQJ0aiECIAAgBCAFakECdGohBiAEQX9qIgNBJ0shBANAIAQNBCADIAVqIgdBKE8NAiAGIAIoAgA2AgAgBkF8aiEGIAJBfGohAiADQX9qIgNBf0cNAAsLIAFBIEkNBCAAQQA2AgQgAUHAAE8NAQwECyAHQShB5IrhABCwBwALIABBCGpBADYCACAFQQEgBUEBSxsiAkECRg0CIABBDGpBADYCACACQQNGDQIgAEEQakEANgIAIAJBBEYNAiAAQRRqQQA2AgAgAkEFRg0CIABBGGpBADYCACACQQZGDQIgAEEcakEANgIAIAJBB0YNAiAAQSBqQQA2AgAgAkEIRg0CIABBJGpBADYCACACQQlGDQIgAEEoakEANgIAIAJBCkYNAiAAQSxqQQA2AgAgAkELRg0CIABBMGpBADYCACACQQxGDQIgAEE0akEANgIAIAJBDUYNAiAAQThqQQA2AgAgAkEORg0CIABBPGpBADYCACACQQ9GDQIgAEFAa0EANgIAIAJBEEYNAiAAQcQAakEANgIAIAJBEUYNAiAAQcgAakEANgIAIAJBEkYNAiAAQcwAakEANgIAIAJBE0YNAiAAQdAAakEANgIAIAJBFEYNAiAAQdQAakEANgIAIAJBFUYNAiAAQdgAakEANgIAIAJB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IAIoAiBBAWo2AiAgAEEEaiACQSQQiQMaIABBADYCAAsgBEGAA2okAA8LQYQBQQQQ4gwAC9AJAgR/AX4jAEGQA2siAiQAIAIgARCHAyIDNgIoAkAgA0HbAEYEQCACQbABaiIFIAEoAgAiA0EIaigCACIENgIAIAJBvAFqIAQ2AgAgAykCACEGIAJBHGpCADcCACACIAY3ArQBIAJBCGogBSkDADcDACACQRBqIAJBuAFqKQMANwMAIAJB2LrMACgCADYCGCACIAY3AwAgARDMAQJAAkAgASgCACgCACABQQhqKAIARwRAIAJBqAFqQQRyIQMDQAJAAkACQAJAAkACQAJAAkACQCABEIcDIgRB2gBMBEAgBEEmRg0CIARBLUcNCCABEK4DQS1HDQggAUHYtswAQQIQzQRFDQEgAkGoAWogAkEkEIkDGiACQShqIAFBASACQagBahCiAyACIAJBKGpBJBCJAxoMCQsCQAJAAkAgBEGlf2oOAwEKBQALIARB/gBGDQEMCQsgASgCACIEKAI0Qf////8HTw0FIARBQGsoAgANBAwHCyABEK4DQf4ARw0HIAFBoLbMAEECEM0EBEAgAkGoAWogAkEkEIkDGiACQShqIAFBAiACQagBahCiAyACIAJBKGpBJBCJAxoMCQtBorbMAEEmQci2zAAQ0QkAC0HatswAQSZBgLfMABDRCQALIAEQrgNBJkcNBSABQZC3zABBAhDNBARAIAJBqAFqIAJBJBCJAxogAkEoaiABQQAgAkGoAWoQogMgAiACQShqQSQQiQMaDAcLQZK3zABBJkG4t8wAENEJAAsgAkGwAmogAkEkEIkDGiACQagBaiABIAJBsAJqELkBIAIoAqwBIQQCQCACKAKoAUEBRwRAIAJBKGogBUGAARCJAxogBA0BIAIgAkEoakEkEIkDGgwHCyACQShqIAVBPBCJAxogAEEIaiACQShqQTwQiQMaIAAgBDYCBEEBIQEMAwsgAEEEaiACQShqQYABEIkDGkEAIQEMAgsgAkEoaiABEJQCIAItAEFBAkYNAiADIAIpAyg3AgAgA0EYaiACQUBrKAIANgIAIANBEGogAkE4aikDADcCACADQQhqIAJBMGopAwA3AgAgAkEDNgKoASACIAJBqAFqEI0DDAQLQbC6zABBGCACQagBakGUu8wAQci3zAAQ8wYA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ACAESQRAIAFBNGooAgAhDSABQShqKAIAIQ8gASgCLCEOIAEoAiAhB0EAIQEDQAJAIA8gASADai0AACAFQQh0ciIFSwRAIAFBAWohASAMIAcgBUECdGooAgAiBUkNASAFQQFHBEBBACECIA0gBU0NAiAOIAVBDGxqIggoAghFDQIgCCgCACICKAIEIQogAigCACELQQEhAiABIQkMAgsgACALNgIEIAAgAjYCACAAQQxqIAk2AgAgAEEIaiAKNgIADAYLIAUgD0HUwMsAELAHAAsgASAERw0ACwsgACALNgIEIAAgAjYCACAAQQxqIAk2AgAgAEEIaiAKNgIADAILIABBADYCAAwBCyAGQRBqIA0gAiADIARBACAOKAIgEQgAAkACQAJAIAYoAhAiAUEBaw4CAQACC0HIvssAQShB1L/LABDRCQALIAAgBikCFDcCBCAAQQxqIAZBHGooAgA2AgBBASEBCyAAIAE2AgALIAZBIGokAAvaCAEJfyMAQYABayIGJAAgBkHYAGogASACIAQQhgIgBkH4AGoiCiAGQegAaigCADYCACAGIAZB4ABqKQMANwNwIAYoAlwhCAJAAkACQAJAAkACQCAGKAJYQQFHBEAgBkEQaiAKKAIANgIAIAYgBikDcDcDCCAGQewAaigCACEJIAQgBUYNAiAGQQA2AlggBiABQeAEaigCACIKNgJoIAhBA0cEQCAGQSBqIAZBEGooAgA2AgAgBiAGKQMINwMYIAZB2ABqEJ4LIAghCyAJIQoLIAZCADcCLCAGQaCrywAoAgA2AiggBkFAayIIIAZBIGoiCSgCADYCACAGIAYpAxg3AzggBkHgAGohDCAEIAVPDQMgBkHYAGpBBHIhCSAFIARrIQUDQCABKALgBCEEIAkgBikDODcCACAJQQhqIAgoAgA2AgAgBiALNgJYIAEgBkHYAGogBBDDASAGQcgAaiABEJoIIAZB2ABqIAEgAhA7IAZB+ABqIg0gDEEIaigCADYCACAGIAwpAgA3A3AgBigCXCELAkACQCAGKAJYQQFHBEAgC0EDRw0CIAAgARCuBgwBCyAAIAs2AgQgAEEBNgIAIABBCGogBikDcDcCACAAQRBqIAZB+ABqKAIANgIACyAGQcgAahCeCyAGQShqEPAIIAZBKGoQywoMCAsgBigCbCEEIAggDSgCADYCACAG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QYCABEkEQCACQT9xQYB/ciEJIAJBDHZBYHIhCiACQQZ2IQJBAwwECyACQT9xQYB/ciELIAJBEnZBcHIhCiACQQZ2QT9xQYB/ciEJIAJBDHYhAkEEDAMLQbD53QBBK0GM+N0AENEJAAtBsPndAEErQZz43QAQ0QkACyACQQZ2QUByIQpBACEJQQILIQggAyAFNgIMIAMgCDYCKAJAIAUgCEYEQCAFQX5qIghBA08NASAAIAQ6AAEgAEEIaiALOgAAIABBB2ogAToAACAAQQZqIAk6AAAgAEEFaiAGOgAAIABBBGogAkE/cUGAf3I6AAAgAEEDaiAHOgAAIABBAmogCjoAACAAIAhBAWo6AAAMDQsgA0EANgIQIANBDGogA0EoaiADQRBqQaz43QAQxwcACyADIAU2AgwgA0EkakEBNgIAIANCATcCFCADQfT33QA2AhAgA0EXNgIsIAMgA0EoajYCICADIANBDGo2AiggA0EQakH8990AENcKAAsgACAMPAABIABBADoAACAAQQJqIAI6AAAMCgsgCEF/akEDTw0CIAhBAWohCCAFQej53QBqIAVBBGoiByEFKAIAIgYgBEkNACAHIQUgBiACTw0ACyABIAZBAWogAhDDCSAGCyECIAkNASACQf+vA0sNAgwBCwsgA0EkakEBNgIAIANCATcCFCADQej43QA2AhAgA0GMATYCLCADQZD53QA2AiggAyADQShqNgIgIANBEGpBmPndABDXCgALIAFBgMADIAIQwwlB/68DIQIMAQsLIAEoAggiBQ0ACwsgAEEEOgAACyADQTBqJAAL5QgCCn8CfiMAQfAAayIBJAACQAJAAkACQAJAAkAgAC0AAA4JBQUFBQUAAQIDBAsgAEEQaigCAC0AAEEETQ0EDAMLIABBGGooAgAtAABBBEsNAgwDCyAAQQxqKAIADQEMAgsgAEEMaigCAEUNAQsCQAJAQSBBBBDkCyICBEAgAiAAKQIANwIAIABBADoAACACQRhqIgQgAEEYaikCADcCACACQRBqIABBEGopAgA3AgAgAkEIaiAAQQhqKQIANwIAIABBgwI7ARwgAUIBNwIEIAEgAjYCACABQRhqIgcgAkEJaikAADcDACABQSBqIgggAkERaikAADcDACABQSdqIgkgBCkAADcAACABIAIpAAE3AxAgAi0AACIAQQlGDQEgAUEwakEBciEEIAFBMGpBBHIhCgNAIAQgASkDEDcAACAEQQhqIAcpAwA3AAAgBEEQaiAIKQMANwAAIARBF2ogCSkAADcAACABIAA6ADACQAJAAkACQAJAIABB/wFxQQVrDgQBAgADBAsgASgCPCEAIAFBADYCPCABKAI0IQIgASAKNgJgIAEgAiAAQQV0ajYCXCABIAI2AlggAUEANgJUIAEgADYCUCABIAFB0ABqEKcDDAMLIAEoAkAiACkCACELIABBADoAACABQdgAaiIDIABBCGopAgA3AwAgAUHgAGoiBSAAQRBqKQIANwMAIABBGGopAgAhDCAAQYMCOwEcIAFB6ABqIgYgDDcDACABIAs3A1AgASgCCCICIAEoAgRGBEAgASACEI4JIAEoAgghAgsgASgCACACQQV0aiIAIAEpA1A3AgAgAEEIaiADKQMANwIAIABBEGogBSkDADcCACAAQRhqIAYpAwA3AgAgASACQQFqNgIIDAILIAEoAkgiACkCACELIABBADoAACABQdgAaiIDIABBCGopAgA3AwAgAUHgAGoiBSAAQRBqKQIANwMAIABBGGopAgAhDCAAQYMCOwEcIAFB6ABqIgYgDDcDACABIAs3A1AgASgCCCICIAEoAgRGBEAgASACEI4JIAEoAgghAgsgASgCACACQQV0aiIAIAEpA1A3AgAgAEEIaiADKQMANwIAIABBEGogBSkDADcCACAAQRhqIAYpAwA3AgAgASACQQFqNgIIDAELIAEoAjwhACABQQA2AjwgASgCNCECIAEgCjYCYCABIAIgAEEFdGo2AlwgASACNgJYIAFBADYCVCABIAA2AlAgASABQdAAahCnAwsgAUEwahDZAiABKAIIIgBFDQMgByABKAIAIgIgAEF/aiIDQQV0aiIAQQlqKQAANwMAIAggAEERaikAADcDACAJIABBGGopAAA3AAAgASADNgIIIAEgACkAATcDECAALQAAIgBBCUcNAAsMAQtBIEEEEOIMAAsgA0UNACADQQV0IQADQCACENwCIAJBIGohAiAAQWBqIgANAAsLIAEoAgQiAEUgAEEFdEVyDQAgASgCABCJAQsgAUHwAGokAAuoCAIHfwF+IwBB0ABrIgIkAAJAAkAgASgCACIDKAJURQRAIANBfzYCVCADQeAAakEANgIAIAEoAgQhCCABQQhqKAIAIgUhBiADKAIAIAVGDQIDQCABEIcDIgRBd2pBBUkgBEEgRnJFBEAgBEGAAUkNAyAEEPgCRQ0DCyABELECGiADKAIAIAVHDQALDAELQci6zABBECACQThqQaS7zABBgLbMABDzBgALIAMoAgAhBgsgA0HYAGohByACQRhqIANBCGooAgA2AgAgAiADKQIANwMQIAUhBCAFIAZHBEADQAJAIAEQhwNBMEkNACABEIcDQTpPDQACQCABEIcDIgZB/wBNBEAgAygCYCIEIAMoAlxGBH8gByAEEOIIIAMoAmAFIAQLIAMoAlhqIAY6AAAgAyADKAJgQQFqNgJgDAELIAJBADYCOCAHIAJBOGoCfyAGQYAQTwRAIAZBgIAESQRAIAIgBkE/cUGAAXI6ADogAiAGQQx2QeABcjoAOCACIAZBBnZBP3FBgAFyOgA5QQMMAgsgAiAGQT9xQYABcjoAOyACIAZBEnZB8AFyOgA4IAIgBkEGdkE/cUGAAXI6ADogAiAGQQx2QT9xQYABcjoAOUEEDAELIAIgBkE/cUGAAXI6ADkgAiAGQQZ2QcABcjoAOEECCyACQThqahDkCAsgARDhChogAygCACAFRw0BCwsgAygCACEECyACQShqIAJBGGooAgA2AgAgAkE0aiADQQhqKAIANgIAIAIgAikDEDcDICACIAMpAgA3AiwCQCAEIAVGDQADQCABEIcDIgRBd2pBBUkgBEEgRnJFBEAgBEGAAUkNAiAEEPgCRQ0CCyABEOEKGiADKAIAIAVHDQALCwJAIAACfwJAIAMoAmAiAQRAIAcoAgAgAUEKEOUMIglCAYNQDQEgAkEIaiAFQQAQhQggAigCDCEBIAIoAgggCCAFEIkDIQQgAEEoaiAFNgIAIABBJGogATYCACAAQSBqIAQ2AgAgAEEYaiACQcgAaikCADcCACAAQRBqIAJBQGspAgA3AgAgAEEIaiACKQI4NwIAIABBLGogAikDIDcCACAAQTRqIAJBKGopAwA3AgAgAEE8aiACQTBqKQMANwIAQQYhBUEBDAILIAIgBUEAEIUIIAIoAgQhASACKAIAIAggBRCJAyEEIABCgYCAgNAANwIAIABBKGogBTYCACAAQSRqIAE2AgAgAEEgaiAENgIAIABBCGogAikCODcCACAAQRBqIAJBQGspAgA3AgAgAEEYaiACQcgAaikCADcCACAAQSxqIAIpAyA3AgAgAEE0aiACQShqKQMANwIAIABBPGogAkEwaikDADcCAAwCCyAJQiCIpyEFQQALNgIAIAAgBTYCBAsgAyADKAJUQQFqNgJUIAJB0ABqJAALjAcBBX8gABDzDCIAIAAQ3gwiAhDwDCEBAkACQAJAIAAQ3wwNACAAKAIAIQMCQCAAEIMMRQRAIAIgA2ohAiAAIAMQ8QwiAEGgmOEAKAIARw0BIAEoAgRBA3FBA0cNAkGYmOEAIAI2AgAgACACIAEQigsPCyACIANqQRBqIQAMAgsgA0GAAk8EQCAAELIDDAELIABBDGooAgAiBCAAQQhqKAIAIgVHBEAgBSAENgIMIAQgBTYCCAwBC0GIleEAQYiV4QAoAgBBfiADQQN2d3E2AgALAkAgARD1CwRAIAAgAiABEIoLDAELAkACQAJAQaSY4QAoAgAgAUcEQCABQaCY4QAoAgBHDQFBoJjhACAANgIAQZiY4QBBmJjhACgCACACaiIBNgIAIAAgARC0Cw8LQaSY4QAgADYCAEGcmOEAQZyY4QAoAgAgAmoiATYCACAAIAFBAXI2AgQgAEGgmOEAKAIARg0BDAILIAEQ3gwiAyACaiECAkAgA0GAAk8EQCABELIDDAELIAFBDGooAgAiBCABQQhqKAIAIgFHBEAgASAENgIMIAQgATYCCAwBC0GIleEAQYiV4QAoAgBBfiADQQN2d3E2AgALIAAgAhC0CyAAQaCY4QAoAgBHDQJBmJjhACACNgIADAMLQZiY4QBBADYCAEGgmOEAQQA2AgALQcCY4QAoAgAgAU8NAUGAgHxBCEEIEMQLQRRBCBDEC2pBEEEIEMQLamtBd3FBfWoiAEEAQRBBCBDEC0ECdGsiASABIABLG0UNAUGkmOEAKAIARQ0BQQhBCBDECyEAQRRBCBDECyEBQRBBCBDECyECQQACQEGcmOEAKAIAIgQgAiABIABBCGtqaiICTQ0AQaSY4QAoAgAhAUGwmOEAIQACQANAIAAoAgAgAU0EQCAAEIUMIAFLDQILIAAoAggiAA0AC0EAIQALIAAQ4AwNACAAQQxqKAIAGgwAC0EAEL4Da0cNAUGcmOEAKAIAQcCY4QAoAgBNDQFBwJjhAEF/NgIADwsgAkGAAkkNASAAIAIQqwNByJjhAEHImOEAKAIAQX9qIgA2AgAgAA0AEL4DGg8LDwsgAkEDdiIDQQN0QZCV4QBqIQECf0GIleEAKAIAIgJBASADdCIDcQRAIAEoAggMAQtBiJXhACACIANyNgIAIAELIQMgASAANgIIIAMgADYCDCAAIAE2AgwgACADNgIIC4EIAQp/IwBB4ABrIgIkAEEBIQQCQCABKAIIIgdFDQAgASgCACIIIAdBBHQiAWohCyAIIQMDQCABRQ0BIAFBcGohASADKAIIIANBEGohA0UNAAsgACgCACEEAkACQAJAIAAoAggiCUUNACAEIAlBBHQiAWohCiAEIQMDQCABRQ0BIAFBcGohASADKAIIIANBEGohA0UNAAsgCUEEdCEBIAQhAwNAIAFFDQEgAUFwaiEBIAMtAAwgA0EQaiEDDQALIAQgCkcEQCAJQQR0IQMgBEEIaiEBA0AgASgCAEEAIAFBBGotAAAbIAZqIQYgAUEQaiEBIANBcGoiAw0ACwsgCUEEdCEHIARBCGohCiAIIQQMAQsgCUEEdCIDBEAgBEEIaiEBA0AgASgCACAGaiEGIAFBEGohASADQXBqIgMNAAsLIAdBBHQhAyAIQQhqIQEDQCABKAIAIAZqIQYgAUEQaiEBIANBcGoiAw0ACwwBCwNAIAQiBUEQaiEEIAchAyAKIQEDQCABQQRqLQAARQRAIAUoAgggASgCACAGamohBgsgAUEQaiEBIANBcGoiAw0ACyAEIAtHDQALC0EAIQQgBiAAKAIMSw0AIAJBCGogABCRAgJAIAIoAhANAEEQQQQQ5AsiAwRAIANCADcCBCADQQxqQQA6AAAgA0Hw590AKAIANgIAIAJBCGoQlAkgAigCDCIBRSABQQR0RXJFBEAgAigCCBCJAQsgAkKBgICAEDcCDCACIAM2AggMAQtBEEEEEOIMAAsgAkHNAGohBwNAIAJB0ABqIAJBCGoQoAQgAigCVCEDIAIgAigCUCIBIAIoAlgiBEEEdGo2AiQgAiABNgIgIAIgAzYCHCACIAE2AhggCCIDQRBqIQgCQCAERQ0AA0AgAkE4aiIKIAFBCGooAgA2AgAgAkEuaiIEIAFBD2otAAA6AAAgAiABQRBqNgIgIAIgASkCADcDMCACIAEvAA07ASwgAS0ADCIBQQJGDQEgByACLwEsOwAAIAJByABqIgUgCigCADYCACAHQQJqIAQtAAA6AAAgAiABOgBMIAIgAikDMDcDQCACQUBrIAMoAgAiASABIAMoAghqEOQIIAIgAy0ADDoATCACQdgAaiIEIAUpAwA3AwAgAiACKQNANwNQIAAoAggiASAAKAIERgRAIAAgARCLCSAAKAIIIQELIAAoAgAgAUEEdGoiASACKQNQNwIAIAFBCGogBCkDADcCACAAIAAoAghBAWo2AgggAigCICIBIAIoAiRHDQALCyACQRhqEPcGIAggC0cNAAsgAkEIahCUCSACKAIMIgBFIABBBHRFckUEQCACKAIIEIkBC0EBIQQLIAJB4ABqJAAgBAu6CAIIfwd+AkACQAJAAkACQAJAIAEpAwAiDVBFBEAgDUL//////////x9WDQEgA0UNA0GgfyABLwEYIgFBYGogASANQoCAgIAQVCIBGyIFQXBqIAUgDUIghiANIAEbIg1CgICAgICAwABUIgEbIgVBeGogBSANQhCGIA0gARsiDUKAgICAgICAgAFUIgEbIgVBfGogBSANQgiGIA0gARsiDUKAgICAgICAgBBUIgEbIgVBfmogBSANQgSGIA0gARsiDUKAgICAgICAgMAAVCIBGyANQgKGIA0gARsiDUI/h6dBf3NqIgVrQRB0QRB1QdAAbEGwpwVqQc4QbSIBQdEATw0CIAFBBHQiAUGa3OAAai8BACEHAn8CQAJAIAFBkNzgAGopAwAiDkL/////D4MiDyANIA1Cf4VCP4iGIg1CIIgiEH4iEUIgiCAOQiCIIg4gEH58IA4gDUL/////D4MiDX4iDkIgiHwgEUL/////D4MgDSAPfkIgiHwgDkL/////D4N8QoCAgIAIfEIgiHwiD0FAIAUgAUGY3OAAai8BAGprIgFBP3GtIg2IpyIFQZDOAE8EQCAFQcCEPUkNASAFQYDC1y9JDQJBCEEJIAVBgJTr3ANJIgYbIQhBgMLXL0GAlOvcAyAGGwwDCyAFQeQATwRAQQJBAyAFQegHSSIGGyEIQeQAQegHIAYbDAMLIAVBCUshCEEBQQogBUEKSRsMAgtBBEEFIAVBoI0GSSIGGyEIQZDOAEGgjQYgBhsMAQtBBkEHIAVBgK3iBEkiBhshCEHAhD1BgK3iBCAGGwshBkIBIA2GIQ4CQCAIIAdrQRB0QYCABGpBEHUiByAEQRB0QRB1IglKBEAgDyAOQn98IhGDIQ8gAUH//wNxIQsgByAEa0EQdEEQdSADIAcgCWsgA0kbIglBf2ohDEEAIQEDQCAFIAZuIQogASADRg0HIAUgBiAKbGshBSABIAJqIApBMGo6AAAgASAMRg0IIAEgCEYNAiABQQFqIQEgBkEKSSAGQQpuIQZFDQALQZDo4ABBGUHk6eAAENEJAAsgACACIANBACAHIAQgD0IKgCAGrSANhiAOEJ8CDwsgAUEBaiIBIAMgASADSxshBSALQX9qQT9xrSESQgEhEANAIBAgEohQRQRAIABBADYCAA8LIAEgBUYNByAQQgp+IRAgD0IKfiITIBGDIQ8gASACaiATIA2Ip0EwajoAACAJIAFBAWoiAUcNAAsgACACIAMgCSAHIAQgDyAOIBAQnwIPC0HT1+AAQRxBkOngABDRCQALQaDp4ABBJEHE6eAAENEJAAsgAUHRAEHQ5uAAELAHAAtB7OjgAEEhQdTp4AAQ0QkACyADIANB9OngABCwBwALIAAgAiADIAkgByAEIAWtIA2GIA98IAatIA2GIA4QnwIPCyAFIANBhOrgABCwBwALowgBA38jAEHwAGsiBSQAIAUgAzYCDCAFIAI2AgggBQJ/AkACfwJAAkAgAUGBAk8EQANAIAZBgAJqIAAgBmoiB0GAAmosAABBv39KDQQaIAZB/wFqIAdB/wFqLAAAQb9/Sg0EGiAHQf4BaiwAAEG/f0oNAyAHQf0BaiwAAEG/f0oNAiAGQXxqIgZBgH5HDQALQQAhBgwECyAFIAE2AhQgBSAANgIQIAVBlO3gADYCGEEADAQLIAZB/QFqDAELIAZB/gFqCyIHIAFJBEAgByEGDAELIAcgASIGRg0AIAAgAUEAIAdByPvgABCMAQALIAUgBjYCFCAFIAA2AhAgBUHY/OAANgIYQQULNgIcAkACQAJAAkACQAJAAkAgAiABSyIGIAMgAUtyRQRAIAIgA0sNASACRQ0CAkAgAiABTwRAIAEgAkcNAQwECyAAIAJqLAAAQb9/Sg0DCyAFIAI2AiAgAiEDDAMLIAUgAiADIAYbNgIoIAVBxABqQQM2AgAgBUHcAGpB4AM2AgAgBUHUAGpB4AM2AgAgBUIDNwI0IAVBgP3gADYCMCAFQRc2AkwgBSAFQcgAajYCQCAFIAVBGGo2AlggBSAFQRBqNgJQIAUgBUEoajYCSAwGCyAFQeQAakHgAzYCACAFQdwAakHgAzYCACAFQdQAakEXNgIAIAVBxABqQQQ2AgAgBUIENwI0IAVBvP3gADYCMCAFQRc2AkwgBSAFQcgAajYCQCAFIAVBGGo2AmAgBSAFQRBqNgJYIAUgBUEMajYCUCAFIAVBCGo2AkgMBQsgBSADNgIgIANFDQELA0ACQCADIAFPBEAgASADRg0FDAELIAAgA2osAABBv39KDQMLIANBf2oiAw0ACwtBACEDCyABIANGDQAgACADaiIALAAAIgFB/wFxIQYCfwJAAkAgAUF/TARAIAAtAAFBP3EhByABQR9xIQIgBkHfAUsNASACQQZ0IAdyIQYMAgsgBSAGNgIkQQEMAgsgAC0AAkE/cSAHQQZ0ciEGIAFB/wFxQfABSQRAIAYgAkEMdHIhBgwBCyACQRJ0QYCA8ABxIAAtAANBP3EgBkEGdHJyIgZBgIDEAEYNAgsgBSAGNgIkQQEgBkGAAUkNABpBAiAGQYAQSQ0AGkEDQQQgBkGAgARJGwshByAFIAM2AiggBSADIAdqNgIsIAVBxABqQQU2AgAgBUHsAGpB4AM2AgAgBUHkAGpB4AM2AgAgBUHcAGpB4wM2AgAgBUHUAGpB8AI2AgAgBUIFNwI0IAVBkP7gADYCMCAFQRc2AkwgBSAFQcgAajYCQCAFIAVBGGo2AmggBSAFQRBqNgJgIAUgBUEoajYCWCAFIAVBJGo2AlAgBSAFQSBqNgJIDAELQYHw4ABBKyAEENEJAAsgBUEwaiAEENcKAAueCAEVfyMAQeAAayIDJAAgASgCACIJIAEoAggiBkEDdGohCyAGBEAgCSEBA0AgAUEEaigCACAEIAEoAgBrakEBaiEEIAFBCGoiASALRw0ACwsCQCAAIAQQoQYiEA0AIANBCGogABCRAgJAIAMoAhANAEEQQQQQ5AsiAQRAIAFCADcCBCABQQxqQQA6AAAgAUHw590AKAIANgIAIANBCGoQlAkgAygCDCIERSAEQQR0RXJFBEAgAygCCBCJAQsgA0KBgICAEDcCDCADIAE2AggMAQtBEEEEEOIMAAsgBgRAIANBzQBqIQwDQCAJKAIEQQFqIQ0gCSgCACEGA0AgBiANIAYgDUsbIQQCQANAIAQgBiIBRg0BIAFBAWohBiABQYBwcUGAsANGIAFB///DAEtyDQALIANB0ABqIANBCGoQoAQgAygCVCEEIAMgAygCUCIBIAMoAlgiBUEEdGo2AiQgAyABNgIgIAMgBDYCHCADIAE2AhgCQCAFRQ0AIAZBf2oiB0EGdiIEQUByIREgB0EMdiIFQWByIRIgB0E/cUGAf3IhCiAHQRJ2QXByIRMgBEE/cUGAf3IhDiAFQT9xQYB/ciEUA0AgA0E4aiIEIAFBCGooAgA2AgAgA0EuaiIFIAFBD2otAAA6AAAgAyABQRBqNgIgIAMgASkCADcDMCADIAEvAA07ASwgAS0ADCIBQQJGDQEgDCADLwEsOwAAIANByABqIhUgBCgCADYCACAMQQJqIAUtAAA6AAAgAyADKQMwNwNAIAMgAToATCADQQA2AlACfwJ/AkACQCAHQYABTwRAIAdBgBBJDQEgB0GAgARPDQIgAyAKOgBSIAMgDjoAUSADIBI6AFBBAwwDCyADIAc6AFBBASEIQQEMAwsgAyAKOgBRIAMgEToAUEECDAELIAMgCjoAUyADIA46AFIgAyAUOgBRIAMgEzoAUEEECyEIQQALIQEgAyAIQQAQhQggAygCBCADKAIAIANB0ABqIAgQiQMhBSACRSABckUEQCAIQQF2IQ8gBSAIakF/aiEBIAUhBANAIAQtAAAhFyAEIAEtAAA6AAAgASAXOgAAIAFBf2ohASAEQQFqIQQgD0F/aiIPDQALCyADQUBrIAUgBSAIahDkCCADQdgAaiIEIBUpAwA3AwAgAyADKQNANwNQIAAoAggiASAAKAIERgRAIAAgARCLCSAAKAIIIQELIAAoAgAgAUEEdGoiASADKQNQNwIAIAFBCGogBCkDADcCACAAIAAoAghBAWo2AggEQCAFEIkBCyADKAIgIgEgAygCJEcNAAsLIANBGGoQ9wYMAQsLIAlBCGoiCSALRw0ACwsgA0EIahCUCSADKAIMIgBFIABBBHRFcg0AIAMoAggQiQELIANB4ABqJAAgEEEBcwu3CAILfwF+IwBBEGsiBiQAIAAoAhwiAygCCCIFIAMoAgRGBEAgAyAFEOwIIAMoAgghBQsgAygCACAFQRhsaiICQgA3AgAgAkEIaiABKQIANwIAIAJBEGogAUEIaikCADcCACADIAMoAghBAWo2AggCQCAAKAIcIgQoAggiAUUEQAwBCyAAQQRqIQsDQCAEIAFBf2oiATYCCCAEKAIAIAFBGGxqIgMoAgQhBCADQQxqKAIAIQogA0EIaigCACEBAkACQAJAIAMoAgAOAwABBAELIAAoAhwiCEEUaigCACICIAAoAghBAWogBGwgAWoiB0EFdiIFSwRAIANBEGopAgAhDQNAIAgoAgwgBUECdGoiBSgCACIDQQEgB3QiAnENAyAFIAIgA3I2AgACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBCAAKAIAIgVB+ANqKAIAIgJJBEAgBSgC8AMgBEEEdGoiCSgCAEEBaw4GBwECAwQFCAsgBCACQdDjywAQsAcACyAJQQhqKAIAIQIgACgCHCIFKAIIIgggBSgCBEYEQCAFIAgQ7AggBSgCCCEICyAFKAIAIAhBGGxqIgMgAjYCBCADQQA2AgAgA0EQaiANNwIAIANBDGogCjYCACADQQhqIAE2AgAgBSAFKAIIQQFqNgIIDAgLIAYgDTcDCCAGIAo2AgQgBiABNgIAIAsgBiAJQQRqIgIQ1AFFDQ0gAigCACEEDAkLIAlBCGooAgAgCkcNDCAJKAIEIQQMAgsgCUEEaiICIAoQ3wRFDQsgAigCACEEDAELIA1CgICAgBCDUA0KIAlBCGotAAAgDUIoiKdB/wFxIgNLDQogCUEEaiICLQAFIANJDQogAigCACEECyAGIAsgASANp2oQkAYgBikDCCENIAYoAgQhCiAGKAIAIQEMBQsgCUEIaiIFKAIAIgggACgCGEkiAg0BDAILQQEhDCAJKAIEIgEgACgCEEkEfyAAKAIMIAFqQQE6AAAgACgCAAUgBQtBhARqKAIAQQFHDQcMCQsgACgCFCAIQQN0akEAIAIbIgIoAgQhAyACKAIAIQIgACgCHCIEKAIIIgcgBCgCBEYEQCAEIAcQ7AggBCgCCCEHCyAEKAIAIAdBGGxqIgcgCDYCBCAHQQE2AgAgB0EMaiADNgIAIAdBCGogAjYCACAEIAQoAghBAWo2AgggBSgCACIDIAAoAhgiAk8NASAAKAIUIANBA3RqIgIgATYCBCACQQE2AgALIAkoAgQhBAwBCyADIAJB4OPLABCwBwALIAAoAhwiCEEUaigCACICIAAoAghBAWogBGwgAWoiB0EFdiIFSw0ACwsgBSACQfDjywAQsAcACyAEIAAoAhhPDQAgACgCFCAEQQN0aiICIAo2AgQgAiABNgIACyAAKAIcIgQoAggiAQ0ACwsgBkEQaiQAIAwLrwgBCn8jAEEgayIIJAACQAJAAkAgASgCGEUNACAIQQhqIAFBGGoQqQwgCCgCCCILRQ0AIAgoAgwhDCABLQA5RUEBckUEQCAAQQA2AgAMAwsgCyAMKAIsEQQARQ0BAkAgASgCECABKAIAIgZJDQAgAUE0aigCACAGTQ0AIAEoAiwgBkEMbGoiBSgCCEUNACAFKAIAIgUoAgQhDSAFKAIAIQ5BASEKC0EAIARJBEBBACEFA0ACQAJAIAItABANACACKAIMIAVLDQACQCACKAIAIgdBKEkNACACKAIEIAcgAigCCGxBAXRPDQAgAkEBOgAQDAELIAYgASgCAEcNACAIQRBqIAsgAiADIAQgBSAMKAIgEQgAIAACfwJAIAgoAhAiB0ECRwRAIAdBAWsNASAAIAgpAhQ3AgQgAiACKAIAQQFqNgIAIABBDGogCEEcaigCACIANgIAIAIgAigCBCAAIAUgCEEYaigCAGprajYCBEEBDAILIAIgAigCAEEBajYCACACIAIoAgQgCCgCFCIHIAVrajYCBAwDCyACIAIoAgBBAWo2AgAgAiACKAIEIAQgBWtqNgIEQQALNgIADAYLIAUhBwsCQAJAIAcgBEkEQCAHQQFqIQUgASAGIAMgB2otAAAQyAghBiABKAIQIAZPDQEMAgsgByAEQeS/ywAQsAcACyAGQQFHBEBBACEKIAEoAjQgBk0NASABKAIsIAZBDGxqIgcoAghFDQEgBygCACIJKAIEIQ0gCSgCACEOQQEhCiAFIQkMAQsgACAONgIEIAAgCjYCACAAQQxqIAk2AgAgAEEIaiANNgIADAULIAUgBEkNAAsLIAAgDjYCBCAAIAo2AgAgAEEMaiAJNgIAIABBCGogDTYCAAwCCyABLQA5GkEBBEACQCABKAIQIAEoAgAiAkkNACABQTRqKAIAIAJNDQAgASgCLCACQQxsaiIGKAIIRQ0AIAYoAgAiBigCBCELIAYoAgAhCkEBIQcLQQAgBEkEQEEAIQYDQCAGIgVBAWohBiABIAIgAyAFai0AABDICCECAkAgASgCECACSQ0AIAJBAUcEQEEAIQcgASgCNCACTQ0BIAEoAiwgAkEMbGoiBSgCCEUNASAFKAIAIgUoAgQhCyAFKAIAIQpBASEHIAYhCQwBCyAAIAo2AgQgACAHNgIAIABBDGogCTYCACAAQQhqIAs2AgAMBQsgBCAGRw0ACwsgACAKNgIEIAAgBzYCACAAQQxqIAk2AgAgAEEIaiALNgIADAILIABBADYCAAwBCyAIQRBqIAsgAiADIARBACAMKAIgEQgAAkACQAJAIAgoAhAiAUEBaw4CAQACC0HIvssAQShB1L/LABDRCQALIAAgCCkCFDcCBCAAQQxqIAhBHGooAgA2AgBBASEBCyAAIAE2AgALIAhBIGokAAubCAEKfyMAQSBrIgYkAAJAAkACQCABKAIQRQ0AIAZBCGogAUEQahCpDCAGKAIIIgpFDQAgBigCDCEMIAEtACVFQQFyRQRAIABBADYCAAwDCyAKIAwoAiwRBABFDQECQCABQSBqKAIAIAEoAgAiCE0NACABKAIYIAhBJGxqIgUoAhxFDQAgBSgCFCIFKAIEIQ0gBSgCACEOQQEhCwtBACAESQRAQQAhBQNAAkAgAi0AEA0AIAIoAgwgBUsNAAJAIAIoAgAiB0EoSQ0AIAIoAgQgByACKAIIbEEBdE8NACACQQE6ABAMAQsgCCABKAIARw0AIAZBEGogCiACIAMgBCAFIAwoAiARCAAgAAJ/AkAgBigCECIHQQJHBEAgB0EBaw0BIAAgBikCFDcCBCACIAIoAgBBAWo2AgAgAEEMaiAGQRxqKAIAIgA2AgAgAiACKAIEIAAgBSAGQRhqKAIAamtqNgIEQQEMAgsgAiACKAIAQQFqNgIAIAIgAigCBCAGKAIUIgcgBWtqNgIEIAchBQwCCyACIAIoAgBBAWo2AgAgAiACKAIEIAQgBWtqNgIEQQALNgIADAULIAUgBE8EQCAFIARBkMXLABCwBwALAkACQCABIAggAyAFai0AABDyCCIIQQFHBEAgASgCICIHIAhNDQEgBUEBaiEFIAEoAhggCEEkbGoiB0EcaigCAEUNAiAHKAIUIgkoAgQhDSAJKAIAIQ5BASELIAUhCQwCCyAAIA42AgQgACALNgIAIABBDGogCTYCACAAQQhqIA02AgAMBgsgCCAHQeDGywAQsAcACyAFIARJDQALCyAAIA42AgQgACALNgIAIABBDGogCTYCACAAQQhqIA02AgAMAgsgAS0AJRpBAQRAAkAgAUEgaigCACABKAIAIgJNDQAgASgCGCACQSRsaiIFKAIcRQ0AIAUoAhQiBSgCBCEIIAUoAgAhC0EBIQcLQQAgBEkEQEEAIQUDQAJAAkAgASACIAMgBWotAAAQ8ggiAkEBRwRAIAEoAiAiCiACTQ0BIAVBAWohBSABKAIYIAJBJGxqIgpBHGooAgBFDQIgCigCFCIJKAIEIQggCSgCACELQQEhByAFIQkMAgsgACALNgIEIAAgBzYCACAAQQxqIAk2AgAgAEEIaiAINgIADAYLIAIgCkHgxssAELAHAAsgBCAFRw0ACwsgACALNgIEIAAgBzYCACAAQQxqIAk2AgAgAEEIaiAINgIADAILIABBADYCAAwBCyAGQRBqIAogAiADIARBACAMKAIgEQgAAkACQAJAIAYoAhAiAUEBaw4CAQACC0H0w8sAQShBgMXLABDRCQALIAAgBikCFDcCBCAAQQxqIAZBHGooAgA2AgBBASEBCyAAIAE2AgALIAZBIGokAAutBwEJfyMAQRBrIgkkAAJAAkACQAJAAkACQAJAIAEoAggiBg4CAgABCyABQQA2AgggASgCACIDLQAAIgJBCUYNAyAAIAI6AAAgACADKQABNwABIABBCWogA0EJaikAADcAACAAQRFqIANBEWopAAA3AAAgAEEYaiADQRhqKQAANwAADAILIAZBBXQhBSABKAIAIghBHGohA0GDDiECA0BBACEEIAJBAXEEQCADLQAAQQFxIQQLIAJBAnEEfyADLwEAQQJxBUEACyACQXxxIARyciEEAn8CQCACQcAAcQRAIARBv/8DcSECDAELIARBv/8DcSECQQAgAy0AAEHAAHFFDQEaC0HAAAshBCACIARyIQQCfwJAIAJBgAFxBEAgBEH//gNxIQIMAQsgBEH//gNxIQJBACADLQAAQYABcUUNARoLQYABCyEKQQAhB0EAIQQgAkGAAnEEQCADLwEAQYACcSEECyACQYAEcQR/IAMvAQBBgARxBUEACyACQf/xA3EgCnIgBHJyIAJBgAhxBEAgAy8BAEGACHEhBwsgA0EgaiEDIAdyIQIgBUFgaiIFDQALDAMLIABBgwI7ARwgAEEAOgAAIAEoAgAhAwsgASgCBCIARSAAQQV0RXINAiADEIkBDAILQfDl3QBBK0Hs3t0AENEJAAsgBkEFdCEDIAJBw/8DcSAIIQICfwNAQQIhBEECIANFDQEaIAIvARwiB0EGcSIKBEAgA0FgaiEDIAJBIGohAiAHQQRxRQ0BCwsgCkEARwsiAkEBcUECdEEAIAJBAkcbcgJAIAZFDQAgCEF8aiEEIAZBBXQhAwJAA0AgAyAEai8BACIFQQhxIgcgBUECcUVyDQEgA0FgaiIDDQALQQIhBAwBCyAHQQBHIQQLQQIhBSAEQQFxQQN0QQAgBEECRxtyIAZBBXQhAyAIIQICQANAIANFDQEgAi8BHCIHQRJxIgoEQCADQWBqIQMgAkEgaiECIAdBEHFFDQELCyAKQQBHIQULIAVBAXFBBHRBACAFQQJHG3IhBAJ/QQIgBkUNABogCEF8aiECIAZBBXQhAwJAA0AgAiADai8BACIIQSBxIgYgCEECcUVyDQEgA0FgaiIDDQALQQIMAQsgBkEARwshAiAJQQxqIAFBCGooAAA2AAAgAEEHOgAAIAkgASkAADcABCAAIAkpAAE3AAEgAEEIaiAJQQhqKQAANwAAIAAgBCACQQFxQQV0QQAgAkECRxtyOwEcCyAJQRBqJAAL+gICCH8BfiMAQSBrIgQkAAJAAkAgAkUEQCAAQgA3AgQgAEGAvswAKAIANgIADAELAkAgAkEMbCIDQXRqQQxurSILQiCIp0UEQCABIANqIQkgAUEMaiEHIAunIQYgAkEMbCEFIAEhAwNAIAVFDQIgBUF0aiEFIAYgAygCCGoiCCAGTyADQQxqIQMgCCEGDQALC0HgvMwAQTVB4L3MABCJDAALIARBCGogBkEAEIUIIARBADYCGCAEIAQpAwg3AxAgBEEQaiABKAIAIgMgAyABKAIIahDkCCAGIAQoAhgiAWshBSAEKAIQIAFqIQMgAkEBRwRAA0AgBUUNAyAHQQhqKAIAIQEgBygCACECIANBqNPdAC0AADoAACAFQX9qIgggAUkNAyADQQFqIAIgARCJAyABaiEDIAggAWshBSAJIAdBDGoiB0cNAAsLIAAgBCkDEDcCACAAQQhqIAYgBWs2AgALIARBIGokAA8LQYq+zABBI0HwvcwAENEJAAvaCAEEfyMAQdAAayIHJAACQAJAAkACQAJAAkAgAigCAEEBaw4CAgEACyAAQQA2AgAMAwsgB0IANwIMIAdBoKvLACgCADYCCCACQQxqKAIAIQggAkEIaigCACEJIAcgAigCBCICNgIgIAcgCTYCHCAHIAI2AhggByACIAhBBHRqNgIkIAhFDQEgB0E4akEEciIIQQhqIQkDQCAHIAJBEGo2AiAgAigCACIKQQNGDQIgCCACKQIENwIAIAkgAkEMaigCADYCACAHIAo2AjggB0EoaiABIAdBOGogAyAEIAUgBhCTASAHKAIQIgIgBygCDEYEQCAHQQhqIAIQ6QggBygCECECCyAHKAIIIAJBBHRqIgogBykDKDcCACAKQQhqIAdBMGopAwA3AgAgByACQQFqNgIQIAcoAiAiAiAHKAIkRw0ACwwBCyACKAIEIQICQAJAAkACQAJAAkACQCADBEAgAUHgBGooAgAhAyABKALYBCEBIAVFBEAgAyACTQ0CIAcgASACQRRsaiIBNgIYIAEoAgBBAkcNAyABENcIIAFBAzYCACABIAQ2AgQgAEEBNgIAIAAgAjYCBAwKCyADIAJNDQMgByABIAJBFGxqIgE2AhggASgCAEECRw0EIAEQ1wggAUEANgIAIAFBAjYCBCABQQxqIAY2AgAgAUEIaiAENgIAIABBADYCAAwJCyAFRQ0GIAFB4ARqKAIAIgMgAk0NBCAHIAEoAtgEIAJBFGxqIgE2AhggASgCAEECRw0FIAEQ1wggAUEENgIAIAEgBjYCBCAAQQE2AgAgACACNgIEDAgLIAIgA0Gso8sAELAHAAsgB0HMAGpBATYCACAHQgE3AjwgB0HwpssANgI4IAdBiwE2AiwgByAHQShqNgJIIAcgB0EYajYCKCAHQThqQYinywAQ1woACyACIANBnKPLABCwBwALIAdBzABqQQE2AgAgB0IBNwI8IAdB8KbLADYCOCAHQYsBNgIsIAcgB0EoajYCSCAHIAdBGGo2AiggB0E4akH4pssAENcKAAsgAiADQbyjywAQsAcACyAHQcwAakEBNgIAIAdCATcCPCAHQfCmywA2AjggB0GLATYCLCAHIAdBKGo2AkggByAHQRhqNgIoIAdBOGpBmKfLABDXCgALIAdBsKTLAEGMARDmCyAHQcwAakEBNgIAIAdCATcCPCAHQfijywA2AjggByAHKQMANwMoIAcgB0EoajYCSCAHQThqQbikywAQ1woACyAHQRhqEPQGAkACQAJAAkAgBygCEA4CAgABCyAHQQA2AhAgBygCCCIBKAIAIgJBA0YNBCAAIAI2AgAgACABKQIENwIEIABBDGogAUEMaigCADYCAAwCCyAAIAcpAwg3AgQgAEECNgIAIABBDGogB0EQaigCADYCAAwCCyAAQQA2AgALIAdBCGoQ8AggB0EIahDLCgsgB0HQAGokAA8LQairywBBK0GMo8sAENEJAAuuCQICfwd+IwBB8AJrIgMkACADQaACaiACQQEQlQEgA0EIaiADQaACaiACEHAgA0GgAmogA0EIakEBEJUBIANBMGogA0GgAmogAhBwIANBgAFqIAEgA0EIahBwIANB0AFqIAEgA0EwahBwIANBoAJqIANB0AFqEM8CIANB+AFqIANBoAJqQSgQiQMaIANBoAJqIANB+AFqQQIQlQEgA0GoAWogA0HQAWogA0GgAmoQcCADQdgAaiADQYABaiADQagBahBwIANBoAJqIANB2ABqQQEQlQEgA0HQAWogAiADQaACahBwIANB0AFqIAEQ5gYhBCADQaACaiABQSgQiQMaIANC8P///////z8gAykDwAJ9IgZC/////////wODQvD///////8/IAMpA7gCfSIFQjOIfDcDwAIgAyAFQv////////8Dg0Lw////////PyADKQOwAn0iBUIziHw3A7gCIAMgBUL/////////A4NC8P///////z8gAykDqAJ9IgVCM4h8NwOwAiADIAVC/////////wODQtD9//////8/IAMpA6ACfSIFQjOIfDcDqAIgAyAGQjOIQhN+IAVC/////////wODfDcDoAIgA0HQAWogA0GgAmoQ5gYhAiADQaACaiABQSgQiQMaIANC8P///////z8gAykDwAJ9IgZC/////////wODQvD///////8/IAMpA7gCfSIFQjOIfDcDwAIgAyAFQv////////8Dg0Lw////////PyADKQOwAn0iBUIziHw3A7gCIAMgBUL/////////A4NC8P///////z8gAykDqAJ9IgVCM4h8NwOwAiADIAVC/////////wODQtD9//////8/IAMpA6ACfSIFQjOIfDcDqAIgAyAGQjOIQhN+IAVC/////////wODfDcDoAIgA0H4AWogA0GgAmpB0IPgABBwIANB0AFqIANB+AFqEOYGIQEgA0GgAmpB0IPgACADQdgAahBwIANCACABIAJyENoLrUL/AYN9IgYgAykDcCIFIAMpA7gChYMgBYUiBTcDcCADIAMpA3giByADKQPAAoUgBoMgB4UiBzcDeCADIAMpA1giCCADKQOgAoUgBoMgCIUiCDcDWCADIAMpA2AiCSADKQOoAoUgBoMgCYUiCTcDYCADIAYgAykDaCIGIAMpA7AChYMgBoUiCjcDaCADQfgBaiADQdgAahD2ASADIAdCACADLQD4AUEBcRDaC61C/wGDfSIGIAdC8P///////z8gB30iB0L/////////A4NC8P///////z8gBX0iC0IziHyFg4U3A3ggAyAFIAUgC0L/////////A4NC8P///////z8gCn0iBUIziHyFIAaDhTcDcCADIAVC/////////wODQvD///////8/IAl9IgVCM4h8IAqFIAaDIAqFNwNoIAMgBUL/////////A4NC0P3//////z8gCH0iBUIziHwgCYUgBoMgCYU3A2AgAyAHQjOIQhN+IAVC/////////wODfCAIhSAGgyAIhTcDWCACIARyENoLIQEgAEEIaiADQdgAakEoEIkDGiAAIAE6AAAgA0HwAmokAAvpBgIBfxR+IwBB8AFrIgMkACABKQMgIQUgASkDGCEGIAEpAxAhBCABKQMIIQcgASkDACEIA0AgA0GwAWogCCAIENYGIANBgAFqIAcgBUITfiIKENYGIANBQGsgBkITfiIJIAQQ1gYgA0HgAWogCSAGENYGIANB8ABqIAggBxDWBiADQTBqIAQgChDWBiADQeAAaiAHIAcQ1gYgA0EgaiAIIAQQ1gYgA0HQAWogCSAFENYGIANBwAFqIAogBRDWBiADQaABaiAIIAYQ1gYgA0EQaiAHIAQQ1gYgAyAEIAQQ1gYgA0GQAWogCCAFENYGIANB0ABqIAcgBhDWBiADKQOQASIOIAMpA1B8IgRCAYYiDyADKQMAfCIHIAMpA6ABIhAgAykDEHwiCEIBhiIRIAMpA8ABfCIFIAMpAyAiEiADKQPQAXwiBkIBhiITIAMpA2B8IgogAykDcCIUIAMpAzB8IglCAYYiFSADKQPgAXwiDCADKQOAASIWIAMpA0B8IgtCAYYiFyADKQOwAXwiDUIziCANIBdUrSADQbgBaikDACALIBZUrSADQYgBaikDACADQcgAaikDAHx8QgGGIAtCP4iEfHxCDYaEfCILQjOIIAsgDFStIAwgFVStIANB6AFqKQMAIAkgFFStIANB+ABqKQMAIANBOGopAwB8fEIBhiAJQj+IhHx8fEINhoR8IglCM4ggCSAKVK0gCiATVK0gA0HoAGopAwAgBiASVK0gA0EoaikDACADQdgBaikDAHx8QgGGIAZCP4iEfHx8Qg2GhHwiBkIziCAGIAVUrSAFIBFUrSADQcgBaikDACAIIBBUrSADQagBaikDACADQRhqKQMAfHxCAYYgCEI/iIR8fHxCDYaEfCIFQjOIIAUgB1StIAcgD1StIANBCGopAwAgBCAOVK0gA0GYAWopAwAgA0HYAGopAwB8fEIBhiAEQj+IhHx8fEINhoRCE34gDUL/////////A4N8IgRC/////////wODIQggC0L/////////A4MgBEIziHwhByAFQv////////8DgyEFIAZC/////////wODIQYgCUL/////////A4MhBCACQX9qIgINAAsgACAFNwMgIAAgBjcDGCAAIAQ3AxAgACAHNwMIIAAgCDcDACADQfABaiQAC/YIAQF/IwBBMGsiAiQAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAC0AAEEBaw4RAQIDBAUGBwgJCgsMDQ4PEBEACyACIAAtAAE6AAggAkEsakEBNgIAIAJCAjcCHCACQZzH4AA2AhggAkHCAzYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahC1BwwRCyACIABBCGopAwA3AwggAkEsakEBNgIAIAJCAjcCHCACQYDH4AA2AhggAkHDAzYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahC1BwwQCyACIABBCGopAwA3AwggAkEsakEBNgIAIAJCAjcCHCACQYDH4AA2AhggAkHEAzYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahC1BwwPCyACIABBCGorAwA5AwggAkEsakEBNgIAIAJCAjcCHCACQeTG4AA2AhggAkHFAzYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahC1BwwOCyACIABBBGooAgA2AgggAkEsakEBNgIAIAJCAjcCHCACQcTG4AA2AhggAkHDAjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahC1BwwNCyACIABBBGopAgA3AwggAkEsakEBNgIAIAJCATcCHCACQbDG4AA2AhggAkHVADYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahC1BwwMCyACQSxqQQA2AgAgAkHoxOAANgIoIAJCATcCHCACQaDG4AA2AhggASACQRhqELUHDAsLIAJBLGpBADYCACACQejE4AA2AiggAkIBNwIcIAJBjMbgADYCGCABIAJBGGoQtQcMCgsgAkEsakEANgIAIAJB6MTgADYCKCACQgE3AhwgAkH4xeAANgIYIAEgAkEYahC1BwwJCyACQSxqQQA2AgAgAkHoxOAANgIoIAJCATcCHCACQeTF4AA2AhggASACQRhqELUHDAgLIAJBLGpBADYCACACQejE4AA2AiggAkIBNwIcIAJBzMXgADYCGCABIAJBGGoQtQcMBwsgAkEsakEANgIAIAJB6MTgADYCKCACQgE3AhwgAkG8xeAANgIYIAEgAkEYahC1BwwGCyACQSxqQQA2AgAgAkHoxOAANgIoIAJCATcCHCACQbDF4AA2AhggASACQRhqELUHDAULIAJBLGpBADYCACACQejE4AA2AiggAkIBNwIcIAJBpMXgADYCGCABIAJBGGoQtQcMBAsgAkEsakEANgIAIAJB6MTgADYCKCACQgE3AhwgAkGQxeAANgIYIAEgAkEYahC1BwwDCyACQSxqQQA2AgAgAkHoxOAANgIoIAJCATcCHCACQfjE4AA2AhggASACQRhqELUHDAILIAJBLGpBADYCACACQejE4AA2AiggAkIBNwIcIAJB4MTgADYCGCABIAJBGGoQtQcMAQsgASAAQQRqKAIAIABBCGooAgAQtwsLIAJBMGokAAvtBwELfyMAQeAAayIEJAAgBCACQRxqIgY2AgQgBCACKAIYIgk2AgAgBEE4aiAEIAMQswQCQAJAIAQtAFwiAkEIRw0AIAFBDGohDQNAIARBOGogBBDABCAEKAI4IgtBBEcEQCAEKAJAIQogBCgCPCEHAn8CQAJAAkAgC0EBaw4DAQICAAtBACEIIAcMAgtBASEIIAcMAQsgCigCACEIIApBBGoLIQUgBCgCRCEMIAEoAhQiAiABKAIQRgRAIA0gAhCSCSABKAIUIQILIAEoAgwgAkEYbGoiAiALNgIIIAIgBjYCBCACIAk2AgAgAkEUaiAMNgIAIAJBEGogCjYCACACQQxqIAc2AgAgASABKAIUQQFqNgIUIAQgBTYCBCAEIAg2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AQILQgEhCQwBCyABQQxqKAIAIQdCAiEJCyABQQhqNQIAQiCGIQoLIAEtABQhCBCfCyEDIAJBMGogASgCEBCfASADQRhqIAJByABqKQMANwIAIANBEGogAkFAaykDADcCACADQQhqIAJBOGopAwA3AgAgAyACKQMwNwIAIAkgCoQhCUEFIQQMBAsCQAJAAkACQCABQQRqKAIAQQFrDgIBAgALIAJBADYCGCACIAFBCGooAgA2AhwMAgsgAkEYakEEciABQQhqENcHIAJBKGogAUEUaigCACIINgIAIAJBATYCGCACQSRqKAIAIQMgAkEgaigCACEHDAELIAJBAjYCGAsQnwshBiACQTBqIAEoAhgQnwEgBkEYaiACQcgAaikDADcCACAGQRBqIAJBQGspAwA3AgAgBkEIaiACQThqKQMANwIAIAYgAikDMDcCACACQRZqIAJBK2otAAA6AAAgAiACLwApOwEUIAIpAxghCUEGIQQMAwsgAkEwaiABQQRqENwEIAIoAjghByACKQMwIQlBByEEDAILIAJBMGogAUEEahDcBCACKAI4IQcgAikDMCEJQQghBAwBC0EBIQULIAAgBToAASAAIAQ6AAAgAEEUaiAIOgAAIABBEGogAzYCACAAQQxqIAc2AgAgAEEEaiAJNwIAIABBFWogAi8BFDsAACAAIAEvARw7ARwgAEEYaiAGNgIAIABBF2ogAkEWai0AADoAACACQdAAaiQAC7YHAgd/An4jAEHQAGsiAiQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBAWsOCAABAgMGBwgJCwtCACABQQhqNQIAQiCGIAFBBGoxAAAiCUIBUSIDGyAJhCABQQVqMQAAQgiGQgAgAxuEIQlBASEEDAoLAn4gAUEEaigCAEEBRwRAIAEoAgghBSACQQhqIAFBEGooAgAiAxCPByACKAIMIQcgAigCCCIGIAUgA0EDdBCJAxpCAAwBCyABKAIIIQUgAiABQRBqKAIAIgMQoAcgAigCBCEHIAIoAgAiBiAFIANBAXQQiQMaQgELIAatQiCGhCEJQQIhBAwJC0EDIQQCQCABLQABQQFrDgMIAgAJC0EDIQUMCAtBBCEEIAEtAAFBAWsOAwYAAQcLQQIhBQwGC0EDIQUMBQtCAyEJAkACQAJAAkAgAUEEaigCACIGQX1qIgNBAyADQQNJG0EBaw4DAAECAwtCBCEJDAILQgUhCQwBC0IAIQkCQAJAAkAgBkEBaw4CAAECC0IBIQkMAQsgAUEMaigCACEHQgIhCQsgAUEIajUCAEIghiEKCyABLQAUIQgQnwshAyACQTBqIAEoAhAQoAEgA0EYaiACQcgAaikDADcCACADQRBqIAJBQGspAwA3AgAgA0EIaiACQThqKQMANwIAIAMgAikDMDcCACAJIAqEIQlBBSEEDAQLAkACQAJAAkAgAUEEaigCAEEBaw4CAQIACyACQQA2AhggAiABQQhqKAIANgIcDAILIAJBGGpBBHIgAUEIahDXByACQShqIAFBFGooAgAiCDYCACACQQE2AhggAkEkaigCACEDIAJBIGooAgAhBwwBCyACQQI2AhgLEJ8LIQYgAkEwaiABKAIYEKABIAZBGGogAkHIAGopAwA3AgAgBkEQaiACQUBrKQMANwIAIAZBCGogAkE4aikDADcCACAGIAIpAzA3AgAgAkEWaiACQStqLQAAOgAAIAIgAi8AKTsBFCACKQMYIQlBBiEEDAMLIAJBMGogAUEEahDcBCACKAI4IQcgAikDMCEJQQchBAwCCyACQTBqIAFBBGoQ3AQgAigCOCEHIAIpAzAhCUEIIQQMAQtBASEFCyAAIAU6AAEgACAEOgAAIABBFGogCDoAACAAQRBqIAM2AgAgAEEMaiAHNgIAIABBBGogCTcCACAAQRVqIAIvARQ7AAAgACABLwEcOwEcIABBGGogBjYCACAAQRdqIAJBFmotAAA6AAAgAkHQAGokAAvgBgEGfyAAKAIQIQQCQAJAAkACQCAAKAIIIghBAUcEQCAEQQFGDQEgACgCGCABIAIgAEEcaigCACgCDBEFACEDDAMLIARBAUcNAQsgASACaiEHAkACQCAAQRRqKAIAIgZFBEAgASEEDAELIAEhBANAIAQiAyAHRg0CAn8gA0EBaiADLAAAIgRBf0oNABogA0ECaiAEQf8BcSIEQeABSQ0AGiADQQNqIARB8AFJDQAaIARBEnRBgIDwAHEgAy0AA0E/cSADLQACQT9xQQZ0IAMtAAFBP3FBDHRycnJBgIDEAEYNAyADQQRqCyIEIAUgA2tqIQUgBkF/aiIGDQALCyAEIAdGDQAgBC0AACIDQfABTwRAIANBEnRBgIDwAHEgBC0AA0E/cSAELQACQT9xQQZ0IAQtAAFBP3FBDHRycnJBgIDEAEYNAQsCQAJAIAVFBEBBACEEDAELIAUgAk8EQEEAIQMgBSACIgRGDQEMAgtBACEDIAUiBCABaiwAAEFASA0BCyAEIQUgASEDCyAFIAIgAxshAiADIAEgAxshAQsgCEEBRg0ADAILIABBDGooAgAhBwJAIAJFBEBBACEEDAELIAJBA3EhBQJAIAJBf2pBA0kEQEEAIQQgASEDDAELQQAhBEEAIAJBfHFrIQYgASEDA0AgBCADLAAAQb9/SmogA0EBaiwAAEG/f0pqIANBAmosAABBv39KaiADQQNqLAAAQb9/SmohBCADQQRqIQMgBkEEaiIGDQALCyAFRQ0AA0AgBCADLAAAQb9/SmohBCADQQFqIQMgBUF/aiIFDQALCyAHIARLBEBBACEDIAcgBGsiBCEFAkACQAJAQQAgAC0AICIGIAZBA0YbQQNxQQFrDgIAAQILQQAhBSAEIQMMAQsgBEEBdiEDIARBAWpBAXYhBQsgA0EBaiEDIABBHGooAgAhBCAAKAIEIQYgACgCGCEAAkADQCADQX9qIgNFDQEgACAGIAQoAhARAQBFDQALQQEPC0EBIQMgBkGAgMQARg0BIAAgASACIAQoAgwRBQANAUEAIQMDQCADIAVGBEBBAA8LIANBAWohAyAAIAYgBCgCEBEBAEUNAAsgA0F/aiAFSQ8LDAELIAMPCyAAKAIYIAEgAiAAQRxqKAIAKAIMEQUAC4sHAQZ/An8gAQRAQStBgIDEACAAKAIAIglBAXEiARshCiABIAVqDAELIAAoAgAhCUEtIQogBUEBagshBwJAIAlBBHFFBEBBACECDAELAkAgA0UEQAwBCyADQQNxIQYCQCADQX9qQQNJBEAgAiEBDAELQQAgA0F8cWshCyACIQEDQCAIIAEsAABBv39KaiABQQFqLAAAQb9/SmogAUECaiwAAEG/f0pqIAFBA2osAABBv39KaiEIIAFBBGohASALQQRqIgsNAAsLIAZFDQADQCAIIAEsAABBv39KaiEIIAFBAWohASAGQX9qIgYNAAsLIAcgCGohBwtBASEBAkACQCAAKAIIQQFHBEAgACAKIAIgAxCkCQ0BDAILAkACQAJAAkAgAEEMaigCACIGIAdLBEAgCUEIcQ0EQQAhASAGIAdrIgYhB0EBIAAtACAiCCAIQQNGG0EDcUEBaw4CAQIDCyAAIAogAiADEKQJDQQMBQtBACEHIAYhAQwBCyAGQQF2IQEgBkEBakEBdiEHCyABQQFqIQEgAEEcaigCACEIIAAoAgQhBiAAKAIYIQkCQANAIAFBf2oiAUUNASAJIAYgCCgCEBEBAEUNAAtBAQ8LQQEhASAGQYCAxABGDQEgACAKIAIgAxCkCQ0BIAAoAhggBCAFIAAoAhwoAgwRBQANASAAKAIcIQIgACgCGCEAQQAhAQJ/A0AgByABIAdGDQEaIAFBAWohASAAIAYgAigCEBEBAEUNAAsgAUF/agsgB0khAQwBCyAAKAIEIQggAEEwNgIEIAAtACAhCSAAQQE6ACAgACAKIAIgAxCkCQ0AQQAhASAGIAdrIgIhAwJAAkACQEEBIAAtACAiByAHQQNGG0EDcUEBaw4CAAECC0EAIQMgAiEBDAELIAJBAXYhASACQQFqQQF2IQMLIAFBAWohASAAQRxqKAIAIQcgACgCBCECIAAoAhghBgJAA0AgAUF/aiIBRQ0BIAYgAiAHKAIQEQEARQ0AC0EBDwtBASEBIAJBgIDEAEYNACAAKAIYIAQgBSAAKAIcKAIMEQUADQAgACgCHCEBIAAoAhghBEEAIQYCQANAIAMgBkYNASAGQQFqIQYgBCACIAEoAhARAQBFDQALQQEhASAGQX9qIANJDQELIAAgCToAICAAIAg2AgRBAA8LIAEPCyAAKAIYIAQgBSAAQRxqKAIAKAIMEQUAC6sHAQ5/IwBBIGsiAyQAAkACQCAAKAIIIglFDQAgASgCCCIKRQ0AIAEoAgAhDgNAIAcgCkkEQAJAAkACQAJAAkAgACgCCCICIAZLBEAgDiAHQQN0aiIFKAIEIgsgACgCACIMIAZBA3RqIgQoAgAiAUkNAyAEKAIEIgQgBSgCACIISQ0CIAEgCCABIAhLGyALIAQgBCALSxtLDQEgAyAENgIEIAMgATYCACAHIAogByAKSxshDQJAA0ACQCAHIA1HBEAgASAFKAIAIgIgASACSxsgBUEEaiIPKAIAIgIgBCAEIAJLG0sNAyADQQhqIAMgBRC4AyADKAIQIQECQCADKAIIIgtBgIDEAEYEQCABQYCAxABHDQEMCgsgAygCDCEMIAFBgIDEAEYEQCAMIQIgCyEBDAMLIAMoAhQhAiAAKAIIIgggACgCBEYEQCAAIAgQjwkgACgCCCEICyAAKAIAIAhBA3RqIgggDDYCBCAIIAs2AgAgACAAKAIIQQFqNgIIDAILIAMoAhQhAgwBCyANIApBnMHMABCwBwALIAMgAjYCBCADIAE2AgAgDygCACAESwRAIAIhBAwCCyAFQQhqIQUgAiEEIAogB0EBaiIHRw0ACyAKIQcLIAAoAggiBSAAKAIERgRAIAAgBRCPCSAAKAIIIQULIAAoAgAgBUEDdGoiAiAENgIEIAIgATYCACAAIAAoAghBAWo2AggMBAsgBiACQbDAzAAQsAcAC0HAwMwAQckAQYzBzAAQ0QkACyAAKAIEIAJGBH8gACACEI8JIAAoAgAhDCAAKAIIBSACC0EDdCAMaiICIAQ2AgQgAiABNgIAIAAgACgCCEEBajYCCAwBCyAHQQFqIQcMAQsgBkEBaiEGCyAGIAlJDQELCwJAIAYgCU8EQCAAKAIIIQEMAQsgBkEDdCEFIAAoAgghAQNAIAEgBksEQCAAKAIAIgQgBWoiAigCACEHIAJBBGooAgAhAiAAKAIEIAFGBH8gACABEI8JIAAoAgAhBCAAKAIIBSABC0EDdCAEaiIBIAI2AgQgASAHNgIAIAAgACgCCEEBaiIBNgIIIAVBCGohBSAGQQFqIgYgCUcNAQwCCwsgBiABQazBzAAQsAcACyABIAlJDQEgAEEANgIIIAMgCTYCCCADQRRqIAAoAgAiAiAJQQN0ajYCACADIAA2AhggAyACNgIQIAMgASAJazYCDCADQQhqEOwECyADQSBqJAAPCyAJIAFBgPXdABCyBwALzgcBA38jAEEQayIDJAACQAJAAkACQAJAAkACQAJAAkACQCACLQAEQQFrDgcBAgMEBQcGAAsgA0EIaiABQQhqKQIANwMAIAMgASkCADcDACAAIAMQjwghACABKAIARSAAQQpGciEADAgLIANBCGogAUEIaikCADcDACADIAEpAgA3AwAgACADELUJIQIgASgCACAAKAIERiACQQpGciEADAcLIAEoAgBFIQAMBgsgASgCACAAKAIERiEADAULIANBCGoiBCABQQhqIgUpAgA3AwAgAyABKQIANwMAIAAgAxCPCCECIAQgBSkCADcDACADIAEpAgA3AwAgACADELUJIQRBACEAAn9BACACQf//wwBLDQAaQQAgAkGAcHFBgLADRg0AGiACEOIJCyAEQYBwcUGAsANGIARB///DAEtyBH8gAAUgBBDiCQtzIQAMBAsgA0EIaiIEIAFBCGoiBSkCADcDACADIAEpAgA3AwAgACADEI8IIQIgBCAFKQIANwMAIAMgASkCADcDACAAIAMQtQkhBEEAIQACf0EAIAJB///DAEsNABpBACACQYBwcUGAsANGDQAaIAIQ4gkLIARBgHBxQYCwA0YgBEH//8MAS3IEfyAABSAEEOIJC3NBAXMhAAwDCyADQQhqIgQgAUEIaiIFKQIANwMAIAMgASkCADcDACAAIAMQjwghAiAEIAUpAgA3AwAgAyABKQIANwMAIAAgAxC1CSEEIAAtAAhFDQEgAkF/RgRAQQAhACABKAIADQMLIARBf0cNAUEAIQAgASgCBEF/Rw0CIAEtAAxFDQEMAgsgA0EIaiIEIAFBCGoiBSkCADcDACADIAEpAgA3AwAgACADEI8IIQIgBCAFKQIANwMAIAMgASkCADcDACAAIAMQtQkhBAJAIAAtAAhFDQAgAkF/RgRAQQAhACABKAIADQMLIARBf0cNAEEAIQAgASgCBEF/Rw0CIAEtAAwNAgtBACEBQQAhAEGAgMQAQYCAxAAgAiACQYBwcUGAsANGGyACQf//wwBLGyICQf8ATQR/IAIQ6wkFIAALQYCAxABBgIDEACAEIARBgHBxQYCwA0YbIARB///DAEsbIgJB/wBNBH8gAhDrCQUgAQtzIQAMAQtBACEBQQAhAEGAgMQAQYCAxAAgAiACQYBwcUGAsANGGyACQf//wwBLGyICQf8ATQR/IAIQ6wkFIAALQYCAxABBgIDEACAEIARBgHBxQYCwA0YbIARB///DAEsbIgJB/wBNBH8gAhDrCQUgAQtzQQFzIQALIANBEGokACAAC4cFAgp/An4jAEHwDmsiAyQAIANBCGoQpwogA0GYDWoQowYgA0GQBmoiCBCnCiADQbgEaiADQQhqQdgBEIkDGiADQegHaiADQZgNakGAARCJAyEJIANB6AhqEKQGIANBCGpBq/HBAEG38cEAELwLAkAgAygCCCIFIAMoAgwiCkcEQCADIAMoAhAiBGpB6AdqIQYgBEGAASAEQYABSxsiCyAEayEHIANB6AhqIARqIQQDQCAFLQAAIQwgB0UNAiAGIAYtAAAgDHM6AAAgBCAELQAAIAUtAABzOgAAIAdBf2ohByAEQQFqIQQgBkEBaiEGIAVBAWoiBSAKRw0ACwsgA0G4BGogCUGAARDEAyAIIANB6AhqQYABEMQDIANBCGogA0G4BGpBsAQQiQMaIANBCGogACABENgMIANBuARqIANBCGpBsAQQiQMaIANBmAZqKQMAIQ0gAykDkAYhDiADQZgNakEEciADQeQGaiADQeQHahC0AyADIANB4AZqKAIANgKYDSADQfgIaiADQaAGakHAABCJAxogA0G4CWogA0GYDWpBhAEQiQMaIAMgDTcD8AggAyAONwPoCCADQcALaiADQbgEakHYARCJAxogA0HACmoQ+wsgA0GYDWogA0HAC2pB2AEQiQMaIANBmA1qIANBwApqEM0FIANB6AhqIANBwApqQcAAEMQDIANBwAtqIANB6AhqQdgBEIkDGiADQYALahD7CyADQZgNaiADQcALakHYARCJAxogA0GYDWogA0GAC2oQzQUgA0GYDWogA0GAC2pBwAAQiQMaIAJBwAAgA0GYDWpBwABBgPXBABCICyADQfAOaiQADwsgC0GAAUGM9MEAELAHAAvkBwEMfyMAQZAFayIDJAAgAyACNgIkAkAgAS0AAUUEQCADQShqENMKDAELIANBKGogAkEmakGAAhCJAxoLIANBGGogAkEgaiIGKAIAIAMtAKcCQQFqbCIEQQEQ+gUgAygCHCEHIAMoAhghCCADQRBqIAYoAgAiBRDeBSADQQA2ArACIAMgAykDEDcDqAIgA0IANwK8AiADQezDywAoAgA2ArgCIANBqAJqIAUgA0G4AmoQggQgBigCACEFIAIoAgghCSACKAIEIQogAigCACELIAItACUhDCACLQAkIQ0CfyACKAIQRQRAIAUhBkEADAELIANBCGogAkEQahD/CSACKAIgIQYgAygCDCECIAMoAggLIQ4gA0HzAmogA0EoakGAAhCJAxogA0HgAmogBDYCACADQdwCaiAHNgIAIANB1AJqIAI2AgAgA0HsAmogA0GwAmooAgA2AgAgAyAINgLYAiADQQA6APICIAMgDDoA8QIgAyANOgDwAiADIA42AtACIANCADcDyAIgAyAFNgLEAiADIAk2AsACIAMgCjYCvAIgAyALNgK4AiADIAMpA6gCNwLkAgJAAkACQAJAIAYEQEEAIQVBACECA0AgAyACNgL4BCADKALsAiIEIAJNDQIgAygC5AIgAyADKAIkIAIQ3QkgBWogAygCACIEIAQgAygCBEEDdGoQuAggAygCJCIHQSBqKAIAIgggAygC+AQiBE0NAyADIAcoAhggBEEkbGooAhA2AvwEIAMgA0H8BGo2AowFIAMgA0H4BGo2AogFIAMgA0G4Amo2AoQFIAMgA0EkajYCgAUgByADQShqIAQgA0GABWoQ3wcgBUEMaiEFIAYgAkEBaiICRw0ACwsgA0G4AmoQswEgA0G4AmoQ0AUCQCABLQAARQRAIAMtAKcCQf8BRg0BIABBATYCBAwECyADQYAFaiADQbgCahCMAwJAIAMoAoAFIgFBAkYEQCADLQCnAkH/AUYNASAAQQM2AgQMBQsgAEEIaiADKQKEBTcCACAAIAE2AgQgAEEBNgIAAkAgAygC0AIiAEUNACAAIAMoAtQCKAIAEQMAIAMoAtQCIgAoAgRFDQAgACgCCBogAygC0AIQiQELIANB2AJqEMoKIANB7AJqKAIAIgAEQCADKALkAiECIABBDGwhBQNAIAIQxwogAkEMaiECIAVBdGoiBQ0ACwsgA0HkAmoQyQoMBQsgAEECNgIEDAMLIABBADYCBAwCCyACIARB3MPLABCwBwALIAQgCEGgxssAELAHAAsgAEEIaiADQbgCakG8AhCJAxogAEEANgIACyADQZAFaiQAC4UHAgZ/A34jAEGQAWsiAyQAAkACfwJAAkACQEEAIAEoAgBBFGotAAAiBUECRyAFQQFxG0UEQCACLQAYQQFrDgICAwELIANBIGoiBCACQRBqKQIANwMAIANBGGoiBiACQQhqKQIANwMAIAMgAikCADcDECABKAIEIQIgA0EIaiABQQhqKAIAIgFBABCFCCADKAIMIQUgAygCCCACIAEQiQMhAiAAQQxqIAE2AgAgAEEIaiAFNgIAIAAgAjYCBCAAQShqQQA6AAAgAEEBNgIAIABBEGogAykDEDcCACAAQRhqIAYpAwA3AgAgAEEgaiAEKQMANwIADAQLIAJBHGooAgAMAgsgAkEkaigCACEEQQEhBiACQRxqKAIADAELIAJBMGooAgAhByACQShqKAIAIQggAkEkaigCACEEQQIhBiACQRxqKAIACyEFIANB+ABqIAc2AgAgA0H0AGogCDYCACADQfAAaiAENgIAIAMgBTYCbCADIAY2AmggA0FAayADQegAahBZIANBEGogASACIANBQGsQgwMCQAJAAkAgAygCEEUEQCADQegAaiABIAIgAi0ANCADQRBqQQRyEI0FIAMtAIwBIgRBCEcNASADQRxqKAIARQ0CCyAAIANBEGpBLBCJAxoMAwsgA0FAayADQegAakEkEIkDGiADQT5qIgEgA0GPAWotAAA6AAAgAyADLwCNATsBPCAAQQRqIANBQGtBJBCJAxogAEEoaiAEOgAAIABBATYCACAAQSlqIAMvATw7AAAgAEEraiABLQAAOgAADAELIANB+ABqIgQgAkEQaikCADcDACADQfAAaiIGIAJBCGopAgA3AwAgAyACKQIANwNoIAEoAgQhAiADIAFBCGooAgAiAUEAEIUIIAMoAgQhBSADKAIAIAIgARCJAyECIANB0ABqIAQpAwAiCTcDACADQcgAaiAGKQMAIgo3AwAgAyADKQNoIgs3A0AgAEEMaiABNgIAIABBCGogBTYCACAAIAI2AgQgAEEQaiALNwIAIABBGGogCjcCACAAQSBqIAk3AgAgAEEoakEGOgAAIAAgAy8AaDsAKSAAQStqIANB6gBqLQAAOgAAIABBATYCAAsgAygCEEUEQCADQRhqKAIAIgBFIABBA3RFcg0BIAMoAhQQiQEMAQsgA0EYaigCAEUNACADKAIUEIkBCyADQZABaiQAC/8HAgR/BX4jAEGACWsiBCQAAkACQAJAAkACQAJAIAMEQAJ/QQQgAb0iCEL///////////8Ag1ANABogCEL/////////B4MiDEKAgICAgICACIQgCEIBhkL+////////D4MgCEI0iKdB/w9xIgUbIglCAYMhCwJAIAhCgICAgICAgPj/AIMiClBFBEAgCkKAgICAgICA+P8AUg0BQQNBAiAMUBsMAgsgBUHNd2ohBUIBIQogC6dBAXMMAQtCgICAgICAgCAgCUIBhiAJQoCAgICAgIAIUSIGGyEJQgJCASAGGyEKQct3Qcx3IAYbIAVqIQUgC6dBAXMLIQcgBCAFOwH4CCAEIAo3A/AIIARCATcD6AggBCAJNwPgCCAEIAc6APoIAn8gB0ECRgRAQQAhAkGU7eAADAELIAhCOIhCgAGDIQggAkUEQCAIQgeIpyECQZTt4ABBkO3gACAIUBsMAQtBASECQZHt4ABBkO3gACAIUBsLIQYgB0F+aiIHQQMgB0H/AXFBA0kbQf8BcUEBaw4DAgQDAQtBoe3gAEEdQcDt4AAQ0QkACyAEQQM2ApAIIARBmO3gADYCjAggBEECOwGICCAEIAI2AtQIIAQgBjYC0AggBCAEQYgIajYC2AhBASEFDAMLIARBAzYCkAggBEGV7eAANgKMCCAEQQI7AYgIIAQgAjYC1AggBCAGNgLQCCAEIARBiAhqNgLYCEEBIQUMAgsgA0GBCE9BAEF0QQUgBUEQdEEQdSIFQQBIGyAFbCIFQb/9AEsbRQRAIAMgBUEEdkEVaiIFIAUgA0sbIgVBgQhPDQMgBEGICGogBEHgCGogBEEIaiAFQYCAAhCLAQJAIAQoAogIRQRAIARB0AhqIARB4AhqIARBCGogBUGAgAIQOAwBCyAEQdgIaiAEQZAIaigCADYCACAEIAQpA4gINwPQCAsgBCAEKALQCCAEKALUCCAELwHYCCADIARBiAhqEKkCIAQgAjYC1AggBCAGNgLQCCAEIAQoAgA2AtgIIAQoAgQhBQwCC0HQ7eAAQT1BkO7gABDRCQALQQEhBSADQQFNBEAgBEEDNgKQCCAEQQI7AYgIIAQgAjYC1AggBCAGNgLQCCAEQZ7t4AA2AowIIAQgBEGICGo2AtgIDAELIARBqAhqQQI2AgAgBEGkCGpBsu7gADYCACAEQZgIaiADQX9qNgIAIARBAjsBoAggBEEAOwGUCCAEQQI2ApAIIARB4OvgADYCjAggBEECOwGICCAEIAI2AtQIIAQgBjYC0AggBCAEQYgIajYC2AhBAyEFCyAEQdwIaiAFNgIAIAAgBEHQCGoQ7gEgBEGACWokAA8LIAVBgAhBoO7gABCyBwAL/QUBDH8jAEFAaiIDJAAgA0EYakIANwMAIANBEGpCADcDACADQQhqQgA3AwAgA0IANwMAIAEgAxCtCiADQQA2AiBBnO7BACgCACEKQZTuwQAoAgAhCUGY7sEAKAIAIQsCQAJAAkACQAJAA0AgBkEDdiECAn8CQAJAAkACQAJAAn8CQAJAIAZBB3EiBUEFTwRAAn8CfyACQSBPBEBBACACQSBrIgRBIE8NAhogAyAEagwBCyABIAJqCy0AACEHQQELIQgCfwJ/IAJBAWoiBEEgTwRAQQAgBEEgayIEQSBPDQIaIAMgBGoMAQsgASAEagstAAAhDEEBCyEEIAJBAmoiAkEgSQ0BIAJBIGsiAkEgTw0HIAIgA2ohAgwGCwJ/An8gAkEgTwRAQQAgAkEgayIHQSBPDQIaIAMgB2oMAQsgASACagstAAAhBEEBCyEIIAJBAWoiAkEgSQ0BIAJBIGsiAkEgTw0DIAIgA2oMAgsgASACaiECDAQLIAEgAmoLIQ0gCA0BCyADKAIgIgENCEGA8cEAQStB8O/BABDRCQALIAQgBUEDanRB/g9xIQIgDS0AAEEFIAVrdgwDCyAEIAhxDQELIAMoAiAiAQ0FQYDxwQBBK0GA8MEAENEJAAsgAi0AAEENIAVrdiECIAcgBUEDanRB/g9xIAwgBUEbanRyCyACciECAkACQCADKAIgRQRAIAJBgBBPDQIgA0EwaiAJIAJBA3RqIgIoAgAgAigCBBCzCSADKAIgBEAgA0EgahCkCwsgA0EoaiADQThqKAIANgIAIAMgAykDMDcDIAwBCyADQSBqIAsgChDnCyACQf8PSw0DIANBIGogCSACQQN0aiICKAIAIAIoAgQQ5wsLIAZBC2oiBkGIAkYNAwwBCwsgAkGAEEGg8MEAELAHAAsgAkGAEEGQ8MEAELAHAAsgAygCICIBRQ0BCyAAIAE2AgQgAEEANgIAIABBCGogAykCJDcCAAwBC0GA8cEAQStB4O/BABDRCQALIANBQGskAAv6BgEDfyMAQeAAayICJAACQAJAAkAgACgCACIDQXdqQQVJIANBIEZyDQAgA0GAAU8EQCADEPgCDQELIAMQxQtFDQELIAJBzABqQQE2AgAgAkIBNwI8IAJBkN/dADYCOCACQewCNgIsIAIgAzYCUCACIAJBKGo2AkggAiACQdAAajYCKCACQRhqIAJBOGoQ/wEMAQsgAkEANgI4IAJBEGoCfwJAAkAgA0GAAU8EQCADQYAQSQ0BIANBgIAETw0CIAIgA0E/cUGAAXI6ADogAiADQQx2QeABcjoAOCACIANBBnZBP3FBgAFyOgA5QQMMAwsgAiADOgA4QQEMAgsgAiADQT9xQYABcjoAOSACIANBBnZBwAFyOgA4QQIMAQsgAiADQT9xQYABcjoAOyACIANBEnZB8AFyOgA4IAIgA0EGdkE/cUGAAXI6ADogAiADQQx2QT9xQYABcjoAOUEECyIDQQAQhQggAiACKAIUNgIcIAIgAigCECIENgIYIAQgAkE4aiADEIkDGiACIAM2AiALAkACQAJAIAAoAgQiAEF3akEFSSAAQSBGcg0AIABBgAFPBEAgABD4Ag0BCyAAEMULRQ0BCyACQcwAakEBNgIAIAJCATcCPCACQZDf3QA2AjggAkHsAjYCVCACIAA2AlwgAiACQdAAajYCSCACIAJB3ABqNgJQIAJBKGogAkE4ahD/AQwBCyACQQA2AjggAkEIagJ/AkACQCAAQYABTwRAIABBgBBJDQEgAEGAgARPDQIgAiAAQT9xQYABcjoAOiACIABBDHZB4AFyOgA4IAIgAEEGdkE/cUGAAXI6ADlBAwwDCyACIAA6ADhBAQwCCyACIABBP3FBgAFyOgA5IAIgAEEGdkHAAXI6ADhBAgwBCyACIABBP3FBgAFyOgA7IAIgAEESdkHwAXI6ADggAiAAQQZ2QT9xQYABcjoAOiACIABBDHZBP3FBgAFyOgA5QQQLIgBBABCFCCACIAIoAgw2AiwgAiACKAIIIgM2AiggAyACQThqIAAQiQMaIAIgADYCMAsgAiABQZjf3QBBERCLCzcDOCACQThqQanf3QBBBSACQRhqQbDf3QAQ8AJBwN/dAEEDIAJBKGpBsN/dABDwAhD5BiACKAIsBEAgAigCKBCJAQsgAigCHARAIAIoAhgQiQELIAJB4ABqJAAL2AYBBn8jAEEgayIGJAACQAJAAkACQAJAIAIEQCAAQQhqIQkDQCAGQQhqQSQgASACEL0CIAYoAghFDQICQAJAAkAgBigCDCIEBEAgAiAESw0BIAIgBEcNAgsgAyABIAQQ5wsMAgsgASAEaiIFLAAAQb9/TA0AIAMgASAEEOcLIAUsAABBv39KDQEgASACIAQgAkGE2ssAEIwBAAsgASACQQAgBEH02csAEIwBAAsgASAEaiIFQQFqIQECQAJAAkACQAJAIAIgBGsiAkECTwRAIAEtAABBJEYNAQsgBkEQaiAFIAIQ4QEgBigCECIHQQJGDQEgBigCGCEIIAYoAhQhBCAGKAIcIgFFDQMgAiABSw0CIAEgAkYNAwwKCyADQZTaywBBARDnCyACQQNPBEAgBSwAAkG/f0wNCAsgAkF+aiECIAVBAmohAQwDCyADQZTaywBBARDnCwJAIAJBAU0EQCACQQFGDQEMCQsgASwAAEG/f0wNCAsgAkF/aiECDAILIAEgBWosAABBv39MDQcLIAIgAWshAiABIAVqIQEgB0UEQCAGQRBqIAAgBCAIEPkDIAMCf0EAIAYoAhAiCEUNABogBigCFCEHIAYoAhwiBSAGKAIYIgRJDQkCQCAERQ0AIAQgB08EQCAEIAdGDQEMCwsgBCAIaiwAAEFASA0KCwJAIAVFDQAgBSAHTwRAIAUgB0cNCwwBCyAFIAhqLAAAQb9/TA0KCyAFIARrIQUgBCAIagsiBEG42ssAIAQbIAVBACAEGxDnCwwBCyAGQRBqIAkgBBCxBiADAn9BACAGKAIQQQFHDQAaIAAoAgQhByAAKAIAIQggBigCGCIFIAYoAhQiBEkNCAJAIARFDQAgBCAHTwRAIAQgB0YNAQwKCyAEIAhqLAAAQUBIDQkLAkAgBUUNACAFIAdPBEAgBSAHRw0KDAELIAUgCGosAABBv39MDQkLIAUgBGshBSAEIAhqCyIEQbjaywAgBBsgBUEAIAQbEOcLCyACDQALC0EAIQILIAMgASACEOcLIAZBIGokAA8LIAUgAkECIAJBmNrLABCMAQALIAUgAkEBIAJBuNrLABCMAQALIAUgAiABIAJBqNrLABCMAQALIAggByAEIAVBzN3LABCMAQALiQcBBn8CQAJAAkAgAkEJTwRAIAMgAhDMAiICDQFBAA8LQQAhAkGAgHxBCEEIEMQLQRRBCBDEC2pBEEEIEMQLamtBd3FBfWoiAUEAQRBBCBDEC0ECdGsiBSAFIAFLGyADTQ0BQRAgA0EEakEQQQgQxAtBe2ogA0sbQQgQxAshBSAAEPMMIgEgARDeDCIGEPAMIQQCQAJAAkACQAJAAkACQCABEIMMRQRAIAYgBU8NASAEQaSY4QAoAgBGDQIgBEGgmOEAKAIARg0DIAQQ9QsNByAEEN4MIgcgBmoiCCAFSQ0HIAggBWshBiAHQYACSQ0EIAQQsgMMBQsgARDeDCEEIAVBgAJJDQYgBCAFQQRqT0EAIAQgBWtBgYAISRsNBSABKAIAIgYgBGpBEGohByAFQR9qQYCABBDECyEEQQAiBUUNBiAFIAZqIgEgBCAGayIAQXBqIgI2AgQgASACEPAMQQc2AgQgASAAQXRqEPAMQQA2AgRBqJjhAEGomOEAKAIAIAQgB2tqIgA2AgBBxJjhAEHEmOEAKAIAIgIgBSAFIAJLGzYCAEGsmOEAQayY4QAoAgAiAiAAIAIgAEsbNgIADAkLIAYgBWsiBEEQQQgQxAtJDQQgASAFEPAMIQYgASAFEMUKIAYgBBDFCiAGIAQQ+AEMBAtBnJjhACgCACAGaiIGIAVNDQQgASAFEPAMIQQgASAFEMUKIAQgBiAFayIFQQFyNgIEQZyY4QAgBTYCAEGkmOEAIAQ2AgAMAwtBmJjhACgCACAGaiIGIAVJDQMCQCAGIAVrIgRBEEEIEMQLSQRAIAEgBhDFCkEAIQRBACEGDAELIAEgBRDwDCIGIAQQ8AwhByABIAUQxQogBiAEELQLIAcgBygCBEF+cTYCBAtBoJjhACAGNgIAQZiY4QAgBDYCAAwCCyAEQQxqKAIAIgkgBEEIaigCACIERwRAIAQgCTYCDCAJIAQ2AggMAQtBiJXhAEGIleEAKAIAQX4gB0EDdndxNgIACyAGQRBBCBDEC08EQCABIAUQ8AwhBCABIAUQxQogBCAGEMUKIAQgBhD4AQwBCyABIAgQxQoLIAENAwsgAxBAIgVFDQEgBSAAIAMgARDeDEF4QXwgARCDDBtqIgEgASADSxsQiQMgABCJAQ8LIAIgACADIAEgASADSxsQiQMaIAAQiQELIAIPCyABEIMMGiABEPIMC+YGAQl/IwBB8ABrIgEkACABQRhqQQhBABD6BSABQgA3AyAgASABKQMYNwMoIAEgACgCAC0ABwR/IAFBOGpCADcDAEEBBUEACzYCMCABQQA7AUAgAUEQaiABQUBrENEKIAFBMGpBBHIhByABLQAQQQFxBEAgAS0AESECIABB9ARqKAIAIQQgACgC1AQiA0EkbCEFA0ACQCAEIANLBEAgACgC7AQgBWogAhDyBSICIANGDQEgASACNgJQAkAgASgCMEEBRw0AIAEoAjgiBkUNACABQeAAaiABKAI0IAYgAUHQAGoQ+QQgASgCYEEBRg0AIAEoAmgNAgsgAUEgaiACEOIHIAEoAjBBAUcNASAHIAIQ3gcMAQsgAyAEQcDGywAQsAcACyABQQhqIAFBQGsQ0QogAS0ACSECIAEtAAhBAXENAAsLIAEoAiAiAiABKAIkRwRAIABB1ARqIQkDQCABIAEoAixBf2ogAkEBanE2AiAgASgCKCACQQJ0aigCACEAIAFBADYCSCABIAA2AkQgASAJNgJAIAFB0ABqIAFBQGsQzAMCQCABKAJQQQFHDQACQAJAAkADQAJAIAEtAFQhBiABIAEoAlgiBDYCXAJAAkAgASgCMEEBRw0AIAEoAjgiAkUNACABQeAAaiABKAI0IAIgAUHcAGoQ+QQgASgCYEEBRg0AIAEoAmgNAQsgAUEgaiAEEOIHIAEoAjBBAUYEQCAHIAQQ3gcLIAEoAkAhAyAAIQIDQCADKAIgIgUgAk0NAiAFIAMoAhgiCCACQSRsaigCECICTQ0EIAggAkEkbCIFaiAGEPIFRQ0ACyADKAIgIgggAk0NBCADKAIYIAVqIAYQ8gUhAiADKAIgIgUgBE0NBSADKAIYIARBJGxqIAI2AhAgAyACIAQQ2AgLIAFB0ABqIAFBQGsQzAMgASgCUEEBRg0BDAULCyACIAVBwMbLABCwBwALIAIgBUHAxssAELAHAAsgAiAIQcDGywAQsAcACyAEIAVB0MbLABCwBwALIAEoAkAiAiACKAIAIAAQ2AggASgCICICIAEoAiRHDQALCyACIQAgASgCMARAIAcQ3wYgASgCICECIAEoAiQhAAsgAUHgAGogASgCKCABKAIsIAAgAhCnBiABQShqEMoKIAFB8ABqJAALvQgBA38jAEFAaiIEJAACQAJAAkACQAJAAkAgAC0AAEEBaw4DAQIDAAsgBCAAQQRqKAIANgIEQRRBARDkCyIARQ0EIABBEGpByM/gACgAADYAACAAQQhqQcDP4AApAAA3AAAgAEG4z+AAKQAANwAAIARClICAgMACNwIMIAQgADYCCCAEQTxqQQI2AgAgBEEkakHIAzYCACAEQgM3AiwgBEHQzeAANgIoIARByQM2AhwgBCAEQRhqNgI4IAQgBEEEajYCICAEIARBCGo2AhggASAEQShqELUHIQAgBCgCDEUNAyAEKAIIIgFFDQMgARCJAQwDC0GyzeAAIQJBECEDAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAtAAFBAWsOKAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicpC0GhzeAAIQJBESEDDCgLQY/N4AAhAkESIQMMJwtB/8zgACECDCYLQe/M4AAhAgwlC0HczOAADCMLQcrM4AAhAkESIQMMIwtBvczgACECQQ0hAwwiC0GvzOAAIQJBDiEDDCELQZrM4AAhAkEVIQMMIAtBjszgACECQQwhAwwfC0GDzOAAIQJBCyEDDB4LQe7L4AAhAkEVIQMMHQtB2cvgACECQRUhAwwcC0HKy+AAIQJBDyEDDBsLQbzL4AAhAkEOIQMMGgtBqcvgAAwYC0GDy+AAIQJBJiEDDBgLQcvK4AAhAkE4IQMMFwtBssrgACECQRkhAwwWC0GbyuAAIQJBFyEDDBULQY/K4AAhAkEMIQMMFAtBhsrgACECQQkhAwwTC0H8yeAAIQJBCiEDDBILQezJ4AAhAgwRC0HVyeAAIQJBFyEDDBALQbzJ4AAhAkEZIQMMDwtBrsngACECQQ4hAwwOC0GhyeAAIQJBDSEDDA0LQY3J4AAhAkEUIQMMDAtBhcngACECQQghAwwLC0HqyOAAIQJBGyEDDAoLQdzI4AAhAkEOIQMMCQtBy8jgACECQREhAwwIC0G1yOAAIQJBFiEDDAcLQaDI4AAhAkEVIQMMBgtBlcjgACECQQshAwwFC0H/x+AAIQJBFiEDDAQLQfLH4AAhAkENIQMMAwtB58fgACECQQshAwwCC0HUx+AACyECQRMhAwsgBEE8akEBNgIAIAQgAzYCHCAEIAI2AhggBEHKAzYCDCAEQgE3AiwgBEHMx+AANgIoIAQgBEEYajYCCCAEIARBCGo2AjggASAEQShqELUHIQAMAgsgAEEEaigCACIAKAIAIAAoAgQgARDkDCEADAELIABBBGooAgAiACgCACABIAAoAgQoAhARAQAhAAsgBEFAayQAIAAPC0EUQQEQ4gwAC7wGAQZ/IwBB0ABrIggkAAJ/AkACQCABKAIARQRAIAFBfxDfCyABQYwDaiEJIAFBCGohCwJ/QQAgBSgCBCIKIAZNDQAaIAUoAgAgBmotAAAhDUEBIQwgBiEKQQELIQYgCEEkaiAENgIAIAhBHGpBATYCACALQYwDakEANgIAIAhBFGogBUEIaigCADYCACAIIAUpAgA3AgwgCCAJNgIoIAggAzYCICAIIAI2AhggCEEQaigCACEDIAggADYCCAJ/IAsoApgDIgIgAEH4A2ooAgAgA0EBamxBH2pBBXYiA08EQCALIAM2ApgDIAMhAgtBACACRQ0AGiALKAKQA0EAIAJBAnQQkQUaIAsoApgDCyECAkAgAyACTQ0AIAtBkANqIAIgAyACayIEEIoIIARFDQAgAkF/cyADaiECA0AgCUEUaigCACIAIAlBEGooAgBGBEAgCUEMaiAAEOsIIAkoAhQhAAsgCSgCDCAAQQJ0akEANgIAIAkgCSgCFEEBajYCFCACBEAgAkF/aiECIAgoAighCQwBCwsgCCgCCCEACyAALQCwBA0CIAhBCGpBBHIhA0EAIQIDQAJ/IAAQ9AhFBEAgDSEFQX8MAQsgCCgCCCEAIAggDToATSAIIAw6AEwgCCAGNgJIIAhBfzYCRCAIIAo2AkAgCEEwaiADIAAgCEFAaxDOASAILQA8IgxBAkYNAyAILwE+IQkgCC0APSEFIAgoAjghBiAIKAIwIQogCCgCNAshACAIIAk7AU4gCCAFOgBNIAggDDoATCAIIAY2AkggCCAANgJEIAggCjYCQCAIQQhqIAhBQGsQeiACciICQQFxBEBBASAIKAIIQYQEaigCAEEBRg0FGgsgCiAHTw0CIAYgCmohCUEAIQYgCCgCCCEAIAgoAhAiCiAJSwRAIAgoAgwgCWotAAAhDSAJIQpBASEGCyAGIQwMAAsAC0G06MsAQRAgCEEIakHU6csAQcDjywAQ8wYACyACDAELQQAgCg0AGiAIQc0AaiANOgAAIAggDDoATCAIIAY2AkggCEKAgICAcDcDQCAIQQhqIAhBQGsQegsgASABKAIAQQFqEN8LIAhB0ABqJABBAXEL8wUBDn8jAEEQayIIJAAgACAAKAIAQQFqNgIAAkAgAkUgAEEQaigCAEEDS3INACAAQQRqIgMgAS0AACIEEJwIIABBFmotAABFDQAgAyAEQb9/akH/AXFBGk8EfyAEQV9xIAQgBEGff2pB/wFxQRpJGwUgBEEgcgsQnAgLAkAgAEGfBGotAABFDQACQAJAIAAoAhgiCkEDTQRAIAJB/wFLDQEgAkUNAyABLQAAIQMgCCABIAEgAmoQvAsgAEEeai0AACEMAkAgCCgCACIGIAgoAgQiDUYEQCADIQQMAQsgA0H0/MsAai0AACELIAgoAgghBSADIQQDQCAFQYACIAVBgAJLGyEOQQAhCQNAIAUgDkYNBSAAIAYtAAAiA2oiD0GfAmoiByAHLQAAIgcgBSAHIAVB/wFxIhBLGzoAACAMBEAgA0G/f2pB/wFxQRpPBH8gA0HfAXEgAyADQZ9/akH/AXFBGkkbBSADQSByCyAAakGfAmoiByAHLQAAIgcgBSAHIBBLGzoAAAsCQCAJRQRAIA9BH2otAABFDQELQQEhCSAFQQFqIQUgBkEBaiIGIA1HDQEMBwsLIAMgBCADQfT8ywBqLQAAIgMgC0H/AXFJIgkbIQQgAyALIAkbIQsgBUEBaiEFIAZBAWoiBiANRw0ACyAEQf8BcSEDCyAAIANqQR9qIgUtAAAgBUEBOgAARQRAIAAgCkEBaiIKNgIYIABBHGoiBSAFLwEAIANB9PzLAGotAABqOwEACyAMRQ0DIAAgBEG/f2pB/wFxQRpPBH8gBEFfcSAEIARBn39qQf8BcUEaSRsFIARBIHILQf8BcSIEakEfaiIDLQAAIANBAToAAA0DIAAgCkEBajYCGCAAQRxqIgMgAy8BACAEQfT8ywBqLQAAajsBAAwDCyAAQQA6AJ8EDAILIABBADoAnwQMAQtBxIDMAEErQaT7ywAQ0QkACyAAQcgEai0AAEECRwRAIABBoARqIAEgAhDRBQsgCEEQaiQAC4EGAgd/AX4CQCACRQ0AQQAgAkF5aiIEIAQgAksbIQggAUEDakF8cSABayEJQQAhBAJAAkADQAJAAkACQCABIARqLQAAIgZBGHRBGHUiB0EATgRAIAkgBGtBA3EgCUF/RnINAQJAIAQgCE8NAANAIAEgBGoiBSgCACAFQQRqKAIAckGAgYKEeHENASAEQQhqIgQgCEkNAAsLIAQgAk8NAgNAIAEgBGosAABBAEgNAyACIARBAWoiBEcNAAsMBwtCASEKQQEhBQJAAkACQAJAAkACQAJAAkACQCAGQcf54ABqLQAAQX5qDgMAAQIOCyAEQQFqIgMgAkkNBkEAIQVCACEKDA0LQQAhBUIAIQogBEEBaiIDIAJPDQwgASADai0AACEDIAZBoH5qIgZFDQEgBkENRg0CDAMLQQAhBUIAIQogBEEBaiIDIAJPDQsgASADai0AACEDAkACQAJAAkAgBkGQfmoOBQEAAAACAAsgA0EYdEEYdUF/SiAHQQ9qQf8BcUECS3IgA0HAAU9yDQ0MAgsgA0HwAGpB/wFxQTBPDQwMAQsgA0EYdEEYdUF/SiADQY8BS3INCwsgBEECaiIDIAJPDQsgASADaiwAAEG/f0oNCCAEQQNqIgMgAk8NCyABIANqLAAAQb9/TA0FQgMhCkEBIQUMCwsgA0HgAXFBoAFHDQkMAgsgA0EYdEEYdUF/SiADQaABT3INCAwBCyAHQR9qQf8BcUEMTwRAIAdBfnFBbkcgA0EYdEEYdUF/SnIgA0HAAU9yDQgMAQsgA0EYdEEYdUF/SiADQb8BS3INBwsgBEECaiIDIAJPDQcgASADaiwAAEG/f0oNBAwBCyABIANqLAAAQb9/Sg0FCyADQQFqIQQMAQsgBEEBaiEECyAEIAJJDQEMBAsLQgIhCkEBIQUMAQtCASEKQQEhBQsgACAENgIEIABBC2pBADoAACAAQQlqIAo9AAAgAEEIaiAFOgAAIABBATYCAA8LIAAgATYCBCAAQQhqIAI2AgAgAEEANgIAC+QGAQZ/IwBBoANrIgEkAAJAAkACQAJAAkACQCAAKAIADgoFBQUFBQUAAQIDBAsgAEFAaygCACgCAEEETQ0EDAMLIABByABqKAIAKAIAQQRLDQIMAwsgAEEkaigCAA0BDAILIABBJGooAgBFDQELAkACQEGEAUEEEOQLIgMEQCADIABBhAEQiQMhBCAAQRhqQQA2AgAgAEEQakIANwIAIABBCGpCADcCACAAQgA3AgAgAUIBNwIEIAEgBDYCACAEKAIAIQAgAUEQaiAEQQRqQYABEIkDGiAAQQpGDQEgAUGQAWpBBHIhBSABQawBaiEEA0AgASAANgKQASAFIAFBEGpBgAEQiQMaAkACQAJAAkACQCAAQQZrDgQBAgADBAsgASgCtAEhACABQQA2ArQBIAEoAqwBIQIgASAENgKoAiABIAIgAEGEAWxqNgKkAiABIAI2AqACIAFBADYCnAIgASAANgKYAiABIAFBmAJqEM4DDAMLIAFBmAJqIAEoAtABIgBBhAEQiQMaIABCADcCACAAQRhqQQA2AgAgAEEQakIANwIAIABBCGpCADcCACABKAIEIAJGBEAgASACEIgJIAEoAgAhAyABKAIIIQILIAMgAkGEAWxqIAFBmAJqQYQBEIkDGiABIAJBAWo2AggMAgsgAUGYAmogASgC2AEiAEGEARCJAxogAEIANwIAIABBGGpBADYCACAAQRBqQgA3AgAgAEEIakIANwIAIAEoAgQgAkYEQCABIAIQiAkgASgCACEDIAEoAgghAgsgAyACQYQBbGogAUGYAmpBhAEQiQMaIAEgAkEBajYCCAwBCyABKAK0ASEAIAFBADYCtAEgASgCrAEhAiABIAQ2AqgCIAEgAiAAQYQBbGo2AqQCIAEgAjYCoAIgAUEANgKcAiABIAA2ApgCIAEgAUGYAmoQzgMLIAFBkAFqEMACIAEoAggiAEUNAyABIABBf2oiAjYCCCABKAIAIgMgAkGEAWxqIgYoAgAhACABQRBqIAZBBGpBgAEQiQMaIABBCkcNAAsMAQtBhAFBBBDiDAALIAJFDQAgAkGEAWwhAANAIAMQhgMgA0GEAWohAyAAQfx+aiIADQALCyABKAIEIgBFIABBhAFsRXINACABKAIAEIkBCyABQaADaiQAC6EGAQ1/IwBBIGsiBiQAAkACQAJAIAAtADpFBEAgACgCDCICQQJJDQMgACgCACIBIAJPDQIgAEE0aigCACIFIAEgBSABSxshAyAAKAIsIAFBDGxqQQhqIQQDQCABIANGDQIgBCgCAEUNAyAEQQxqIQQgAiABQQFqIgFHDQALIAIhAQwCC0GMwssAQTBBvMLLABDoCgALIAMgBUHMwssAELAHAAsgBkEIaiACQQEQ+gUgBiACNgIYIAYgBigCDDYCFCAGIAYoAggiCjYCEAJAIAJBf2oiAyABSwRAIAAoAiwiC0EUaiEJIABBNGooAgAhBwJAAkACQAJAA0AgByADSwRAAkAgCyADQQxsaigCCEUNACAAIAMgARCQAyACIANNDQMgCiADQQJ0aiABNgIAIAIgAU0NBCAKIAFBAnRqIAM2AgAgAyABQQFqIgggAyAISxshBSAJIAFBDGxqIQQDQCABQQFqIgEgA08EQCAFIQEMAgsgByABTQ0GIAQoAgAgBEEMaiEEDQALCyADQX9qIgMgAUsNAQwFCwsgAyAHQdzCywAQsAcACyADIAJB7MLLABCwBwALIAEgAkH8wssAELAHAAsgByAIIAcgCEsbIAdBjMPLABCwBwALIAAoAgwhAgsgAkUEQCAGKAIYIQcMAQsgAEG6AmotAAAiBUEBaiEKIAVBAnRBBGohAyAAQShqKAIAIQsgACgCICEMQQAhCCAGKAIQIQ0gBigCGCEHA0ACQCAIIApsIgUgCmoiBCAFTwRAIAsgBE8EQCAIQQFqIQggDCAFQQJ0aiEEIAMhBQNAAkAgByAEKAIAIglLBEAgDSAJQQJ0aigCACIJRQ0BIAQgCTYCAAwBCyAJIAdBrMPLABCwBwALIARBBGohBCAFQXxqIgUNAAsMAgsgBCALQZzDywAQsgcACyAFIARBnMPLABCzBwALIAIgCEcNAAsLAkAgByAAKAIAIgJLBEAgBigCECACQQJ0aigCACICRQ0BIAAgAjYCAAwBCyACIAdBvMPLABCwBwALIAAgAUF/ajYCECAGQRBqEMoKCyAGQSBqJAALqwYBDX8jAEHQAGsiBCQAIAQgAkEcaiIJNgIEIAQgAigCGCIKNgIAIARBEGogBCADEJYFAkACQCAEKAIQIgJBIEcNACABQQxqIQ8DQCAEQRBqIAQQwAQgBCgCECILQQRHBEAgBCgCGCEIIAQoAhQhBwJ/AkACQAJAIAtBAWsOAwECAgALQQAhBSAHDAILQQEhBSAHDAELIAgoAgAhBSAIQQRqCyEGIAQoAhwhDSABKAIUIgIgASgCEEYEQCAPIAIQkgkgASgCFCECCyABKAIMIAJBGGxqIgIgCzYCCCACIAk2AgQgAiAKNgIAIAJBFGogDTYCACACQRBqIAg2AgAgAkEMaiAHNgIAIAEgASgCFEEBajYCFCAEIAY2AgQgBCAFNgIAIARBEGogBCADEJYFIAUhCiAGIQkgBCgCECICQSBGDQEMAgsgBEEQaiAEIAMQ1QYgBCgCECICQSBGBEAgBAJ/AkACQANAAkAgASgCFCICBEAgASACQX9qIgw2AhQgASgCDCIOIAxBGGxqIgUoAgAiCEECRw0BCyAAQSA2AgAMCAsgBUEUaigCACEHIAVBEGooAgAhAiAFKAIIIQkgBUEMaigCACEGIAQgBSgCBCINNgIMIAQgCDYCCAJAAkAgCUEBaw4DAQQBAAsgBw0CCyAEQRBqIARBCGogAxDVBiAEKAIQIgJBIEYNAAsgAEEEaiAEQRBqQQRyQTwQiQMaIAAgAjYCAAwGCyACQdwAaiEFIAdBf2ohEEEAIQtBACEKIAIMAQsgBygCACEKQQMhCyAGIQIgByIFQQRqCyIJNgIEIAQgCjYCACABKAIQIAxGBEAgDyAMEJIJIAEoAhQhDCABKAIMIQ4LIA4gDEEYbGoiBiALNgIIIAYgDTYCBCAGIAg2AgAgBkEUaiAQNgIAIAZBEGogBTYCACAGQQxqIAI2AgAgASABKAIUQQFqNgIUIARBEGogBCADEJYFIAQoAhAiAkEgRg0BDAILCyAAQQRqIARBEGpBBHJBPBCJAxogACACNgIADAELIABBBGogBEEQakEEckE8EIkDGiAAIAI2AgALIARB0ABqJAALtgYBAX8jAEGAFGsiBCQAIARBCGogAUEFEO4CIARBiAJqIANBCBDuAkH/ASEBA0ACQCABIgMgBEEIamotAAANACAEQYgCaiADai0AAA0AIANBf2ohASADDQELCyAEQYgEaiACEPwDIARBiA5qQQBBKBCRBRogBEG4DmpCADcDACAEQcAOakIANwMAIARByA5qQgA3AwAgBEHQDmpCADcDACAEQeAOakIANwMAIARB6A5qQgA3AwAgBEHwDmpCADcDACAEQfgOakIANwMAIARCATcDsA4gBEIBNwPYDgNAIARBgA9qIARBiA5qEPoCAkACQAJAAkACQCAEQQhqIANqLAAAIgFBAU4EQCABQf8BcSICQQF2IQEgBEHAEWogBEGAD2oQ0AkgAkEQTw0CIARB4BJqIARBiARqIAFBoAFsakGgARCJAxogBEGgEGogBEHAEWogBEHgEmoQxQIgBEGAD2ogBEGgEGpBoAEQiQMaDAELIAFBf0oNAEEAIAFrIgJBGHRBGHVBAXYhASAEQcARaiAEQYAPahDQCSACQf8BcUEQTw0CIARB4BJqIARBiARqIAFBoAFsakGgARCJAxogBEGgEGogBEHAEWogBEHgEmoQxgIgBEGAD2ogBEGgEGpBoAEQiQMaCyAEQYgCaiADaiwAACIBQQFOBEAgBEHgEmogBEGAD2oQ0AkgBEGgEGogAUH+AXFBAXZB+ABsQfiD4ABqQfgAEIkDGiAEQcARaiAEQeASaiAEQaAQahDhAiAEQYAPaiAEQcARakGgARCJAxoMBAsgAUF/Sg0DQQAgAWtBGHRBGHUiAkEBdiEBIARB4BJqIARBgA9qENAJIAJBf0wNAiAEQaAQaiABQfgAbEH4g+AAakH4ABCJAxogBEHAEWogBEHgEmogBEGgEGoQ4gIgBEGAD2ogBEHAEWpBoAEQiQMaDAMLIAFBCEGgweAAELAHAAsgAUEIQaDB4AAQsAcACyABQcAAQbDB4AAQsAcACyAEQeASaiAEQYAPahCfCiAEQYgOaiAEQeASakH4ABCJAxogAwRAIANBf2ohAwwBBSAAIARBiA5qEPUJIARBgBRqJAALCwuFBgEDfyMAQZACayICJAAgAkEYaiIDQcAANgIEIAMgATYCAAJAIAIoAhxBwABGBEAgAigCGCEBIAJBOGpCADcDACACQTBqQgA3AwAgAkEoakIANwMAIAJCADcDICACQdgAakIANwMAIAJB0ABqIgNCADcDACACQcgAaiIEQgA3AwAgAkIANwNAIAJBIGpBICABQSBBpP/fABCICyACQUBrQSAgAUEgakEgQbT/3wAQiAsCQAJAIAItAF8iAUEPTQRAIAJBvwFqIAJB1wBqKQAANwAAIAJBuAFqIAMpAwA3AwAgAkGwAWogBCkDADcDACACIAIpA0A3A6gBIAIgAToAxwEgAkGAAWpBAXIgAkGoAWoQrgkMAQsgAkG/AWogAkHXAGopAAA3AAAgAkG4AWogAykDADcDACACQbABaiAEKQMANwMAIAIgAikDQDcDqAEgAiABOgDHASACQegBaiACQagBahD8BCACLQDoAUEBRw0BIAJBmQFqIAJBgQJqKQAANwAAIAJBkQFqIAJB+QFqKQAANwAAIAJBiQFqIAJB8QFqKQAANwAAIAIgAikA6QE3AIEBCyACQfgAaiIBIAJBmQFqKQAANwMAIAJB8ABqIgMgAkGRAWopAAA3AwAgAkHoAGoiBCACQYkBaikAADcDACACIAIpAIEBNwNgIAJBwAFqIAJBOGopAwA3AwAgAkG4AWogAkEwaikDADcDACACQbABaiACQShqKQMANwMAIAIgAikDIDcDqAEgAkHQAWogBCkDADcDACACQdgBaiADKQMANwMAIAJB4AFqIAEpAwA3AwAgAiACKQNgNwPIASAAQQFqIAJBqAFqQcAAEIkDGiAAQQA6AAAMAgsgAkEBNgKoASACQQhqIAJBqAFqELgKIABBBGogAikDCDcCACAAQQE6AAAMAQsgAkGwAWpCiYCAgIAINwMAIAJBuP7fADYCrAEgAkECNgKoASACQRBqIAJBqAFqELgKIABBBGogAikDEDcCACAAQQE6AAALIAJBkAJqJAAL8AUBBn8jAEHQAGsiAyQAAkAgASgCACIELQCvBEUEQCADQQhqIAIQ6wogAygCDCEBIAMoAgghBiADQQA2AiACQCABIAZGBEBBfyECDAELIARB7ARqIQcgAUF+aiEBQX8hAgNAIAMgByACrSABMQAAQiCGhCABQQFqIgUxAABCKIaEIAQoAuAEEMsDAkAgAygCAEEBRgRAIAMoAgQhAgwBCyAFLQAAIQUgAS0AACIIBEAgBCAIakGPBWpBAToAAAsgBCAFakGQBWpBAToAAAJAIAJBf0cEQCADIAEvAAA7AUggA0EGNgJAIAMgAjYCRCAEIANBQGsQ0QcMAQsgAyABLwAAOwBBIANBBDoAQCADQTBqIAQgA0FAaxD7BiADQSBqEJ4LIANBKGogA0E4aikDADcDACADIAMpAzA3AyALIAQoAuAEIgVBf2oiAiAFTQ0AQairywBBK0HQqMsAENEJAAsgASAGRiABQX5qIQFFDQALCwwBCyADQQA2AiAgA0EYaiACEOsKAkAgAygCGCIBIAMoAhwiBkYEQEF/IQIMAQsgBEHsBGohB0F/IQIDQCADQRBqIAcgAq0gATEAAEIghoQgAUEBaiIFMQAAQiiGhCAEKALgBBDLAwJAIAMoAhBBAUYEQCADKAIUIQIMAQsgBS0AACEFIAEtAAAiCARAIAQgCGpBjwVqQQE6AAALIAQgBWpBkAVqQQE6AAACQCACQX9HBEAgAyABLwAAOwFIIANBBjYCQCADIAI2AkQgBCADQUBrENEHDAELIAMgAS8AADsAQSADQQQ6AEAgA0EwaiAEIANBQGsQ+wYgA0EgahCeCyADQShqIANBOGopAwA3AwAgAyADKQMwNwMgCyAEKALgBCIFQX9qIgIgBU0NAEGoq8sAQStB0KjLABDRCQALIAFBAmoiASAGRw0ACwsLIAAgAykDIDcCBCAAQQA2AgAgAEEUaiACNgIAIABBDGogA0EoaikDADcCACADQdAAaiQAC+IFAQp/IwBB0ABrIgQkACABQeAEaigCACEJIARCADcCBCAEQaCrywAoAgA2AgAgA0F/aiEGIAMEQCAJIQcgBgRAIARBMGpBBHIhCiAEQUBrQQRyIQsgA0EBdEF+aiEMIAIhAwNAIAsgBCkCEDcCACALQQhqIARBGGoiDSgCADYCACAEIAU2AkAgASAEQUBrIAcQwwEgBEEgaiABEJoIIAEoAuAEIQcgAy0AASEFIAMtAAAiCARAIAEgCGpBjwVqQQE6AAALIAEgBWpBkAVqQQE6AAAgAy0AACEFIAQgAy0AAToAQiAEIAU6AEEgBEEEOgBAIARBMGogASAEQUBrEPsGIAQoAggiBSAEKAIERgRAIAQgBRDpCCAEKAIIIQULIANBAmohAyAEKAIAIAVBBHRqIgggBCkDMDcCACAIQQhqIARBOGopAwA3AgAgBCAFQQFqNgIIIARByABqIARBKGopAwA3AwAgBCAEKQMgNwNAIARBMGogASAEQUBrQQEgB0EAIAQQkwEgDSAKQQhqKAIANgIAIAQgCikCADcDECAEKAIwIQUgASgC4AQhByAMQX5qIgwNAAsLIAIgBkEBdGoiAy0AACECIAMtAAEhBiACBEAgASACakGPBWpBAToAAAsgASAGakGQBWpBAToAACADLQAAIQIgBCADLQABOgBCIAQgAjoAQSAEQQQ6AEAgBEEwaiABIARBQGsQ+wYgBCgCCCIDIAQoAgRGBEAgBCADEOkIIAQoAgghAwsgBCgCACADQQR0aiICIAQpAzA3AgAgAkEIaiAEQThqKQMANwIAIARBCGoiAiADQQFqNgIAIARBzABqIARBGGooAgA2AgAgBCAFNgJAIAQgBCkDEDcCRCABIARBQGsgBxDDASAAQRBqIAIoAgA2AgAgAEEIaiAEKQMANwIAIABBFGogCTYCACAAQoCAgIAgNwIAIARB0ABqJAAPCyAGQQBB3KLLABCyBwALrAYCBH8BfiMAQfAEayIDJAAgAyABEIcDIgQ2ApADAkACQAJAAkACQAJAIARB3QBGBEAgA0HAAWogAkEkEIkDGiADQQRqIANBwAFqEIIFIANBADYCwAEgA0HAAWpBBHIgA0EEakHcABCJAxogA0HgAGogASADQcABahDXASABKAIAIgQoAjQNAyAEQX82AjQgBEFAaygCACICRQRAIANBAjoAwAEMBwsgBCACQX9qIgI2AkAgA0HAAWogBEE4aigCACACQaQBbGpBpAEQiQMaIAMtAMABIgVBf2oOAgEGAgsgA0EANgLAASADQZADakGkrswAIANBwAFqQaiuzAAQxgcAC0HIrswAQRlB5K7MABDoCgALIANB6AJqIANBwAFqQQRyIgZBJBCJAxogA0GQA2ogA0HoAWpB/AAQiQMaIAEQsQIaIAQpAgAhByADQaQDaiAEQQhqKAIANgIAIAMgBzcCnAMgA0GoA2oiARDaBCABIANB4ABqQeAAEIkDGiAEKAJABEBB/ABBBBDkCyIBRQ0C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CyADKAIAIARHDQALCyABQdAAaiQAC8gFAQl/IwBBQGoiBCQAAkACQCABKAIAQQFGBEAgAUEsaiEFIAFBIGohByABQRxqKAIAIQggAUEYaigCACEJIAFBFGooAgAhCiABQRBqKAIAIQsgAUEMaigCACEMIAFBCGooAgAhBgJAIAEoAgQiASACKAIARw0AAkACQAJAAkAgAUFzag4FAwIGBgEACyABQRdHDQUgBiACKAIERw0DDAULIAYgAigCBEcNAiAMIAJBCGooAgBHDQIgCyACQQxqKAIARw0CIAogAkEQaigCAEcNAiAJIAJBFGooAgBHDQIgCCACQRhqKAIARg0EDAILIAYgAigCBEcNASAMIAJBCGooAgBHDQEgCyACQQxqKAIARw0BIAogAkEQaigCAEcNASAJIAJBFGooAgBHDQEgCCACQRhqKAIARg0DDAELIAYgAigCBEcNACAMIAJBCGooAgBHDQAgCyACQQxqKAIARw0AIAogAkEQaigCAEcNACAJIAJBFGooAgBHDQAgCCACQRhqKAIARg0CCyAAIAE2AgQgAEEBNgIAIABBHGogCDYCACAAQRhqIAk2AgAgAEEUaiAKNgIAIABBEGogCzYCACAAQQxqIAw2AgAgAEEIaiAGNgIAIABBIGogBykCADcCACAAQSxqIAUpAgA3AgAgAEEoaiAHQQhqKAIANgIAIABBNGogBUEIaikCADcCACAAQTxqIAVBEGopAgA3AgAMAgsgACABQcQAEIkDGgwBCyAEQRhqIANBGGooAgA2AgAgBEEQaiADQRBqKQIANwMAIARBCGogA0EIaikCADcDACAEQTBqIAVBCGopAgA3AwAgBEE4aiAFQRBqKQIANwMAIARBJGogB0EIaigCADYCACAEIAMpAgA3AwAgBCAFKQIANwMoIAQgBykCADcCHCAAQQRqIARBwAAQiQMaIABBATYCAAsgBEFAayQAC4YGAQZ/IwBB8ABrIgQkAAJAAkACQAJAAkACQAJAAkAgASgCBCIGIAMoAgAiB08EQCAGIAdrIQMgASgCACIJIAdqIQUCQAJ/An8CQAJAAkACQCACKAKQASIBQQFrDgQAAQIDDgsgAkGgAWohAQJ/AkACQAJAAkAgAkGoAWooAgAOBAoBAgMACyAEIAJBlAFqIAUgAxCbBSAEKAIAIQIgBCgCBAwD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IAMgASAFKAI4LQACIAcgBhDkASAFKAI0IQMgBSgCMAtFDQwMBAsgBUHYAGogAUGYAWoiASAHIAYQrwQgBSgCWEUNCyAFKAJcIQMgBUHQAGogARDrCwwDCyAFQeAAaiABQZQBaiAHIAYQPCAFQewAaigCACAFQegAaigCAGsMAQsgBUHgAGogAUGUAWogByAGQQAQhwcgBUHsAGooAgAgBUHoAGooAgBrCyEDIAUoAmBFDQgLIAMgBGohA0EBIQIMCAsgBCADQZTWywAQsQcAC0EAQQBBzNjLABCwBwALQQBBAEGs2MsAELAHAAtBASABQbzYywAQsAcAC0EAQQBB/NfLABCwBwALQQEgAUGM2MsAELAHAAtBAiACQZzYywAQsAcAC0EAIQILIAAgAzYCBCAAIAI2AgAgBUHwAGokAAubBQEEfyMAQfAEayICJAAgAiABNgIUIAJBGGogARCaAyACQeABaiIEIAJBMGopAAA3AwAgAkHYAWoiBSACQShqKQAANwMAIAJB0AFqIgMgAkEgaikAADcDACACIAIpABg3A8gBIAJBOGogAkHIAWoQtQggAkGgAWogAkHQAGopAwA3AwAgAkGYAWogAkHIAGopAwA3AwAgAkGQAWogAkFAaykDADcDACACIAIpAzg3A4gBIAJB0ANqQZDdygBBoAEQiQMaIAJByAFqIAJB0ANqIAJBiAFqENwMIAJBiAFqIAJByAFqEPsEIAJB2ABqIAJBiAFqEPMJIAJB1AFqQSA2AgAgAkEgNgLMASACIAE2AsgBIAIgAkHYAGo2AtABIAJB+ABqIAJByAFqQQIQxwUgAkGIAWpBAEHAABCRBRogAkEIaiACQfgAahDNCyACQYgBakHAACACKAIIIAIoAgxB4OTKABCICyACQcgBaiACQYgBahDSAQJAAkAgAigCyAFBAUcEQCAEIAAgA0HgARCJAyIAQdgBaikAADcDACAFIABB0AFqKQAANwMAIAMgAEHIAWopAAA3AwAgAiAAKQDAATcDyAEgAiACQcgBajYCtAMgAkHIAWogARCADEUNASACQcgBaiAAQaABahDzCSACIAJByAFqNgKwAyACIAJB2ABqNgK0AyACQcgBaiACQdgAahCADA0CIAJBADYCuAMgAkGwA2ogAkG0A2ogAkG4A2pBkOXKABC6BwALIAIgAikCzAE3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rAMQ5gsgAikDECEDIAJBCGogAkHYAGpBFxDmCyACQaQBakECNgIAIAIgAzcDeCACQgM3ApQBIAJB5IXeADYCkAEgAiACKQMINwOAASACIAJB+ABqNgKgASABIAJBkAFqELUHDAMLIAJBpAFqQQA2AgAgAkGQhN4ANgKgASACQgE3ApQBIAJBwIXeADYCkAEgASACQZABahC1BwwCCyACIAApAgQ3A0ggAiAAQQxqKAIANgJUIAIgAEEQaikCADcDWCACIABBGGooAgA2AmQgAiAAQRxqKQIANwNoIAIgAEEkaigCADYCdCACQUBrIAJByABqQawDEOYLIAIpA0AhAyACQThqIAJB1ABqQRcQ5gsgAikDOCEEIAJBMGogAkHYAGpBrAMQ5gsgAikDMCEFIAJBKGogAkHkAGpBFxDmCyACKQMoIQYgAkEgaiACQegAakGsAxDmCyACKQMgIQcgAkEYaiACQfQAakEXEOYLIAJBjAFqQQY2AgAgAiAHNwOwASACIAY3A6gBIAIgBTcDoAEgAiAENwOYASACIAM3A5ABIAJCBzcCfCACQeCE3gA2AnggAiACKQMYNwO4ASACIAJBkAFqNgKIASABIAJB+ABqELUHDAELIAJBpAFqQQA2AgAgAkGQhN4ANgKgASACQgE3ApQBIAJBiITeADYCkAEgASACQZABahC1BwsgAkHAAWokAAv6BAEFfyMAQUBqIgMkACADIAE2AhwgACgCACEEAkACQAJAAkAgAS0A/wFB/wFHBEAgBA0BIANBADoAMCAAQQxqKAIAIQEgACgCBCADIAI2AiggAyADQTBqNgIkIAMgA0EcajYCICABIANBIGoQgAIMAgsgBEUEQCAAQQxqKAIAIQEgACgCBCADQShqIAJBCGopAgA3AwAgAyACKQIANwMgIAEgA0EgahCbAwwCCyADQQA7ASAgAEEMaigCACEFIAAoAgQhByADQQhqIANBIGoQ0QogAy0ACEEBcUUNASADLQAJIQADQCAFIABB/wFxIgFNDQMCQCAHIAFBAnRqKAIAIgEEQCACKAIIIQQgAigCBCEGDAELIAIoAgAoAgAgAigCBCIGIAIoAggiBCgCACACKAIMKAIAIAAQkAghAQsgBiAEKAIAIAAgARC7CCADIANBIGoQ0QogAy0AASEAIAMtAABBAXENAAsMAQsgA0EwaiIEQQA6AAggBEEANgIEIAQgATYCACADQShqIANBOGooAgA2AgAgAyADKQMwNwMgIABBDGooAgAhBSAAKAIEIQcgA0EYaiADQSBqEIoGIAMtABhBAXFFDQAgAy0AGSEAA0AgBSAAQf8BcSIBTQ0DAkAgByABQQJ0aigCACIBBEAgAigCCCEEIAIoAgQhBgwBCyACKAIAKAIAIAIoAgQiBiACKAIIIgQoAgAgAigCDCgCACAAEJAIIQELIAYgBCgCACAAIAEQuwggA0EQaiADQSBqEIoGIAMtABEhACADLQAQQQFxDQALCyADQUBrJAAPCyABIAVBoMfLABCwBwALIAEgBUGwx8sAELAHAAvgBAEJfyMAQYAGayICJAAgAkHgBWoQxwYgAkHwBWoiB0IANwMAIAJBgQI7AfgFIAJB3N3LACgCADYC7AUgAkEoaiABEM0LIAJBIGogAigCKCACKAIsELILAkAgAigCICIFIAIoAiQiCEYNACACQewFaiEJQQEhAwNAIAIgAwR/IAUoAghBAUYFQQALOgD4BSACQRhqIAUQzQsgAigCHCEGIAIoAhghAwJAAkACQCAFKAIIIgpBf2oiBCAKTQRAIANFIAQgBk9yDQMgAyAEai0AACEDIAJBEGogAkHgBWoQzQsgAigCFCIEIANNDQEgAigCECADai0AAA0DIANBGHRBGHUiBkEATg0CIAJBADoA+QUMAgtB5N3LAEErQbDcywAQ0QkACyADIARBwNzLABCwBwALIAIoAvQFIgQgAigC8AVGBH8gCSAEEPkIIAIoAvQFBSAECyACKALsBWogBjoAACACIAIoAvQFQQFqNgL0BSACQQhqIAJB4AVqEM0LIAIoAgwiBCADSwRAIAIoAgggA2pBAToAAAwBCyADIARB0NzLABCwBwALIAVBEGoiBSAIRg0BIAItAPgFIQMMAAsACyACQaADaiACQfgFaigCADYCACACQZgDaiAHKQMANwMAIAJBkANqIAJB6AVqIgMpAwA3AwAgAiACKQPgBTcDiAMgAkEwaiABIAJBiANqEOUBIAcgAUEQaigCADYCACADIAFBCGopAgA3AwAgAiABKQIANwPgBSACQYgDaiACQTBqQdgCEIkDGiAAIAJB4AVqIAJBiANqEMAHIAJBgAZqJAAL2gQBCX8jAEEQayIEJAACQAJAAn8CQCAAKAIIQQFGBEAgAEEMaigCACEGIARBDGogAUEMaigCACIFNgIAIAQgAUEIaigCACICNgIIIAQgAUEEaigCACIDNgIEIAQgASgCACIBNgIAIAAtACAhCSAAKAIEIQogAC0AAEEIcQ0BIAohCCAJIQcgAwwCCyAAIAEQ2AEhAgwDCyAAKAIYIAEgAyAAQRxqKAIAKAIMEQUADQFBASEHIABBAToAIEEwIQggAEEwNgIEIARBADYCBCAEQZTt4AA2AgBBACAGIANrIgMgAyAGSxshBkEACyEBIAUEQCAFQQxsIQMDQAJ/AkACQAJAIAIvAQBBAWsOAgIBAAsgAkEEaigCAAwCCyACQQhqKAIADAELIAJBAmovAQAiBUHoB08EQEEEQQUgBUGQzgBJGwwBC0EBIAVBCkkNABpBAkEDIAVB5ABJGwshBSACQQxqIQIgASAFaiEBIANBdGoiAw0ACwsCfwJAIAYgAUsEQEEAIQIgBiABayIBIQMCQAJAAkAgB0EDcUEBaw4DAAEAAgtBACEDIAEhAgwBCyABQQF2IQIgAUEBakEBdiEDCyACQQFqIQIgAEEcaigCACEBIAAoAhghBwNAIAJBf2oiAkUNAiAHIAggASgCEBEBAEUNAAsMAwsgACAEENgBDAELIAAgBBDYAQ0BQQAhAgNAQQAgAiADRg0BGiACQQFqIQIgByAIIAEoAhARAQBFDQALIAJBf2ogA0kLIQIgACAJOgAgIAAgCjYCBAwBC0EBIQILIARBEGokACACC+EEAQZ/IwBBQGoiAyQAIANBCGogASACEOYLIAMgAygCCCADKAIMEOYLIAMgAykDADcDECADQTBqIANBEGoQ4gECQAJAAkACQCADKAIwIgYEQCADKAI0IQEgA0E8aigCAA0CIAAgBjYCBAwBCyAAQejQ4AA2AgRBACEBCyAAQQA2AgAgAEEIaiABNgIADAELAkACQCACQQBOBEAgAg0BQQEhBQwCCxCPCgALIAJBARDkCyIFRQ0CCyADQQA2AiAgAyAFNgIYIAMgAjYCHCABIAJLBEAgA0EYakEAIAEQ7gQgAygCGCEFIAMoAiAhBAsgBCAFaiAGIAEQiQMaIAMgASAEaiICNgIgIAMoAhwgAmtBAk0EQCADQRhqIAJBAxDuBCADKAIgIQILIAMoAhgiBCACaiIBQfDR4AAvAAAiBjsAACABQQJqQfLR4AAtAAAiBzoAACADIAJBA2oiAjYCICADIAMpAxA3AyggA0EwaiADQShqEOIBIAMoAjAiBQRAA0AgAygCPCADKAIcIAJrIAMoAjQiAUkEQCADQRhqIAIgARDuBCADKAIYIQQgAygCICECCyACIARqIAUgARCJAxogAyABIAJqIgI2AiAEQCADKAIcIAJrQQJNBEAgA0EYaiACQQMQ7gQgAygCICECCyADKAIYIgQgAmoiASAGOwAAIAFBAmogBzoAACADIAJBA2oiAjYCIAsgA0EwaiADQShqEOIBIAMoAjAiBQ0ACwsgACADKQMYNwIEIABBATYCACAAQQxqIANBIGooAgA2AgALIANBQGskAA8LIAJBARDiDAAL2wQBDH8jAEGwAWsiAyQAIANCADcCLCADQYz+wQAoAgAiBTYCKCADQaQBaiIGQQA2AgAgA0GcAWoiB0IANwIAIANBmAFqIghBADoAACADQZQBaiIJQQA2AgAgA0GQAWoiCkEAOgAAIANBjAFqIgtBADYCACADQYgBaiIMQQA6AAAgA0GEAWoiDUEANgIAIANBgAFqIgRBADoAACADQfwAaiIOQQA7AQAgA0EBOgCoASADQQA2AnggAyAANgJwIAMgACABajYCdCADQShqIANB8ABqEGIgA0EgakEIEOYHIANBADYCQCADIAMpAyA3AzggA0E4akHD98EAQQgQ5wsgA0E4akHwlsAAQQAQ5wsgA0EYaiADQThqEM0LIANCADcCTCADIAU2AkggAygCHCEBIAMoAhghACAGQQA2AgAgB0IANwIAIAhBADoAACAJQQA2AgAgCkEAOgAAIAtBADYCACAMQQA6AAAgDUEANgIAIARBADoAACAOQQA7AQAgA0EBOgCoASADQQA2AnggAyAAIAFqNgJ0IAMgADYCcCADQcgAaiADQfAAahBiIANBEGogA0EoahDNCyADKAIUIQAgAygCECEBIANBCGogA0HIAGoQzQsgA0HYAGogASAAIAMoAgggAygCDCACEFUgAygCWEEGRwRAIAQgA0HoAGooAgA2AgAgA0H4AGogA0HgAGopAwA3AwAgAyADKQNYNwNwQcD4wQBBKyADQfAAakHs+MEAQbD4wQAQ8wYACyADQcgAahCkCyADQThqEKQLIANBKGoQpAsgA0GwAWokAAvM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AzAgAkIBNwMoIAJB0ABqIAJBARCVASACQfgAaiACQdAAaiACQShqEL4FIAJBoAFqIAJB0ABqQYCD4AAQcCACIAIpA6ABQgF8NwOgAUEIIQMDQCACQaABaiADaiIEIAQpAwAgAkEoaiADaikDAHw3AwAgA0EIaiIDQShHDQALIAJB8AFqIAJB+ABqIAJBoAFqEJQBIAItAPABIQMgAkHIAWogAkH4AWpBKBCJAxogAAJ+IANBAUYEQCACQgAgAS0AH0EHdhDaC61C/wGDfSIIQvD///////8/IAIpA+gBIgV9IglC/////////wODQvD///////8/IAIpA+ABIgd9IgZCM4h8IAWFgyAFhTcD6AEgAiAHIAcgBkL/////////A4NC8P///////z8gAikD2AEiBX0iBkIziHyFIAiDhTcD4AEgAiAFIAUgBkL/////////A4NC8P///////z8gAikD0AEiB30iBkIziHyFIAiDhTcD2AEgAiAHIAcgBkL/////////A4NC0P3//////z8gAikDyAEiBX0iBkIziHyFIAiDhTcD0AEgAiAFIAUgCUIziEITfiAGQv////////8Dg3yFIAiDhTcDyAEgAkHwAWogAkHIAWpBKBCJAxogAkGYAmogAkEoEIkDGiACQcACaiACQShqQSgQiQMaIAJB6AJqIAJByAFqIAIQcCAAQQhqIAJB8AFqQaABEIkDGkIBDAELQgALNwMAIAJBkANqJAALxgQBB38jAEEgayIDJAAgA0EYakIANwMAIANBEGpCADcDACADQQhqQgA3AwAgA0IANwMAAkACQAJAAkAgAg4CAAIBC0EAQQBB2ILeABCwBwALIAMgASABQRBqELMCQQAhAgNAIAIgA2oiBCAEKAIAIAAgAmooAgBzNgIAIAJBBGoiAkEgRw0ACyAAQYABaiEEIABB4ABqIQYgAEFAayEHIABBIGohCEEIIQkMAQtBAUEBQeiC3gAQsAcACwNAIAMQ3gEgAxD8AUEAIQIDQCACIANqIgUgBSgCACACIAhqKAIAczYCACACQQRqIgJBIEcNAAsgCUHoAEYEQEEAIQIDQCACIANqIgQgBCgCACIEQQR2IARzQYCegPgAcSIGIARzIAZBBHRzNgIAIAJBBGoiAkEgRw0ACyAAQcADaiEAIAMQ3gFBACECA0AgAiADaiIEIAQoAgAgACACaigCAHM2AgAgAkEEaiICQSBHDQALIAMgARC0AiADQSBqJAAFIAMQ3gEgAxDEAkEAIQIDQCACIANqIgUgBSgCACACIAdqKAIAczYCACACQQRqIgJBIEcNAAsgAxDeASADEP0BQQAhAgNAIAIgA2oiBSAFKAIAIAIgBmooAgBzNgIAIAJBBGoiAkEgRw0ACyADEN4BIAMQwANBACECA0AgAiADaiIFIAUoAgAgAiAEaigCAHM2AgAgAkEEaiICQSBHDQALIARBgAFqIQQgBkGAAWohBiAHQYABaiEHIAhBgAFqIQggCUEgaiEJDAELCwvIBAEGfiAAIAEpAyAiA0IziEITfiABKQMAIgJC/////////wODfCIEQhN8QjOIIAEpAwgiBUL/////////A4MgAkIziHwiAnxCM4ggASkDECIGQv////////8DgyAFQjOIfCIFfEIziCABKQMYIgdC/////////wODIAZCM4h8IgZ8QjOIIANC/////////wODIAdCM4h8Igd8QjOIQhN+IAR8IgM8AAAgACADQiiIPAAFIAAgA0IgiDwABCAAIANCGIg8AAMgACADQhCIPAACIAAgA0IIiDwAASAAIANCM4ggAnwiBEIliDwACyAAIARCHYg8AAogACAEQhWIPAAJIAAgBEINiDwACCAAIARCBYg8AAcgACAEQjOIIAV8IgJCKog8ABIgACACQiKIPAARIAAgAkIaiDwAECAAIAJCEog8AA8gACACQgqIPAAOIAAgAkICiDwADSAAIANCMIhCB4MgBEL/////////A4MiBEIDhoQ8AAYgACACQjOIIAZ8IgNCJ4g8ABggACADQh+IPAAXIAAgA0IXiDwAFiAAIANCD4g8ABUgACADQgeIPAAUIAAgAkL/////////A4MiBUIGhiAEQi2IhDwADCAAIANCM4ggB3wiAkIkiDwAHiAAIAJCHIg8AB0gACACQhSIPAAcIAAgAkIMiDwAGyAAIAJCBIg8ABogACADQv////////8DgyIDQgGGIAVCMoiEPAATIAAgAkL/////////A4MiAkIsiDwAHyAAIAJCBIYgA0IviIQ8ABkLsgQBCH8jAEGABmsiAiQAIAJB4AVqEMcGIAJB8AVqIgZCADcDACACQYECOwH4BSACQdzdywAoAgA2AuwFIAJBKGog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KQMANwIAIAUgBjYCACAFIAUpAxg3AgQgBUEoahCeCwsgBUEoaiABIAIgAxC3AiAFQSBqIgMgBUE4aigCADYCACAFIAVBMGopAwA3AxggBSgCLCECIAUoAihBAUYNASACQQNGDQIgBUE8aigCACEDIAVBMGogBUEIaikDADcDACAFIAUpAwA3AyggASAFQShqIAMQwwEgAEEIaiAFKQMYNwIAIABBEGogBUEgaigCADYCACAAQRRqIAUoAhA2AgAMAwsgBUEgaiAEQQhqKAIAIgE2AgAgBSAEKQIAIgc3AxggAEEQaiABNgIAIABBCGogBzcCACAAIAY2AgQgAEEBNgIADAMLIAAgAjYCBCAAQQE2AgAgAEEIaiAFKQMYNwIAIABBEGogAygCADYCACAFEJ4LDAILIAUQngsLIABBADYCACAAIAI2AgQLIAVBQGskAAukBAIGfwF+IwBB4ABrIgIkACABKAIAIQUgASgCBCEEIAJB0ABqQQo2AgAgAkHIAGpCioCAgBA3AwAgAkHEAGogBDYCACACQUBrQQA2AgAgAkE8aiAENgIAIAJBADsBVCACIAU2AjggAiAENgI0IAJBADYCMEF/IQMDQCADQQFqIQMgAkEQaiACQTBqEJYCIAIoAhANAAsgAiADNgIcAkAgBEUNACAEIAVqQX9qLQAAQQpHDQAgAiADQQFqIgM2AhwLAkAgAkEIaiADQQJPBEAgAkIANwIkIAJBsNfdACgCADYCICACQTBqIAJBIGpB/NXdABDYCiACQRxqIAJBMGoQiAwNASACKAIoIQYgAigCJARAIAIoAiAQiQELIAIoAhwhAwsgAxCBByACKQMIIQggAEEUakEANgIAIAAgCDcCDCACQgA3AjQgAkGo190AKAIAIgc2AjAgAEEMaiADIAJBMGoQ2gMgAEEcakIANwIAIAAgBzYCGCAAIAY2AgggACAENgIEIAAgBTYCACACQThqIgQgASgCDCIDQQhqKQIANwMAIAJBQGsiBSADQRBqKQIANwMAIAIgAykCADcDMCAAIAJBMGoQlgMgASgCECIBBEAgBSABQRBqKQIANwMAIAQgAUEIaikCADcDACACIAEpAgA3AzAgACACQTBqEJYDCyACQeAAaiQADwtBlNbdAEE3IAJB2ABqQajY3QBBmNfdABDzBgALnQQBBH8jAEGAAWsiAiQAIAJByABqIAEQrAMCQCACKAJIQQFHBEAgAkEgaiACQeAAaikDADcDACACQRhqIAJB2ABqKQMANwMAIAIgAkHQAGoiBCkDADcDECACQcgAaiACQRBqEMkBIAIoAkhBAUYNASACQTBqIAJB1ABqKAIANgIAIAIgAikCTDcDKCACQQhqIAJBKGoQzQsgAigCCCEBIAIoAgwhBSACQegAaiIDQQA7AQggAyABNgIAIAMgASAFajYCBCAEIAJB8ABqKAIANgIAIAIgAikDaDcDSCACQThqIAJByABqENEEIAIoAkAiASACKAI8RgRAIAJBOGogARD6CCACKAJAIQELIAIoAjggAUEBdGpBADsBACACIAIoAkBBAWo2AkAgAiACQShqEM0LIAJByABqIAIoAgAgAigCBBDCCCAAIAJByABqELkDIAJBOGoQ+AogAkEoahCkCwJAAkACQAJAIAItABAOBQMDAwECAAsgAkEQakEEchDdBgwCCyACQRBqQQRyEKQLDAELIAJBEGpBBHIiABDwAyAAEPMKCyACQYABaiQADwsgAiACKAJMNgJoQeTmygBBKyACQegAakHA58oAQbzlygAQ8wYACyACQfgAaiACQdwAaikCADcDACACQfAAaiACQdQAaikCADcDACACIAIpAkw3A2hB5ObKAEErIAJB6ABqQaDnygBBzOXKABDzBgAL7wMBBX8jAEGQAWsiAiQAAkACQAJAIAEtACgNACABKAIIRQ0AIAEtACIhBCACQRBqIAEQhgUgASgCDCEFIAJBCGogAUEUaigCACIDEIgGIAJBIGogAigCDDYCACACIAIoAggiBjYCHCAGIAUgA0EBdBCJAxogAkEkaiADNgIAIAIgBDoAMiACIAEvASA7ATAgAiABKQIYNwMoIAJBEGogAS0AJBCYByACQThqIAJBEGoQpwIgAUElai0AACIDQQJGIANBAXFFcg0BIAFBJmotAAAhBCABQSdqLQAAIQUgAS0AJCEBIAJB0ABqIAJBEGpBJBCJAxogAkGEAWogAkHIAGopAwA3AgAgAkH8AGogAkFAaykDADcCACACIAIpAzg3AnQgACACQdAAakE8EIkDIgBBAToARCAAQQA2AjwgACABIANBAUZBCHRyQYCACCAEQQBHQRB0IARBAkYbckGAgIAQIAVBAEdBGHQgBUECRhty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QegEaiAFQZACaikDADcDACAFQeAEaiAFQYgCaikDADcDACAFQdgEaiAFQYACaikDADcDACAFQfgEaiAFQcACaikAADcDACAFQYAFaiAFQcgCaikAADcDACAFQYgFaiAFQdACaikAADcDACAFIAUpA/gBNwPQBCAFIAUpALgCNwPwBCAFQfgCaiAFQdAEakHAABCJAxogACAFQfgCahCXBiAFQZAFaiQAC4AEAQZ/IwBBMGsiAyQAIABCADcCBCAAQejn3QAoAgAiBDYCACABKAIAIQIgASAENgIAIAEoAgQhBSABKAIIIQQgAUIANwIEIAMgAiAEQQR0ajYCFCADIAI2AhAgAyAFNgIMIAMgAjYCCAJAIARFDQADQCADIAJBEGo2AhAgAkENaiEEAkACQAJAIAItAAwiBQ4DAAEEAQsgA0EoaiIFIAJBCGooAgA2AgAgA0EeaiIGIARBAmotAAA6AAAgAyACKQIANwMgIAMgBC8AADsBHCAAKAIIIgIgACgCBEYEQCAAIAIQiwkgACgCCCECCyAAKAIAIAJBBHRqIgIgAykDIDcCACACQQA6AAwgAiADLwEcOwANIAJBCGogBSgCADYCACACQQ9qIAYtAAA6AAAgACAAKAIIQQFqNgIIDAELIANBKGoiBiACQQhqKAIANgIAIANBHmoiByAEQQJqLQAAOgAAIAMgAikCADcDICADIAQvAAA7ARwgASgCCCICIAEoAgRGBEAgASACEIsJIAEoAgghAgsgASgCACACQQR0aiICIAMpAyA3AgAgAiAFOgAMIAIgAy8BHDsADSACQQhqIAYoAgA2AgAgAkEPaiAHLQAAOgAAIAEgASgCCEEBajYCCAsgAygCECICIAMoAhRHDQALCyADQQhqEPcGIANBMGokAAvNAwINfwF+An8CQCAFQX9qIgwgASgCFCIIaiIHIANJBEAgBSABKAIQIg1rIQ4gASkDACEUQQAgASgCCCIKayEPA0ACQAJAIAECfyAUIAIgB2oxAACIQgGDUEUEQCAKIAogASgCHCILIAogC0sbIAYbIgkgBSAJIAVLGyEQIAIgCGohESAJIQcCQANAIAcgEEYEQEEAIAsgBhshCyAKIQcCQAJAAkADQCALIAdPBEAgASAFIAhqIgI2AhQgBkUNAgwOCyAHQX9qIgcgBU8NAiAHIAhqIgkgA08N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A0IAIQcDQCADMQAAIAeGIAaEIQYgA0EBaiEDIAdCCHwiB0LAAFINAAsgAkEIaiAEQQN0aiAGNwMAIAVCAXwiBUIIUgRAIAFBCGohASACQQhqIAWnQQN0aikDACEGDAELCyACIAIpAwgiBUL/////////B4M3A0ggAiACKQNAIgdCFIg3A5ABIAIgAikDKCIGQgSIQv////////8HgzcDcCACIAIpAxAiCEIMhiAFQjSIhEL/////////B4M3A1AgAiACKQMYIgVCGIYgCEIoiIRC/////////weDNwNYIAIgAikDICIIQiSGIAVCHIiEQv////////8HgzcDYCACIAZCMIYgCEIQiIRC/////////weDNwNoIAIgAikDMCIFQgiGIAZCOIiEQv////////8HgzcDeCACIAIpAzgiBkIUhiAFQiyIhEL/////////B4M3A4ABIAIgB0IghiAGQiCIhEL/////////B4M3A4gBIAJBmAFqIAJByABqQcDB4AAQSyACQcgAaiACQZgBakEoEIkDGiACQZgBaiACQfAAakHoweAAEEsgAkHwAGogAkGYAWpBKBCJAxogACACQfAAaiACQcgAahD4BiACQcABaiQAC9ADARp+IAExABIhBiABMQARIQcgATEAECEIIAExAA8hCSABMQANIQogATEADiELIAExAB8hDCABMQAeIQ0gATEAHSEOIAExABwhDyABMQAbIRAgATEAGiERIAExAAwhAiABMQALIRIgATEACiETIAExAAkhFCABMQAHIRUgATEACCEWIAExABkhAyABMQAYIQQgATEAFyEXIAExABYhGCABMQATIQUgATEAFCEZIAExABUhGiAAIAE1AAAgATEABEIghoQgATEABUIohoQgATEABiIbQjCGhEL/////////A4M3AwAgACAFIBlCCIaEIBpCEIaEIBhCGIaEIBdCIIaEIARCKIaEIANCMIaEQgGIQv////////8DgzcDGCAAIBsgFUIIhoQgFkIQhoQgFEIYhoQgE0IghoQgEkIohoQgAkIwhoRCA4hC/////////wODNwMIIAAgBCADQgiGhCARQhCGhCAQQhiGhCAPQiCGhCAOQiiGhCANQjCGhCAMQjiGhEIMiEL/////////A4M3AyAgACACIApCCIaEIAtCEIaEIAlCGIaEIAhCIIaE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QegBakGgARCJAyEEQQAhAgNAIANBiANqIAEgAiACQQFxaiIAQQF2QcAHbGogA0EIaiAAai0AABDHAiADQegBaiAEIANBiANqEOECIANByABqIANB6AFqENAJIAQgA0HIAGpBoAEQiQMaQQBBPyAAayICIAJBwABLGyAAQQFqIgJBAXFLDQALIANBgARqJAAPCyADQYgDaiABIAJBAXZBwAdsaiAAIAVqLQAAEMcCIANB6AFqIAQgA0GIA2oQ4QIgA0HIAGogA0HoAWoQ0AkgBCADQcgAakGgARCJAxogACECDAALAAubAwIEfwF+IwBB0ABrIgQkACABQeAEaigCACEGIARBCGogARCaCCAEQShqIAEgAhA7IARByABqIgUgBEE4aigCADYCACAEIARBMGopAwA3A0AgBCgCLCECAkACQAJAIAQoAihBAUcEQCACQQNHDQIgACABEK4GDAELIAAgAjYCBCAAQQE2AgAgAEEIaiAEKQNANwIAIABBEGogBSgCADYCAAsgBEEIahCeCwwBCyAEQTxqKAIAIQUgBEEgaiAEQcgAaigCACIHNgIAIAQgBCkDQCIINwMYIARBNGogBzYCACAEIAI2AiggBCAINwIsIAEgBEEoaiAGEMMBAkAgA0UEQCAEQTBqIARBEGopAwA3AwAgBCAEKQMINwMoIARBQGsgASAEQShqQQAgBEEBIAUQkwEMAQsgBEEwaiAEQRBqKQMANwMAIAQgBCkDCDcDKCAEQUBrIAEgBEEoakEBIAVBACAEEJMBCyAAIAQpA0A3AgQgAEEANgIAIABBFGogBjYCACAAQQxqIARByABqKQMANwIACyAEQdAAaiQAC5gDAQd/IwBBEGsiCSQAIAAoAgQiBSAAKAIAIgcgAaciCnEiCGooAABBgIGChHhxIgZFBEBBBCEEA0AgBCAIaiEGIARBBGohBCAFIAYgB3EiCGooAABBgIGChHhxIgZFDQALCwJAIAAoAgggBSAGaEEDdiAIaiAHcSIEaiwAACIGQX9KBH8gBSAFKAIAQYCBgoR4cWhBA3YiBGotAAAFIAYLQQFxIghFcg0AIAkgACADENUFIAAoAgQiBSAAKAIAIgcgCnEiBmooAABBgIGChHhxIgNFBEBBBCEEA0AgBCAGaiEDIARBBGohBCAFIAMgB3EiBmooAABBgIGChHhxIgNF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vgUgAEEoaiADQdgAakEoEIkDIQFBACEEA0AgASAEaiICIAIpAwAgA0GAAWogBGopAwB8NwMAIARBCGoiBEEoRw0ACyAAQdAAaiADQfgBakEoEIkDIQFBACEEA0AgASAEaiICIAIpAwAgA0GoAWogBGopAwB8NwMAIARBCGoiBEEoRw0ACyAAQfgAaiADQfgBaiADQagBahC+BSADQaACaiQAC5UDAQR/IwBBoAJrIgMkACADQQhqIAFBKGoiBUEoEIkDGgNAIANBCGogBGoiBiAGKQMAIAEgBGopAwB8NwMAIARBCGoiBEEoRw0ACyADQTBqIAUgARC+BSADQdgAaiADQQhqIAJBKGoQcCADQYABaiADQTBqIAIQcCADQagBaiABQfgAaiACQfgAahBwIANB0AFqIAFB0ABqIAJB0ABqEHAgA0H4AWogA0HQAWpBKBCJAxpBACEEA0AgA0H4AWogBGoiASABKQMAIANB0AFqIARqKQMAfDcDACAEQQhqIgRBKEcNAAsgACADQdgAaiADQYABahC+BSAAQShqIANB2ABqQSgQiQMhAUEAIQQDQCABIARqIgIgAikDACADQYABaiAEaikDAHw3AwAgBEEIaiIEQShHDQALIABB0ABqIANB+AFqIANBqAFqEL4FIABB+ABqIANB+AFqQSgQiQMhAEEAIQQDQCAAIARqIgEgASkDACADQagBaiAEaikDAHw3AwAgBEEIaiIEQShHDQALIANBoAJqJAALywMCBH8CfiMAQYABayIDJAAgAEIANwMIIABCATcDACAAQgE3AyggAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEwakEAQcgAEJEFGiACQRh0IgJBH3UiBCACQRh1aiAEcyEFQQEhAgNAIAAgASACIAVzIgZBf2ogBkF/c3FBgIACcUEPdhDaCxDWCiABQfgAaiEBIAJBAWoiAkEJRw0ACyAEQQFxENoLIQEgA0EIaiAAQShqQSgQiQMaIANBMGogAEEoEIkDGiADQdgAaiAAQdAAakEoEIkDGiADQfgAaiICQvD///////8/IAIpAwB9IghC/////////wODQvD///////8/IANB8ABqIgIpAwB9IgdCM4h8NwMAIAIgB0L/////////A4NC8P///////z8gA0HoAGoiAikDAH0iB0IziHw3AwAgAiAHQv////////8Dg0Lw////////PyADQeAAaiICKQMAfSIHQjOIfDcDACACIAdC/////////wODQtD9//////8/IAMpA1h9IgdCM4h8NwMAIAMgCEIziEITfiAHQv////////8Dg3w3A1ggACADQQhqIAEQ1gogA0GAAWokAAv2AwEBfyMAQRBrIgIkAAJ/AkACQAJAAkACQAJAAkAgACgCAEEBaw4FAQIDBAUACyACIAFBm/fBAEEKEIsLNwMAIAIgAEEEajYCDCACQaX3wQBBBCACQQxqQaT2wQAQ8AIaIAIgAEEMajYCDCACQan3wQBBBSACQQxqQbD3wQAQ8AIaIAIgAEEQajYCDCACQcD3wQBBAyACQQxqQbD3wQAQ8AIaDAULIAIgAUGQ98EAQQsQiws3AwAgAiAAQQRqNgIMIAJB5PbBAEEDIAJBDGpBpPbBABDwAhoMBAsgAiABQf72wQBBDBCLCzcDACACIABBBGo2AgwgAkGK98EAQQQgAkEMakGk9sEAEPACGiACIABBDGo2AgwgAkGO98EAQQIgAkEMakGk9sEAEPACGgwDCyABQe/2wQBBDxC3CwwDCyACIAFB0PbBAEEUEIsLNwMAIAIgAEEEajYCDCACQeT2wQBBAyACQQxqQaT2wQAQ8AIaIAIgAEEMajYCDCACQef2wQBBCCACQQxqQaT2wQAQ8AIaDAELIAIgAUGU9sEAQQsQiws3AwAgAiAAQQRqNgIMIAJBn/bBAEEEIAJBDGpBpPbBABDwAhogAiAAQQxqNgIMIAJBtPbBAEEMIAJBDGpBwPbBABDwAhoLIAIQ+QYLIAJBEGokAAutAwEHfyMAQSBrIgUkACAFIAM2AhwgBSACNgIYAkACQAJAAkAgASgCFCIEQUBrKAIAIgdBgICAgAJPBEAgAiACKAIAIgJBf2o2AgBBACEBIAJBAUcNASAFQRhqEPUKDAELIARBOGoiCSAEQcQAaigCABCkByABKAIAIgEtALIEBEAgAUGcBGohCkGAASEBA0AgBUEQaiAKEM0LIAUoAhQiCCABQf8BcSIGTQ0EIAQoAkAiCCAHIAUoAhAgBmotAABqIgZNDQUgCSgCACAGQQJ0akGCgICAeDYCACABQQFqIgFBgAJHDQALCyAEIAQoAmAgAyAEKAJEQQJ0ampBFGo2AmAgAiACKAIAIgFBAWo2AgAgAUF/TA0BIAVBCGogBCACIAMgBxD9AiAEQShqKAIAIgEgBEEkaigCAEYEQCAEQSBqIAEQ7QggBCgCKCEBCyAEKAIgIAFBA3RqIgEgAzYCBCABIAI2AgBBASEBIAQgBCgCKEEBajYCKAsgACAHNgIEIAAgATYCACAFQSBqJAAPCwALIAYgCEG01ssAELAHAAsgBiAIQfzWywAQsAcAC4ADAQZ/IwBBEGsiBiQAAkACQAJAAkACQAJAAkACQBDUCSIFEA0iBBADQQFHDQAgBBAOIgEQA0EBRwRAIAFBJEkNASABEAAMAQsgARAPIgIQECACQSRPBEAgAhAACyABQSRPBEAgARAACyAEQSRPBEAgBBAAC0EBRw0BQdD9ygBBBhARIQMgBkEIahDyCiAGKAIIBEAgBigCDCIDQSRPBEAgAxAACyAAQoGAgIDAgYCAgH83AgAMAwsgAEEIaiADNgIAIABCADcCAAwCCyAEQSRJDQAgBBAACyAFEBIhAiAFEBMhASACEANBAUYEQCABQSNLIAEhAyACIQENAwwECyABEANBAUYNASAAQoGAgIDwgICAgH83AgAgAkEkTwRAIAIQAAsgAUEkSQ0AIAEQAAsgBUEjSw0DDAQLIAIhAyACQSRJDQELIAMQAAsgAEEMakGAAhAsNgIAIABBCGogATYCACAAQoCAgIAQNwIAIAVBI00NAQsgBRAACyAGQRBqJAALqgMBCH8jAEEgayICJAACQAJAIAAQuwVFBEAgACgCACAAKAIIIgQQbCAERQ0CIAQhAQJAA0ACQAJAAkAgASAETQ0AAkAgBSABQX9qIgNJBEAgAiAAKAIAIgEgA0EDdGoiByABIAZqEO0GIAIoAgAiA0GAgMQARw0BIAAoAgghAQwCCyAFIANBqMLMABCwBwALIAIoAgQhASAHIAM2AgAgByABNgIEDAELIAEgBU0NASAAKAIAIgggBmoiAygCACEHIANBBGooAgAhAyAAKAIEIAFGBH8gACABEI8JIAAoAgAhCCAAKAIIBSABC0EDdCAIaiIBIAM2AgQgASAHNgIAIAAgACgCCEEBajYCCAsgBkEIaiEGIAAoAgghASAFQQFqIgUgBEcNAQwCCwsgBSABQbjCzAAQsAcACyABIARJDQEgAEEANgIIIAIgBDYCCCACQRRqIAAoAgAiAyAEQQN0ajYCACACIAA2AhggAiADNgIQIAIgASAEazYCDCACQQhqEOwECyACQSBqJAAPCyAEIAFBgPXdABCyBwALQezBzABBKUGYwswAENEJAAuFAwEDfwJAAkACQAJAIAFBCU8EQEEQQQgQxAsgAUsNAQwCCyAAEEAhAwwCC0EQQQgQxAshAQtBgIB8QQhBCBDEC0EUQQgQxAtqQRBBCBDEC2prQXdxQX1qIgRBAEEQQQgQxAtBAnRrIgIgAiAESxsgAWsgAE0NACABQRAgAEEEakEQQQgQxAtBe2ogAEsbQQgQxAsiBGpBEEEIEMQLakF8ahBAIgJFDQAgAhDzDCEAAkAgAUF/aiIDIAJxRQRAIAAhAQwBCyACIANqQQAgAWtxEPMMIQJBEEEIEMQLIQMgABDeDCACQQAgASACIABrIANLG2oiASAAayICayEDIAAQgwxFBEAgASADEMUKIAAgAhDFCiAAIAIQ+AEMAQsgACgCACEAIAEgAzYCBCABIAAgAmo2AgALIAEQgwwNASABEN4MIgJBEEEIEMQLIARqTQ0BIAEgBBDwDCEAIAEgBBDFCiAAIAIgBGsiBBDFCiAAIAQQ+AEMAQsgAw8LIAEQ8gwgARCDDBoLnwMBCH8jAEEgayIEJAACQAJAIAAQnAVFBEAgACgCACAAKAIIIgMQayADRQ0CIAMhAQJAA0ACQAJAAkAgASADTQ0AAkAgBSABQX9qIgJJBEAgACgCACIBIAJBAXRqIgIgASAGahC4BiIBQQFxDQEgACgCCCEBDAILIAUgAkGowswAELAHAAsgAiABQQh2OgAAIAIgAUEQdjoAAQwBCyABIAVNDQEgACgCACIHIAZqIgItAAAhCCACQQFqLQAAIQIgACgCBCABRgR/IAAgARCRCSAAKAIAIQcgACgCCAUgAQtBAXQgB2oiASACOgABIAEgCDoAACAAIAAoAghBAWo2AggLIAZBAmohBiAAKAIIIQEgBUEBaiIFIANHDQEMAgsLIAUgAUG4wswAELAHAAsgASADSQ0BIABBADYCCCAEIAM2AgggBEEUaiAAKAIAIgIgA0EBdGo2AgAgBCAANgIYIAQgAjYCECAEIAEgA2s2AgwgBEEIahDrBAsgBEEgaiQADwsgAyABQYD13QAQsgcAC0HswcwAQSlBmMLMABDRCQALrQMCAX8BfiMAQYAGayIFJAAgBSADNgIkIAUgAjYCICAFQYAEaiAEELYBAkAgAAJ/AkAgBS0AgARBAUcEQCAFIAUtAIMEOgAqIAUgBS8AgQQ7ASggBSkChAQhBiAFQegAaiAFQYwEakE1EIkDGiAFQTNqIAVB6ABqQTUQiQMaIAUgBjcAKyAFQegAahCnCiAFQYAEaiABQaABEIkDGiAFQeACaiAFQYAEahC+CSAFQegAaiAFQShqQSAQxAMgBUHoAGogAUGgAWpBIBDEAyAFQRhqIAVBIGoQqQwgBUHoAGogBSgCGCAFKAIcEMQDIAVBgARqIAVB6ABqQdgBEIkDGiAFQcACaiAFQYAEahCIByAFQYAEaiAFQcACaiAFQeACaiAFQcgAahC1ASAFQdgFaiAFQYAEahD7BCAFQdgFaiAFQShqQSAQlgkNAUEADAILIAVBCGogBSgChAQgBUGIBGooAgAQ5gsgBSkDCCEGIABBATYCACAAIAY3AgQMAgsgBUEDNgLYBSAFQRBqIAVB2AVqELgKIAAgBSkDEDcCBEEBCzYCAAsgBUGABmokAAuaAwEBfyMAQYAGayICJAAgAkEIaiABQQEQlQEgAkHYBWogAkEIakEBEJUBIAJBMGogAkHYBWpBARCVASACQdgAaiABIAJBMGoQcCACQYABaiACQQhqIAJB2ABqEHAgAkGoAWogAkGAAWpBARCVASACQdABaiACQdgAaiACQagBahBwIAJB+AFqIAJB0AFqQQUQlQEgAkGgAmogAkH4AWogAkHQAWoQcCACQcgCaiACQaACakEKEJUBIAJB8AJqIAJByAJqIAJBoAJqEHAgAkGYA2ogAkHwAmpBFBCVASACQcADaiACQZgDaiACQfACahBwIAJB6ANqIAJBwANqQQoQlQEgAkGQBGogAkHoA2ogAkGgAmoQcCACQbgEaiACQZAEakEyEJUBIAJB4ARqIAJBuARqIAJBkARqEHAgAkGIBWogAkHgBGpB5AAQlQEgAkGwBWogAkGIBWogAkHgBGoQcCACQdgFaiACQbAFakEyEJUBIAAgAkHYBWogAkGQBGoQcCAAQShqIAJBgAFqQSgQiQMaIAJBgAZqJAALpwMCBH8BfiMAQfAJayIDJAAgA0GoB2ogASACEIMGIANBqAdqQQRyIQICQCADKAKoB0EBRwRAIANB6ARqIAJBqAIQiQMaIAMgA0HoBGpBqAIQiQMiAi0AJCEFAkACQCABLQAKIgZFBEAgAkGoAmogAkGoAhCJAxpBACEBDAELIAJBqAdqIAFBCGogAhCmAUEBIQEgAkGoB2pBBHIhBCACKAKoB0EBRg0BIAJB6ARqIARBwAIQiQMaIAJBqAJqIAJB6ARqQcACEIkDGgsgAEEIaiACQagCakHAAhCJAxogAEHIAmogBToAACAAIAE2AgQgAEEANgIAIAZFDQIgAkEQahCTCiACQRhqIgAQrwggABDOCgwCCyACQfAEaiAEQQhqKAIAIgE2AgAgAiAEKQIAIgc3A+gEIABBDGogATYCACAAIAc3AgQgAEEBNgIAIAJBEGoQkwogAkEYaiIAEK8IIAAQzgoMAQsgA0HwBGogAkEIaigCACIBNgIAIAMgAikCACIHNwPoBCAAQQxqIAE2AgAgACAHNwIEIABBATYCAAsgA0HwCWokAAunAwIEfwF+IwBB8AlrIgMkACADQagHaiABIAIQhAYgA0GoB2pBBHIhAgJAIAMoAqgHQQFHBEAgA0HoBGogAkGoAhCJAxogAyADQegEakGoAhCJAyICLQAkIQUCQAJAIAEtAAoiBkUEQCACQagCaiACQagCEIkDGkEAIQEMAQsgAkGoB2ogAUEIaiACEKYBQQEhASACQagHakEEciEEIAIoAqgHQQFGDQEgAkHoBGogBEHAAhCJAxogAkGoAmogAkHoBGpBwAIQiQMaCyAAQQhqIAJBqAJqQcACEIkDGiAAQcgCaiAFOgAAIAAgATYCBCAAQQA2AgAgBkUNAiACQRBqEJMKIAJBGGoiABCvCCAAEM4KDAILIAJB8ARqIARBCGooAgAiATYCACACIAQpAgAiBzcD6AQgAEEMaiABNgIAIAAgBzcCBCAAQQE2AgAgAkEQahCTCiACQRhqIgAQrwggABDOCgwBCyADQfAEaiACQQhqKAIAIgE2AgAgAyACKQIAIgc3A+gEIABBDGogATYCACAAIAc3AgQgAEEBNgIACyADQfAJaiQAC/gCAQV/IwBB0ABrIgYkACAGQQhqIAEgAhDqCQJAAkAgBCAFTwRAIAYoAgwiByAEIAVrSw0CIAYoAgghBCADIAVqIQMgB0EITwRAIAQgB0F4aiIJaiEKIAlBAU4EQCADIQEDQCAEKQAAIAEpAABSDQUgAUEIaiEBIARBCGoiBCAKSQ0ACwsgCikAACADIAlqKQAAUg0DDAILIAYgAyAHEMcLIAZBEGogBCAEIAdqIAYoAgAgBigCBBCrCSAGQcgAaiAGQShqKAIANgIAIAZBQGsgBkEgaikDADcDACAGQThqIgMgBkEYaikDADcDACAGIAYpAxA3AzADQCAGKAJAIgEgBigCRE8NAiAGIAFBAWo2AkAgBkEwaiABEL0MIAMgARC9DCEBLQAAIAEtAABGDQALDAILIAUgBEH4iMwAELEHAAsgAEEMaiAFIAdqNgIAIABBCGogBzYCACAAIAJB//8DcTYCBEEBIQgLIAAgCDYCACAGQdAAaiQAC4cDAQl/IwBBEGsiAyQAAkAgASgCBCIFLwEyIgZBC08EQCADIAEoAggQlAggA0EIaigCACEEIAMoAgQhByABKAIAIQggAyADKAIANgIIIAMgCDYCACADIAU2AgQQrQsiBkEAOwEyIAZBADYCACADIAYQnQYhCSAEQQFqIgogBiAFIAdBAUYbIgEvATIiB00EQCABQQRqIgsgCkECdGogCyAEQQJ0aiAHIARrQQJ0EMIBCyABIARBAnRqQQRqIAI2AgAgACAINgIEIABBATYCACAAQRRqIAY2AgAgAEEQakEANgIAIABBDGogCTYCACAAQQhqIAU2AgAgASAHQQFqOwEyDAELIAEoAggiBEEBaiIIIAZNBEAgBUEEaiIHIAhBAnRqIAcgBEECdGogBiAEa0ECdBDCAQsgBSAEQQJ0akEEaiACNgIAIABBADYCACAAQQxqIAQ2AgAgAEEIaiAFNgIAIAAgASgCADYCBCAFIAZBAWo7ATIgBSEBCyAAIAE2AhggA0EQaiQAC4IDAQJ/IwBBIGsiAyQAIAMgASACEIECIAMoAgAhAQJAAkACQCADKAIIIgRBAkYEQCABLwAAQePMAUYNAQsgA0EQaiABIAQQiAVBASECIAMtABBBAUcEQCADKAIUIgJFDQEgAEEMaiADQRhqKAIANgIAIABBCGogAjYCAEEAIQIgAEEEakEANgIADAILIAAgAy0AEToAAQwBCyADQRBqIAEgBBCxBEEBIQICQCADLQAQQQFHBEAgAygCFCICRQ0BIABBDGogA0EYaigCADYCACAAQQhqIAI2AgAgAEEEakEBNgIAQQAhAgwCCyAAIAMtABE6AAEMAQsgA0EQaiABIAQQwAZBASECIAMtABBBAUcEQCADKAIUIgIEQCAAQQxqIANBGGooAgA2AgAgAEEIaiACNgIAIABBBGpBAjYCAEEAIQIMAgsgAEEBOwEAIAMoAgRFDQIgARCJAQwCCyAAIAMtABE6AAELIAAgAjoAACADKAIERQ0AIAEQiQELIANBIGokAAuCAwEDfwJAIAFFDQACQCAALQAAIgNBGHRBGHUiAkF/Sg0AAkAgAkFgcUFARwRAIAJBcHFBYEYNASACQXhxQXBHIAFBBElyDQMgAC0AASIBQcABcUGAAUcNAyAALQACIgRBQHFBgAFHDQMgAC0AAyIAQUBxQYABRw0DQYCAxAAhAyABQf8AcUEMdCACQQ9xQRJ0ciAEQf8AcUEGdHIiASAAQf8AcXIiAEGAgHxqQf//P0sNAkGAgMQAIAAgAUGA8P8BcUGAsANGGw8LIAFBAkkNAkGAgMQAIQMgAC0AASIAQcABcUGAAUcNASAAQf8AcSACQT9xQQZ0ciIAQYCAxAAgAEGAf2pBgA9JGw8LIAFBA0kNASAALQABIgFBwAFxQYABRw0BIAAtAAIiAEFAcUGAAUcNAUGAgMQAIQMgAUH/AHFBBnQgAkEfcUEMdHIiASAAQf8AcXIiAEGAcGpB/+8DSw0AQYCAxAAgACABQYDwB3FBgLADRhshAwsgAw8LQYCAxAALnwMCAn8BfiMAQZACayIDJAAgA0EQaiABQQAQ0AoCQAJAAn4CQAJAIAMoAhBBAUcEQCADQRBqIAFBABDQCiADKAIQQQFGDQEgA0EQaiABQQAQ0AogAygCEEEBRg0CIANBEGogASACEOABAkAgAygCECICQQJGBEAgARDDBSABEIUGIAEoAgAiAi0ABkUNAQwGCyADKQIUDAQLIAMgAi0ABDoAECADQRBqENMLRQRAIAEQrQEMBQsgARBqDAQLIAMoAhQhAiADQRhqKQMADAILIAMoAhQhAiADQRhqKQMADAELIAMoAhQhAiADQRhqKQMACyEFIAAgAjYCBCAAQQE2AgAgAEEIaiAFNwIAIAEQ3woMAQsgARDlAyADQRBqIAFB/AZqIgIQvwYgAUH6BGogA0EQakGAAhCJAxogASgCAC0ABkUEQCADQQhqIAFBBGoQhQEgAykDCCEFIAFB5ARqIgQQkwogBCAFNwIACyABEOoGIABBBGogAUHUBGpBqAIQiQMaIABBADYCACABQQRqEP0JIAIQ2gkLIANBkAJqJAALnwMCAn8BfiMAQZACayIDJAAgA0EQaiABQQAQ0AoCQAJAAn4CQAJAIAMoAhBBAUcEQCADQRBqIAFBABDQCiADKAIQQQFGDQEgA0EQaiABQQAQ0AogAygCEEEBRg0CIANBEGogASACEN0BAkAgAygCECICQQJGBEAgARDDBSABEIUGIAEoAgAiAi0ABkUNAQwGCyADKQIUDAQLIAMgAi0ABDoAECADQRBqENMLRQRAIAEQrQEMBQsgARBqDAQLIAMoAhQhAiADQRhqKQMADAILIAMoAhQhAiADQRhqKQMADAELIAMoAhQhAiADQRhqKQMACyEFIAAgAjYCBCAAQQE2AgAgAEEIaiAFNwIAIAEQ3woMAQsgARDlAyADQRBqIAFB/AZqIgIQvwYgAUH6BGogA0EQakGAAhCJAxogASgCAC0ABkUEQCADQQhqIAFBBGoQhQEgAykDCCEFIAFB5ARqIgQQkwogBCAFNwIACyABEOoGIABBBGogAUHUBGpBqAIQiQMaIABBADYCACABQQRqEP0JIAIQ2gkLIANBkAJqJAAL5wIBAn8gABCHAQJAAkACQAJAAkACQAJAIAAtAAAOCAUFAQUFAgMEAAsgAEEMaigCACICBEAgAEEEaigCACEBIAJBBXQhAgNAIAEQ3AIgAUEgaiEBIAJBYGoiAg0ACwsgAEEIaigCACIBRSABQQV0RXINBCAAKAIEEIkBDwsgAEEEaigCAEUEQCAAQQxqKAIAIgFFIAFBA3RFcg0EIAAoAggQiQEPCyAAQQxqKAIAIgFFIAFBAXRFcg0DIAAoAggQiQEMAwsgAEEQaiIAKAIAENgCDAMLAkAgAEEEaigCAEEBRw0AIABBDGooAgBFDQAgAEEIaigCABCJAQsgAEEYaiIAKAIAENgCDAILIABBDGooAgAiAgRAIABBBGooAgAhASACQQV0IQIDQCABENwCIAFBIGohASACQWBqIgINAAsLIABBCGooAgAiAUUgAUEFdEVyDQAgACgCBBCJAQsPCyAAKAIAEIkBC+cCAQJ/IAAQhwECQAJAAkACQAJAAkACQCAALQAADggFBQEFBQIDBAALIABBDGooAgAiAgRAIABBBGooAgAhASACQQV0IQIDQCABENwCIAFBIGohASACQWBqIgINAAsLIABBCGooAgAiAUUgAUEFdEVyDQQgACgCBBCJAQ8LIABBBGooAgBFBEAgAEEMaigCACIBRSABQQN0RXINBCAAKAIIEIkBDwsgAEEMaigCACIBRSABQQF0RXINAyAAKAIIEIkBDAMLIABBEGoiACgCABDZAgwDCwJAIABBBGooAgBBAUcNACAAQQxqKAIARQ0AIABBCGooAgAQiQELIABBGGoiACgCABDZAgwCCyAAQQxqKAIAIgIEQCAAQQRqKAIAIQEgAkEFdCECA0AgARDcAiABQSBqIQEgAkFgaiICDQALCyAAQQhqKAIAIgFFIAFBBXRFcg0AIAAoAgQQiQELDwsgACgCABCJAQvnAgECfyAAEIcBAkACQAJAAkACQAJAAkAgAC0AAA4IBQUBBQUCAwQACyAAQQxqKAIAIgIEQCAAQQRqKAIAIQEgAkEFdCECA0AgARDcAiABQSBqIQEgAkFgaiICDQALCyAAQQhqKAIAIgFFIAFBBXRFcg0EIAAoAgQQiQEPCyAAQQRqKAIARQRAIABBDGooAgAiAUUgAUEDdEVyDQQgACgCCBCJAQ8LIABBDGooAgAiAUUgAUEBdEVyDQMgACgCCBCJAQwDCyAAQRBqIgAoAgAQ2gIMAwsCQCAAQQRqKAIAQQFHDQAgAEEMaigCAEUNACAAQQhqKAIAEIkBCyAAQRhqIgAoAgAQ2gIMAgsgAEEMaigCACICBEAgAEEEaigCACEBIAJBBXQhAgNAIAEQ3AIgAUEgaiEBIAJBYGoiAg0ACwsgAEEIaigCACIBRSABQQV0RXINACAAKAIEEIkBCw8LIAAoAgAQiQEL5wIBAn8gABCHAQJAAkACQAJAAkACQAJAIAAtAAAOCAUFAQUFAgMEAAsgAEEMaigCACICBEAgAEEEaigCACEBIAJBBXQhAgNAIAEQ3AIgAUEgaiEBIAJBYGoiAg0ACwsgAEEIaigCACIBRSABQQV0RXINBCAAKAIEEIkBDwsgAEEEaigCAEUEQCAAQQxqKAIAIgFFIAFBA3RFcg0EIAAoAggQiQEPCyAAQQxqKAIAIgFFIAFBAXRFcg0DIAAoAggQiQEMAwsgAEEQaiIAKAIAENsCDAMLAkAgAEEEaigCAEEBRw0AIABBDGooAgBFDQAgAEEIaigCABCJAQsgAEEYaiIAKAIAENsCDAILIABBDGooAgAiAgRAIABBBGooAgAhASACQQV0IQIDQCABENwCIAFBIGohASACQWBqIgINAAsLIABBCGooAgAiAUUgAUEFdEVyDQAgACgCBBCJAQsPCyAAKAIAEIkBC+cCAQJ/IAAQhwECQAJAAkACQAJAAkACQCAALQAADggFBQEFBQIDBAALIABBDGooAgAiAgRAIABBBGooAgAhASACQQV0IQIDQCABENwCIAFBIGohASACQWBqIgINAAsLIABBCGooAgAiAUUgAUEFdEVyDQQgACgCBBCJAQ8LIABBBGooAgBFBEAgAEEMaigCACIBRSABQQN0RXINBCAAKAIIEIkBDwsgAEEMaigCACIBRSABQQF0RXINAyAAKAIIEIkBDAMLIABBEGoiACgCABDcAgwDCwJAIABBBGooAgBBAUcNACAAQQxqKAIARQ0AIABBCGooAgAQiQELIABBGGoiACgCABDcAgwCCyAAQQxqKAIAIgIEQCAAQQRqKAIAIQEgAkEFdCECA0AgARDcAiABQSBqIQEgAkFgaiICDQALCyAAQQhqKAIAIgFFIAFBBXRFcg0AIAAoAgQQiQELDwsgACgCABCJAQuJAwEEfyMAQSBrIgMkACACKAIYIQQCQAJAIAEoAgAiBUEUai0AACIGQQJGIAZBAXFyRQRAAkAgBEH/AUsNACACLQAcQQNHDQAgAkEdai0AAEUNAgsgAEEAOgAEIABBADYCACAAQQhqIAQ2AgAMAgsgAEEAOgAEIABBADYCACAAQQhqIAQ2AgAMAQsgBEEYdEEYdUF/TARAIAUtABUEQCAAQQE6AAQgAEEANgIAIABBBWogBDoAAAwCCyADQRhqIgQgAkEQaikCADcDACADQRBqIgUgAkEIaikCADcDACADIAIpAgA3AwggASgCBCECIAMgAUEIaigCACIBQQAQhQggAygCBCEGIAMoAgAgAiABEIkDIQIgAEEMaiABNgIAIABBCGogBjYCACAAIAI2AgQgAEEoakEBOgAAIABBATYCACAAQRBqIAMpAwg3AgAgAEEYaiAFKQMANwIAIABBIGogBCkDADcCAAwBCyAAQQA6AAQgAEEANgIAIABBCGogBDYCAAsgA0EgaiQAC/4CAQR/IwBBwANrIgIkACACIAEQmgMgAkHYAGogAkEYaikAADcDACACQdAAaiACQRBqKQAANwMAIAJByABqIAJBCGopAAA3AwAgAiACKQAANwNAIAJBIGogAkFAaxC1CCACQZgCaiACQThqIgMpAwA3AwAgAkGQAmogAkEwaiIEKQMANwMAIAJBiAJqIAJBKGoiBSkDADcDACACIAIpAyA3A4ACIAJBoAJqQZDdygBBoAEQiQMaIAJBQGsgAkGgAmogAkGAAmoQ3AwgAkGAAmogAkFAaxD7BCACQeABaiACQYACahDzCSAAQaABaiACQeABahDVBCAAIAIpAyA3APABIABB+AFqIAUpAwA3AAAgAEGAAmogBCkDADcAACAAQYgCaiADKQMANwAAIABB6AFqIAFBGGopAAA3AAAgAEHgAWogAUEQaikAADcAACAAQdgBaiABQQhqKQAANwAAIAAgASkAADcA0AEgACACQUBrQaABEIkDGiACQcADaiQAC/UCAQF/IwBB8ABrIgckACAHIAI2AgwgByABNgIIIAcgBDYCFCAHIAM2AhAgBwJ/AkACQAJAIABB/wFxQQFrDgIBAgALIAdBofHgADYCGEECDAILIAdBn/HgADYCGEECDAELIAdBmPHgADYCGEEHCzYCHAJAIAUoAgBFBEAgB0HMAGpB4QM2AgAgB0HEAGpB4QM2AgAgB0HsAGpBAzYCACAHQgQ3AlwgB0GE8uAANgJYIAdB4AM2AjwgByAHQThqNgJoDAELIAdBMGogBUEQaikCADcDACAHQShqIAVBCGopAgA3AwAgByAFKQIANwMgIAdB7ABqQQQ2AgAgB0HUAGpB4gM2AgAgB0HMAGpB4QM2AgAgB0HEAGpB4QM2AgAgB0IENwJcIAdB4PHgADYCWCAHQeADNgI8IAcgB0E4ajYCaCAHIAdBIGo2AlALIAcgB0EQajYCSCAHIAdBCGo2AkAgByAHQRhqNgI4IAdB2ABqIAYQ1woAC4wDAQF/IwBBgAFrIgMkACADQThqIAAQRAJAAkAgAy0AOEEBRwRAIANBMGogA0HRAGopAAA3AwAgA0EoaiADQckAaikAADcDACADQSBqIANBwQBqKQAANwMAIAMgAykAOTcDGCADQThqIAEQwQQgAygCOEEBRg0BIANB6ABqIANBxABqIgAoAgA2AgAgAyADKQI8NwNgIANBOGogAhDBBCADKAI4QQFGDQIgA0H4AGogACgCADYCACADIAMpAjw3A3AgA0EQaiADQeAAahDNCyADKAIUIQAgAygCECEBIANBCGogA0HwAGoQzQsgA0EYaiABIAAgAygCCCADKAIMEOMBIANB8ABqEKQLIANB4ABqEKQLIANBgAFqJAAPCyADIAMoAjw2AhhBwIPAAEErIANBGGpB7IPAAEHsgMAAEPMGAAsgAyADKAI8NgJwQcCDwABBKyADQfAAakHsg8AAQfyAwAAQ8wYACyADIAMoAjw2AnBBwIPAAEErIANB8ABqQeyDwABBjIHAABDzBgAL+wIBBH8jAEHwAWsiAyQAIAMgAUEoaiIFQSgQiQMhBEEAIQMDQCADIARqIgYgBikDACABIANqKQMAfDcDACADQQhqIgNBKEcNAAsgBEEoaiAFIAEQvgUgBEHQAGogBCACEHAgBEH4AGogBEEoaiACQShqEHAgBEGgAWogAUH4AGogAkHQAGoQcCAEQcgBaiABQdAAaiIBQSgQiQMaQQAhAwNAIARByAFqIANqIgIgAikDACABIANqKQMAfDcDACADQQhqIgNBKEcNAAsgACAEQdAAaiAEQfgAahC+BSAAQShqIARB0ABqQSgQiQMhAUEAIQMDQCABIANqIgIgAikDACAEQfgAaiADaikDAHw3AwAgA0EIaiIDQShHDQALIABB0ABqIARByAFqQSgQiQMhAUEAIQMDQCABIANqIgIgAikDACAEQaABaiADaikDAHw3AwAgA0EIaiIDQShHDQALIABB+ABqIARByAFqIARBoAFqEL4FIARB8AFqJAAL+wIBBH8jAEHwAWsiAyQAIAMgAUEoaiIFQSgQiQMhBEEAIQMDQCADIARqIgYgBikDACABIANqKQMAfDcDACADQQhqIgNBKEcNAAsgBEEoaiAFIAEQvgUgBEHQAGogBCACQShqEHAgBEH4AGogBEEoaiACEHAgBEGgAWogAUH4AGogAkHQAGoQcCAEQcgBaiABQdAAaiIBQSgQiQMaQQAhAwNAIARByAFqIANqIgIgAikDACABIANqKQMAfDcDACADQQhqIgNBKEcNAAsgACAEQdAAaiAEQfgAahC+BSAAQShqIARB0ABqQSgQiQMhAUEAIQMDQCABIANqIgIgAikDACAEQfgAaiADaikDAHw3AwAgA0EIaiIDQShHDQALIABB0ABqIARByAFqIARB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IQEgBCgCCCIGIAcgAxCJAxoMAQsgASgCBCEFIARBEGogAUEIaigCACIDQQAQhQggBCgCFCEBIAQoAhAiBiAFIAMQiQMaQQQhBQsgACAGNgIEIABBATYCACAAQQxqIAM2AgAgAEEIaiABNgIAIABBEGogAikCADcCACAAQShqIAU6AAAgAEEYaiACQQhqKQIANwIAIABBIGogAkEQaikCADcCAAsgBEFAayQAC9ICAQN/IwBBEGsiAiQAAkAgAUH/AE0EQCAAKAIIIgMgAEEEaigCAEYEQCAAIAMQ7wQgACgCCCEDCyAAIANBAWo2AgggACgCACADaiABOgAADAELIAJBADYCDAJ/IAFBgBBPBEAgAUGAgARJBEAgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwCCyACIAFBP3FBgAFyOgAPIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAQsgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQILIQEgAEEEaigCACAAQQhqIgQoAgAiA2sgAUkEQCAAIAMgARDuBCAEKAIAIQMLIAAoAgAgA2ogAkEMaiABEIkDGiAEIAEgA2o2AgALIAJBEGokAAvoAgEDfyMAQeAAayIEJAAgBEEQaiACIAMQqwIgBC8BECEFIARBCGogAiADEOQFIAQgBTsBICAEIAQpAwg3AxhBACEFAn9BACABRQ0AGkEAIANBAkkNABogBCAEQSBqIAIgAxD9CEHAAkEAIAQtAABBrJnMAGotAABB+wFJGwshBgJAAkACQCADDgICAQALIARByABqIAIgAxC5AiAEQUBrIARB2ABqKQMANwEAIARBOGogBEHQAGopAwA3AQAgBCAEKQNINwEwQQIhBQwBCyACLQAAIQFBASEFCyAAIAQpAxg3AiwgACAGNgI4IABBADYCICAAIAE6AAEgACAFOgAAIABBAmogBCkBKjcBACAAQShqIAM2AgAgAEEkaiACNgIAIABBNGogBEEgaigCADYCACAAQQpqIARBMmopAQA3AQAgAEESaiAEQTpqKQEANwEAIABBGGogBEFAaykBADcBACAEQeAAaiQAC88CAQJ/IAAQsgECQAJAAkACQAJAAkACQAJA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BCACKAIIIgMoAgAgAigCDCgCACAGEJAIIQULIAQgAygCACAGIAUQuwggAUEBaiEBIAAgB0cNAAsgAUH//wNxQf8BSw0BCyACKAIMIQAgAigCACECA0AgAigCACAEIAMoAgAgACgCACABEJAIIQUgBCADKAIAIAEgBRC7CCABQf//A3EgAUEBaiEBQf8BSQ0ACwsLugIBCX9BrObdACECAkACQCABKAIIIgVFDQAgASgCACIGIAVBBHQiAWohCSAGIQQDQCABRQ0BIAFBcGohASAEKAIIIARBEGohBEUNAAsgBigCCCECQQAhAQJAIAVBAUYEQCACIQMMAQsgBkEQaiEFIAIgBigCAGpBf2ohCiACIQMDQCAFIgFBEGohBQJAIAEoAggiB0UEQEEAIQEMAQsgASgCAEF/aiEEQQAhASAKIQgDQCABIAJGBEAgAiEBDAILIAQgB2otAAAgCC0AAEcNASAEQX9qIQQgCEF/aiEIIAcgAUEBaiIBRw0ACyAHIQELIAEgAyADIAFLGyEDIAUgCUcNAAsgAiADayEBIAIgA0kNAgsgBigCACABaiECCyAAIAM2AgQgACACNgIADwsgASACQajn3QAQsQcAC70CAgJ/AX4jAEHgAGsiBCQAIARBMGoiBSACQQhqKAIANgIAIAQgAikCADcDKCAEQQhqIAEgBEEoahDGAwJAIAQoAghBAUcEQCAEQUBrIARBJGooAgA2AgAgBEE4aiAEQRxqKQIANwMAIAUgBEEUaikCADcDACAEIAQpAgw3AyggBEHYAGogA0EQaikDADcDACAEQdAAaiADQQhqKQMANwMAIAQgAykDADcDSCAEQShqIARByABqEK8CIABBBjoAAAwBCyAEQRBqKAIAIARBFGooAgBBGGxqIgEpAwAhBiABIAMpAwA3AwAgACAGNwMAIAFBCGoiAikDACEGIAIgA0EIaikDADcDACAAQQhqIAY3AwAgAUEQaiIBKQMAIQYgASADQRBqKQMANwMAIABBEGogBjcDAAsgBEHgAGokAAvEAgEDfyMAQYABayIEJAACQAJAAkACQCABKAIAIgJBEHFFBEAgAkEgcQ0BIAA1AgBBASABEJcDIQAMBAsgACgCACEAQQAhAgNAIAIgBGpB/wBqQTBB1wAgAEEPcSIDQQpJGyADajoAACACQX9qIQIgAEEPSyAAQQR2IQANAAsgAkGAAWoiAEGBAU8NASABQQFB9PPgAEECIAIgBGpBgAFqQQAgAmsQogEhAAwDCyAAKAIAIQBBACECA0AgAiAEakH/AGpBMEE3IABBD3EiA0EKSRsgA2o6AAAgAkF/aiECIABBD0sgAEEEdiEADQALIAJBgAFqIgBBgQFPDQEgAUEBQfTz4ABBAiACIARqQYABakEAIAJrEKIBIQAMAgsgAEGAAUHk8+AAELEHAAsgAEGAAUHk8+AAELEHAAsgBEGAAWokACAAC6cCAQV/IAAgAkEDdCIEaiEFAkACQCABIAJrIgYgAkkEQCADIAUgBkEDdCIEEIkDIgcgBGohBCACQQFIIAZBAUhyDQEgAUEDdCAAakF4aiECA0AgAiAFIAQgBEF4aiIGLQAAIAVBeGoiCC0AAEkiARtBeGopAgA3AgAgBCAGIAEbIQQgACAIIAUgARsiBU8NAiACQXhqIQIgBCAHSw0ACwwBCyADIAAgBBCJAyAEaiEEIAJBAUggASACTHINASAAIAFBA3RqIQEDQCAAIAUgAyAFLQAAIgIgAy0AACIGSSIHGykCADcCACAAQQhqIQAgAyACIAZPQQN0aiIDIARPDQIgBSAHQQN0aiIFIAFJDQALDAELIAUhAAsgACADIAQgA2tBeHEQiQMaC7sCAQJ/IAAQsgECQAJAAkACQAJAAkACQCAAKAIADgkGAQYGBgIDBAUACyAAQSRqKAIAIgIEQCAAQRxqKAIAIQEgAkGEAWwhAgNAIAEQhgMgAUGEAWohASACQfx+aiICDQALCyAAQSBqKAIAIgFFIAFBhAFsRXINBSAAKAIcEIkBDAULIABBOGooAgAiAUUgAUEcbEVyDQQgACgCNBCJAQ8LAkACQCAAKAIEDgIBBQALIABBIGoQ2gQPCyAAQQhqEKcIDwsgAEFAayIAKAIAEKADIAAoAgAQiQEPCyAAQQRqENMHDwsgAEEkaigCACICBEAgAEEcaigCACEBIAJBhAFsIQIDQCABEIYDIAFBhAFqIQEgAkH8fmoiAg0ACwsgAEEgaigCACIBRSABQYQBbEVyDQAgACgCHBCJAQsL1gIBB38jAEEgayIDJAACQCABKAIAIgQoAjQiBUH/////B0kEQCAEIAVBAWo2AjQgBEFAaygCAEGkAWwhAiAEQThqKAIAIQYDQCACRQ0CIAIgBmogAkHcfmoiCCECQdx+ai0AAA0ACyAAQQQ2AgAgA0EYaiIFIAYgCGoiAkE4aikCADcDACADQRBqIgYgAkEwaikCADcDACADIAJBKGopAgA3AwggASgCBCEHIAMgAUEIaigCACIBQQAQhQggAygCACECIABBIGogAygCBDYCACAAIAI2AhwgAiAHIAEQiQMaIABBJGogATYCACAAIAMpAwg3AiggAEEwaiAGKQMANwIAIABBOGogBSkDADcCACAEIAQoAjRBf2o2AjQgA0EgaiQADwtBsLrMAEEYIANBCGpBlLvMAEGsr8wAEPMGAAsgBCAFNgI0QbyvzABBHUHcr8wAEOgKAAvZAgIBfwF+IwBBsAJrIgQkACAEQcgBaiADQSQQiQMaIARBDGogBEHIAWoQggUgBEEANgLIASAEQcgBakEEciAEQQxqQdwAEIkDGiAEQegAaiABIARByAFqENcBIAEoAgAiASgCNEUEQCABQX82AjQgBEHKAWogBEHoAGpB4AAQiQMaIAFBQGsoAgAiAyABQTxqKAIARgRAIAFBOGogAxCKCSABKAJAIQMLIAEoAjggA0GkAWxqIgMgAjoAASADQQE6AAAgA0ECaiAEQcgBakHiABCJAxogASABKAJAQQFqNgJAIABBHGpCADcCACAAQdi6zAAoAgA2AhggACABKQIAIgU3AgwgAEEUaiABQQhqKAIAIgI2AgAgACAFNwIAIABBCGogAjYCACABIAEoAjRBAWo2AjQgBEGwAmokAA8LQci6zABBECAEQcgBakGku8wAQeyvzAAQ8wYAC9ICAgR/AX4gAEHMAGohAyAAKQMAIQUCQCAAKAIIIgFBwABHBEAgAUHAAEkNASABQcAAQcyC4AAQsAcACyADIABBDGpBARA3QQAhASAAQQA2AggLIAEgAEEMaiIBakGAAToAACAAIAAoAggiBEEBaiICNgIIAkAgAkHBAEkEQCAAIAJqQQxqQQBBPyAEaxCRBRpBwAAgACgCCGtBCEkEQCADIAFBARA3IAAoAggiAkHBAE8NAiABQQAgAhCRBRoLIABBxABqIAVCKIZCgICAgICAwP8AgyAFQjiGhCAFQhiGQoCAgICA4D+DIAVCCIZCgICAgPAfg4SEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISENwIAIAMgAUEBEDcgAEEANgIIDwsgAkHAAEHcguAAELEHAAsgAkHAAEHsguAAELIHAAutAgEHfyMAQUBqIgMkACADQQhqIAIQkAcgAygCCCEEIAMoAgwhBiAAQQA2AgggACAGNgIEIAAgBDYCACADQRBqIAEgASACQQR0ahC8CyADQThqIANBGGooAgA2AgAgAyADKQMQNwMwIANBIGogA0EwaiAGEJALAkACQCADKAIsIgdFDQAgAygCICEBIAMoAiQhCCAEIAMoAigiBUEEdGohBCAGIAUgBiAFSxsiCSAFayEFA0AgASAIRg0BIAVFDQIgA0EgaiABEM0IIAMgAUEMai0AADoALCAEIAMpAyA3AgAgBEEIaiADQShqKQMANwIAIAVBf2ohBSAEQRBqIQQgAUEQaiEBIAdBf2oiBw0ACwsgACACNgIIIANBQGskAA8LIAkgBkGQ6csAELAHAAuiAgEGfyAAIAJBAXQiBGohBQJAAkAgASACayIGIAJJBEAgAyAFIAZBAXQiBBCJAyIHIARqIQQgAkEBSCAGQQFIcg0BIAFBAXQgAGpBfmohAgNAIAIgBUF+aiIGLwEAIgEgBEF+aiIILwEAIgkgCSABSSIBGzsBACAEIAggARshBCAAIAYgBSABGyIFTw0CIAJBfmohAiAEIAdLDQALDAELIAMgACAEEIkDIARqIQQgAkEBSCABIAJMcg0BIAAgAUEBdGohBgNAIAAgBS8BACIBIAMvAQAiAiABIAJJIgcbOwEAIABBAmohACADIAEgAk9BAXRqIgMgBE8NAiAFIAdBAXRqIgUgBkkNAAsMAQsgBSEACyAAIAMgBCADa0F+cRCJAxoLtQICCH8BfiMAQUBqIgIkACABQQhqKAIAIQQgASgCBCAAKAIEIQcgACgCACEIAn8CQCAAKAIIIgMgACgCDCIFRwRAIAEoAgAhAANAIAJBEGogA0EQaiIBKAIANgIAIAJBCGogA0EIaiIJKQIANwMAIAIgAykCACIKNwMAIAqnQQVGDQIgAkE4aiABKAIANgIAIAJBMGogCSkCADcDACACIAMpAgA3AyggAkEYaiACQShqEJYHIABBCGogAkEgaikDADcCACAAIAIpAxg3AgAgBEEBaiEEIABBEGohACADQRRqIgEhAyABIAVHDQALCyACQQU2AgAgBQwBCyADQRRqCyEDIAIQywggBDYCACADIAUgA2tBFG0Q3gYgAiAHNgIsIAIgCDYCKCACQShqEM0KIAJBQGskAAuuAgIFfwN+IwBBIGsiAyQAIAAoAgQgACgCCCIEayABQQxqKAIAIAEoAghrQQV2IgJJBEAgACAEIAIQhAkgACgCCCEECyAAKAIAIQIgA0EQaiABQQhqKQIAIgc3AwAgA0EYaiABQRBqKAIANgIAIAMgASkCADcDCCAHpyIBIANBFGooAgAiBUcEQCACIARBBXRqIQICQANAIAEtAABBCUcEQCABQQhqKQIAIQcgAUEQaikCACEIIAEpAgAhCSACQRhqIAFBGGopAgA3AgAgAkEQaiAINwIAIAJBCGogBzcCACACIAk3AgAgBEEBaiEEIAJBIGohAiABQSBqIgYhASAFIAZHDQEMAgsLIAFBIGohBQsgAyAFNgIQCyAAIAQ2AgggA0EIahChBCADQSBqJAALuAIBAX8jAEHgA2siAiQAIAJBwAFqIAEQwQQgAigCwAFBAUYEQCACIAIoAsQBNgJgQcCDwABBKyACQeAAakHsg8AAQZyAwAAQ8wYACyACQRhqIAJBzAFqKAIANgIAIAIgAikCxAE3AxAgAkEgakEAQcAAEJEFGiACQQhqIAJBEGoQzQsgAkEgakHAACACKAIIIAIoAgxBrIDAABCICyACQcABaiACQSBqQcAAEIkDGiACQeAAaiACQcABahDGCiACQcABaiACQeAAahCZBiACQaABaiACQcABahCCCyACQdgBaiACQbgBaikAADcDACACQdABaiACQbABaikAADcDACACQcgBaiACQagBaikAADcDACACIAIpAKABNwPAASAAIAJBwAFqEN4CIAJBEGoQpAsgAkHgA2okAAu8AgEIfyMAQRBrIgMkAAJAAkACQCAAKAIAIgQgACgCBCIAEOUFQf8BcSICQQNGDQAgAkEBaw4CAAECCyAAQQFqIQhBgIDEACEGA0AgBCAIIAQgCEsbIQIDQCACIAQiAEYNAyAAQQFqIQQgAEGAcHFBgLADRiAAQf//wwBLcg0ACyAGQYCAxABHQQAgBEF/aiIAIAZJGw0AIAMgABCLBSADKAIAIgBBAkYNASADKAIEIQIgAARAIAIhBgwBCyADKAIIIgkgAkYNACABKAIIIQADQCACKAIAIQUgASgCBCAA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ELwLAn9BACAEKAIAIgUgBCgCBCIJRg0AGiAEKAIIQQFqIQMCQANAIAUtAAAiCkEYdEEYdSILQX9KDQEgA0EBaiEDIAtB/wBxIAJ0IAdyIQcgAkEHaiECIAVBAWoiBSAJRw0AC0EAIQNBAAwBCyAKIAJ0IAdyCyECIAYgA0kNASABIAEoAgBBACACQQFxayACQQF2c2oiAjYCACABIAYgA2s2AgggASADIAhqNgIEQQELIQUgACACNgIEIAAgBTYCACAEQRBqJAAPCyADIAZBzNPLABCxBwALqwIBBn8jAEEwayICJAACQAJAAkAgAS0AAEEBaw4CAAECCyABLQABIQdBASEDDAELIAJBKGogAUEYaikBADcBACACQSBqIAFBEGopAQA3AQAgAiABQQhqKQEANwEYQQIhAwsgAUEoaigCACEEIAFBJGooAgAhBQJAIAEoAiBBAUYEQCAFIQYMAQsgAkEIaiAEQQAQhQggAigCCCIGIAUgBBCJAxoLIABBATYCICAAIAM6AAAgACAHOgABIAAgASkCLDcCLCAAQQJqIAIpARI3AQAgAEEoaiAENgIAIABBJGogBjYCACAAQQpqIAJBGmopAQA3AQAgAEESaiACQSJqKQEANwEAIABBGGogAkEoaikBADcBACAAQTRqIAFBNGopAgA3AgAgAkEwaiQAC5oCAgN/An4gACAAKQMAIgYgAq1CA4Z8Igc3AwAgAEEIaiIDIAMpAwAgByAGVK18NwMAAkACQAJAAkBBgAEgACgCUCIDayIEIAJNBEAgAEEQaiIFIAMEQCADQYEBTw0FIAMgAEHUAGoiA2ogASAEEIkDGiAAQQA2AlAgBSADQQEQMyACIARrIQIgASAEaiEBCyABIAJBB3YQMyAAQdQAaiABIAJBgH9xaiACQf8AcSICEIkDGgwBCyACIANqIgQgA0kNASAEQYABSw0CIAAgA2pB1ABqIAEgAhCJAxogACgCUCACaiECCyAAIAI2AlAPCyADIARBoIDgABCzBwALIARBgAFBoIDgABCyBwALIANBgAFBsIDgABCxBwALkwIBAn8jAEEQayICJAACQCABQf8ATQRAIAAoAggiAyAAKAIERgR/IAAgAxDiCCAAKAIIBSADCyAAKAIAaiABOgAAIAAgACgCCEEBajYCCAwBCyACQQA2AgwgACACQQxqAn8gAUGAEE8EQCABQYCABEkEQCACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAILIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwBCyACIAFBP3FBgAFyOgANIAIgAUEGdkHAAXI6AAxBAgsQ5wsLIAJBEGokAEEAC5ECAQN/IwBBMGsiBCQAIARBCGoCfyABKAIEIgMEQCABKAIADAELEKsLIgNBADsBkgMgA0EANgKIAiABIAM2AgQgAUEANgIAQQALIAMgAhD3BEEBIQUgBEEIakEEciEDAkAgBCgCCEEBRgRAIARBIGoiBSACQQhqKAIANgIAIARBLGogA0EIaigCADYCACAAIAIpAgA3AgQgAEEcaiABNgIAIAQgAykCADcCJCAAQQxqIAUpAwA3AgAgAEEUaiAEQShqKQMANwIAQQAhBQwBCyAAIAMpAgA3AgQgAEEQaiABNgIAIABBDGogA0EIaigCADYCACACKAIERQ0AIAIoAgAQiQELIAAgBTYCACAEQTBqJAAL3QIBAX8jAEEQayICJAACQAJAAkACQAJAAkAgAC0AAEEBaw4EAQIDBAALIAIgAUGYq8sAQQQQiws3AwAgAiAAQQRqNgIMIAJBnKvLAEEEIAJBDGpB0KnLABDwAhoMBAsgAiABQfiqywBBCRCLCzcDACACIABBAWo2AgwgAkGBq8sAQQQgAkEMakGIq8sAEPACGgwDCyACIAFB4KrLAEEEEIsLNwMAIAIgAEEEajYCDCACQeSqywBBASACQQxqQeiqywAQ8AIaDAILIAIgAUHDqssAQQYQiws3AwAgAiAAQQRqNgIMIAJByarLAEEGIAJBDGpB0KrLABDwAhoMAQsgAiABQaSqywBBBRCLCzcDACACIABBAWo2AgwgAkGpqssAQQUgAkEMakGwqssAEPACGiACIABBAmo2AgwgAkHAqssAQQMgAkEMakGwqssAEPACGgsgAhD5BiACQRBqJAALkwIBAn8jAEEQayICJAACQCABQf8ATQRAIAAoAggiAyAAKAIERgR/IAAgAxD5CCAAKAIIBSADCyAAKAIAaiABOgAAIAAgACgCCEEBajYCCAwBCyACQQA2AgwgACACQQxqAn8gAUGAEE8EQCABQYCABEkEQCACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAILIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwBCyACIAFBP3FBgAFyOgANIAIgAUEGdkHAAXI6AAxBAgsQ5wsLIAJBEGokAEEAC5ECAQN/IwBB0ABrIgIkACAAKAIEIAAoAggiA2sgASgCICIESQRAIAAgAyAEEIQJIAAoAgghAwsgACgCACEEIAJBCGogAUEkEIkDGiACKAIoBEAgAkEwaiACQQhqEKABAkAgAi0AMEEJRg0AIAQgA0EFdGohAQNAAkAgAiACKAIoQX9qNgIoIAFBGGogAkHIAGopAwA3AgAgAUEQaiACQUBrKQMANwIAIAFBCGogAkE4aikDADcCACABIAIpAzA3AgAgAigCKEUNACADQQFqIQMgAUEgaiEBIAJBMGogAkEIahCgASACLQAwQQlHDQEMAgsLIANBAWohAwsgACADNgIICyACQQhqENwCIAJB0ABqJAALhQMAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAEEBaw4VAQIDBAUGBwgJCgsMDQ4PEBESExQVAAsgASAAKAIEIABBCGooAgAQtwsPCyAAQQRqIAEQrgEPCyABQZSTywBBGBC3Cw8LIAFB+ZLLAEEbELcLDwsgAUHfkssAQRoQtwsPCyABQcaSywBBGRC3Cw8LIAFBupLLAEEMELcLDwsgAUGnkssAQRMQtwsPCyABQZSSywBBExC3Cw8LIAFBhpLLAEEOELcLDwsgAUH4kcsAQQ4QtwsPCyABQeqRywBBDhC3Cw8LIAFB3JHLAEEOELcLDwsgAUHJkcsAQRMQtwsPCyABQa+RywBBGhC3Cw8LIAFB8ZDLAEE+ELcLDwsgAUHdkMsAQRQQtwsPCyABQbmQywBBJBC3Cw8LIAFBq5DLAEEOELcLDwsgAUGYkMsAQRMQtwsPCyABQfyPywBBHBC3Cw8LIAFB5I/LAEEYELcLC5kCAQZ/IAEoAgQiBARAAn8CQAJAIAEoAgAgAqciBUGlxoiheHNBswNsIAJCIIinIgZB/wFxc0GzA2wgAkIoiKciB0H/AXFzQbMDbCAEcEECdGoiCCgCACIEIAFBEGooAgAiCU8NACABKAIIIARBDGxqIgQoAgAgBUcNACAELQAEIAZB/wFxRw0AIAQtAAUgB0H/AXFGDQELIAggCTYCACABKAIQIgQgAUEMaigCAEYEQCABQQhqIAQQ7wggASgCECEECyABKAIIIARBDGxqIgQgAzYCCCAEIAI3AgAgASABKAIQQQFqNgIQQQAMAQsgBCgCCCEEQQELIQEgACAENgIEIAAgATYCAA8LQfCoywBBOUHgqMsAENEJAAuMAgEFfwJAIAEoAgAiAkEgaigCACIEIAEoAgQiA0sEQCAAAn8gAAJ/IAIoAhgiBiADQSRsaiICKAIAQQFHBEBBACABKAIIIgUgAkEMaigCAE8NAhogASAFQQFqNgIIIAYgA0EkbGooAgQgBUEDdGoiASgCBCECIAEtAAAMAQsgAkEMaigCACIEIAEoAggiAyAEIANLGyEFIAJBBGohBgNAQQAgAyAFRg0CGiAEIANB/wFxIgJNDQQgASADQQFqIgM2AgggBigCACACQQJ0aigCACICRQ0ACyADQX9qCzoABCAAQQhqIAI2AgBBAQs2AgAPCyADIARBwMfLABCwBwALIAIgBEHQx8sAELAHAAuTAgEIf0Gs5t0AIQcCQCABKAIIIgRFDQAgASgCACIFIARBBHQiAWohCCAFIQIDQCABRQ0BIAFBcGohASACKAIIIAJBEGohAkUNAAsgBSgCCCEDIARBAUYEQCAFKAIAIQcMAQsgBUEQaiEEIAUoAgAhCSADIQIDQCAEIgFBEGohBAJAIAMgASgCCCIGIAYgA0sbIgZFBEBBACEBDAELIAEoAgAhB0EAIQEDQCABIAdqLQAAIAEgCWotAABHDQEgBiABQQFqIgFHDQALIAYhAQsgASACIAIgAUsbIQIgBCAIRw0ACyADIAJPBEAgBSgCACEHIAIhAwwBCyACIANBmOfdABCyBwALIAAgAzYCBCAAIAc2AgALjwICBX8BfiMAQaABayICJAAgACgCBCAAKAIIIgNrIAFBDGooAgAgASgCCGtBhAFuIgRJBEAgACADIAQQggkgACgCCCEDCyAAKAIAIQQgAkEQaiABQQhqKQIAIgc3AwAgAkEYaiABQRBqKAIANgIAIAIgASkCADcDCCAHpyIFIAJBFGooAgAiBkcEQCAEIANBhAFsaiEBA0AgBSIEKAIAIgVBCkcEQCACQSBqIARBBGpBgAEQiQMaIAEgBTYCACABQQRqIAJBIGpBgAEQiQMaIAFBhAFqIQEgA0EBaiEDIAYgBEGEAWoiBUcNAQsLIAIgBEGEAWo2AhALIAAgAzYCCCACQQhqEOsDIAJBoAFqJAALJAEBfyMAQSBrIgEkACAAQQA2AhQgAEEAOgAoQQAgAUEgaiQAC6cCAgJ/AX4jAEHgAGsiAiQAIAAoAgwhAyAAQQA2AgwgAwRAIABBEGopAgAhBCACQQhqIAEQzQsgAkEQaiACKAIIIAIoAgwQswkgAkHTAGogAkEYaigCADYAACACIAIpAxA3AEsgAiACQc8AaikAADcALyACIAIpAEg3AyggAiAENwI8IAIgAzYCOCACQdAAaiACKQAvNwAAIAJBAzoASCACIAIpAyg3AEkgAkEQaiAAIAJBOGogAkHIAGoQnQMCQCACLQAQIgBBBkYNAAJAAkACQCAADgUDAwMBAgALIAJBEGpBBHIQ3QYMAgsgAkEQakEEchCkCwwBCyACQRBqQQRyIgAQ8AMgABDzCgsgAkHgAGokAEEADwtB6PTKAEErQfT1ygAQiQwAC4sCAgR/AX4jAEEwayIEJAACQCACIANqIgMgAk8EQEEEIQIgASgCBCIGQQF0IgUgAyAFIANLGyIDQQQgA0EESxsiA61CDH4iCEIgiKcEQEEAIQILIAinIQUCQCAGBEAgASgCACEHIARBKGpBBDYCACAEIAZBDGw2AiQgBCAHNgIgDAELIARBADYCIAsgBEEQaiAFIAIgBEEgahC+BEEBIQIgBCgCEEEBRwRAIAQoAhQhAiABIAM2AgQgASACNgIAQQAhAgwCCyAEQQhqIAQoAhQgBEEYaigCABDmCyAAIAQpAwg3AgQMAQsgACADNgIEIABBCGpBADYCAEEBIQILIAAgAjYCACAEQTBqJAALiwICBX8BfiMAQTBrIgMkAAJAIAJBAWoiBCACTwRAQQQhAiABKAIEIgZBAXQiBSAEIAUgBEsbIgRBBCAEQQRLGyIErUIUfiIIQiCIpwRAQQAhAgsgCKchBQJAIAYEQCABKAIAIQcgA0EoakEENgIAIAMgBkEUbDYCJCADIAc2AiAMAQsgA0EANgIgCyADQRBqIAUgAiADQSBqEL4EQQEhAiADKAIQQQFHBEAgAygCFCECIAEgBDYCBCABIAI2AgBBACECDAILIANBCGogAygCFCADQRhqKAIAEOYLIAAgAykDCDcCBAwBCyAAIAQ2AgQgAEEIakEANgIAQQEhAgsgACACNgIAIANBMGokAAuLAgIFfwF+IwBBMGsiAyQAAkAgAkEBaiIEIAJPBEBBBCECIAEoAgQiBkEBdCIFIAQgBSAESxsiBEEEIARBBEsbIgStQhh+IghCIIinBEBBACECCyAIpyEFAkAgBgRAIAEoAgAhByADQShqQQQ2AgAgAyAGQRhsNgIkIAMgBzYCIAwBCyADQQA2AiALIANBEGogBSACIANBIGoQvgRBASECIAMoAhBBAUcEQCADKAIUIQIgASAENgIEIAEgAjYCAEEAIQIMAgsgA0EIaiADKAIUIANBGGooAgAQ5gsgACADKQMINwIEDAELIAAgBDYCBCAAQQhqQQA2AgBBASECCyAAIAI2AgAgA0EwaiQAC4sCAgV/AX4jAEEwayIDJAACQCACQQFqIgQgAk8EQEEEIQIgASgCBCIGQQF0IgUgBCAFIARLGyIEQQQgBEEESxsiBK1CJH4iCEIgiKcEQEEAIQILIAinIQUCQCAGBEAgASgCACEHIANBKGpBBDYCACADIAZBJGw2AiQgAyAHNgIgDAELIANBADYCIAsgA0EQaiAFIAIgA0EgahC+BEEBIQIgAygCEEEBRwRAIAMoAhQhAiABIAQ2AgQgASACNgIAQQAhAgwCCyADQQhqIAMoAhQgA0EYaigCABDmCyAAIAMpAwg3AgQMAQsgACAENgIEIABBCGpBADYCAEEBIQILIAAgAjYCACADQTBqJAALlAICA38BfkKAgAQhBgJAAkAgASACRiIFRQRAIAIgAU8NASAAIAJqLQAAQQpGrUIQhiEGCwJ/QQAgAiABTw0AGkEBIAAgAmotAAAiA0HfAXFBv39qQf8BcUEaSSADQTBPQQAgA0HfAEYgA0E6SXIbcg0AGkEACyEDAkAgAkUNACACQX9qIgIgAU8NAkEBIQQgACACai0AACIAQd8BcUG/f2pB/wFxQRpJIABBME9BACAAQd8ARiAAQTpJchtyDQBBACEECyAFrUIAQoCCgAggARuEIAaEQoCAgIAQQoCAgICAICADIARzG4RCgICAgICAgAFCACADG4QPCyACIAFB5NXLABCwBwALIAIgAUH01csAELAHAAu2AgIEfwF+IwBBEGsiAiQAIAIgAToADwJ/QQIgAkEPahDgCkH/AXEiAUEDRg0AGiABQYCEiBByIQNBnJLMACgCACEEQZSSzAAoAgAhBUEACyEBIAJBgAJBARDQBiACKQMAIQYgAEEfakEAQYAEEJEFGiAAQcgEaiABOgAAIABBxARqIAM2AgAgAEHCBGpBADoAACAAQcAEakEAOwEAIABBuARqQv////8PNwIAIABBsARqQgA3AgAgAEGsBGogBDYCACAAQaQEakIANwIAIAAgBTYCoAQgAEEAOgDMBCAAQQA2AgAgAEGfBGpBAToAACAAQR5qQQA6AAAgAEEcakEAOwEAIABBADYCGCAAQRZqQQA6AAAgAEEUakEAOwEAIABBDGpCgAI3AgAgACAGNwIEIAJBEGokAAuKAgIBfwF+IwBBIGsiAyQAIAMgAjoADCADIAE2AgggA0EAQQAQhQggA0EANgIYIAMgAykDADcDEAJAAkACQCADQQhqEKEFIgSnQQFxRQRAA0AgBEKAAoNQDQIgAygCGCIBIAMoAhRGBH8gA0EQaiABEOIIIAMoAhgFIAELIAMoAhBqIARCEIg8AAAgAyADKAIYQQFqNgIYIANBCGoQoQUiBEIBg1ANAAsLIABBATYCACAAIARCIIg+AgQgA0EQahCkCyADKAIIIgFBJEkNAgwBCyAAIAMpAxA3AgQgAEEANgIAIABBDGogA0EYaigCADYCACADKAIIIgFBI00NAQsgARAACyADQSBqJAALywEBCX8jAEEQayIEJAAgACgCBCAAKAIIIgNrQcAASQRAIAAgAxD2CCAAKAIIIQMLIAAoAgAgA0EMbGohAkE/IQUgASgCCCIGQQN0IQcgASgCACEIA0AgBEEIaiAGEPYFIAQoAgwhCSAEKAIIIAggBxCJAyEKIAJBCGogBjYCACACQQRqIAk2AgAgAiAKNgIAIAJBDGohAiAFQX9qIgUNAAsgAiABKQIANwIAIAAgA0FAazYCCCACQQhqIAFBCGooAgA2AgAgBEEQaiQAC+kBAQZ/AkAgAkECSQRAQQEhBwwBC0EBIQVBASEHQQEhBANAIAQhCQJAAkACQCAGIAhqIgQgAkkEQCABIAVqLQAAIQUgASAEai0AACEEAkAgA0UEQCAFIARJDQMgBSAESw0BDAQLIAUgBEsNAiAFIARPDQMLIAYgCWpBAWoiBCAIayEHQQAhBgwDCyAEIAJB5JfMABCwBwALQQEhByAJQQFqIQRBACEGIAkhCAwBC0EAIAZBAWoiBCAEIAdGIgQbIQYgB0EAIAQbIAlqIQQLIAQgBmoiBSACSQ0ACwsgACAHNgIEIAAgCDYCAAuLAgEJfyMAQRBrIgUkACAAKAIEIAAoAggiA2sgAUkEQCAAIAMgARCFCSAAKAIIIQMLIAAoAgAgA0EMbGohBCABQQJPBEAgAUF/aiEGIAIoAggiB0EYbCEIIAIoAgAhCQNAIAVBCGogBxCCByAFKAIMIQogBSgCCCAJIAgQiQMhCyAEQQhqIAc2AgAgBEEEaiAKNgIAIAQgCzYCACAEQQxqIQQgBkF/aiIGDQALIAEgA2pBf2ohAwsCQCABBEAgBCACKQIANwIAIAAgA0EBajYCCCAEQQhqIAJBCGooAgA2AgAMAQsgACADNgIIIAIoAgQiAEUgAEEYbEVyDQAgAigCABCJAQsgBUEQaiQAC64CAgF/AX4jAEFAaiIFJAAgBSAENgIUIAUgAzYCEAJAAkACQCADIARHBEACQAJAIAMgBE8EQCACIANJDQQgAiADRg0CIAQgA0kNASAEIANB+MnLABCwBwALIAIgBEkNBCACIARGDQULIAAgASAEQSRsajYCBCAAIAEgA0EkbGo2AgAgBUFAayQADwtBAEEAQejJywAQsAcACyAFQQhqIAVBEGpBFxDmCyAFKQMIIQYgBSAFQRRqQRcQ5gsgBUEsakECNgIAIAUgBjcDMCAFQgI3AhwgBUGYycsANgIYIAUgBSkDADcDOCAFIAVBMGo2AiggBUEYakGoycsAENcKAAtBmMvLAEEjQdjJywAQ0QkAC0GYy8sAQSNBuMnLABDRCQALQQBBAEHIycsAELAHAAuLAgEEfyMAQTBrIgQkAAJAIAIgA2oiAyACTwRAQQQhAiABKAIEIgZBAXQiBSADIAUgA0sbIgNBBCADQQRLGyIDQf////8BcSADRwRAQQAhAgsgA0EDdCEFAkAgBgRAIAEoAgAhByAEQShqQQQ2AgAgBCAGQQN0NgIkIAQgBzYCIAwBCyAEQQA2AiALIARBEGogBSACIARBIGoQwgVBASECIAQoAhBBAUcEQCAEKAIUIQIgASADNgIEIAEgAjYCAEEAIQIMAgsgBEEIaiAEKAIUIARBGGooAgAQ5gsgACAEKQMINwIEDAELIAAgAzYCBCAAQQhqQQA2AgBBASECCyAAIAI2AgAgBEEwaiQAC50CAQZ/IwBBEGsiBCQAAkACQAJAIAEoAgQiA0UEQEECIQMMAQsgASADIAEoAggiBSADIAMgBUsbIgNrNgIEIAEgASgCACIFIANqNgIAIANFDQEgBCAFLQAAIAEoAgwiBkEBdCIHELkGAkACfyAELQAAQQFHBEAgA0EBTQ0FIAQtAAEhCEEBIQMgBCAFLQABIAdBAXIQuQYgBC0AAEEBRgRAIARBCGooAgAMAgsgBC0AASAIQQR0ciEFDAILIARBCGooAgALIQMgBCgCBCEFIAIgAzYCBCACIAU2AgBBACEDCyABIAZBAWo2AgwLIAAgBToAASAAIAM6AAAgBEEQaiQADwtBAEEAQYiFywAQsAcAC0EBQQFBmIXLABCwBwALiwIBBH8jAEEwayIEJAACQCACIANqIgMgAk8EQEEEIQIgASgCBCIGQQF0IgUgAyAFIANLGyIDQQQgA0EESxsiA0H/////AXEgA0cEQEEAIQILIANBA3QhBQJAIAYEQCABKAIAIQcgBEEoakEENgIAIAQgBkEDdDYCJCAEIAc2AiAMAQsgBEEANgIgCyAEQRBqIAUgAiAEQSBqEL4EQQEhAiAEKAIQQQFHBEAgBCgCFCECIAEgAzYCBCABIAI2AgBBACECDAILIARBCGogBCgCFCAEQRhqKAIAEOYLIAAgBCkDCDcCBAwBCyAAIAM2AgQgAEEIakEANgIAQQEhAgsgACACNgIAIARBMGokAAuLAgEEfyMAQTBrIgQkAAJAIAIgA2oiAyACTwRAQQQhAiABKAIEIgZBAXQiBSADIAUgA0sbIgNBBCADQQRLGyIDQf////8DcSADRwRAQQAhAgsgA0ECdCEFAkAgBgRAIAEoAgAhByAEQShqQQQ2AgAgBCAGQQJ0NgIkIAQgBzYCIAwBCyAEQQA2AiALIARBEGogBSACIARBIGoQvgRBASECIAQoAhBBAUcEQCAEKAIUIQIgASADNgIEIAEgAjYCAEEAIQIMAgsgBEEIaiAEKAIUIARBGGooAgAQ5gsgACAEKQMINwIEDAELIAAgAzYCBCAAQQhqQQA2AgBBASECCyAAIAI2AgAgBEEwaiQAC4sCAQR/IwBBMGsiBCQAAkAgAiADaiIDIAJPBEBBBCECIAEoAgQiBkEBdCIFIAMgBSADSxsiA0EEIANBBEsbIgNB/////wBxIANHBEBBACECCyADQQR0IQUCQCAGBEAgASgCACEHIARBKGpBBDYCACAEIAZBBHQ2AiQgBCAHNgIgDAELIARBADYCIAsgBEEQaiAFIAIgBEEgahC+BEEBIQIgBCgCEEEBRwRAIAQoAhQhAiABIAM2AgQgASACNgIAQQAhAgwCCyAEQQhqIAQoAhQgBEEYaigCABDmCyAAIAQpAwg3AgQMAQsgACADNgIEIABBCGpBADYCAEEBIQILIAAgAjYCACAEQTBqJAAL7QEBA38gACADKAIIIAEoAgwgASgCCCIFQQ53IAVBGXdzIAVBA3ZzamogBCgCBCIGQQ93IAZBDXdzIAZBCnZzaiIGNgIMIAAgAygCBCAFIAEoAgQiB0EOdyAHQRl3cyAHQQN2c2pqIAQoAgAiBUEPdyAFQQ13cyAFQQp2c2oiBTYCCCAAIAMoAgAgByABKAIAIgFBDncgAUEZd3MgAUEDdnNqaiAGQQ93IAZBDXdzIAZBCnZzajYCBCAAIAQoAgwgASACKAIMIgBBDncgAEEZd3MgAEEDdnNqaiAFQQ93IAVBDXdzIAVBCnZzajYCAAuhAgEDfyMAQRBrIgQkACACBEAgACgCCCIFQf//A00EQCAAIAU7ASAgAEEUaigCACIDIABBEGooAgBGBEAgAEEMaiADEPoIIAAoAhQhAwsgACgCDCADQQF0aiAFOwEAIAAgACgCFEEBajYCFCAEQQhqIAJBABCFCCAEKAIMIQMgBCgCCCABIAIQiQMhBSAAKAIIIgEgACgCBEYEQCAAIAEQ+wggACgCCCEBCyAAKAIAIAFBDGxqIgEgAjYCCCABIAM2AgQgASAFNgIAIAAgACgCCEEBajYCCCAAIAAoAhwgAmo2AhwgACACIAAoAhgiACAAIAJLGzYCGCAEQRBqJAAPC0HIj8wAQTdBgJDMABDRCQALQayOzABBI0G4j8wAENEJAAuoAgEEfyMAQSBrIgIkAAJAIAFFBEAgAkHg5d0AKAIAIgE2AhwgAiABNgIYIAJBADYCFCACIAE2AhAgAiACQRBqEOcEIAIQywIgAkEAQf//wwAQrQkgAEEEakEANgEAIABBEGogAigCCDYBACAAQQhqIAIpAwA3AQBBASEBDAELIAJB6OXdACgCACIBNgIcIAIgATYCGCACQQA2AhQgAiABNgIQIAIgAkEQahDoBCACEM0CIAJBAEH/ARCsCSACKAIEIQUgAigCACEDQQEhASACKAIIIgQEQCAEQQF0IANqQX9qLAAAQX9KIQELIABBEGogBDYBACAAQQxqIAU2AQAgAEEIaiADNgEAIABBBGpBATYBAAsgACABOwEcIABBAjoAACACQSBqJAALhgIBBH8jAEFAaiICJAAgAkEQaiABIAEoAhAQ3QMCQCACLQAQIgNBAkdBACADQQFxG0UEQCAAQgA3AgQgAEGohcsAKAIANgIADAELIAItABEhAyACQShqIAEQzwcgAkEIakF/IAIoAigiBEEBaiIFIAUgBEkbIgRBCCAEQQhLG0EAEIUIIAIoAgwhBCACKAIIIgUgAzoAACACQSBqIgNBATYCACACIAQ2AhwgAiAFNgIYIAJBOGogAUEQaigCADYCACACQTBqIAFBCGopAgA3AwAgAiABKQIANwMoIAJBGGogAkEoahCKBSAAQQhqIAMoAgA2AgAgACACKQMYNwIACyACQUBrJAALkgIBA38jAEEQayIBJAACQAJAAkACQCAAKAIAIgItAAYEQCAAQfQEaigCACEDIAAoAtQEIQIMAQsgASACLQAEOgANIAFBDWoQ0wtFDQEgAEH0BGooAgAiAyAAKALUBCICTQ0DIABB7ARqKAIAIAJBJGxqQRxqKAIARQ0BCyADIAJNDQEgAEHsBGooAgAgAUEAOwEOIAFBCGogAUEOahDRCiABLQAIQQFxRQ0AIAJBJGxqIQMgAS0ACSEAA0AgAyAAEPIFIAJGBEAgAyAAQQEQrAQLIAEgAUEOahDRCiABLQABIQAgAS0AAEEBcQ0ACwsgAUEQaiQADwsgAiADQdDGywAQsAcACyACIANBwMbLABCwBwAL+gEBBn8jAEEwayICJAAgAkIANwIEIAJB6OfdACgCADYCACACIAApAgw3AgwgASACED0gAhCgBgJAAkACQCACKAIIIgVFDQAgBUEEdCEBIAIoAgAiBCEDA0AgAUUNASABQXBqIQEgAygCCCADQRBqIQNFDQALIAVBBHQhAQNAIAFFDQIgAUFwaiEBIAQoAgggBEEQaiEEDQALCyACEJQJIAIoAgQiAEUgAEEEdEVyDQEgAigCABCJAQwBCyACQShqIAJBEGooAgA2AgAgAkEgaiACQQhqKQMANwMAIAIgAikDADcDGCAAIAJBGGoQpgIhBwsgAkEwaiQAIAcLqgIBA38jAEEgayICJAACQAJAAkACQAJAAkACQAJAAkAgARCHAyIDQY1/ag4GBAEGAQEHAAsCQCADQZd/ag4FAgEBAQMACyADQdUARg0ECyACQQhqIAEQgwUgASgCBCEDIAIgAUEIaigCACIBQQAQhQggAigCBCEEIAIoAgAgAyABEIkDIQMgAEEoaiABNgIAIABBJGogBDYCACAAQSBqIAM2AgAgAEEEakEQNgIAIABBAToAACAAQSxqIAIpAwg3AgAgAEE0aiACQRBqKQMANwIAIABBPGogAkEYaikDADcCAAwGCyAAQQA7AQAMBQsgAEGAAjsBAAwECyAAQYAEOwEADAMLIABBgAY7AQAMAgsgAEGACDsBAAwBCyAAQYAKOwEACyACQSBqJAALkgICA38DfiMAQSBrIgJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJCADcDAANAIAanIQQgASEDQgAhBwNAIAMxAAAgB4YgBYQhBSADQQFqIQMgB0IIfCIHQsAAUg0ACyACIARBA3RqIAU3AwAgBkIBfCIGQgRSBEAgAUEIaiEBIAIgBqdBA3RqKQMAIQUMAQsLIAAgAikDACIFQv////////8HgzcDACAAIAIpAxgiBkIQiDcDICAAIAIpAwgiB0IMhiAFQjSIhEL/////////B4M3AwggACACKQMQIgVCGIYgB0IoiIRC/////////weDNwMQIAAgBkIkhiAFQhyIhEL/////////B4M3AxgLlgIBBn8jAEEwayIGJAAgASgCBCIHLwGSAyEEEKwLIgJBADsBkgMgAkEANgKIAiAGQQhqIAEgAhCUAyACLwGSAyIFQQFqIQMCQCAFQQxJBEAgAyAEIAEoAggiA2siBEcNASACQZgDaiADQQJ0IAdqQZwDaiAEQQJ0EIkDGiABKAIAIQNBACEBA0ACQCACIAFBAnRqQZgDaigCACIEIAE7AZADIAQgAjYCiAIgASAFTw0AIAEgASAFSWoiASAFTQ0BCwsgACAGQQhqQSgQiQMiAEE0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AjYCICABIAU2AhwgASACNgIQIAEgBTYCDEEACyECIAEgBDYCKCABIAI2AhggASACNgIIIAFBCGoQhQcMAgsgAEEIaigCAEUNASAAQQRqKAIAEIkBDAELIABBBGoiAhDwAyAAQQhqKAIAIgRFIARBGGxFcg0AIAIoAgAQiQELIABBGGohACADQWhqIgMNAAsLIAFBMGokAAuSAgEDfyMAQRBrIgMkAAJAAkACQAJAAkACQCABKAIAQQFrDgQAAQIDBQsgAUEIaigCACICDQMMBAsgAUEIaigCACICRQ0DIAFBADYCCCABKAIEIQQgAUG42ssANgIEDAMLIAFBCGooAgAiAkUNAiABIAJBf2o2AgggASABKAIEIgFBEGo2AgQgAyABEM0LIAMoAgAhBCADKAIEIQIMAgsgAUEIaigCACICRQ0BIAEgAkF/ajYCCCABIAEoAgQiAUEQajYCBCADQQhqIAEQzQsgAygCCCEEIAMoAgwhAgwBCyABIAJBf2o2AghBASECIAEgASgCBCIEQQFqNgIECyAAIAI2AgQgACAENgIAIANBEGokAAuBAgEEfyMAQSBrIgMkACABIAIQnAKnIgUgASgCEHEiBiABQRRqKAIAaigAACEEIANBEGpBADYCACADIAQ2AhQgAyAGNgIMIAMgAUEQajYCCCADIAVBGXYiAToAHCADIAQgAUGBgoQIbHMiAUF/cyABQf/9+3dqcUGAgYKEeHE2AhggAigCAEEIaiEEIAIoAgQhAQJ/A0AgAyADQQhqELoEQQAgAygCAEUNARogBCABIAMoAggoAgQiAiADKAIEQX9zIgVBDGxqIgYoAgBBCGogBigCBBCYC0UNAAsgAiAFQQxsaigCCCEEQQELIQEgACAENgIEIAAgATYCACADQSBqJAALjAIBAn8jAEHQAGsiAyQAAkAgASgCAARAIANBEGogAUE8EIkDGiACKAIEIQQgA0EIaiACQQhqKAIAIgFBABCFCCADKAIMIQIgAygCCCAEIAEQiQMhBCAAQShqIAE2AgAgAEEkaiACNgIAIABBIGogBDYCACAAQoGAgIAwNwIAIABBLGogAykCFDcCACAAQTRqIANBHGopAgA3AgAgAEE8aiADQSRqKQIANwIAIAMoAhBBBEkNASADQRBqQQRyEKcIDAELIABBADYCACAAIAEpAgQ3AgQg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AgwhCSAEKAIIIQogAUEgaigCACIFIQMgAUEcaigCACAFRgRAIAFBGGogBRDuCCABKAIgIQMLIAEoAhggA0EkbGoiAyACNgIgIAMgBjYCFCADQQEgByAIGzYCECADIAo2AgQgA0EBNgIAIANBGGpCADcCACADQQxqQYACNgIAIANBCGogCTYCACAAIAU2AgQgAEEANgIAIAEgASgCIEEBajYCICAEQRBqJAAL0AEBAn8jAEEgayIEJAACQCACIANqIgMgAk8EQCABKAIEIgJBAXQiBSADIAUgA0sbIgNBCCADQQhLGyEDAkAgAgRAIARBGGpBATYCACAEIAI2AhQgBCABKAIANgIQDAELIARBADYCEAtBASECIAQgA0EBIARBEGoQvgQgBCgCAEEBRwRAIAQoAgQhAiABIAM2AgQgASACNgIAQQAhAgwCCyAAIAQpAgQ3AgQMAQsgACADNgIEIABBCGpBADYCAEEBIQILIAAgAjYCACAEQSBqJAALigIBA38jAEEgayIEJABBASEFQeiU4QBB6JThACgCACIGQQFqNgIAAkBB0JjhACgCAEEBRgRAQdSY4QAoAgBBAWohBQwBC0HQmOEAQQE2AgALQdSY4QAgBTYCAAJAAkAgBkEASCAFQQJLcg0AIAQgAzYCHCAEIAI2AhhB3JThACgCACICQX9MDQBB3JThACACQQFqIgI2AgBB3JThAEHklOEAKAIAIgMEf0HglOEAKAIAIARBCGogACABKAIQEQAAIAQgBCkDCDcDECAEQRBqIAMoAhQRAABB3JThACgCAAUgAgtBf2o2AgAgBUEBTQ0BCwALIwBBEGsiAiQAIAIgATYCDCACIAA2AggAC+YBAQJ/IwBBEGsiAiQAIAIgASgCGEG2jOEAQREgAUEcaigCACgCDBEFADoACCACIAE2AgAgAkEAOgAJIAJBADYCBCACIAA2AgwgAiACQQxqQeSL4QAQrwMaAn8gAi0ACCIBIAIoAgQiA0UNABogAUH/AXEhAEEBIAANABogAigCACEAAkAgA0EBRw0AIAItAAlFDQAgAC0AAEEEcQ0AQQEgACgCGEG08+AAQQEgAEEcaigCACgCDBEFAA0BGgsgACgCGEG18+AAQQEgAEEcaigCACgCDBEFAAsgAkEQaiQAQf8BcUEARwvnAQEBfyMAQbABayIEJAAgBEHw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KQAANwMAIAJBCGogAkEpaikAADcDACACIAIpACE3AwAgAkEgaiACENwBIAAgAkHAAWoQ8wkgAEE4aiACQfgBaikDADcAACAAQTBqIAJB8AFqKQMANwAAIABBKGogAkHoAWopAwA3AAAgACACKQPgATcAICACQeABahDDCiACQYACaiQAC8wBAQJ/IwBB0ABrIgIkACACQTBqQbDlygBBBxCzCSACQUBrIAEQkgMgAkEgakG35coAQQMQswkgAkEQaiIBIAJBOGooAgA2AgAgAkEcaiIDIAJByABqKAIANgIAIAIgAikDMDcDCCACIAIpA0A3AhQgAEEkaiACQQhqEIQCIABBCGogASgCADYCACAAIAIpAwg3AgAgACACKQIUNwIMIABBFGogAygCADYCACAAIAIpAyA3AhggAEEgaiACQShqKAIANgIAIAJB0ABqJAAL5AEBAn8jAEEgayICJAAgAiABQfT2ygBBBRCLCzcDCAJAIAAoAgAiAEEATgRAIAIgADYCECACQQhqQcD3ygBBCCACQRBqQcj3ygAQ8AIaDAELIAIgABDECSACKAIAIgEEQCACKAIEIQMgAiABNgIQIAIgAzYCFCACIAA2AhwgAkEIakGY98oAQQ0gAkEcakGI98oAEPACGiACQQhqQaX3ygBBCyACQRBqQbD3ygAQ8AIaDAELIAIgADYCECACQQhqQfn2ygBBDCACQRBqQYj3ygAQ8AIaCyACQQhqEPkGIAJBIGokAAvDAQECfyMAQSBrIgMkACABIAAoAgRHBEAgACACQQF0IgQ2AiAgA0EIaiABEIIGIAAQygogAEEQaiICKAIAQQJ0BEAgACgCDBCJAQsgACADKQMINwIAIAIgA0EYaigCADYCACAAQQhqIANBEGoiAikDADcCACADIAEgBGwiARD2BSACQQA2AgAgAyADKQMANwMIIANBCGogASADEPAFIABBFGoQxwogAEEcaiACKAIANgIAIAAgAykDCDcCFAsgA0EgaiQAC7sBAQR/An8CQCADIAVJDQAgBQRAIAUhCSACIQcDQCAHLQAAIAZBAXRqIQYgB0EBaiEHIAlBf2oiCQ0ACwsgASgCBCEHIAEoAgAhCQNAAkAgAyAIaiEBIAYgCUYEQCACIAEgBCAFELoFDQELIAEgBU0NAiACIAVqLQAAIAYgByACLQAAbGtB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BEEQaiAEQTFqKQAANwMAIAQgBCkAKTcDCCAEQShqIAAgBEEIaiACIAMQxQEgBEEoahCvBSIFQiCIpyEAIAWnDQEgBEGQAWokACAADwsgBCAEKAIsNgIIQcCDwABBKyAEQQhqQeyDwABBgIPAABDzBgALIAQgADYCjAFBwIPAAEErIARBjAFqQfyDwABBkIPAABDzBgALywEBBH8gACgCCCEBIABByL7MADYCCCAAQQxqIgIoAgAhAyACQci+zAA2AgACQAJAIAEgA0YEQCAAKAIEIgFFDQEgACgCACIDIAAoAhAiACgCCCICRg0CIAAoAgAiBCACQQF0aiAEIANBAXRqIAFBAXQQwgEMAgsgACgCBCIBRQ0AIAAoAgAiAyAAKAIQIgAoAggiAkcEQCAAKAIAIgQgAkEBdGogBCADQQF0aiABQQF0EMIBCyAAIAEgAmo2AggLDwsgACABIAJqNgIIC8sBAQR/IAAoAgghASAAQci+zAA2AgggAEEMaiICKAIAIQMgAkHIvswANgIAAkACQCABIANGBEAgACgCBCIBRQ0BIAAoAgAiAyAAKAIQIgAoAggiAkYNAiAAKAIAIgQgAkEDdGogBCADQQN0aiABQQN0EMIBDAILIAAoAgQiAUUNACAAKAIAIgMgACgCECIAKAIIIgJHBEAgACgCACIEIAJBA3RqIAQgA0EDdGogAUEDdBDCAQsgACABIAJqNgIICw8LIAAgASACajYCCAvFAQEDfyMAQSBrIgIkACABKAIMLwEcIQMCfwJAIAEQ2ggEQCADQcMBcSEEDAELIANBzwFxIANBAnQiBEEgcXIgBEEQcXIhBEEAIANBgAJxRQ0BGgtBgAILIQMgAkEUaiABQQhqKQAANwAAIAJBHGogAUEQaigAADYAACAAQQU6AAAgACADIARyOwEcIAIgASkAADcADCAAIAIpAAk3AAEgAEEJaiACQRFqKQAANwAAIABBEGogAkEYaikAADcAACACQSBqJAALvgEBAn8jAEEgayIDJAACQCABIAJqIgIgAUkNACAAQQRqKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyECAkAgAQRAIANBGGpBATYCACADIAE2AhQgAyAAKAIANgIQDAELIANBADYCEAsgAyACIANBEGoQzgUgAygCAEEBRgRAIANBCGooAgAiAEUN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IAIoAgghASAAIAIoAgwiBDYCBCAAIAE2AgACQCAERQ0AIAdBDGwhBQNAIAVFDQEgAygCACEGIAIgAygCCCIIEPYFIAIoAgQhCSACKAIAIAYgCEEDdBCJAyEGIAFBCGogCDYCACABQQRqIAk2AgAgASAGNgIAIAFBDGohASAFQXRqIQUgA0EMaiEDIARBf2oiBA0ACwsgACAHNgIIIAJBEGokAAu2AQEEfyMAQSBrIgQkACAEIAI2AhwgBCABNgIYIARBEGogBEEYaiADEOEFIAQoAhQhBgJAIAQoAhAEQANAIAFFBEBBASEFDAMLIAQgAiAGQQJ0akE0aigCACICNgIcIAQgAUF/aiIBNgIYIARBCGogBEEYaiADEOEFIAQoAgwhBiAEKAIIDQALCyABIQcLIAAgBzYCBCAAIAU2AgAgAEEMaiAGNgIAIABBCGogAjYCACAEQSBqJAALwAEBA38jAEEQayIHJAACQCAEIAVPBEACQCAEIAVrIghFDQAgB0EIaiABLQCAAiABLQCBAiADIAVqIAgQiAIgBygCCEUNACACKAIMIAcoAgwgBWoiBkkEQCACIAY2AgwLIAYgBE8NAiAAIAVBACAGIAEgAyAGai0AAGotAABrIgEgASAGSxsiASABIAVJGzYCBEECIQYLIAAgBjYCACAHQRBqJAAPCyAFIARBxPvLABCxBwALIAYgBEHU+8sAELAHAAu+AQEBfyMAQaABayICJAAgAkEIaiABQdAAahD6ByACQTBqIAEgAkEIahBwIAJB2ABqIAFBKGogAkEIahBwIAJBgAFqIAJB2ABqEPYBIABBF2ogAkGXAWopAAA3AAAgAEEQaiACQZABaikAADcAACAAQQhqIAJBiAFqKQAANwAAIAAgAikAgAE3AAAgAi0AnwEhASACQYABaiACQTBqEPYBIAAgASACLQCAAUEBcRDaC0EHdHM6AB8gAkGgAWokAAvHAQEFfyMAQUBqIgIkAAJAIAEsAB9BAEgNACACQRhqIgQgAUEYaikAADcDACACQRBqIgUgAUEQaikAADcDACACQQhqIgYgAUEIaikAADcDACACIAEpAAA3AwAgAiACLQAfQf8AcToAHyACQSBqIAIQSiACIAJBIGoQ1AhB/wFxQQFHDQAgACACKQMANwABIABBGWogBCkDADcAACAAQRFqIAUpAwA3AAAgAEEJaiAGKQMANwAAQQEhAwsgACADOgAAIAJBQGskAAvDAQEGfyMAQSBrIgMkAAJAAkAgASgCBCIEIAJPBEAgBEUNAiAEQQJ0IQQgASgCACEFIAJBAnQiBkUEQEEEIQcgBEUNAiAFEIkBDAILIAUgBEEEIAYQxgsiBw0BIAAgBjYCBCAAQQhqQQQ2AgBBASEIDAILIANBHGpBADYCACADQZCBywA2AhggA0IBNwIMIANBiIHLADYCCCADQQhqQZCBywAQ1woACyABIAI2AgQgASAHNgIACyAAIAg2AgAgA0EgaiQAC8MBAQZ/IwBBIGsiAyQAAkACQCABKAIEIgQgAk8EQCAERQ0CIARBA3QhBCABKAIAIQUgAkEDdCIGRQRAQQQhByAERQ0CIAUQiQEMAgsgBSAEQQQgBhDGCyIHDQEgACAGNgIEIABBCGpBBDYCAEEBIQgMAgsgA0EcakEANgIAIANBnKDLADYCGCADQgE3AgwgA0GUoMsANgIIIANBCGpBnKDLABDXCgALIAEgAjYCBCABIAc2AgALIAAgCDYCACADQSBqJAALwwEBBn8jAEEgayIDJAACQAJAIAEoAgQiBCACTwRAIARFDQIgBEECdCEEIAEoAgAhBSACQQJ0IgZFBEBBBCEHIARFDQIgBRCJAQwCCyAFIARBBCAGEMYLIgcNASAAIAY2AgQgAEEIakEENgIAQQEhCAwCCyADQRxqQQA2AgAgA0GcoMsANgIYIANCATcCDCADQZSgywA2AgggA0EIakGcoMsAENcKAAsgASACNgIEIAEgBzYCAAsgACAINgIAIANBIGokAAvOAQECfwJAAkACQAJAAkACQCABQSBqKAIADgICAAELIAFBADYCICABKAIYIgIoAgAiA0EKRg0DIAAgAzYCACAAQQRqIAJBBGpBgAEQiQMaDAILIABBBGogAUEkEIkDGiAAQQg2AgAMAwsgAEEANgIAIAAgASkCADcCBCAAQRRqIAFBEGopAgA3AgAgAEEMaiABQQhqKQIANwIAIAEoAhghAgsgAUEcaigCACIARSAAQYQBbEVyDQEgAhCJAQ8LQZCpzABBK0GcqMwAENEJAAsLzgEBAn8CQAJAAkACQAJAAkAgAUEgaigCAA4CAgABCyABQQA2AiAgASgCGCICKAIAIgNBCkYNAyAAIAM2AgAgAEEEaiACQQRqQYABEIkDGgwCCyAAQQRqIAFBJBCJAxogAEEJNgIADAMLIABBADYCACAAIAEpAgA3AgQgAEEUaiABQRBqKQIANwIAIABBDGogAUEIaikCADcCACABKAIYIQILIAFBHGooAgAiAEUgAEGEAWxFcg0BIAIQiQEPC0GQqcwAQStBrKjMABDRCQALC84BAQJ/AkACQAJAAkACQAJAIAFBIGooAgAOAgIAAQsgAUEANgIgIAEoAhgiAigCACIDQQhGDQMgACADNgIAIABBBGogAkEEakHYABCJAxoMAgsgAEEEaiABQSQQiQMaIABBBzYCAAwDCyAAQQA2AgAgACABKQIANwIEIABBFGogAUEQaikCADcCACAAQQxqIAFBCGopAgA3AgAgASgCGCECCyABQRxqKAIAIgBFIABB3ABsRXINASACEIkBDwtBkKnMAEErQYCpzAAQ0QkACwvKAQEEfyABKAIAIgMoAgAhAgJAAn9BASABEIcDIgRBgAFJDQAaQQIgBEGAEEkNABpBA0EEIARBgIAESRsLIAJqIgUgAk8EQCADKAIIIgJBAWoiBCACSQ0BIAMoAgQhAiABEIcDIQEgACAFNgIMIABBCGogA0EIaigCADYCACAAIAMpAgA3AgAgAEEUakEBIAQgAUEKRiIBGzYCACAAQRBqIAEgAmo2AgAPC0HouswAQStBrKzMABDRCQALQei6zABBK0G8rMwAENEJAAu2AQEBfyMAQcADayICJAAgAkGoAWogAUEoEIkDGiACQdABaiABQShqQSgQiQMaIAJB+AFqIAFB0ABqQSgQiQMaQQMiAQRAA0AgAkGgAmogAkGoAWoQ+gIgAkEIaiACQaACakGgARCJAxogAkGgAmogAkEIahCfCiACQagBaiACQaACakH4ABCJAxogAUF/aiIBDQALCyACQaACaiACQagBahD6AiAAIAJBoAJqENAJIAJBwANqJAALyAEBAn8jAEHQBmsiAiQAIAIgASgCACIBNgIIIAJB4AVqIAFBCGoQvgYgAkHEBmpCADcCACACQcAGakGg6csAKAIAIgM2AgAgAkG4BmpCADcDACACIAM2ArQGIAJBsANqIAFBwARqEJMDIAJByARqIAFB+AhqEJMDIAJBEGogAkGwA2pBoAMQiQMaIABBADYCACAAQQRqIAJBDGpBpAMQiQMa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AkEMakHc8t0AEPACGiACIABBAWo2AgwgAkHs8t0AQQogAkEMakHc8t0AEPACGiACIABBAmo2AgwgAkH28t0AQRQgAkEMakHc8t0AEPACGiACIABBA2o2AgwgAkGK890AQQogAkEMakHc8t0AEPACGiACIABBBGo2AgwgAkGU890AQQcgAkEMakHc8t0AEPACGiACEPkGIAJBEGokAAuuAQEBfyMAQcADayIDJAAgASACIANBAEHAABCRBRDwASADQaABaiADQcAAEIkDGiADQUBrIANBoAFqEMYKIANBoAFqIANBQGsQmQYgA0GAAWogA0GgAWoQggsgA0G4AWogA0GYAWopAAA3AwAgA0GwAWogA0GQAWopAAA3AwAgA0GoAWogA0GIAWopAAA3AwAgAyADKQCAATcDoAEgACADQaABahDeAiADQcADaiQAC6EBAgF/AX4jAEEwayIBJAAgAUEIakGAAUEAEIUIIAFBADYCKCABIAEpAwg3AyAgASABQSBqNgIsAn4gACgCACABQSxqENIFIgBFBEAgASABKQIkNwIUIAEgASgCIDYCECABIAFBEGoQzQsgASgCACABKAIYEAQhACABQRBqEKQLQgAMAQsgAUEgahCkC0IBCyECIAFBMGokACAArUIghiAChAupAQEEfyMAQdAAayIBJAAgAUEANgIAIAFBKGogAUEEciABQSRqELwLIAEoAigiAiABKAIsIgNHBEAgASgCACEEIAJBACADIAJrIgIQkQUaIAEgAiAEajYCAAsgAUEoaiABQSQQiQMaIABBGGogAUHEAGopAgA3AAAgAEEQaiABQTxqKQIANwAAIABBCGogAUE0aikCADcAACAAIAEpAiw3AAAgAUHQAGokAAt0AQJ/IwBBIGsiAyQAAkAgAUEIaiIEQQhJIARBfEtyRQRAIANBCGogASACEPAEIAMoAghBAUYNASAAIAMpAgw3AwAgA0EgaiQADwtBnNHLAEErIANBGGpByNHLAEG00MsAEPMGAAsgBEEDakF8cUEEEOIMAAvEAQECfyMAQRBrIgIkACAAAn9BASAALQAEDQAaIAAoAgAhASAALQAFRQRAIAEoAhhBqPPgAEEHIAFBHGooAgAoAgwRBQAMAQsgAS0AAEEEcUUEQCABKAIYQaLz4ABBBiABQRxqKAIAKAIMEQUADAELIAJBAToADyACQQhqIAJBD2o2AgAgAiABKQIYNwMAQQEgAkGe8+AAQQMQvwENABogASgCGEGh8+AAQQEgASgCHCgCDBEFAAsiADoABCACQRBqJAAgAAueAQIBfwF+IwBBMGsiASQAIAFBCGpBgAFBABCFCCABQQA2AiggASABKQMINwMgIAEgAUEgajYCLAJ+IAAgAUEsahCeBSIARQRAIAEgASkCJDcCFCABIAEoAiA2AhAgASABQRBqEM0LIAEoAgAgASgCGBAEIQAgAUEQahCkC0IADAELIAFBIGoQpAtCAQshAiABQTBqJAAgAK1CIIYgAoQLngECAX8BfiMAQTBrIgEkACABQQhqQYABQQAQhQggAUEANgIoIAEgASkDCDcDICABIAFBIGo2AiwCfiAAIAFBLGoQnwUiAEUEQCABIAEpAiQ3AhQgASABKAIgNgIQIAEgAUEQahDNCyABKAIAIAEoAhgQBCEAIAFBEGoQpAtCAAwBCyABQSBqEKQLQgELIQIgAUEwaiQAIACtQiCGIAKEC54BAgF/AX4jAEEwayIBJAAgAUEIakGAAUEAEIUIIAFBADYCKCABIAEpAwg3AyAgASABQSBqNgIsAn4gAUEsaiAAEL8FIgBFBEAgASABKQIkNwIUIAEgASgCIDYCECABIAFBEGoQzQsgASgCACABKAIYEAQhACABQRBqEKQLQgAMAQsgAUEgahCkC0IBCyECIAFBMGokACAArUIghiAChAueAQIBfwF+IwBBMGsiASQAIAFBCGpBgAFBABCFCCABQQA2AiggASABKQMINwMgIAEgAUEgajYCLAJ+IAAgAUEsahCrBiIARQRAIAEgASkCJDcCFCABIAEoAiA2AhAgASABQRBqEM0LIAEoAgAgASgCGBAEIQAgAUEQahCkC0IADAELIAFBIGoQpAtCAQshAiABQTBqJAAgAK1CIIYgAoQLkwEBAX8gABCHAQJAAkACQAJAAkACQCAALQAADgcBAQABAQIDBQsgAEEIaiEBIABBBGooAgBFBEAgARD5Cg8LIAEQ+AoLDwsgAEEQaiIAKAIAELAFDAELIABBBGooAgBBAUYEQCAAQQhqEKQLCyAAQRhqIgAoAgAQsAULIAAoAgAQiQEPCyAAQQRqIgAQiwogABD7CguTAQEBfyAAEIcBAkACQAJAAkACQAJAIAAtAAAO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IAVqIgJBBHRqIgYoAgAgAyAEIAYoAgQiBiAGIARLGxCWCSIIRQRAIAYgBEkNAiAEIAZHDQEgASACQQR0aiIBKAIIIQUgAUEMaigCACEEDAULIAhBAEgNAQsgAiEHDAELIAJBAWohBQsgByAFayECIAcgBUsNAAtBACEFCyAAIAQ2AgQgACAFNgIAC78BAQF/IwBBEGsiAiQAIAIgAUH0390AQQ8Qiws3AwACQCAALQAAIgFBGHRBGHVBf0wEQCACQanf3QBBBSAAQZTg3QAQ8AIaDAELIAIgATYCDCACQanf3QBBBSACQQxqQYTg3QAQ8AIaCwJAIAAsAAEiAUF/TARAIAJBwN/dAEEDIABBAWpBlODdABDwAhoMAQsgAiABQf8BcTYCDCACQcDf3QBBAyACQQxqQYTg3QAQ8AIaCyACEPkGIAJBEGokAAvjAQECfiAAIAEpAyAgAikDIH1C8P///////z98IgRC/////////wODIAEpAxggAikDGH1C8P///////z98IgNCM4h8NwMgIAAgA0L/////////A4MgASkDECACKQMQfULw////////P3wiA0IziHw3AxggACADQv////////8DgyABKQMIIAIpAwh9QvD///////8/fCIDQjOIfDcDECAAIANC/////////wODIAEpAwAgAikDAH1C0P3//////z98IgNCM4h8NwMIIAAgBEIziEITfiADQv////////8Dg3w3AwALtQEBBH8jAEFAaiICJAAgAkEQaiIDIAEoAgAiBDYCACADIAQgASgCCGo2AgQgAigCFCEDIAIoAhAhASAAKAIAIgBB84zAAEEBEOcLIAEgA0cEQEEBIQQDQCAERQRAIABB9YzAAEEBEOcLCyACQQhqIAJBGGogAS0AABCNBiAAIAIoAgggAigCDBDnC0EAIQQgAUEBaiIFIQEgAyAFRw0ACwsgAEH0jMAAQQEQ5wsgAkFAayQAQQALowEBAn8jAEEQayIJJAAgCUEAOgAPAkACQAJAIAEgAiAJQQ9qIAMgBCAFIAYgByAIEPYCRQ0AIARFDQEgBEEBRg0CIAMoAgBBAUcNACADKAIIQQFHDQAgA0EMaigCACEBIAAgAygCBDYCBCAAQQhqIAE2AgBBASEKCyAAIAo2AgAgCUEQaiQADwtBAEEAQbjvywAQsAcAC0EBQQFByO/LABCwBwALwgEBAX8jAEEQayICJAACfwJAAkACQCAAKAIAQQFrDgIBAgALIAIgAUHE5N0AQQwQvQogAiAAQQRqNgIMIAIgAkEMakG05N0AEK8DGiACEJsGDAILIAIgAUGg5N0AQQsQiws3AwAgAiAAQQRqNgIMIAJBq+TdAEEEIAJBDGpBqODdABDwAhogAiAAQRBqNgIMIAJBr+TdAEEFIAJBDGpBtOTdABDwAhogAhD5BgwBCyABQZTk3QBBDBC3CwsgAkEQaiQAC6gBAQJ/AkACQAJAIAIEQEEBIQQgAUEATg0BDAILIAAgATYCBEEBIQQMAQsCQAJAAkACQCADKAIAIgUEQCADKAIEIgNFBEAgAQ0CDAQLIAUgAyACIAEQxgsiA0UNAgwECyABRQ0CCyABIAIQ5AsiAw0CCyAAIAE2AgQgAiEBDAMLIAIhAwsgACADNgIEQQAhBAwBC0EAIQELIAAgBDYCACAAQQhqIAE2AgALpgEBA38jAEEQayIBJAAgAEH0BGooAgAiAiAAKALUBCIDSwRAIABB7ARqKAIAIQAgAUEAOwEOIAFBCGogAUEOahDRCiABLQAIQQFxBEAgACADQSRsaiECIAEtAAkhAANAIAIgABDyBUUEQCACIAAgAxCsBAsgASABQQ5qENEKIAEtAAEhACABLQAAQQFxDQALCyABQRBqJAAPCyADIAJB0MbLABCwBwALoQEBBH8CQCAAKAIMRQ0AIAAoAgQiAUEEaiECIAAoAgAgAWpBAWohBCABKAIAQX9zQYCBgoR4cSEAA0AgAEUEQANAIAIgBE8NAyABQUBqIQEgAigCACACQQRqIgAhAkGAgYKEeHEiA0GAgYKEeEYNAAsgACECIANBgIGChHhzIQALIAEgAGhBA3ZBf3NBBHRqEKQLIABBf2ogAHEhAAwACwALC5wBAQR/AkAgAUECSQ0AIAAvAQIiAyAALwEAIgRPDQAgAEECaiECIAAgAzsBAAJAIAFBA0kNACAALwEEIgMgBE8NACAAIAM7AQIgAUEBdCAAakF+aiABQQNHBEAgAUF9aiEBIABBBGohAgNAIAJBAmoiAC8BACIFIARPDQIgAiAFOwEAIAAhAiABQX9qIgENAAsLIQILIAIgBDsBAAsLpwEBA38jAEHgDWsiAiQAIAJBwAxqIAEQkgcDQCACIANqIAJBwAxqQaABEIkDGiADQaABaiIDQYAKRw0AC0EAIQMDQCACQcAMaiABIAIgA2oiBBDFAiACQaALaiACQcAMahDQCSACQYAKaiACQaALahCSByAEQaABaiACQYAKakGgARCJAxogA0GgAWoiA0HgCEcNAAsgACACQYAKEIkDGiACQeANaiQAC5UBAgR/AX4jAEEQayIEJAAgASACQQN0IgVqIQYgBQRAIAFBBGohAgNAIAIoAgAgA2ohAyACQQhqIQIgBUF4aiIFDQALCyAEQQhqIANBABCFCCAEKQMIIQcgAEEANgIIIAAgBzcCACABIAZHBEADQCAAIAEoAgAgAUEEaigCABDnCyABQQhqIgEgBkcNAAsLIARBEGokAAuqAQIDfwJ+IwBBMGsiAiQAIAJBCGoiAyABQQhqIgQoAgA2AgAgAiABKQIANwMAIAJBGGogAhD4AyACKAIcRQRAQbCcywBBK0G0mcsAENEJAAsgAkEQaiACQShqKQMANwMAIAMgAkEgaikDACIFNwMAIAIgAikDGCIGNwMAIAQgBT4CACABIAY3AgAgACACKQIMNwIAIABBCGogAkEUaigCADYCACACQTBqJAALqQEBBX8gASgCACEGIAEtACUhB0GQy8sAKAIAIQUgAUEgaigCACIEIQMgAUEcaigCACAERgRAIAFBGGogBBDuCCABKAIgIQMLIAEoAhggA0EkbGoiAyACNgIgIAMgBTYCFCADQQEgBiAHGzYCECADIAU2AgQgA0EANgIAIANBGGpCADcCACADQQhqQgA3AgAgACAENgIEIABBADYCACABIAEoAiBBAWo2AiALqgECA38CfiMAQTBrIgIkACACQQhqIgMgAUEIaiIEKAIANgIAIAIgASkCADcDACACQRhqIAIQ+gMgAigCHEUEQEG44ssAQStBvN/LABDRCQALIAJBEGogAkEoaikDADcDACADIAJBIGopAwAiBTcDACACIAIpAxgiBjcDACAEIAU+AgAgASAGNwIAIAAgAikCDDcCACAAQQhqIAJBFGooAgA2AgAgAkEwaiQAC58BAQR/IwBBIGsiAiQAIAAoAgAhBCACQQhqIAAoAggiAxCgByACIAIoAgw2AhQgAiACKAIIIgU2AhAgBSAEIANBAXQQiQMaIAIgAzYCGCACQRBqIAEQkwIgACABKAIAIgMgAyAB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QAwBC0EBIQRBASEBQQEhAwNAIAIgACgCACAEakF/ai8AADsBCCACQQhqIAAQsQMNASABIAVJIQMgASAFRg0BIARBAmohBCAAKAIIIgYgAUsgAUEBaiIIIQENAAsgCEF/aiAGQfC/zAAQsAcACyAAEM0CIAJBEGokACADC5UBAQV/IAAoAgQgACgCCCIDayACIAFrQQN2IgRJBEAgACADIAQQgwkgACgCCCEDCyABIAJHBEAgACgCACADQQF0aiEEA0AgBEEBaiABLQAAIgUgAUEEai0AACIGIAUgBksiBxs6AAAgBCAGIAUgBxs6AAAgBEECaiEEIANBAWohAyABQQhqIgEgAkcNAAsLIAAgAzYCCAuVAQEFfyAAKAIEIAAoAggiA2sgAiABa0EDdiIESQRAIAAgAyAEEIAJIAAoAgghAwsgASACRwRAIAAoAgAgA0EDdGohBANAIARBBGogASgCACIFIAFBBGooAgAiBiAFIAZLIgcbNgIAIAQgBiAFIAcbNgIAIARBCGohBCADQQFqIQMgAUEIaiIBIAJHDQALCyAAIAM2AggLmwEBAn8jAEEgayICJAAgABCjAyACQRhqIABB5ABqKQIANwMAIAJBEGogAEHcAGopAgA3AwAgAkEIaiAAQdQAaikCADcDACACIAApAkw3AwBBACEAA0AgACABaiAAIAJqKAIAIgNBGHQgA0EIdEGAgPwHcXIgA0EIdkGA/gNxIANBGHZycjYAACAAQQRqIgBBIEcNAAsgAkEgaiQAC5MBAQN/IABBAEHAABCRBSIDIQADQCAAQQFqIAEgAmotAAAiBEEEdjoAACAAIARBD3E6AAAgAEECaiEAIAJBAWoiAkEgRw0ACyADLQAAIQBBACECA0AgAiADaiIBIAAgAEEIaiIAQfABcWs6AAAgAUEBaiIBIAEtAAAgAEEYdEEcdWoiADoAACACQQFqIgJBP0cNAAsLoAEBAX8jAEEgayICJAACQAJAIAEoAgAQK0UEQCABKAIAEB8NASAAQQA2AgAMAgsgAkEQaiABEJsJIABBCGogAkEYaigCADYCACAAIAIpAxA3AgAMAQsgAiABKAIAECg2AgwgAkEQaiACQQxqEJsJIABBCGogAkEYaigCADYCACAAIAIpAxA3AgAgAigCDCIAQSRJDQAgABAACyACQSBqJAALngECA38BfgJAIAFBAkkNACAALQAIIAAtAABPDQAgAEEIaiECIAApAgAhBSAAIAApAgg3AgACQCABQQNJDQAgAC0AECAFp0H/AXEiA08NACABQX5qIQEgAEEQaiEAA0AgACICQXhqIgQgACkCADcCACABQX9qIgFFDQEgBEEQaiEAIAJBCGotAAAgA0kNAAsLIAIgBUL/gYCAcIM3AgALC3cCA38BfiMAQRBrIgMkAAJAAkACQCABrUIMfiIFQiCIp0UEQCAFpyICQQBIDQEgAkUNAiACQQQQ5AsiBA0DIAJBBBDiDAALEI8KAAsgA0EIaiABQQAQ5gsQjwoAC0EEIQQLIAAgATYCBCAAIAQ2AgAgA0EQaiQAC3cCA38BfiMAQRBrIgMkAAJAAkACQCABrUIkfiIFQiCIp0UEQCAFpyICQQBIDQEgAkUNAiACQQQQ5AsiBA0DIAJBBBDiDAALEI8KAAsgA0EIaiABQQAQ5gsQjwoAC0EEIQQLIAAgATYCBCAAIAQ2AgAgA0EQaiQAC6IBAQF/IwBBIGsiBCQAIAQgAzYCHCAEIAI2AhggBEEQaiABKAIUIARBGGoQ8gNBASECAkAgBCgCEEEBRgRAIAQoAhQhASAEKAIYIgMgAygCACIDQX9qNgIAIANBAUcNASAEQRhqEPUKDAELIARBCGogASAEKAIYIAQoAhwQyQIgBCgCDCEBIAQoAgghAgsgACACNgIAIAAgATYCBCAEQSBqJAALhwEBBX8gASgCBCIDLwEyIgdBAnQhAUF/IQQgA0EEaiEFIAIoAgAhBkEBIQMCQANAIAFFBEAgByEEDAILIAUoAgAhAiAEQQFqIQQgAUF8aiEBIAVBBGohBUF/IAIgBkcgBiACSRsiAkEBRg0ACyACQf8BcQ0AQQAhAwsgACAENgIEIAAgAzYCAAuiAQECfyMAQdAGayICJAAgAkHgBWogASgCACIBQQhqEL4GIAJBxAZqQgA3AgAgAkHABmpBoOnLACgCACIDNgIAIAJBuAZqQgA3AwAgAiADNgK0BiACQbADaiABQcAEahCTAyACQcgEaiABQfgIahCTAyACQRBqIAJBsANqQaADEIkDGiAAQQA2AgAgAEEEaiACQQxqQaQDEIkDGiACQdAGaiQAC68BAQJ/IwBBEGsiAiQAIABBBGohAwJAIAAoAgBBAUcEQCACIAFBlZTMAEEPEIsLNwMAIAIgAzYCDCACQfOTzABBAyACQQxqQfiTzAAQ8AIaDAELIAIgAUHgk8wAQRMQiws3AwAgAiADNgIMIAJB85PMAEEDIAJBDGpB+JPMABDwAhogAiAAQQhqNgIMIAJBiJTMAEENIAJBDGpB+JPMABDwAhoLIAIQ+QYgAkEQaiQAC4EBAQR/AkAgAkUEQEEBIQQMAQsgASACaiEFIAEtAAAhA0EBIQJBASEEA0AgBSAGBH8gAQUgBSABayACQX9qTQ0CIAEgAmoLIgJGDQFBASEGIARBAXQhBCACQQFqIQEgAi0AACADQQF0aiEDQQAhAgwACwALIAAgBDYCBCAAIAM2AgALlAEBBn8CQCAAIAFNBEBB7hUhAkHuFSEEA0ACQEEBQX8gAkEBdiADaiICQQxsQbCezQBqKAIAIgUgAUsiBhsiByAHQQAgBhsgBSAASRsiBUEBRgRAIAIhBAwBCyAFQf8BcUH/AUcNAyACQQFqIQMLIAQgA2shAiAEIANLDQALQQAPC0G5pc8AQR5B2KXPABDRCQALQQELkwEBA38jAEGAAWsiAyQAIAAvAQAhAkEAIQADQCAAIANqQf8AakEwQdcAIAJBD3EiBEEKSRsgBGo6AAAgAEF/aiEAIAIiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQeTz4AAQsQcACyABQQFB9PPgAEECIAAgA2pBgAFqQQAgAGsQogEgA0GAAWokAAuTAQEDfyMAQYABayIDJAAgAC0AACECQQAhAANAIAAgA2pB/wBqQTBB1wAgAkEPcSIEQQpJGyAEajoAACAAQX9qIQAgAiIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFB5PPgABCxBwALIAFBAUH08+AAQQIgACADakGAAWpBACAAaxCiASADQYABaiQAC5IBAQN/IwBBgAFrIgMkACAALQAAIQJBACEAA0AgACADakH/AGpBMEE3IAJBD3EiBEEKSRsgBGo6AAAgAEF/aiEAIAIiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQeTz4AAQsQcACyABQQFB9PPgAEECIAAgA2pBgAFqQQAgAGsQogEgA0GAAWokAAuSAQEDfyMAQYABayIDJAAgAC8BACECQQAhAANAIAAgA2pB/wBqQTBBNyACQQ9xIgRBCkkbIARqOgAAIABBf2ohACACIgRBBHYhAiAEQQ9LDQALIABBgAFqIgJBgQFPBEAgAkGAAUHk8+AAELEHAAsgAUEBQfTz4ABBAiAAIANqQYABakEAIABrEKIBIANBgAFqJAALgwECAn8DfiMAQRBrIgEkAAJ+QoAMIABBCGooAgAiAkUNABogAUEIaiAAKAIEQQAgAhsiACgCACAAKAIEEOYLIAEoAgggASgCDBCHCCIDp0EBcUUEQCADQoD+g4BwgwwBC0IBIQQgA0IgiKetQiCGIgULIAFBEGokAEKA/gODIAWEIASEC4MBAgJ/A34jAEEQayIBJAACfkKADCAAQQhqKAIAIgJFDQAaIAFBCGogACgCBEEAIAIbIgAoAgAgACgCBBDmCyABKAIIIAEoAgwQiAgiA6dBAXFFBEAgA0KA/oOAcIMMAQtCASEEIANCIIinrUIghiIFCyABQRBqJABCgP4DgyAFhCAEhAuDAQICfwN+IwBBEGsiASQAAn5CgAggAEEIaigCACICRQ0AGiABQQhqIAAoAgRBACACGyIAKAIAIAAoAgQQ5gsgASgCCCABKAIMEPgJIgOnQQFxRQRAIANCgP6DgHCDDAELQgEhBCADQiCIp61CIIYiBQsgAUEQaiQAQoD+A4MgBYQgBIQLlgECAn8BfiAAKAIEIAAoAggiA2sgAiABa0EDdiIESQRAIAAgAyAEEN8IIAAoAgghAwsgASACRwRAIAAoAgAgA0EDdGohBANAIAEpAgAhBSABQQRqQQA2AgAgAUEAOgAAIAQgBTwAACAEQQRqIAVCIIg+AgAgBEEIaiEEIANBAWohAyABQQhqIgEgAkcNAAsLIAAgAzYCCAuTAQEDfyMAQRBrIgUkAAJAIAEtAAAEQEECIQMMAQsgAigCABAXIQMgBUEIahDyCiAFKAIMIQIgBSgCCCIEBEBBASEDIAFBAToAAAwBCwJ/IAIgAyAEGyIEEBgEQCABQQE6AABBAgwBCyAEEBkhAkEACyEDIARBJEkNACAEEAALIAAgAjYCBCAAIAM2AgAgBUEQaiQAC5EBAQN/IwBBIGsiAiQAIAAoAgQgACgCCCIDayABKAIMIAEoAghrQRRtIgRJBEAgACADIAQQ6AggACgCCCEDCyAAKAIAIQQgAkEIaiABQQhqKQIANwMAIAIgASkCADcDACACQRhqIAM2AgAgAiAAQQhqNgIUIAIgBCADQQR0ajYCECACIAJBEGoQpgMgAkEgaiQAC5EBAQN/IAAoAgQgACgCCCIDayABSQRAIAAgAyABEOUIIAAoAgghAwsgACgCACADQQN0aiEEIAFBAk8EQCABQX9qIQUDQCAEQQA2AgAgBEEEaiACNgIAIARBCGohBCAFQX9qIgUNAAsgASADakF/aiEDCyAAIAEEfyAEIAI2AgQgBEEANgIAIANBAWoFIAMLNgIIC6ABAQR/IwBBEGsiAiQAIAIgARCtAwJAAkAgAigCAEUEQCAAQQA2AgAMAQsgAUEQaigCACEDIAEoAgwhBCABKAIAKAIAQZwEaigCACIBIAEoAgAiBUEBajYCACAFQX9MDQEgACADNgIEIAAgBDYCACAAQQhqIAIpAwA3AgAgAEEUaiABNgIAIABBEGogAkEIaigCADYCAAsgAkEQaiQADwsAC5IBAQJ/AkACQCAAKAIAQQFHBEAgACgCBEF8aiECIABBDGooAgBBA3QhACABQf8BcSEBA0AgAEUEQEEADwsgAkEEaiAAQXhqIQAgAkEIaiECLQAAIAFHDQALDAELIABBDGooAgAiAiABQf8BcSIBTQ0BIAAoAgQgAUECdGohAgsgAigCAA8LIAEgAkGAx8sAELAHAAuYAQIBfwF+IwBBEGsiAyQAIAACfwJAIAJBwABGBEAgAS0APyICQSBJDQELIANBCGpBADYCACAAQQRqIAMpAwg3AgBBAQwBCyAAIAEvAAA7AAEgAEEDaiABQQJqLQAAOgAAIAEpAAMhBCAAQQxqIAFBC2pBNBCJAxogAEFAayACOgAAIABBBGogBDcAAEEACzoAACADQRBqJAALjQEBA38jAEGAAWsiAyQAIAAoAgAhAANAIAIgA2pB/wBqQTBB1wAgAEEPcSIEQQpJGyAEajoAACACQX9qIQIgAEEPSyAAQQR2IQANAAsgAkGAAWoiAEGBAU8EQCAAQYABQeTz4AAQsQcACyABQQFB9PPgAEECIAIgA2pBgAFqQQAgAmsQogEgA0GAAWokAAuMAQEDfyMAQYABayIDJAAgACgCACEAA0AgAiADakH/AGpBMEE3IABBD3EiBEEKSRsgBGo6AAAgAkF/aiECIABBD0sgAEEEdiEADQALIAJBgAFqIgBBgQFPBEAgAEGAAUHk8+AAELEHAAsgAUEBQfTz4ABBAiACIANqQYABakEAIAJrEKIBIANBgAFqJAALdgEDfyMAQRBrIgMkAAJAAkACQCABIAFB/////wFxRgRAIAFBA3QiAkEASA0BIAJFDQIgAkEEEOQLIgQNAyACQQQQ4gwACxCPCgALIANBCGogAUEAEOYLEI8KAAtBBCEECyAAIAE2AgQgACAENgIAIANBEGokAAuBAQEBfyMAQeAAayIDJAAgAyABIAIQwgggA0EgahDlCiADQSBqQSAgA0EgQYDdygAQiAsgA0HYAGogA0E4aikAADcDACADQdAAaiADQTBqKQAANwMAIANByABqIANBKGopAAA3AwAgAyADKQAgNwNAIAAgA0FAaxC1CCADQeAAaiQAC5UBAQF/IwBBQGoiAiQAIAJCADcDECACQRBqIAAoAgAQLiACIAIoAhQiADYCOCACIAA2AjQgAiACKAIQNgIwIAJBCGogAkEwakH0ABDmCyACQSRqQQE2AgAgAkICNwIUIAJBzILLADYCECACIAIpAwg3AyggAiACQShqNgIgIAEgAkEQahC1ByACQTBqEKQLIAJBQGskAAt2AQN/IwBBEGsiAyQAAkACQAJAIAEgAUH/////AHFGBEAgAUEEdCICQQBIDQEgAkUNAiACQQQQ5AsiBA0DIAJBBBDiDAALEI8KAAsgA0EIaiABQQAQ5gsQjwoAC0EEIQQLIAAgATYCBCAAIAQ2AgAgA0EQaiQAC5YBAQJ/IwBBEGsiBCQAAkACQAJAIAEgAUH/////A3FGBEAgAUECdCIDQQBIDQECQAJAIAJFBEAgAw0BDAULIANFDQQgA0EEEOULIgJFDQEMBQsgA0EEEOQLIgINBAsgA0EEEOIMAAsQjwoACyAEQQhqIAFBABDmCxCPCgALQQQhAgsgACABNgIEIAAgAjYCACAEQRBqJAALjgEBAn8jAEEQayIGJAAgBCAFTwRAAkAgBCAFayIERQ0AIAZBCGogAS0AACADIAVqIAQQvQIgBigCCEUNACACIAYoAgwgBWoiAjYCDCAAIAVBACACIAEtAAFrIgEgASACSxsiASABIAVJGzYCBEECIQcLIAAgBzYCACAGQRBqJAAPCyAFIARBtPvLABCxBwALrgEBAX8jAEEQayICJAAgAiABQYCAzABBDhCLCzcDACACIAA2AgwgAkH0/8sAQQcgAkEMakGM/8sAEPACGiACIABBgAJqNgIMIAJBzP/LAEEFIAJBDGpBsP/LABDwAhogAiAAQYECajYCDCACQfv/ywBBBSACQQxqQbD/ywAQ8AIaIAIgAEGCAmo2AgwgAkGOgMwAQQUgAkEMakGw/8sAEPACGiACEPkGIAJBEGokAAurAQEBfyMAQRBrIgIkACACIAFB44PMAEEGEIsLNwMAIAIgADYCDCACQemDzABBBCACQQxqQfCDzAAQ8AIaIAIgAEEBajYCDCACQYCEzABBBSACQQxqQYiEzAAQ8AIaIAIgAEECajYCDCACQZiEzABBDyACQQxqQaiEzAAQ8AIaIAIgAEEDajYCDCACQbiEzABBCSACQQxqQaiEzAAQ8AIaIAIQ+QYgAkEQaiQAC6sBAQF/IwBBEGsiAiQAIAIgAUGYicwAQQkQiws3AwAgAiAANgIMIAJBoYnMAEEHIAJBDGpBqInMABDwAhogAiAAQQxqNgIMIAJBuInMAEEIIAJBDGpBwInMABDwAhogAiAAQRBqNgIMIAJB0InMAEEJIAJBDGpBwInMABDwAhogAiAAQRRqNgIMIAJB2YnMAEEOIAJBDGpB6InMABDwAhogAhD5BiACQRBqJAALjwEAIwBBIGsiAiQAIAQgBU8EQCAAAn8CQCAEIAVrIgQEQCACQQhqIAEtAAAgAS0AASABLQACIAMgBWogBBDkASACKAIIDQELIAAgAikCFDcCBCAAQQxqIAJBHGooAgA2AgBBAAwBCyAAIAIoAgwgBWo2AgRBAgs2AgAgAkEgaiQADwsgBSAEQeT8ywAQsQcAC5IBAgF/An4gAEEAQSgQkQUhAANAIAAgA2ogASADaikDACAEfCACIANqKQMAfSIEQv////////8HgzcDACAEQj+HIQQgA0EIaiIDQShHDQALQQAhAwNAIAAgA2oiASABKQMAIAVCNIh8IANBkMLgAGopAwAgBIN8IgVC/////////weDNwMAIANBCGoiA0EoRw0ACwt6AQN/IwBBMGsiAiQAIAAoAgAgAkEgahDZC0EAIQADQCAAIAJqIgQgAikDIDcAACAEQQhqIAJBKGopAwA3AAAgAEEQaiIAQSBHDQALIAJBECABQRBBtOzKABCICyACQQIQ9QEgAUEQIAJBEEG07MoAEIgLIAJBMGokAAucAQEFfyMAQSBrIgIkACACQQhqIAFBABD6BSACKAIMIQQgAigCCCEFIAIgAUEBEPoFIAIgATYCGCACIAIoAgQiBjYCFCACIAIoAgAiAzYCECAGIAFLBEAgAkEQaiABEJ8JIAIoAhAhAyACKAIYIQELIAAgAzYCDCAAQQA2AgggACAFNgIAIABBEGogATYCACAAIAQ2AgQgAkEgaiQAC5sBAgF/AX4jAEGgFWsiAyQAIANBkA5qIAEQxgQgA0GQDmpBBHIhAQJAIAMoApAOQQFHBEAgA0GIB2ogAUGIBxCJAxogACADIANBiAdqQYgHEIkDIAIQ1gIMAQsgA0GQB2ogAUEIaigCACICNgIAIAMgASkCACIENwOIByAAQQxqIAI2AgAgACAENwIEIABBATYCAAsgA0GgFWokAAubAQIBfwF+IwBBoBVrIgMkACADQZAOaiABEMYEIANBkA5qQQRyIQECQCADKAKQDkEBRwRAIANBiAdqIAFBiAcQiQMaIAAgAyADQYgHakGIBxCJAyACENcCDAELIANBkAdqIAFBCGooAgAiAjYCACADIAEpAgAiBDcDiAcgAEEMaiACNgIAIAAgBDcCBCAAQQE2AgALIANBoBVqJAALkgEBAn8jAEEQayIBJAAgAEH0BGooAgAiAkEBSwRAIABB7ARqKAIAIQAgAUEAOwEOIAFBCGogAUEOahDRCiABLQAIQQFxBEAgAEEkaiECIAEtAAkhAANAIAIgAEEBEKwEIAEgAUEOahDRCiABLQABIQAgAS0AAEEBcQ0ACwsgAUEQaiQADwtBASACQdDGywAQsAcAC48BAQJ/IABB+ANqKAIAIgIEQCAAKALwAyEBIAJBBHQhAgNAIAEQsgogAUEQaiEBIAJBcGoiAg0ACwsgAEHwA2oQywogAEH8A2oQygogAEGIBGoiARDBCSABEMkKIAAoApQEIgEgASgCACIBQX9qNgIAIAFBAUYEQCAAQZQEahD+CQsgAEGcBGoQpAsgABCIBAuPAQECfyAAQfgDaigCACICBEAgACgC8AMhASACQQR0IQIDQCABELIKIAFBEGohASACQXBqIgINAAsLIABB8ANqEMsKIABB/ANqEMoKIABBiARqIgEQwQkgARDJCiAAKAKUBCIBIAEoAgAiAUF/ajYCACABQQFGBEAgAEGUBGoQ/gkLIABBnARqEKQLIAAQ9QILbwEDfyMAQRBrIgMkAAJAAkACQCABIAFqIgIgAU8EQCACQQBIDQEgAkUNAiACQQIQ5AsiBA0DIAJBAhDiDAALEI8KAAsgA0EIaiABQQAQ5gsQjwoAC0ECIQQLIAAgATYCBCAAIAQ2AgAgA0EQaiQAC58BACAAQQA6ACIgAEEAOwEgIABCADcCBCAAQQA6ACggAEL/////DzcCGCAAQRBqQgA3AgAgAEGckswAKAIANgIMIABBlJLMACgCADYCACAAIAEtAABBgAQgAS0AASIAQQFGQQh0IABBAkYbckGAgAggAS0AAiIAQQBHQRB0IABBAkYbckGAgIAQIAEtAAMiAEEAR0EYdCAAQQJGG3I2AiQLiQEBB38gASgCBCICQYACIAJBgAJLGyEFIAEoAgAhBiABLQAIQQFHIQcgAUEJai0AACEIAkADQCAFIAIiA0YNASABIANBAWoiAjYCBCAHRUEAIAggAyAGai0AACIERhsNAAsgASAEOgAJIAFBAToACCACQX9qIQQLIAAgBDoAASAAIANBgAJJOgAAC5EBAQR/IwBBIGsiAiQAIAEoAAAhAyABKAAEIQQgASgACCEFIAIgAEEcaigCACABKAAMczYCDCACIAUgAEEYaigCAHM2AgggAiAEIABBFGooAgBzNgIEIAIgAyAAKAIQczYCACACQRhqIABBCGopAgA3AwAgAiAAKQIANwMQIABBEGogAiACQRBqEEcgAkEgaiQAC58BAQJ/IwBBMGsiAiQAQQEhAwJAIAFBmMTgAEEbELcLDQACQCAAKAIABEAgAiAANgIMIAJBJGpBATYCACACQgI3AhQgAkHAxOAANgIQIAJBwQM2AiwgAiACQShqNgIgIAIgAkEMajYCKCABIAJBEGoQtQdFDQEMAgsgAUGzxOAAQQQQtwsNAQsgAUHQxOAAQQIQtwshAwsgAkEwaiQAIAMLgwEBAn8CQAJ/IAJB/wFxIgNB4wBNBEBBAiADQQpJDQEaQQEhBCABIANBAXRBjIjAAGovAAA7AAEMAgsgASACIANB5ABuIgJB5ABsa0H/AXFBAXRBjIjAAGovAAA7AAFBAAsiBCABaiACQTBqOgAACyAAQQMgBGs2AgQgACABIARqNgIAC5ABAQN/IwBBEGsiAiQAIAJBCGogARDyAiACLwEIQQFGBEAgAi8BCiEEA0AgACgCCCIDIAAoAgRGBEAgACADIAEoAgQgASgCAGtBA2pBAnZBAWoQ4wgLIAAoAgAgA0EBdGogBDsBACAAIANBAWo2AgggAiABEPICIAIvAQIhBCACLwEAQQFGDQALCyACQRBqJAALgwEBBH8gASgCACABKAIESQRAA0AgASABKAIAIgJqQQhqLQAAIQQgASACQQFqIgM2AgAgACgCCCICIAAoAgRGBEAgAEF/IAEoAgQgA2siA0EBaiIFIAUgA0kbEJMLCyAAKAIAIAJqIAQ6AAAgACACQQFqNgIIIAEoAgAgASgCBEkNAAsLC5UBAQJ/AkAgASgCBCIEIAJNBEAgBCECQX8hAQwBC0EBIQMgASgCACACaiAEIAJrENUCIgFBgIDEAEYEQEF/IQEMAQsgAUGA8P8AcUGAsANGIAFBgH9qQf/+wwBLcg0AQQIhAyABQYAQSQ0AQQNBBCABQYCABEkbIQMLIABBADoADCAAIAE2AgQgACACNgIAIAAgAzYCCAuKAQAjAEEgayICJAAgBCAFTwRAIAACfwJAIAQgBWsiBARAIAJBCGogAS0AACABLQABIAMgBWogBBCIAiACKAIIDQELIAAgAikCFDcCBCAAQQxqIAJBHGooAgA2AgBBAAwBCyAAIAIoAgwgBWo2AgRBAgs2AgAgAkEgaiQADwsgBSAEQdT8ywAQsQcAC4oBAQJ/IwBBIGsiAiQAAkAgARCHA0HcAEYEQCAAIAEQRQwBCyACQQhqIAEQgwUgARCHAyEDIAEQsQIaIABBJGpBADoAACAAQSBqIAM2AgAgAEIANwIAIABBGGogAkEYaikDADcCACAAQRBqIAJBEGopAwA3AgAgAEEIaiACKQMINwIACyACQSBqJAALkgEBAn8CQAJAAkACQCAAKAIADgcBAQEBAgEDAAsgAEEkaigCACICBEAgAEEcaigCACEBIAJB3ABsIQIDQCABEJYGIAFB3ABqIQEgAkGkf2oiAg0ACwsgAEEgaigCACIBRSABQdwAbEVyDQAgACgCHBCJAQsPCyAAQQRqEKcIDwsgACgCBEEYahC6CSAAKAIEEIkBC5gBAQF/IwBBIGsiAiQAIAEtAAAEQCACQRRqQQE2AgAgAkIBNwIEIAJBpOjdADYCACACQaEDNgIcIAIgATYCGCACIAJBGGo2AhAgAkGU6d0AENcKAAsgAEEYaiABQRxqKQIANwIAIABBEGogAUEUaikCADcCACAAQQhqIAFBDGopAgA3AgAgACABQQRqKQIANwIAIAJBIGokAAuYAQECfyMAQRBrIgMkACAAKAIAIgAoAgBFBEAgAEF/NgIAIABBDGooAgAiAiAAQQhqKAIARgRAIABBBGogAhCJCSAAKAIMIQILIAAoAgQgAkEkbGogAUEkEIkDGiAAIAAoAgxBAWo2AgwgACAAKAIAQQFqNgIAIANBEGokAA8LQbPz3QBBECADQQhqQfjz3QBBsO7dABDzBgALkgEBAn8CQAJAAkACQCAAKAIADgcBAQEBAgEDAAsgAEEkaigCACICBEAgAEEcaigCACEBIAJB3ABsIQIDQCABEJYGIAFB3ABqIQEgAkGkf2oiAg0ACwsgAEEgaigCACIBRSABQdwAbEVyDQAgACgCHBCJAQsPCyAAQQRqEKcIDwsgACgCBEEYahC8CSAAKAIEEIkBC50BAQF/IwBBkAFrIgIkACACQcgAakEAQcAAEJEFGiACQcgAakEgIAFBIEHM/d8AEIgLIAJB6ABqQSAgAUEgakEgQdz93wAQiAsgAiACQcgAakHAABDzBSACLQAAQQFGBEAgAiACKQIENwOIAUH8/d8AQSsgAkGIAWpBqP7fAEHs/d8AEPMGAAsgACACQQFyQcAAEIkDGiACQZABaiQAC4YBAQF/IwBBMGsiBCQAIAQgAzYCKCAEIAM2AiQgBCACNgIgIARBCGogBEEgahCMCCAEQRBqIAEgBCgCCCIBIAQoAgwiAhDMBCACBEAgARCJAQsgBEEoaiAEQRhqKAIANgIAIAQgBCkDEDcDICAEIARBIGoQjAggACAEKQMANwMAIARBMGokAAuKAQEEfyMAQUBqIgIkACACQRhqIgNCADcDACACQRBqIgRCADcDACACQQhqIgVCADcDACACQgA3AwAgAkEgIAFBIEGc8sEAEIgLIAJBOGogAykDADcDACACQTBqIAQpAwA3AwAgAkEoaiAFKQMANwMAIAIgAikDADcDICAAIAJBIGoQrQggAkFAayQAC30BAn4gACABKQMAIgUgAykDAHwgAikDCCIGQj+JIAZCOImFIAZCB4iFfCAEKQMAIgZCLYkgBkIDiYUgBkIGiIV8NwMAIAAgAykDCCABKQMIIAVCP4kgBUI4iYUgBUIHiIV8fCAEKQMIIgVCLYkgBUIDiYUgBUIGiIV8NwMIC5MBAQJ/IAAtAAghASAAKAIEIgIEQCABQf8BcSEBIAACf0EBIAENABogACgCACEBAkAgAkEBRw0AIAAtAAlFDQAgAS0AAEEEcQ0AQQEgASgCGEG08+AAQQEgAUEcaigCACgCDBEFAA0BGgsgASgCGEG18+AAQQEgAUEcaigCACgCDBEFAAsiAToACAsgAUH/AXFBAEcLlwEAIAAQsgECQAJAAkACQAJAAkACQCAAKAIADgkGAQYGBgIDBAUACyAAQRxqIgAQjAogABD+CgwFCyAAQTRqEPwKDwsCQAJAIAAoAgQOAgEFAAsgAEEgahDDBg8LIABBCGoQ+gkPCyAAQUBrIgAoAgAQnAYgACgCABCJAQ8LIABBBGoQ5gkPCyAAQRxqIgAQjAogABD+CgsLiAEBBH8gASAAKAIEIgIvATIiAyAAKAIIIgRBf3NqIgA7ATICQCAAQQxJBEAgAyAEQQFqIgNrIABHDQEgAiAEQQJ0akEEaigCACABQQRqIAIgA0ECdGpBBGogAEECdBCJAxogAiAEOwEyDwsgAEELQeDhywAQsgcAC0GA4ssAQShBqOLLABDRCQALhQEAIwBBIGsiAiQAIAQgBU8EQCAAAn8CQCAEIAVrIgQEQCACQQhqIAEtAAAgAyAFaiAEEL0CIAIoAggNAQsgACACKQIUNwIEIABBDGogAkEcaigCADYCAEEADAELIAAgAigCDCAFajYCBEECCzYCACACQSBqJAAPCyAFIARBxPzLABCxBwALhgEBAX8jAEEwayIDJAAgAyACNgIUIAIgACgCDEYEQCADQQhqIAEgAhDHC0EAIQAgAygCCCICIAMoAgwiAUcEQANAIAItAAAgAEEBdGohACACQQFqIgIgAUcNAAsLIANBMGokACAADwsgA0EANgIYIABBDGogA0EUaiADQRhqQYiJzAAQwgcAC4EBAQV/IAAoAggiAgRAIAAoAgAiACACQQR0aiEEA0AgAEEQaiAAKAIIIgFBAk8EQCABQQF2IQMgACgCACIAIAFqQX9qIQEDQCAALQAAIQUgACABLQAAOgAAIAEgBToAACABQX9qIQEgAEEBaiEAIANBf2oiAw0ACwsiACAERw0ACwsLiAEBBH9BASEDIAAoAhAgAU8EfwJAIAAoAggiAkUEQCABIQIMAQsgAkEEdCIFRQRAQQAhAgwBCyAAKAIAQQhqIQNBACECA0BBACEEIANBBGotAABFBEAgAygCAEEBaiABbCEECyADQRBqIQMgAiAEaiECIAVBcGoiBQ0ACwsgAiAAKAIMSwUgAwsLfQECfyMAQSBrIgQkACAABEAgBEEIaiAAEJEKIAQoAgwhACAEKAIIIAQgAzYCGCAEIAM2AhQgBCACNgIQIAQgBEEQahCMCCABIAQoAgAiASAEKAIEIgIQ6gQgAgRAIAEQiQELIAAgACgCAEF/ahDfCyAEQSBqJAAPCxCZDAALhgEBBH8jAEGQAmsiASQAIAFBADYCACABQYgBaiABQQRyIAFBhAFqELwLIAEoAogBIgIgASgCjAEiA0cEQCABKAIAIQQgAkE2IAMgAmsiAhCRBRogASACIARqNgIACyABQYgBaiABQYQBEIkDGiAAIAFBiAFqQQRyQYABEIkDGiABQZACaiQAC4cBAQR/IwBBkAJrIgEkACABQQA2AgAgAUGIAWogAUEEciABQYQBahC8CyABKAKIASICIAEoAowBIgNHBEAgASgCACEEIAJB3AAgAyACayICEJEFGiABIAIgBGo2AgALIAFBiAFqIAFBhAEQiQMaIAAgAUGIAWpBBHJBgAEQiQMaIAFBkAJqJAALgQEBAX8jAEEwayIDJAAgAyACQajiygAoAgARAAAgA0EYaiAAIAEgAygCACADKAIEEJIFAn8CQCADLQAYQQFHBEAgA0EQaiADQSFqKQAANwMAIAMgAykAGTcDCCACIANBCGpBEEG44soAKAIAEQUARQ0BC0EBDAELQQALIANBMGokAAuXAQEFfyMAQRBrIgAkACAAEMoCQfyT4QAoAgAhA0H4k+EAKAIAIQRB+JPhACAAKQMANwIAQYSU4QAoAgAhAkGAlOEAKAIAIQFBgJThACAAQQhqKQMANwIAAkAgBA0AAkAgA0UEQCABIQIgAUEjSw0BDAILIAFBJE8EQCABEAALIAJBJEkNAQsgAhAACyAAQRBqJABB+JPhAAuMAQEBfyMAQRBrIgUkAAJAAn8gBCADSwRAIAIgBEkNAiACIARrIQIgASAEQQJ0agwBCyAFQQhqIAEgAiAEIAMQtAlBACEDIAUoAgwhAiAFKAIICyEEIAAgATYCCCAAIAI2AgQgACAENgIAIABBDGogAzYCACAFQRBqJAAPC0HorssAQSNB2K7LABDRCQALjAEBAX8jAEEQayIFJAACQAJ/IAQgA0sEQCACIARJDQIgAiAEayECIAEgBEEMbGoMAQsgBUEIaiABIAIgBCADELYJQQAhAyAFKAIMIQIgBSgCCAshBCAAIAE2AgggACACNgIEIAAgBDYCACAAQQxqIAM2AgAgBUEQaiQADwtBmMvLAEEjQYDLywAQ0QkAC4MBAQJ/IwBBIGsiBiQAIAZBADYCECAGQQA2AgggBkEAOgAfAkAgASACIAZBH2ogBkEIakECIAMgBCAFIAQQ9gJFDQAgBigCCEEBRw0AIAYoAhBBAUcNACAAIAYoAgw2AgQgAEEIaiAGQRRqKAIANgIAQQEhBwsgACAHNgIAIAZBIGokAAvFAQECfiAAQvD///////8/IAApAyB9IgJC/////////wODQvD///////8/IAApAxh9IgFCM4h8NwMgIAAgAUL/////////A4NC8P///////z8gACkDEH0iAUIziHw3AxggACABQv////////8Dg0Lw////////PyAAKQMIfSIBQjOIfDcDECAAIAFC/////////wODQtD9//////8/IAApAwB9IgFCM4h8NwMIIAAgAkIziEITfiABQv////////8Dg3w3AwALmQEBAX8jAEEQayICJAAgASgCAEHKi8AAQQEQ5wsgAkEBOgAMIAIgATYCCAJAIAJBCGpB0YrAAEEDIAAQoAUiAQ0AIAJBCGpB1IrAAEEDIABBIGoQoAUiAQ0AIAJBCGpB14rAAEEDIABBQGsQoAUiAQ0AIAItAAwEQCACKAIIKAIAQcuLwABBARDnCwtBACEBCyACQRBqJAAgAQuTAQIBfwF+IwBB0ABrIgIkACACQdCFwAA2AiQgAiABNgIgIAIgADYCHCACQRBqIAJBHGpBFxDmCyACKQMQIQMgAkEIaiACQSBqQRYQ5gsgAkE8akECNgIAIAIgAzcDQCACQgI3AiwgAkGMkcAANgIoIAIgAikDCDcDSCACIAJBQGs2AjggAkEoahC2CCACQdAAaiQAC7ABAwJ/An4BfCMAQRBrIgIkACACIAEoAgAQCAJ+QgAgAigCAEUNABogAisDCCIGRAAAAAAAAODDZiEDQgBC////////////AAJ+IAaZRAAAAAAAAOBDYwRAIAawDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gAxsgBkT////////fQ2QbIAYgBmIbIQQgASgCABAiQQBHrQshBSAAIAQ3AwggACAFNwMAIAJBEGokAAuHAQICfwF+IwBBIGsiAiQAAkAgAUHgBGooAgAiA0UNACABIANBf2oiAzYC4AQgAkEQaiABKALYBCADQRRsaiIBQQhqKQIANwMAIAJBGGogAUEQaigCADYCACACIAEpAgAiBDcDCCAEp0EFRg0AIAJBCGoQ1wgLIABCgICAgDA3AgAgAkEgaiQAC28BA38gACgCBCAAKAIIIgFrQYACSQRAIAAgAUGAAhDnCCAAKAIIIQELIAAoAgAgAUECdGohAkH/ASEDA0AgAkGAgICAeDYCACACQQRqIQIgA0F/aiIDDQALIAJBgICAgHg2AgAgACABQYACajYCCAuMAQECfyAAKAIIIgEEQCAAKAIAIQIgAUECdCEBA0AgAigCACIAQbgCahDeCiAAQcwCahDHCiAAQdwCahDeCiAAQfACahDHCiAAQYADahDLCiAAQYwDahDMCiAAQZgDahDKCiAAQQhqEM0HIABBoAFqEM0HIAIoAgAQiQEgAkEEaiECIAFBfGoiAQ0ACwsLfwEEfwJAIAJBAXQiBSABKAIIIgNPDQAgBUEBciIGIANPDQAgASgCACIBIAJBBHRqQQAgBSADSRsiAigCAEEBRw0AIAEgBkEDdGpBACAGIANJGyIBKAIAQQFHDQAgAEEIaiABKAIENgIAIAAgAigCBDYCBEEBIQQLIAAgBDYCAAuCAQECfyMAQdADayICJAAgACgCACIAIAAoAgAiAUEBajYCAAJAAkAgAUF/SgRAQQRBBBDkCyIBRQ0BIAEgADYCACACQQhqIAEQughByANBCBDkCyIARQ0CIAAgAkEIakHIAxCJAyACQdADaiQADwsAC0EEQQQQ4gwAC0HIA0EIEOIMAAuQAQIEfwF+IwBBEGsiBCQAAkACQCABKAIEIgMgASgCACICKAIISQRAIAJBFGooAgAiBSADTQ0CIARBCGogAiACKAIMIANBAXRqLwEAIgIQ6gkgBCkDCCEGIAAgAjsBACABIANBAWo2AgQgACAGNwIEDAELIABBADYCBAsgBEEQaiQADwsgAyAFQeiQzAAQsAcAC4kBAQR/IwBBIGsiAiQAIABBJGooAgAhBCAAKAIcIQUCQAJAAkACQCAAKAIAQXNqDgUAAQMDAgMLIABBBGohAwwCCyAAQQRqIQMMAQsgAEEEaiEDCyACIAM2AhggAiAENgIMIAIgBTYCCCACIAA2AhAgAiAAQShqNgIUIAJBCGogARB4IAJBIGokAAuGAQECfiAAQgAgAq1C/wGDfSIEIAApAwAiAyABKQMAhYMgA4U3AwAgACAAKQMIIgMgASkDCIUgBIMgA4U3AwggACAAKQMQIgMgASkDEIUgBIMgA4U3AxAgACAAKQMYIgMgASkDGIUgBIMgA4U3AxggACAEIAApAyAiBCABKQMghYMgBIU3AyALiwEBAn8jAEEgayICJAACQAJAIAEoAiAiA0UEQCACIAEQ6QYgAigCBARAIAJBGGogAkEIaigCADYCACACIAIpAwA3AxAgAkEQahDVCQsgAEEANgIEDAELIAEgA0F/ajYCICABEP4HIgFFDQEgACABEMgFCyACQSBqJAAPC0HcncsAQStBzJ3LABDRCQALiwEBAn8jAEEgayICJAACQAJAIAEoAiAiA0UEQCACIAEQ6wYgAigCBARAIAJBGGogAkEIaigCADYCACACIAIpAwA3AxAgAkEQahDeCQsgAEEANgIEDAELIAEgA0F/ajYCICABEIEIIgFFDQEgACABEMoFCyACQSBqJAAPC0GLvssAQStBsLrLABDRCQALewEFf0EBIQQCQCAALQAAIgIgAS0AACIDIAIgA0siBRsgAS0AASIBIAAtAAEiACAAIAFLIgYbQQFqSwRAQQAhBAwBCyADIAIgBRsiAiAAIAEgBhsiASACIAFLIgMbIQAgASACIAMbIQELIAFB/wFxQQh0IABBEHRyIARyC4IBAQF/IAACfwJAAkACQCABQb9/akH/AXFBBk8EQCABQZ9/akH/AXFBBkkNASABQVBqIgNB/wFxQQpJDQIgAEEIaiACNgIAIABBBGogAUH/AXE2AgBBAQwECyAAIAFBSWo6AAEMAgsgACABQal/ajoAAQwBCyAAIAM6AAELQQALOgAAC4UBAQF/IwBB0ABrIgEkACABQgA3AhQgAUHck8AAKAIANgIQIAFBIGogAUEQakGwksAAENgKIAAgAUEgahC0BwRAQciSwABBNyABQcgAakGQlMAA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IAQ2AgQgACADNgIAC34BA38jAEEwayIBJAACfyAAKAIEIgJFBEBBACECQQIMAQsgACgCACEDIAFBIGogAjYCACABQRxqIAM2AgAgAUEQaiACNgIAIAEgAzYCDCAAKAIIIQJBAAshACABIAI2AiggASAANgIYIAEgADYCCCABQQhqEIUHIAFBMGokAAtxACABBEAgAUEUbCEBA0ACQAJAAkAgACgCAA4CAAECCyAAQQRqKAIAQQVHDQEgAEEQaigCAEEDdEUNASAAQQxqKAIAEIkBDAELIABBBGotAABBA0cNACAAQQhqEMcKCyAAQRRqIQAgAUFsaiIBDQALCwt+AQN/IwBBMGsiASQAAn8gACgCBCICRQRAQQAhAkECDAELIAAoAgAhAyABQSBqIAI2AgAgAUEcaiADNgIAIAFBEGogAjYCACABIAM2AgwgACgCCCECQQALIQAgASACNgIoIAEgADYCGCABIAA2AgggAUEIahCYCiABQTBqJAALigEBAX8jAEEQayICJAAgAiABQcS9ywBBCRCLCzcDACACIAA2AgwgAkHsu8sAQQQgAkEMakHUu8sAEPACGiACIABBBGo2AgwgAkHNvcsAQQUgAkEMakHUvcsAEPACGiACIABBBWo2AgwgAkHkvcsAQQMgAkEMakHUvcsAEPACGiACEPkGIAJBEGokAAuaAQEBfyMAQRBrIgIkAAJAIAAtACgNAAJAAkAgACgCCEH/AE0EQCAAKAIIQf//A0sNASACQQhqIAEQzQsgAigCDCIBBEAgACACKAIIIAEQ4gMMBAsMAgsMAQtBgOTLAEE6QaDlywAQ0QkACyAAQQE6ACggAEEAOgAiIAAQngcgAEEAOwEgIABBFGpCgICAgHA3AgALIAJBEGokAAuMAQEBfyMAQRBrIgIkACACIAFB6P/LAEEMEIsLNwMAIAIgADYCDCACQfT/ywBBByACQQxqQYz/ywAQ8AIaIAIgAEGAAmo2AgwgAkHM/8sAQQUgAkEMakGw/8sAEPACGiACIABBgQJqNgIMIAJB+//LAEEFIAJBDGpBsP/LABDwAhogAhD5BiACQRBqJAALigEBAX8jAEEQayICJAAgAiABQa2AzABBDxCLCzcDACACIAA2AgwgAkHM/8sAQQUgAkEMakGw/8sAEPACGiACIABBAWo2AgwgAkH7/8sAQQUg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CyACQShqIAMgARC+BSACQdAAaiABQdAAakEoEIkDGiACQfgAaiABQfgAakGog+AAEHALbQIBfwF+IwBBEGsiAyQAIANBCGogAiABLwEAIgJqEPYFIAMpAwghBCAAQQA2AgggACAENwIAIAJBBU8EQCACQQRBhPbBABCyBwALIAAgAUEEaiIAIAAgAkEDdGoQ7QUgAUEAOwEAIANBEGokAAtqAQN/IwBBkAJrIgEkACABQQA2AgAgAUEEciEDA0AgAiADahDZCyABIAEoAgBBAWo2AgAgAkEQaiICQYABRw0ACyABQYgBaiABQYQBEIkDGiAAIAFBiAFqQQRyQYABEIkDGiABQZACaiQAC3IBAn8jAEEQayICJAACQAJ/QQAgASgCICIDRQ0AGiABIANBf2o2AiAgARD+ByIBRQ0BIAJBCGogARDEBCACKAIMIQMgAigCCAshASAAIAM2AgQgACABNgIAIAJBEGokAA8LQdydywBBK0G8ncsAENEJAAt1AQF/IwBBIGsiAiQAIAEoAgAEQCACQRRqQQE2AgAgAkIBNwIEIAJBmKjLADYCACACQY0BNgIcIAIgATYCGCACIAJBGGo2AhAgAkGgqMsAENcKAAsgACABKQIENwIAIABBCGogAUEMaikCADcCACACQSBqJAALfQECfyMAQRBrIgIkAAJAAkACQAJAAkAgACgCkAEiAUEBaw4EAAECAwQLIABBnAFqKAIAIABBqAFqKAIAaiEBDAMLIAJBCGogAEGYAWoQ6wsgAigCDCEBDAILIABBlAFqEP0GIQEMAQsgAEGUAWoQ7gkhAQsgAkEQaiQAIAELeAEBfyMAQRBrIgIkAAJAAkACQAJAIAFB/wFxQQFrDgIAAQILIAIgADYCCCAAQRRqKAIAIQEgACgCDCACIAJBCGo2AgwgASACQQxqEGMMAgtBkJDMAEEoQbiQzAAQ0QkACyAAKAIMIABBFGooAgAQcgsgAkEQaiQAC24BAn8jAEEwayIDJAAgA0EYakIANwMAIANCADcCDCADQej53QAoAgAiBDYCFCADIAQ2AgggA0EoaiACQQhqKAIANgIAIAMgAikCADcDICAAIANBCGogASADQSBqEJkBIANBCGoQlQkgA0EwaiQAC3wBA38gACAAEPIMIgBBCBDECyAAayICEPAMIQBBnJjhACABIAJrIgE2AgBBpJjhACAANgIAIAAgAUEBcjYCBEEIQQgQxAshAkEUQQgQxAshA0EQQQgQxAshBCAAIAEQ8AwgBCADIAJBCGtqajYCBEHAmOEAQYCAgAE2AgALcgEEfyMAQSBrIgIkAEEBIQMCQCAAIAEQngMNACABQRxqKAIAIQQgASgCGCACQRxqQQA2AgAgAkGU7eAANgIYIAJCATcCDCACQeDv4AA2AgggBCACQQhqEOYBDQAgAEEEaiABEJ4DIQMLIAJBIGokACADC3EBAn8jAEEQayIEJAAgACgCACEFIAAtAARBAUcEQCAFKAIAQfWMwABBARDnCwsgAEECOgAEIAUgASACEPAKGiAFKAIAQfaMwABBARDnCyAEQQhqIAMQzQsgBSAEKAIIIAQoAgwQ8AoaIARBEGokAEEAC3IBAX8jAEEQayIFJAAgBSACNgIEIAUgATYCACAFIAQ2AgwgBSADNgIIIAUQ/gshASAFQQhqEP4LIQIgACABNgIYIABBADYCECAAIAUpAwg3AgggACAFKQMANwIAIAAgAiABIAEgAksbNgIUIAVBEGokAAtTAQF/AkAgACgCCCIBQQBJDQAgAEEANgIIIAFFDQAgAUEMbCEBIAAoAgAhAANAIABBBGooAgAEQCAAKAIAEIkBCyAAQQxqIQAgAUF0aiIBDQALCwtAAQN/IwBBEGsiAiQAIAIgAUEBEIUIIAIoAgQhAyACKAIAIQQgACABNgIIIAAgBDYCACAAIAM2AgQgAkEQaiQAC08BAn8CQAJAIAEgAWoiAiABSSACQQBIckUEQCACRQRADAILIAJBARDkCyIDDQIgAkEBEOIMAAsQjwoAC0EBIQMLIAAgATYCBCAAIAM2AgALZwECfyMAQRBrIgIkACAAKAIAIgBBCGooAgAhAyAAKAIAIQAgAiABEIwLNwMAIAMEQANAIAIgADYCDCACIAJBDGpB9NPgABCKDCAAQQFqIQAgA0F/aiIDDQALCyACEO4KIAJBEGokAAtkAQR/A0AgASECA0ACQCABIgNBAWohASADQf//A3EiBEH+AUsNACACEOsJIAEQ6wlGDQELCyACQf8BcSICBEAgACACakF/akEBOgAACyAAIANB/wFxakEBOgAAIARB/wFJDQALC2cCAn8BfiMAQSBrIgIkACACQQhqIAEoAgwgAUEIaiIDKAIAa0EUbRD5BSACKQMIIQQgAEEANgIIIAAgBDcCACACQRhqIAMpAgA3AwAgAiABKQIANwMQIAAgAkEQahDvBSACQSBqJAALbQEDfwJAAkAgACgCBCAAKAIIIgJrIAFJBEAgACACIAEQ5wggACgCCCECDAELIAFFDQELIAAoAgAgAkECdGohAyABIQQDQCADQYCAgIB4NgIAIANBBGohAyAEQX9qIgQNAAsgACABIAJqNgIICwtjAQJ/IAAoAggiBCABTwRAIAQgACgCBEYEQCAAIARBARDlCAsgACgCACABQQN0aiIFQQhqIAUgBCABa0EDdBDCASAFIAM2AgQgBSACOgAAIAAgBEEBajYCCA8LIAEgBBCuBwALYgEBfyAAKAIIIgEEQCAAKAIAIQAgAUEkbCEBA0ACQAJAAkACQCAALQAADgMAAQIDCyAAQQRqELEFDAILIABBBGoQ+QoMAQsgAEEEahD4CgsgAEEkaiEAIAFBXGoiAQ0ACwsLkwEAAkACQAJAAkACQAJAAkACQCAALQAAQQFrDgcBAgMEBQYHAAsgAUH/vMsAQQkQtwsPCyABQfi8ywBBBxC3Cw8LIAFB77zLAEEJELcLDwsgAUHovMsAQQcQtwsPCyABQdy8ywBBDBC3Cw8LIAFBzbzLAEEPELcLDwsgAUG8vMsAQREQtwsPCyABQai8ywBBFBC3CwteAQF/AkAgASgCECACSQ0AIAJBCHYiAiABQTRqKAIATw0AIAEoAiwgAkEMbGoiASgCCEEATQ0AIAEoAgAhASAAQQxqIAM2AgAgACABKQIANwIEQQEhBAsgACAENgIAC2sCAX8BfiMAQeAAayIFJAAgBUEIaiAAIAEgAiADIAQQeSAFQQhqEKwFIgZCIIinIQAgBqcEQCAFIAA2AlxBwIPAAEErIAVB3ABqQfyDwABBvILAABDzBgALIAVBCGoQgwogBUHgAGokACAAC2QBAn8jAEEgayICJAAgAiABQQEQwgsiAzoAByADBEAgAkEcakEANgIAIAJBGGpB2M/LADYCACACQgE3AgwgAkH80csANgIIIAJBB2ogAkEIahC+BwALIAAgARD7CSACQSBqJAALXQEBfwJAAkACQAJAIAAtAAAOAwABAgMLIABBBGoQ2wIPCyAAQQhqKAIAIgFFIAFBA3RFcg0BIAAoAgQQiQEPCyAAQQhqKAIAIgFFIAFBAXRFcg0AIAAoAgQQiQELC10BAn8gACgCCCIDIAFPBEAgAyAAKAIERgRAIAAgAxCBCQsgACgCACABQShsaiIEQShqIAQgAyABa0EobBDCASAEIAJBKBCJAxogACADQQFqNgIIDwsgASADEK4HAAtxAQF/IwBBMGsiASQAIAFBgAE2AgQgASAANgIAIAFBHGpBAjYCACABQSxqQRc2AgAgAUICNwIMIAFBmMPgADYCCCABQRc2AiQgASABQSBqNgIYIAEgAUEEajYCKCABIAE2AiAgAUEIakGIxOAAENcKAAtwAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBFzYCACACQgM3AgwgAkHU0uAANgIIIAJBFzYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQezS4AAQ1woAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEXNgIAIANCAzcCDCADQZDT4AA2AgggA0EXNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhDXCgALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQRc2AgAgA0ICNwIMIANB+PDgADYCCCADQRc2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACENcKAAttAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBFzYCACADQgI3AgwgA0Ho9+AANgIIIANBFzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQ1woAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEXNgIAIANCAjcCDCADQYj44AA2AgggA0EXNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhDXCgALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQRc2AgAgA0ICNwIMIANBvPjgADYCCCADQRc2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACENcKAAtXAQJ/IwBBIGsiAiQAIAFBHGooAgAhAyABKAIYIAJBGGogAEEQaikCADcDACACQRBqIABBCGopAgA3AwAgAiAAKQIANwMIIAMgAkEIahDmASACQSBqJAALVwECfyMAQSBrIgIkACAAQRxqKAIAIQMgACgCGCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCADIAJBCGoQ5gEgAkEgaiQAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEXNgIAIANCAzcCDCADQYz54AA2AgggA0EXNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhDXCgALbQEBfyMAQeABayIBJAAgARCKByAAIAFBoAFqEPMJIABBOGogAUHYAWopAwA3AAAgAEEwaiABQdABaikDADcAACAAQShqIAFByAFqKQMANwAAIAAgASkDwAE3ACAgAUHAAWoQwwogAUHgAWokAAtgAgF/AX4gASgCCCIEIAJLBEAgASgCACACQQN0aiIDKQIAIQUgAyADQQhqIAQgAkF/c2pBA3QQwgEgASAEQX9qNgIIIAAgBUIgiD4CBCAAIAU+AgAPCyACIAQgAxCvBwALYwEBfyMAQSBrIgQkACAEIAE2AgQgBCAANgIAIARBGGogAkEQaikCADcDACAEQRBqIAJBCGopAgA3AwAgBCACKQIANwMIQQAgBEHU6coAIARBBGpB1OnKACAEQQhqIAMQ3wIAC2MBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQRhqIAJBEGopAgA3AwAgBEEQaiACQQhqKQIANwMAIAQgAikCADcDCEEAIARB5OnKACAEQQRqQeTpygAgBEEIaiADEN8CAAtmAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EYaiACQRBqKQIANwMAIANBEGogAkEIaikCADcDACADIAIpAgA3AwhBACADQYiAywAgA0EEakGIgMsAIANBCGpBwP7KABDfAgALbQECfwJAIAAoAggiAiAAKAIESQRAIAAgAkEBajYCCCAAKAIAIAJBAnRqIAE2AgAgAEEQaigCACIDIAFLDQEgASADQcCtywAQsAcAC0GwrMsAQSVBsK3LABDRCQALIAAoAgwgAUECdGogAjYCAAtkAQF/IwBBIGsiAiQAIAJBCGogAUHAsssAQQAQvQogAiAANgIYIAIgAEEEajYCHCACQQhqIAJBGGpBgLTLABCvAxogAkEIaiACQRxqQYC0ywAQrwMaIAJBCGoQmwYgAkEgaiQAC2kBAX8jAEEgayICJAAgAkHY0csANgIEIAIgADYCACACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCEEAIAJB3NDLACACQQRqQdzQywAgAkEIakHk0ssAEN8CAAtmAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EYaiACQRBqKQIANwMAIANBEGogAkEIaikCADcDACADIAIpAgA3AwhBASADQezQywAgA0EEakHs0MsAIANBCGpB8MjLABDfAgALbwECfyMAQRBrIgMkACABENsIIQQgA0EIaiABEM0DIAAgAygCCCADKAIMEJ0EIAMgARCcAyAAQcgAaiADKAIAIAMoAgQQnQQgAEGQAWogAkHYAhCJAxogACAEOgDoAyABEJQJIAEQ+gogA0EQaiQAC2YBAX8jAEEgayIDJAAgAyABNgIEIAMgADYCACADQRhqIAJBEGopAgA3AwAgA0EQaiACQQhqKQIANwMAIAMgAikCADcDCEEAIANBgILMACADQQRqQYCCzAAgA0EIakG4iMwAEN8CAAtjAQF/IwBBIGsiBCQAIAQgATYCBCAEIAA2AgAgBEEYaiACQRBqKQIANwMAIARBEGogAkEIaikCADcDACAEIAIpAgA3AwhBACAEQZCCzAAgBEEEakGQgswAIARBCGogAxDfAgALZAEBfyMAQSBrIgIkACACQQhqIAFBsoLMAEEAEL0KIAIgADYCGCACIABBBGo2AhwgAkEIaiACQRhqQaCCzAAQrwMaIAJBCGogAkEcakG0gswAEK8DGiACQQhqEJsGIAJBIGokAAtmAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EYaiACQRBqKQIANwMAIANBEGogAkEIaikCADcDACADIAIpAgA3AwhBASADQdSWzAAgA0EEakHUlswAIANBCGpB/JjMABDfAgALZAAgACABAn8CQAJAAkACQAJAAkACQCACKAIAQQVrDgUAAgMEBQELIAIoAgRBAk8NBQsgAEEgNgIADwsgAkEEagwECyACQQRqDAMLIAJBBGoMAgsgAkEEagwBCyACQQhqCxCVAwtjAQF/IwBBIGsiBCQAIAQgATYCBCAEIAA2AgAgBEEYaiACQRBqKQIANwMAIARBEGogAkEIaikCADcDACAEIAIpAgA3AwhBACAEQfjX3QAgBEEEakH4190AIARBCGogAxDfAgALYwEBfyMAQSBrIgQkACAEIAE2AgQgBCAANgIAIARBGGogAkEQaikCADcDACAEQRBqIAJBCGopAgA3AwAgBCACKQIANwMIQQAgBEGI2N0AIARBBGpBiNjdACAEQQhqIAMQ3wIAC2kBAX8jAEEgayICJAAgAkHE6MoANgIEIAIgADYCACACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCEEAIAJBiMDgACACQQRqQYjA4AAgAkEIakG06MoAEN8CAAtmAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EYaiACQRBqKQIANwMAIANBEGogAkEIaikCADcDACADIAIpAgA3AwhBACADQYjx4AAgA0EEakGI8eAAIANBCGpB7NTgABDfAgALYQEDfyAAIAEQkwsgACgCACIEIAAoAggiAmohAwJAAkAgAUECTwRAIANBACABQX9qIgEQkQUaIAQgASACaiICaiEDDAELIAFFDQELIANBADoAACACQQFqIQILIAAgAjYCCAtlAQF/IwBBMGsiAiQAIAIgATYCDCACIAA2AgggAiACQQhqQRgQ5gsgAkEkakEBNgIAIAJCAjcCFCACQayRwAA2AhAgAiACKQMANwMoIAIgAkEoajYCICACQRBqELYIIAJBMGokAAtlAQF/IwBBMGsiAiQAIAIgATYCDCACIAA2AgggAiACQQhqQRgQ5gsgAkEkakEBNgIAIAJCAjcCFCACQdCRwAA2AhAgAiACKQMANwMoIAIgAkEoajYCICACQRBqELYIIAJBMGokAAtQAQF/IABBEGoQvwsgAEEgaiIBELcIIAEQxwogAEE4ahDKCiAAQcgAahDKCiAAQdQAahDKCiAAQeQAahCkCyAAQfAAahDeCiAAQYQBahDeCgtqAQN/IwBBIGsiAiQAIAJBCGogARDNCwJAIAIoAgwiA0EBcUUEQCACKAIIIQQgAkICNwMYIAIgAzYCFCACIAQ2AhAgACACQRBqEPYEDAELIABCgYCAgICAwAg3AgALIAEQpAsgAkEgaiQAC2kBAn8CQAJAIAEoAhAoAgBBgoDEAEcNACABKAIEIgNFDQAgASgCCCIBRQ0BIAMgAW4iAiADIAEgAmxrQQBHaiECCyAAQoCAgIAQNwIAIABBCGogAjYCAA8LQeCNywBBGUHMjcsAENEJAAtaAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQYSOywAgAkEIahDmASACQSBqJAALawEBfyAAQeAEaigCACICIABB3ARqKAIARgRAIABB2ARqIAIQ6gggACgC4AQhAgsgACgC2AQgAkEUbGoiAiABKQIANwIEIAJBADYCACACQQxqIAFBCGopAgA3AgAgACAAKALgBEEBajYC4AQLXwEDfyACQQhqKAIAIQMgAigCBCAAIAFHBEAgAigCACECA0AgACgCACEFIAJBBGogACgCBDYCACACIAU2AgAgAkEIaiECIANBAWohAyAAQQhqIgAgAUcNAAsLIAM2AgALWwEBfwJAAkACQCAAKAIYDgICAQALIABBOGooAgAiAUUgAUEcbEVyDQEgACgCNBCJAQwBCyAAQThqKAIARQ0AIABBNGooAgAQiQELIAAoAkQQoAMgACgCRBCJAQtaAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQbjY3QAgAkEIahDmASACQSBqJAALZQEEfyAAKAIEIAAoAggiAmsgASgCDCABKAIIIgRrIgVBBHUiA0kEQCAAIAIgAxD/CCAAKAIIIQILIAAoAgAgAkEEdGogBCAFEIkDGiAAIAIgA2o2AgggASABKAIMNgIIIAEQ9wYLWgEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGgz+AAIAJBCGoQ5gEgAkEgaiQAC2cBAn8CQAJAAkAgAUEIaigCACICQQBOBEAgASgCACEDIAINAUEBIQEMAgsQjwoACyACQQEQ5AsiAUUNAQsgASADIAIQiQMhASAAIAI2AgggACACNgIEIAAgATYCAA8LIAJBARDiDAALWgEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGE1OAAIAJBCGoQ5gEgAkEgaiQAC1oBAX8jAEEgayICJAAgAiAAKAIANgIEIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBwPXgACACQQhqEOYBIAJBIGokAAtjAgF/AX4jAEEwayIBJAAgAUEMaiAAEI4LIAEgAUEMajYCCCABQQhqEKkEIgJCIIinIQAgAqcEQCABIAA2AixBwIPAAEErIAFBLGpB/IPAAEGMgsAAEPMGAAsgAUEwaiQAIAALZAEBfyMAQRBrIgEkACAAQgA3AAAgAEEYakIANwAAIABBEGpCADcAACAAQQhqQgA3AAAgABDjCSIABEAgASAANgIMQeTmygBBKyABQQxqQZDnygBBoOXKABDzBgALIAFBEGokAAtXAQF/IwBBIGsiAiQAIAIgADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQYSOywAgAkEIahDmASACQSBqJAALXAECfyAAKAIIIgEEQCAAKAIAIQAgAUGkAWwhAQNAAn8gAC0AAEUEQCAAQRxqIgIQjQogAhD9CiAAQUBrDAELIABBBGoLIABBpAFqIQAQwwYgAUHcfmoiAQ0ACwsLWgEBfyMAQTBrIgIkACACIAAgARC7BCACKAIAQQFHBEAgAkEoaiACQRRqKAIANgIAIAJBIGogAkEMaikCADcDACACIAIpAgQ3AxggAkEYahCQBAsgAkEwaiQAC10BAn8jAEEQayIEJAAgAEEgaigCACIFIAJNBEAgAiAFQZDGywAQsAcACyAAKAIYIARBCGogA0EIaikCADcDACAEIAMpAgA3AwAgAkEkbGogASAEEOwBIARBEGokAAtnAQN/IwBBIGsiAiQAIAEoAgAhAyACQQhqIAEoAgQiAUEAEIUIIAIgAigCDDYCFCACIAIoAggiBDYCECAEIAMgARCJAxogAiABNgIYIAIgAkEQahCMCCAAIAIpAwA3AwAgAkEgaiQAC2MBA38CQCABKAIgIgQgAmwiAiAEaiIDIAJPBEAgAUEcaigCACIFIANJDQEgASgCFCEBIAAgBDYCBCAAIAEgAkEDdGo2AgAPCyACIANByM/LABCzBwALIAMgBUHIz8sAELIHAAtdAQJ/IABBDGooAgAiAiACQX9qIgMgACgCBCICIAAoAgBrcWtBAUYEQCAAELQFIAAoAgxBf2ohAyAAKAIEIQILIAAgAkEBaiADcTYCBCAAKAIIIAJBAnRqIAE2AgALVwEBfyMAQSBrIgIkACACIAA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakG42N0AIAJBCGoQ5gEgAkEgaiQAC1cBAX8jAEEgayICJAAgAiAANgIEIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBwPXgACACQQhqEOYBIAJBIGokAAtiAQJ/IAFBCGooAgAiAwRAIAEoAgQhAiABIANBf2o2AgggASACQQhqNgIEIAEgAigCACACKAIEEKwKEJUMIgFBJE8EQCABEAALIABBADYCAA8LQbaGwABBK0HwhMAAENEJAAtAAQF/AkACQCABQQBOBEAgAUUNASABQQEQ5AsiAg0CIAFBARDiDAALEI8KAAtBASECCyAAIAE2AgQgACACNgIAC2QBAn8CfyABKAIEIgJFBEBBACECQQIMAQsgAEEYaiACNgIAIABBFGogASgCACIDNgIAIABBCGogAjYCACAAIAM2AgQgASgCCCECQQALIQEgACACNgIgIAAgATYCECAAIAE2AgALYQEBfyAAKAIIIgEEQCABQRRsIQEgACgCAEEEaiEAA0ACQAJAAkAgAEF8aigCAA4CAAECCyAAELIKDAELIAAtAABBA0cNACAAQQRqEMcKCyAAQRRqIQAgAUFsaiIBDQALCwtYAQF/IwBBEGsiAyQAIAMgAhCMCzcDACABBEAgAUEDdCEBA0AgAyAANgIMIAMgA0EMakGIscsAEIoMIABBCGohACABQXhqIgENAAsLIAMQ7gogA0EQaiQAC2kBAX8jAEEQayICJAAgAiABQeS7ywBBCBCLCzcDACACIAA2AgwgAkHsu8sAQQQgAkEMakHUu8sAEPACGiACIABBBGo2AgwgAkHwu8sAQQQgAkEMakHUu8sAEPACGiACEPkGIAJBEGokAAtpAQF/IwBBEGsi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BCADQRRsakECNgIAIAAgAjYCBCAAQQE2AgAgASABKALgBEEBajYC4AQLcAECfyAAQRhqIgEQ0gggASgCBCICRSACQSRsRXJFBEAgASgCABCJAQsgAEEoaiIBELkIIAEQ2QkgAEE4aiIBEN0HIAEQ2wkgAEHIAGoiARDnCSABENcJIABB2ABqEKQLIABB7ABqIgAQpgcgABDYCQtgAQF/IAAoAggiAiABQf8BcSIBSwRAIAAoAgAgAWoiAi0AAEUEQCACQQE6AAAgACAAKAIMQQFqNgIMIAAgAC8BECABQfT8ywBqLQAAajsBEAsPCyABIAJBtPzLABCwBwALTQECfyAAKAIIIgEEQCAAKAIAIQAgAUEMbCEBA0AgAEEEaigCACICRSACQQN0RXJFBEAgACgCABCJAQsgAEEMaiEAIAFBdGoiAQ0ACwsLTQECfyAAKAIIIgEEQCAAKAIAIQAgAUEMbCEBA0AgAEEEaigCACICRSACQRhsRXJFBEAgACgCABCJAQsgAEEMaiEAIAFBdGoiAQ0ACwsLWgIBfwF+IwBBEGsiASQAIAEgAEGgAWo2AgggAUEIahCoBSICQiCIpyEAIAKnBEAgASAANgIMQcCDwABBKyABQQxqQfyDwABBrILAABDzBgALIAFBEGokACAAC14BAX8jAEGgAmsiAiQAIABBGGogAiABQaACEIkDIgFB2AFqKQMANwAAIABBEGogAUHQAWopAwA3AAAgAEEIaiABQcgBaikDADcAACAAIAEpA8ABNwAAIAFBoAJqJAALUAECfyMAQSBrIgMkACADIAAoAgAQKiIENgIAIAMgAjYCBCACIARGBEAgACABEL8JIANBIGokAA8LIANBADYCCCADIANBBGogA0EIahC7BwALUwECfyAAQRBqKAIAIgIgAUsEQEEAIQIgACgCDCABQQJ0aigCACIDIAAoAghJBH8gACgCACADQQJ0aigCACABRgUgAgsPCyABIAJB0K3LABCwBwALSAECfwJAIAAoAggiAkUNACACIAAoAgQiASAANQIAIAJBAWqtfqdqQX9qQQAgAWtxIgFqQQVqRQ0AIABBDGooAgAgAWsQiQELC1oBAX8jAEEQayICJAACfyAALQAAQQJGBEAgAUHUgcwAQQQQtwsMAQsgAiABQcCBzABBBBC9CiACIAA2AgwgAiACQQxq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IAAgATYCACAEQRBqJAALTgECfiAAQdGGywBBARDnCwJ+IAAgASACEPMBIgOnQf8BcUEERgRAIABB0YbLAEEBEOcLQgQhBEIADAELIANC/wGDIQQgA0KAfoMLIASEC0gBAX8jAEEgayICJAAgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggACACQQhqEM4GIAJBIGokAAtUAQF/IAAoAggiAiAAKAIERgRAIAAgAhDpCCAAKAIIIQILIAAoAgAgAkEEdGoiAiABKQIANwIAIAJBCGogAUEIaikCADcCACAAIAAoAghBAWo2AggLTgEBfyAAQShqKAIAIgMgACACQf8BcWpBO2otAAAgAEG6AmotAABBAWogAWxqIgFNBEAgASADQeTAywAQsAcACyAAKAIgIAFBAnRqKAIAC04BAX8gAEEoaigCACIDIAAgAkH/AXFqQTtqLQAAIABBugJqLQAAQQFqIAFsaiIBTQRAIAEgA0GUwcsAELAHAAsgACgCICABQQJ0aigCAAtRAQF/IABBHGooAgAiAyAAQRhqKAIARgRAIABBFGogAxDtCCAAKAIcIQMLIAAoAhQgA0EDdGoiAyACNgIEIAMgATYCACAAIAAoAhxBAWo2AhwLTAACQAJAAkAgACgCAA4CAAECCyAAKAIEQQVHDQEgAEEQaigCAEEDdEUNASAAQQxqKAIAEIkBDAELIAAtAARBA0cNACAAQQhqEMcKCwtfAgF/AX4jAEEQayICJAAgASgCABEJACIBRQRAQejMywBBxgAgAkEIakH80MsAQYDOywAQ8wYACyABIAEpAwAiA0IBfDcDACAAIAEpAwg3AwggACADNwMAIAJBEGokAAtVAQN/IwBBEGsiAiQAIAEoAgAhBCACQQhqIAEoAggiAUEAEIUIIAIoAgghAyAAIAIoAgw2AgQgACADNgIAIAMgBCABEIkDGiAAIAE2AgggAkEQaiQAC1UBA38jAEEQayICJAAgASgCCCEDIAEoAgQhBCACIAEoAgAiATYCCCACIAQ2AgQgAiABNgIAIAIgASADQQN0ajYCDCAAIAIQ5wQgABDLAiACQRBqJAALVQEDfyMAQRBrIgIkACABKAIIIQMgASgCBCEEIAIgASgCACIBNgIIIAIgBDYCBCACIAE2AgAgAiABIANBAXRq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IAIQ6AMgA0EIaiADQTBqIANB2ABqEDogACADQQhqEIEDIANBgAFqJAALWAECfiAAvSIBQv///////////wCDUARAQQIPCwJ/IAFCgICAgICAgPj/AIMiAkKAgICAgICA+P8AUgRAQQQgAkIAUg0BGkEDDwsgAUL/////////B4NQCwtPAQF/IAAoAgAhBCAALQAEQQFHBEAgBCgCAEH1jMAAQQEQ5wsLIABBAjoABCAEIAEgAhDwChogBCgCAEH2jMAAQQEQ5wsgBCADEL8FGkEAC0sBAn8jAEEQayICJAAgAkEIakHAABDmByACKAIMIQMgAigCCCABQcAAEIkDIQEgAEHAADYCCCAAIAM2AgQgACABNgIAIAJBEGokAAtHAQJ/IwBBEGsiAyQAIANBCGogAhDmByADKAIIIQQgACADKAIMNgIEIAAgBDYCACAEIAEgAhCJAxogACACNgIIIANBEGokAAtGAAJAIAQgA08EQCAEIAJLDQEgACAEIANrNgIEIAAgASADQQJ0ajYCAA8LIAMgBEHIrssAELMHAAsgBCACQciuywAQsgcAC0gBAn8gACgCBCIDIAEoAgAiAk8EQEF/IQEgACgCACACaiADIAJrENUCIgBBgIDEAEcEfyAABSABCw8LIAIgA0GQsssAELEHAAtGAAJAIAQgA08EQCAEIAJLDQEgACAEIANrNgIEIAAgASADQQxsajYCAA8LIAMgBEHwyssAELMHAAsgBCACQfDKywAQsgcACz8BAn8jAEEQayICJAAgACgCACEDIAIgACgCBCIANgIMIAEgAkEMakEEEM8BIAEgA0EIaiAAEM8BIAJBEGokAAtDAQF/IAAQlQUgACgCACIBBEAgACgCBEH/ASABQQVqEJEFGgsgAEEANgIMIAAgASABQQFqQQN2QQdsIAFBCEkbNgIIC1YBA38gAS0AgQIhAiABLQCAAiEDQYICQQEQ5AsiBEUEQEGCAkEBEOIMAAsgBCABQYACEIkDIgEgAjoAgQIgASADOgCAAiAAQdD4ywA2AgQgACABNgIAC0UBAX8gABCcASAAKAIARQRAIABBBGoQkwYPCyAAQRxqIgEoAgAQugkgASgCABCJASAAQSBqIgAoAgAQugkgACgCABCJAQtaAQF/QYDAAyEBAkAgAEH/rwNGDQBBgIDEAEGAgMQAIABBAWoiASABQYDw/wFxQYCwA0YbIABB/v/DAEsbIgFBgIDEAEcNAEHMw8wAQStB6MLMABDRCQALIAELRQEBfyAAEJwBIAAoAgBFBEAgAEEEahCWBg8LIABBHGoiASgCABC8CSABKAIAEIkBIABBIGoiACgCABC8CSAAKAIAEIkBC0wBAn8jAEEQayIBJAAgAUEIakEsQQAQhQggASgCCCECIAAgASgCDDYCBCAAIAI2AgAgAkGDiMsAQSwQiQMaIABBLDYCCCABQRBqJAALRgAgACABQSgQiQMiABCqBiAAQShqIAFBKGpBKBCJAxogAEHQAGogAUHQAGpBKBCJAxogAEH4AGogAUH4AGpBKBCJAxCqBgs/AQN/EDAiAxAnIgQQKCECIARBJE8EQCAEEAALIAIgACgCACABECkgAkEkTwRAIAIQAAsgA0EkTwRAIAMQAAsLSAIBfwF+EIoDIQBBqJThACkCACEBQayU4QAgADYCAEGolOEAQQE2AgACQCABp0UNACABQiCIpyIAQSRJDQAgABAAC0GslOEACzwBAX8gACgCCCIBBEAgACgCACEAIAFBDGwhAQNAIAAoAgAEQCAAEKQLCyAAQQxqIQAgAUF0aiIBDQALCws/AQF/AkAgACgCACIBQX9GDQAgASABKAIEIgFBf2o2AgQgAUEBRw0AIAAoAgRBC2pBfHFFDQAgACgCABCJAQsLSAEBfyAAKAIIIgMgACgCBEYEQCAAIAMQjwkgACgCCCEDCyAAKAIAIANBA3RqIgMgAjYCBCADIAE2AgAgACAAKAIIQQFqNgIIC0sBAX8CQCABQYCAgIB4cyIBQQ1LBEBBACEBDAELIAFBAnQiAkHc+8oAaigCACEBIAJBpPvKAGooAgAhAgsgACACNgIEIAAgATYCAAtBAQF/IABBKGooAgAiAyAAIAJB/wFxakE7ai0AACABaiIBTQRAIAEgA0GEwcsAELAHAAsgACgCICABQQJ0aigCAAtIAQF/IwBBEGsiAiQAIAIgAUGc/8sAQQ4Qiws3AwAgAiAANgIMIAJBqv/LAEEDIAJBDGpBsP/LABDwAhogAhD5BiACQRBqJAALSAEBfyMAQRBrIgIkACACIAFBk4DMAEENEIsLNwMAIAIgADYCDCACQcz/ywBBBSACQQxqQbD/ywAQ8AIaIAIQ+QYgAkEQaiQAC0gBAX8jAEEQayICJAAgAiABQcSTzABBBRCLCzcDACACIAA2AgwgAkHJk8wAQQQgAkEMakHQk8wAEPACGiACEPkGIAJBEGokAAtIAQF/IwBBEGsiAiQAIAIgAUGYw8wAQQsQiws3AwAgAiAANgIMIAJBo8PMAEEGIAJBDGpBrMPMABDwAhogAhD5BiACQRBqJAALSAEBfyMAQRBrIgIkACACIAFBmMPMAEELEIsLNwMAIAIgADYCDCACQaPDzABBBiACQQxqQbzDzAAQ8AIaIAIQ+QYgAkEQaiQAC0gBAX8jAEEQayICJAAgAiABQfTi3QBBDBCLCzcDACACIAA2AgwgAkGA490AQQMgAkEMakGE490AEPACGiACEPkGIAJBEGokAAtIAQF/IwBBEGsiAiQAIAIgAUGU490AQQoQiws3AwAgAiAANgIMIAJBgOPdAEEDIAJBDGpBoOPdABDwAhogAhD5BiACQRBqJAALSAEBfyMAQRBrIgIkACACIAFBweXdAEEHEIsLNwMAIAIgADYCDCACQcjl3QBBBSACQQxqQdDl3QAQ8AIaIAIQ+QYgAkEQaiQAC0ABAn8gACgCBCIBRQRAQQAPCyAAKAIIIgAEQCABIABuIgIgASAAIAJsa0EAR2oPC0HAgd4AQRlBsIHeABDRCQALQwEBfyMAQUBqIgQkACAEIAFBwAFqEK4CIABBAWogBCACIAMgARCQAiAAQQA6AAAgBBDDCiAEQSBqEMMKIARBQGskAAtAAQN/IAAgASABQfgAaiICEHAgAEEoaiABQShqIgMgAUHQAGoiBBBwIABB0ABqIAQgAhBwIABB+ABqIAEgAxBwC0gBAX8jAEEgayIDJAAgA0EUakEANgIAIANBlO3gADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACENcKAAtJAQF/IwBBIGsiAiQAIAJBFGpBATYCACACQgE3AgQgAkG88OAANgIAIAJB4AM2AhwgAiAANgIYIAIgAkEYajYCECACIAEQ1woAC0ACAX8BfCABKAIAQQFxIQIgACsDACEDIAEoAhBBAUYEQCABIAMgAiABQRRqKAIAQQFqEKgBDwsgASADIAIQ0wELRwECfyMAQRBrIgEkAEGw/soAKAIAEQkAIgBFBEBB0P7KAEHGACABQQhqQfj/ygBB6P/KABDzBgALIAAoAgAQCSABQRBqJAALNwECfyAAKAIEIQEgACgCACEAA0AgASgCiAJByANBmAMgABsEQCABEIkBCyAAQQFqIQAiAQ0ACws+AQF/IwBBEGsiASQAIAEgABCaCgJAIAEoAgAiAEUNACABKAIERQ0AIAFBCGooAgAaIAAQiQELIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgABCeCgJAIAEoAgAiAEUNACABKAIERQ0AIAFBCGooAgAaIAAQiQELIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgABCcCgJAIAEoAgAiAEUNACABKAIERQ0AIAFBCGooAgAaIAAQiQELIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgABCbCgJAIAEoAgAiAEUNACABKAIERQ0AIAFBCGooAgAaIAAQiQELIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgABC1CgJAIAEoAgAiAEUNACABKAIERQ0AIAFBCGooAgAaIAAQiQELIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgABCdCgJAIAEoAgAiAEUNACABKAIERQ0AIAFBCGooAgAaIAAQiQELIAFBEGokAAtZAQF/AkBB0JThACgCAEEBRwRAQYiU4QBBiJThACgCACIAQQFqNgIAIABFDQFB1JThACAANgIAQdCU4QBBATYCAAtB1JThAA8LQYiwywBBK0G0sMsAEOgKAAtDAQF/IAFBIGooAgAiAyACTQRAIAIgA0GAxssAELAHAAsgACABKAIYIAJBJGxqIgEoAhQ2AgAgACABQRxqKAIANgIECzUBAn8gACgCBCEBIAAoAgAhAANAIAEoAgBB5ABBNCAAGwRAIAEQiQELIABBAWohACIBDQALC0sBAn8CQAJ/AkACQCABKAIAIgJBAWsOAgABAwsgAUEMaigCACABQQhqKAIAawwBCyABKAIECyEDQQEhAgsgACADNgIEIAAgAjYCAAtEAQF/IAAoAggiAiAAKAIERgRAIAAgAhCICSAAKAIIIQILIAAoAgAgAkGEAWxqIAFBhAEQiQMaIAAgACgCCEEBajYCCAs6AQF/IABBhX9qQQRJIABBpX9qQQNNciAAQV1qIgFBHE1BAEEBIAF0QeubgIABcRtyRQRAQQAPC0EBC0QBAX8jAEEQayIBJAAgABC8BEH/AXEiAEECRgRAQejU3QBBJCABQQhqQZjY3QBB7NXdABDzBgALIAFBEGokACAAQQBHCyoBAX8jAEEQayIBJAAgAUEgNgIMIAEgADYCCCABQQhqEI4DIAFBEGokAAtFAQJ/IABCADcCBCAAQfyNywAoAgA2AgAgASgCCCICBEAgASgCBCEDIAEoAgAhAQNAIAAgASADEOcLIAJBf2oiAg0ACwsLWQEBfyMAQRBrIgAkAEHwlOEAKQMAQgFSBEAgAEICNwMIIABCATcDAEHwlOEAQgE3AwBBgJXhACAAKQMINwMAQfiU4QAgACkDADcDAAsgAEEQaiQAQfiU4QALNwACQAJAAkAgACgCGA4CAgEACyAAQTRqEPwKDAELIABBNGoQpAsLIAAoAkQQnAYgACgCRBCJAQs3AQF/IAAoAggiAQRAIAFBKGwhASAAKAIAQRhqIQADQCAAEKQLIABBKGohACABQVhqIgENAAsLC0YBAn8gAS0AASECIAEtAAAhA0ECQQEQ5AsiAUUEQEECQQEQ4gwACyABIAI6AAEgASADOgAAIABBsPfLADYCBCAAIAE2AgALRgECfyABLQABIQIgAS0AACEDQQJBARDkCyIBRQRAQQJBARDiDAALIAEgAjoAASABIAM6AAAgAEHg9ssANgIEIAAgATYCAAtEAQF/IAEoAggiAyACQf//A3EiAk0EQCACIANB2JDMABCwBwALIAAgASgCACACQQxsaiIBKAIINgIEIAAgASgCADYCAAs1ACAAQf8BcUHfAEYgAEFQakH/AXFBCklyIABBn39qQf8BcUEaSXIgAEG/f2pB/wFxQRpJcgs+AQF/IwBBEGsiAiQAIAIgAUGYksAAQQUQvQogAiAANgIMIAIgAkEMakGgksAAEK8DGiACEJsGIAJBEGokAAtFAQJ/IwBBEGsiASQAQYyvywAoAgARCQAiAEUEQEHozMsAQcYAIAFBCGpB/NDLAEGAzssAEPMGAAsgACgCACABQRBqJAALNAAgACgCHCAAQRRqKAIAQQF0aiAAQThqLwEAQQN0aiAAQSxqKAIAIAAoAghqQQxsakEIags+AQF/IwBBEGsiAiQAIAIgAUH0/ssAQQYQvQogAiAANgIMIAIgAkEMakH8/ssAEK8DGiACEJsGIAJBEGokAAs+AQF/IwBBEGsiAiQAIAIgAUH4gcwAQQUQvQogAiAANgIMIAIgAkEMakHogcwAEK8DGiACEJsGIAJBEGokAAs+AQF/IwBBEGsiAiQAIAIgAUHc0N0AQQ0QvQogAiAANgIMIAIgAkEMakHs0N0AEK8DGiACEJsGIAJBEGokAAs+AQF/IwBBEGsiAiQAIAIgAUH80N0AQRAQvQogAiAANgIMIAIgAkEMakHs0N0AEK8DGiACEJsGIAJBEGokAAs8ACAAIAEpAAA3AAAgAEEYaiABQRhqKQAANwAAIABBEGogAUEQaikAADcAACAAQQhqIAFBCGopAAA3AAALPAAgACABIAIQtQYgAEEoaiABQShqIAIQtQYgAEHQAGogAUHQAGogAhC1BiAAQfgAaiABQfgAaiACELUGCzsBAn8gACABIAFB0ABqIgIQcCAAQShqIAFBKGoiAyACEHAgAEHQAGogAkEBEJUBIABB+ABqIAEgAxBwC0YBAn8gASgCBCECIAEoAgAhA0EIQQQQ5AsiAUUEQEEIQQQQ4gwACyABIAI2AgQgASADNgIAIABB6M7gADYCBCAAIAE2AgALPQIBfwF8IAEoAgBBAXEhAiAAKwMAIQMgASgCEEEBRgRAIAEgAyACIAFBFGooAgAQngEPCyABIAMgAhDIAQtBAAJ+QgAgACABQdGKwABBAxCYCw0AGkKAAiAAIAFB1IrAAEEDEJgLDQAaQoAEQoAGIAAgAUHXisAAQQMQmAsbCws+AQF/IwBBsANrIgMkACADEKcKIAMgASACENgMIANB2AFqIANB2AEQiQMaIAAgA0HYAWoQiAcgA0GwA2okAAsvAAJAAn8CQAJAIAAtABgOAgMBAAsgAEEcahCkCyAAQShqDAELIABBHGoLEKQLCws8AQF/QeiU4QAoAgBB/////wdxBEAQmQtBAXMhAgsgACABNgIEIABBCGogAjoAACAAIAEtAAFBAEc2AgALOQEBfyABQRB2QAAhAiAAQQA2AgggAEEAIAFBgIB8cSACQX9GIgEbNgIEIABBACACQRB0IAEbNgIACzQBAX8gAEEEahDaCSAAQcgEai0AAEECRwRAIABBoARqIgEQ/AggARD3CiAAQawEahD4CgsLNgEBfyAAKAIAIgBBGGoQvgsCQCAAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQiQELCz0BAX8jAEEQayICJAAgAkEIaiABKAIAIAEoAgQoAiQRAAAgACACKAIINgIAIAAgAigCDDYCBCACQRBqJAALTwACQAJAAkACQCAALQAAQQFrDgMBAgMACyABQcfj3QBBCRC3Cw8LIAFBwOPdAEEHELcLDwsgAUG3490AQQkQtwsPCyABQbDj3QBBBxC3CwtPAAJAAkACQAJAIAAtAABBAWsOAwECAwALIAFBtOLdAEEHELcLDwsgAUHg490AQQ0QtwsPCyABQdvj3QBBBRC3Cw8LIAFB0OPdAEELELcLC2sBA38jAEEQayIBJAAgACgCDCICRQRAQfDN4ABBK0G4zuAAENEJAAsgACgCCCIDRQRAQfDN4ABBK0HIzuAAENEJAAsgASACNgIIIAEgADYCBCABIAM2AgAgASgCACABKAIEIAEoAggQywYACx8AIAAQpAsgAEEMahCkCyAAQRhqEKQLIABBJGoQpAsLNQEBfyMAQaAEayIBJAAgASAAEKgDIAFBkAJqIAFBkAIQiQMaIAFBkAJqEJUIIAFBoARqJAALMwEBfyMAQYABayIBJAAgASAAENQEIAFBQGsgAUHAABCJAxogAUFAaxCrCiABQYABaiQACzUBAX8jAEGgBGsiASQAIAEgABDdBCABQZACaiABQZACEIkDGiABQZACahCVCCABQaAEaiQACykBAX8gACgCACIBIAFBAWqtQgx+pyIBakEFagRAIAAoAgQgAWsQiQELCzcBAX8jAEEQayICJAAgAkEIaiABQQRqIAEQ7gUgACACKAIINgIAIAAgAigCDDYCBCACQRBqJAALMAEBfyAAQQhqEMcKIAAoAhQiASABKAIAIgFBf2o2AgAgAUEBRgRAIABBFGoQ/gkLCy0AIABBv39qQf8BcUEaTwRAIABBX3EgACAAQZ9/akH/AXFBGkkbDwsgAEEgcgs0AQF/IAAoAggiAQRAIAAoAgAhACABQQV0IQEDQCAAENwCIABBIGohACABQWBqIgENAAsLCzcBAX8gACgCCCIBBEAgACgCACEAIAFBhAFsIQEDQCAAEIYDIABBhAFqIQAgAUH8fmoiAQ0ACwsLNwEBfyAAKAIIIgEEQCAAKAIAIQAgAUHcAGwhAQNAIAAQlgYgAEHcAGohACABQaR/aiIBDQALCws1AQF/IwBBMGsiAiQAIAJBCGogAUEoEIkDGiACIAJBCGoQuAogACACKQMANwMAIAJBMGokAAtAAQF/IwBBIGsiACQAIABBHGpBADYCACAAQejQ4AA2AhggAEIBNwIMIABB/NDgADYCCCAAQQhqQYTR4AAQ1woACzEBAn8jAEGAAWsiACQAIAAQtwcgAEFAayAAQcAAEIkDGiAAQUBrEKsKIABBgAFqJAALMQEBfyABKAIAIgJBf0cEQCABIAJBAWoQ3wsgACABNgIEIAAgAUEIajYCAA8LEJoMAAsxAQF/IAEoAgAiAkF/RwRAIAEgAkEBahDfCyAAIAE2AgQgACABQQRqNgIADwsQmgwACzkBAX8CQCAAKAIAIgFFDQAgASAAKAIEKAIAEQMAIAAoAgQiASgCBEUNACABKAIIGiAAKAIAEIkBCws2AQF/IwBBEGsiASQAIAAQigQEQEG47coAQSsgAUEIakHk7coAQdDrygAQ8wYACyABQRBqJAALNgEBfyMAQRBrIgEkACAAEM8DBEBBuO3KAEErIAFBCGpB5O3KAEHQ68oAEPMGAAsgAUEQaiQACy8BAX8CQCAAKAIAIgAQA0EBRw0AIAAQFiIAEBRBAUYhASAAQSRJDQAgABAACyABCysAAkAgAEF8Sw0AIABFBEBBBA8LIAAgAEF9SUECdBDkCyIARQ0AIAAPCwALNAEBfyMAQRBrIgEkACABIAAQtwYgASgCBARAA0AgASAAELcGIAEoAgQNAAsLIAFBEGokAAs5AgF/AX4jAEEQayIBJAAgAUEIakGAAkEBENAGIAEpAwghAiAAQYACNgIIIAAgAjcCACABQRBqJAALNAEBfyABKAIEIgIEQCAAQQhqQQQ2AgAgACACQQN0NgIEIAAgASgCADYCAA8LIABBADYCAAs1AQF/IAEoAgQiAgRAIABBCGpBBDYCACAAIAJB8ABsNgIEIAAgASgCADYCAA8LIABBADYCAAs0AQF/IAEoAgQiAgRAIABBCGpBBDYCACAAIAJBJGw2AgQgACABKAIANgIADwsgAEEANgIACzUBAX8gASgCBCICBEAgAEEIakEENgIAIAAgAkGkAWw2AgQgACABKAIANgIADwsgAEEANgIACzQBAX8gASgCBCICBEAgAEEIakEENgIAIAAgAkEobDYCBCAAIAEoAgA2AgAPCyAAQQA2AgALMgEBfyAAIAEgAUH4AGoiAhBwIABBKGogAUEoaiABQdAAaiIBEHAgAEHQAGogASACEHALNQEBfyMAQeABayIEJAAgBCABQdABahDcASAAIAQgAiADEK4IIARBwAFqEMMKIARB4AFqJAALOwEBfxCrCyICQQA7AZIDIAJBADYCiAIgACABIAIQlAMgAEE0aiACNgIAIABBADYCMCAAIAEpAgA3AygLJwEBfyAAKAIAIgEgAUEEdEEQaiIBakEFagRAIAAoAgQgAWsQiQELCzgBAX8gAS0AACECQQFBARDkCyIBRQRAQQFBARDiDAALIAEgAjoAACAAQcD1ywA2AgQgACABNgIACysBAX8gACABRwRAA0AgAiAALAAAQb9/SmohAiAAQQFqIgAgAUcNAAsLIAILNgEBfyMAQRBrIgEkACAAENcFBEBBw9/dAEEeIAFBCGpBnObdAEHk390AEPMGAAsgAUEQaiQACzABAX8jAEEQayICJAAgAkEIaiAAKAIAEP4GIAEgAigCCCACKAIMELcLIAJBEGokAAs3ACAAQdQAakEAQYABEJEFGiAAQRBqQZCB4ABBwAAQiQMaIABCADcDCCAAQgA3AwAgAEEANgJQCzUBAX8jAEHAAmsiAyQAIANBoAFqIAIQkgcgAyABIANBoAFqEMUCIAAgAxDQCSADQcACaiQACzUBAX8jAEHAAmsiAyQAIANBoAFqIAIQkgcgAyABIANBoAFqEMYCIAAgAxDQCSADQcACaiQACzMBAn8gACgCACIBIAAoAgQiAkcEQANAIAFBADoAACAAIAFBAWoiATYCACABIAJHDQALCwsyAQF/QcQAQQQQ5AsiAUUEQEHEAEEEEOIMAAsgAUEANgIAIAFBBGogAEHAABCJAxogAQsqAQF/IwBBEGsiAiQAIAIgATYCDCACIAA2AgggAkEIahDDBCACQRBqJAALKwEBfyMAQSBrIgIkACACIAAQwQggAUEgIAJBIEGQ88EAEIgLIAJBIGokAAsyAQF/IwBBEGsiAiQAIAJBCGogARDNCyAAIAIoAgg2AgAgACACKAIMNgIEIAJBEGokAAstAQF/IwBBEGsiAiQAIAJBCGogABDNCyACKAIIIAIoAgwgARDkDCACQRBqJAALLQEBfyMAQRBrIgIkACACQQhqIAAQzQsgAigCCCACKAIMIAEQmwEgAkEQaiQACzIAIAAoAgAhACABEPcLRQRAIAEQ+AtFBEAgACABEIgMDwsg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IAEpAAg3AgggACABKQAANwIAIABBGGpCADcCAAsfACABIANGBEAgACACIAEQiQMaDwsgASADIAQQtgcACyEAIAAgAUEDcjYCBCAAIAFqQQRqIgAgACgCAEEBcjYCAAsjACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsmACAArUKAgICAEEIAIAAoAhggASACIABBHGooAgAoAgwRBQAbhAspACAArUKAgICAEEIAIAAoAhhBt/PgAEEBIABBHGooAgAoAgwRBQAbhAsfAQF/IABBBGohASAAKAIARQRAIAEQpAsPCyABEJgICyIBAX8jAEEgayICJAAgAiABEPsEIAAgAhDzCSACQSBqJAALJQAgAEUEQEGggcsAQTAQmwwACyAAIAIgAyAEIAUgASgCEBENAAsjACAAIAI2AgwgACABKQIANwIAIABBCGogAUEIaigCADYCAAshAQF/IAAgASACIAEgAksiAxs2AgQgACACIAEgAxs2AgALIAECfiAAKQMAIgIgAkI/hyIDfCADhSACQn9VIAEQlwMLIAEBfyAAKAIEIAAoAggiAmsgAUkEQCAAIAIgARDhCAsLIwAgAEUEQEGggcsAQTAQmwwACyAAIAIgAyAEIAEoAhARBgALIwAgAEUEQEGggcsAQTAQmwwACyAAIAIgAyAEIAEoAhARCwALIwAgAEUEQEGggcsAQTAQmwwACyAAIAIgAyAEIAEoAhARIgALIwAgAEUEQEGggcsAQTAQmwwACyAAIAIgAyAEIAEoAhARIQALGQEBfyABIANGBH8gACACIAEQlglFBSAECwsmAEHQmOEAKAIAQQFGBEBB1JjhACgCAEUPC0HQmOEAQgE3AwBBAQsVACAAKAIAQQFGBEAgAEEEahCkCwsLHwEBf0H4k+EAIQBB+JPhACgCAEECRgR/EKYGBSAACwsfAQF/QayU4QAhAEGolOEAKAIAQQFHBH8QwAkFIAALCyEAIABFBEBBoIHLAEEwEJsMAAsgACACIAMgASgCEBECAAscACAAKAIAQQJPBEAgAEEEaiIAEPAIIAAQywoLCxsBAX9BIEEEEOQLIgAEQCAADwtBIEEEEOIMAAsgAQF/IAAgASgCACICNgIAIAAgAiABKAIIQQR0ajYCBAsgAQF/IAAgASgCACICNgIAIAAgAiABKAIIQQV0ajYCBAskACAALQAARQRAIAFB2PbgAEEFEKEBDwsgAUHU9uAAQQQQoQELGwEBfyMAQUBqIgEkACABIAAQlgggAUFAayQACxIAIAAoAgQEQCAAKAIAEIkBCwsfACAARQRAQaCBywBBMBCbDAALIAAgAiABKAIQEQEACx0AIAEoAgBFBEAACyAAQci+zAA2AgQgACABNgIACx0AIAEoAgBFBEAACyAAQfi/4AA2AgQgACABNgIACxIAQczP4ABBHEG40OAAENEJAAsPACAAEKQLIABBDGoQpAsLEwAgACgCAEUEQCAAQQRqEKQLCwsnAQF/QZgDQQgQ5AsiAEUEQEEAIQALIAAEQCAADwtBmANBCBDiDAALJwEBf0HIA0EIEOQLIgBFBEBBACEACyAABEAgAA8LQcgDQQgQ4gwACyUBAX9BNEEEEOQLIgBFBEBBACEACyAABEAgAA8LQTRBBBDiDAALJwEBf0HkAEEEEOQLIgBFBEBBACEACyAABEAgAA8LQeQAQQQQ4gwACxQAIAAQ/AggABD3CiAAQQxqEPgKCxkBAX8gACgCECIBBH8gAQUgAEEUaigCAAsLIgAgAEL6gYCAoAE3AgwgAEIANwIEIABB6OfdACgCADYCAAsWACAAIAE2AgAgACABIAJBBHRqNgIECxIAQQBBGSAAQQF2ayAAQR9GGwsWACAAIAFBAXI2AgQgACABaiABNgIACxwAIAEoAhhB6O/gAEELIAFBHGooAgAoAgwRBQALHAAgASgCGEHz7+AAQQ4gAUEcaigCACgCDBEFAAsZACAAKAIYIAEgAiAAQRxqKAIAKAIMEQUACxwAIAEoAhhBz4zhAEEFIAFBHGooAgAoAgwRBQALHAAgASgCGEHtk+EAQQsgAUEcaigCACgCDBEFAAsTACAAKAIAIgBBJE8EQCAAEAALCw8AIAAoAgAEQCAAEKQLCwsXACAAQQA2AgggACACNgIEIAAgATYCAAsUACAAKAIIIAFPBEAgACABNgIICwsUACAAKAIABEAgABDEBSAAEKIKCwsUACAAKAIABEAgABCVBSAAEIcKCwsUACAAKAIABEAgABCUCSAAEPoKCwsdACAAQQA6AAogAEGBAjsBCCAAQoKAgICAIDcCAAsTAQF/IAAtAAAgACABOgAAQQFxCxkAIAAoAgAiACgCACABIAAoAgQoAhARAQALEAAgACABakF/akEAIAFrcQsRACAAQSBJIABBgX9qQSFJcgsNACAAIAEgAiADEKwBCxMAIAAgASACajYCBCAAIAE2AgALEgAgACABIAIQmQggACADENADCwwAIAEEQCAAEIkBCwsTACAAKAIAIAEgASACahDkCEEACxYAIAAoAgAiACgCACAAKAIIIAEQ6QcLFgAgACgCACIAKAIAIAAoAgQgARDpBwsWACAAIAEoAgg2AgQgACABKAIANgIACxYAIAAoAgAiACgCACAAKAIIIAEQgwgLFgAgACgCACIAKAIAIAAoAgggARCmCAsWACAAKAIAIgAoAgAgACgCCCABEPIHCxYAIAAoAgAiACgCACAAKAIIIAEQ8QcLFgAgACgCACIAKAIAIAAoAgggARCECAsRACAALQAAQX9qQf8BcUECSQsWACAAKAIAIgAoAgAgACgCCCABEJsBCxYAIAAoAgAiACgCACAAKAIIIAEQ5AwLFgAgACgCACIAKAIAIAAoAgggARD4BwsWACAAKAIAIgAoAgAgACgCCCABEIYICxYAIAAoAgAiACgCACAAKAIIIAEQ+QcLEwAgAEIANwAAIABBCGpCADcAAAsVAQF/IwBBEGsiASAAOgAPIAEtAA8LFgAgACgCACIAKAIAIAAoAgQgARCbAQsWACAAKAIAIgAoAgAgACgCCCABEKoICxQAIAAoAgAgAEEIaigCACABEOQMCw8AIABBAXQiAEEAIABrcgsPACAAKAIAGiAAIAE2AgALDwAgACgCAARAIAAQyAoLCxAAIAAgASABIAJqEOQIQQALEwAgAEEgNgIEIAAgASgCADYCAAsUACAAKAIAIAEgACgCBCgCDBEBAAsJACAAIAEQzAILCQAgACABELwKCxAAIAAgAjYCBCAAIAE2AgALDgAgACABIAEgAmoQ5AgLEAAgAEEAOgAEIAAgATYCAAsWAEHMlOEAIAA2AgBByJThAEEBNgIACxEAIAAoAgAgACgCCCABEIIICw8AIAAgAUEkaikCADcDAAsRACAAKAIAIAAoAgQgARDkDAsRACAAKAIAIAAoAgggARDkDAsNACAALQAcQQRxQQJ2Cw0AIAAtABxBCHFBA3YLEQAgACgCACAAKAIIIAEQmwELEwAgAEEoNgIEIABBlYjeADYCAAsRACAAKAIAIAAoAgQgARCbAQsTACAAQejO4AA2AgQgACABNgIACw4AIAAoAgAgARCCA0EACw0AIAAtAARBAnFBAXYLEQAgASAAKAIAIAAoAgQQoQELDQAgAC0AAEEQcUEEdgsNACAALQAAQSBxQQV2Cw0AIAAgASACEOcLQQALDgAgAEGAqH1qQaTXAEkLDQAgAEEAQcAAEJEFGgsMACAAKAIAEB5BAEcLDwAgACgCACgCACABEMYJCw0AIAAoAgQgACgCAGsLDwAgACgCACgCACABEPYHCwwAIAAgAUEgEJYJRQsNACAAIAFBwAAQiQMaCwoAQQAgAGsgAHELCwAgAC0ABEEDcUULDAAgACABQQNyNgIECw0AIAAoAgAgACgCBGoLDgAgACgCACABEIQDQQALDgAgACgCABoDQAwACwALDgAgADUCAEEBIAEQlwMLDAAgACABIAIQgQsACwsAIAAgASACELwDCw4AIAAoAgAgASACEL8BCw4AIAAxAABBASABEJcDCw4AIAApAwBBASABEJcDCwsAIAAjAGokACMACwsAIAAgASACEOACCwsAIAAgASACELsCCwcAIAAQpAsLDgAgAUHgkcAAQQoQtwsLDgAgAUHqkcAAQRUQtwsLDgAgAUH/kcAAQQ4QtwsLCwAgACgCACABEAoLDAAgACgCACABEIkICw8AIAAoAgAoAgAgARCpCAsMACAAKAIAIAEQ+AULDQBB2IHLAEEbEJsMAAsOAEHzgcsAQc8AEJsMAAsJACAAIAEQLwALDAAgACgCACABELYECwwAIAAoAgAgARD7BwsMACAAKAIAIAEQ5QQLDAAgACgCACABEMcDCwwAIAAoAgAgARC9BwsMACAAKAIAIAEQ7QcLDAAgACgCACABEOwHCwwAIAAoAgAgARDuBwsMACAAKAIAIAEQsAMLDAAgACgCACABEKcHCwwAIAAoAgAgARDqBwsMACAAKAIAIAEQ6wcLDAAgACgCACABEOAGCwwAIAAgASkCADcDAAsMACAAKAIAIAEQ4AQLDAAgACgCACABEMYJCwwAIAAoAgAgARCkCAsMACAAKAIAIAEQpQgLDAAgACgCACABEPAJCwwAIAAoAgAgARCiCwsMACAAKAIAIAEQwwcLDgAgAUGwgswAQQIQoQELLQACfyAAKAIALQAAQQFHBEAgAUHKhMwAQQUQtwsMAQsgAUHBhMwAQQkQtwsLCwwAIAAoAgAgARCkBQsMACAAKAIAIAEQ0goLDAAgACgCACABEP0FCwwAIAAoAgAgARCSCAsMACAAKAIAIAEQ/gULDAAgACgCACABEOEECwsAIAAgAToABCAACwsAIABBAToACiAACwoAIAAtAABBAUYLDAAgACgCACABEOMFCwoAIAAoAgAgAWoLCwAgACgCACABEGkLDAAgACgCACABEK0CCw4AIAFBiL7MAEECEKEBCwwAIAAoAgAgARCoCAsMACAAKAIAIAEQygkLDAAgACgCACABEMkJCwwAIAAoAgAgARCqAQsMACAAKAIAIAEQgQoLDAAgACgCACABEL0FCwwAIAAoAgAgARD3BwsMACAAKAIAIAEQ9gcLDAAgACgCACABELUFCwwAIAAoAgAgARDIBgsMACAAKAIAIAEQ+QILDAAgACgCACABEIAHCwwAIAAoAgAgARDMCQsMACAAKAIAIAEQgAoLDAAgACgCACABEM0JCwwAIAAoAgAgARDBBQsMACAAKAIAIAEQywkLDAAgACgCACABEOQGCwwAIAAoAgAgARD/BgsMACAAKAIAIAEQpgULDgAgAUG4g94AQQkQtwsLDgAgAUHBg94AQQUQtwsLDAAgACgCACABEPILCwsAIAAgASACEMQDCwsAIAAgASACEPQDCwsAIAAgASACEKgKCwsAIAAgASACEKkKCwsAIAAgASACEPoBCwsAIAAgAiABELYCCwoAIAAoAgRBeHELCgAgACgCBEEBcQsKACAAKAIMQQFxCwoAIAAoAgxBAXYLGgAgACABQdiU4QAoAgAiAEHLAyAAGxEAAAALDAAgACgCACABENAECwsAIAIgACABEKEBCwsAIAAgASACEKICCwwAIAAoAgAgARCeAwsMACAAKAIAIAEQmAILDAAgACgCACABEJkDCw4AIAFBgPfgAEECEKEBCw4AIAFB/+XKAEEZELcLCw4AIAFB3OXKAEEXELcLCw4AIAFB8+XKAEEMELcLCw4AIAFBrMfgAEECELcLCwkAIAAoAgAQIAsJACAAQQA2AgALBwAgACABagsHACAAIAFrCwcAIABBCGoLBwAgAEF4agsHACAAELMKCwUAEKsICwQAQQELBABBAAsNAELRrpjEmYOy94R/CwsAQtrLnuW9g+dRCw0AQtv8vMm4lIGowwALDABC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aW5kZ2VuLTAuMy4xXHNyY1xsaWIucnMAACAKEABiAAAAGAAAAA4AAABjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwAAANoKEABPAAAAhQEAABoAAABhbHJlYWR5IGJvcnJvd2VkIgAAAAAAAAABAAAAIwAAACQAAAAAAAAAAQAAACUAAAAmAAAAQzpcVXNlcnNcZG91Z2FcRG9jdW1lbnRzMlxjb2RlXHJ1c3QtcHJvamVjdHNcdHJhbnNmb3JtX3JlY3J5cHRpb25cd2FsbGV0XHNyY1xsaWIucnMAcAsQAFMAAAARAAAAGAAAAGFiYW5kb25hYmlsaXR5YWJsZWFib3V0YWJvdmVhYnNlbnRhYnNvcmJhYnN0cmFjdGFic3VyZGFidXNlYWNjZXNzYWNjaWRlbnRhY2NvdW50YWNjdXNlYWNoaWV2ZWFjaWRhY291c3RpY2FjcXVpcmVhY3Jvc3NhY3RhY3Rpb25hY3RvcmFjdHJlc3NhY3R1YWxhZGFwdGFkZGFkZGljdGFkZHJlc3NhZGp1c3RhZG1pdGFkdWx0YWR2YW5jZWFkdmljZWFlcm9iaWNhZmZhaXJhZmZvcmRhZnJhaWRhZ2FpbmFnZWFnZW50YWdyZWVhaGVhZGFpbWFpcmFpcnBvcnRhaXNsZWFsYXJtYWxidW1hbGNvaG9sYWxlcnRhbGllbmFsbGFsbGV5YWxsb3dhbG1vc3RhbG9uZWFscGhhYWxyZWFkeWFsc29hbHRlcmFsd2F5c2FtYXRldXJhbWF6aW5nYW1vbmdhbW91bnRhbXVzZWRhbmFseXN0YW5jaG9yYW5jaWVudGFuZ2VyYW5nbGVhbmdyeWFuaW1hbGFua2xlYW5ub3VuY2Vhbm51YWxhbm90aGVyYW5zd2VyYW50ZW5uYWFudGlxdWVhbnhpZXR5YW55YXBhcnRhcG9sb2d5YXBwZWFyYXBwbGVhcHByb3ZlYXByaWxhcmNoYXJjdGljYXJlYWFyZW5hYXJndWVhcm1hcm1lZGFybW9yYXJteWFyb3VuZGFycmFuZ2VhcnJlc3RhcnJpdmVhcnJvd2FydGFydGVmYWN0YXJ0aXN0YXJ0d29ya2Fza2FzcGVjdGFzc2F1bHRhc3NldGFzc2lzdGFzc3VtZWFzdGhtYWF0aGxldGVhdG9tYXR0YWNrYXR0ZW5kYXR0aXR1ZGVhdHRyYWN0YXVjdGlvbmF1ZGl0YXVndXN0YXVudGF1dGhvcmF1dG9hdXR1bW5hdmVyYWdlYXZvY2Fkb2F2b2lkYXdha2Vhd2FyZWF3YXlhd2Vzb21lYXdmdWxhd2t3YXJkYXhpc2JhYnliYWNoZWxvcmJhY29uYmFkZ2ViYWdiYWxhbmNlYmFsY29ueWJhbGxiYW1ib29iYW5hbmFiYW5uZXJiYXJiYXJlbHliYXJnYWluYmFycmVsYmFzZWJhc2ljYmFza2V0YmF0dGxlYmVhY2hiZWFuYmVhdXR5YmVjYXVzZWJlY29tZWJlZWZiZWZvcmViZWdpbmJlaGF2ZWJlaGluZGJlbGlldmViZWxvd2JlbHRiZW5jaGJlbmVmaXRiZXN0YmV0cmF5YmV0dGVyYmV0d2VlbmJleW9uZGJpY3ljbGViaWRiaWtlYmluZGJpb2xvZ3liaXJkYmlydGhiaXR0ZXJibGFja2JsYWRlYmxhbWVibGFua2V0Ymxhc3RibGVha2JsZXNzYmxpbmRibG9vZGJsb3Nzb21ibG91c2VibHVlYmx1cmJsdXNoYm9hcmRib2F0Ym9keWJvaWxib21iYm9uZWJvbnVzYm9va2Jvb3N0Ym9yZGVyYm9yaW5nYm9ycm93Ym9zc2JvdHRvbWJvdW5jZWJveGJveWJyYWNrZXRicmFpbmJyYW5kYnJhc3NicmF2ZWJyZWFkYnJlZXplYnJpY2ticmlkZ2VicmllZmJyaWdodGJyaW5nYnJpc2ticm9jY29saWJyb2tlbmJyb256ZWJyb29tYnJvdGhlcmJyb3duYnJ1c2hidWJibGVidWRkeWJ1ZGdldGJ1ZmZhbG9idWlsZGJ1bGJidWxrYnVsbGV0YnVuZGxlYnVua2VyYnVyZGVuYnVyZ2VyYnVyc3RidXNidXNpbmVzc2J1c3lidXR0ZXJidXllcmJ1enpjYWJiYWdlY2FiaW5jYWJsZWNhY3R1c2NhZ2VjYWtlY2FsbGNhbG1jYW1lcmFjYW1wY2FuY2FuYWxjYW5jZWxjYW5keWNhbm5vbmNhbm9lY2FudmFzY2FueW9uY2FwYWJsZWNhcGl0YWxjYXB0YWluY2FyY2FyYm9uY2FyZGNhcmdvY2FycGV0Y2FycnljYXJ0Y2FzZWNhc2hjYXNpbm9jYXN0bGVjYXN1YWxjYXRjYXRhbG9nY2F0Y2hjYXRlZ29yeWNhdHRsZWNhdWdodGNhdXNlY2F1dGlvbmNhdmVjZWlsaW5nY2VsZXJ5Y2VtZW50Y2Vuc3VzY2VudHVyeWNlcmVhbGNlcnRhaW5jaGFpcmNoYWxrY2hhbXBpb25jaGFuZ2VjaGFvc2NoYXB0ZXJjaGFyZ2VjaGFzZWNoYXRjaGVhcGNoZWNrY2hlZXNlY2hlZmNoZXJyeWNoZXN0Y2hpY2tlbmNoaWVmY2hpbGRjaGltbmV5Y2hvaWNlY2hvb3NlY2hyb25pY2NodWNrbGVjaHVua2NodXJuY2lnYXJjaW5uYW1vbmNpcmNsZWNpdGl6ZW5jaXR5Y2l2aWxjbGFpbWNsYXBjbGFyaWZ5Y2xhd2NsYXljbGVhbmNsZXJrY2xldmVyY2xpY2tjbGllbnRjbGlmZmNsaW1iY2xpbmljY2xpcGNsb2NrY2xvZ2Nsb3NlY2xvdGhjbG91ZGNsb3duY2x1YmNsdW1wY2x1c3RlcmNsdXRjaGNvYWNoY29hc3Rjb2NvbnV0Y29kZWNvZmZlZWNvaWxjb2luY29sbGVjdGNvbG9yY29sdW1uY29tYmluZWNvbWVjb21mb3J0Y29taWNjb21tb25jb21wYW55Y29uY2VydGNvbmR1Y3Rjb25maXJtY29uZ3Jlc3Njb25uZWN0Y29uc2lkZXJjb250cm9sY29udmluY2Vjb29rY29vbGNvcHBlcmNvcHljb3JhbGNvcmVjb3JuY29ycmVjdGNvc3Rjb3R0b25jb3VjaGNvdW50cnljb3VwbGVjb3Vyc2Vjb3VzaW5jb3ZlcmNveW90ZWNyYWNrY3JhZGxlY3JhZnRjcmFtY3JhbmVjcmFzaGNyYXRlcmNyYXdsY3JhenljcmVhbWNyZWRpdGNyZWVrY3Jld2NyaWNrZXRjcmltZWNyaXNwY3JpdGljY3JvcGNyb3NzY3JvdWNoY3Jvd2RjcnVjaWFsY3J1ZWxjcnVpc2VjcnVtYmxlY3J1bmNoY3J1c2hjcnljcnlzdGFsY3ViZWN1bHR1cmVjdXBjdXBib2FyZGN1cmlvdXNjdXJyZW50Y3VydGFpbmN1cnZlY3VzaGlvbmN1c3RvbWN1dGVjeWNsZWRhZGRhbWFnZWRhbXBkYW5jZWRhbmdlcmRhcmluZ2Rhc2hkYXVnaHRlcmRhd25kYXlkZWFsZGViYXRlZGVicmlzZGVjYWRlZGVjZW1iZXJkZWNpZGVkZWNsaW5lZGVjb3JhdGVkZWNyZWFzZWRlZXJkZWZlbnNlZGVmaW5lZGVmeWRlZ3JlZWRlbGF5ZGVsaXZlcmRlbWFuZGRlbWlzZWRlbmlhbGRlbnRpc3RkZW55ZGVwYXJ0ZGVwZW5kZGVwb3NpdGRlcHRoZGVwdXR5ZGVyaXZlZGVzY3JpYmVkZXNlcnRkZXNpZ25kZXNrZGVzcGFpcmRlc3Ryb3lkZXRhaWxkZXRlY3RkZXZlbG9wZGV2aWNlZGV2b3RlZGlhZ3JhbWRpYWxkaWFtb25kZGlhcnlkaWNlZGllc2VsZGlldGRpZmZlcmRpZ2l0YWxkaWduaXR5ZGlsZW1tYWRpbm5lcmRpbm9zYXVyZGlyZWN0ZGlydGRpc2FncmVlZGlzY292ZXJkaXNlYXNlZGlzaGRpc21pc3NkaXNvcmRlcmRpc3BsYXlkaXN0YW5jZWRpdmVydGRpdmlkZWRpdm9yY2VkaXp6eWRvY3RvcmRvY3VtZW50ZG9nZG9sbGRvbHBoaW5kb21haW5kb25hdGVkb25rZXlkb25vcmRvb3Jkb3NlZG91YmxlZG92ZWRyYWZ0ZHJhZ29uZHJhbWFkcmFzdGljZHJhd2RyZWFtZHJlc3NkcmlmdGRyaWxsZHJpbmtkcmlwZHJpdmVkcm9wZHJ1bWRyeWR1Y2tkdW1iZHVuZWR1cmluZ2R1c3RkdXRjaGR1dHlkd2FyZmR5bmFtaWNlYWdlcmVhZ2xlZWFybHllYXJuZWFydGhlYXNpbHllYXN0ZWFzeWVjaG9lY29sb2d5ZWNvbm9teWVkZ2VlZGl0ZWR1Y2F0ZWVmZm9ydGVnZ2VpZ2h0ZWl0aGVyZWxib3dlbGRlcmVsZWN0cmljZWxlZ2FudGVsZW1lbnRlbGVwaGFudGVsZXZhdG9yZWxpdGVlbHNlZW1iYXJrZW1ib2R5ZW1icmFjZWVtZXJnZWVtb3Rpb25lbXBsb3llbXBvd2VyZW1wdHllbmFibGVlbmFjdGVuZGVuZGxlc3NlbmRvcnNlZW5lbXllbmVyZ3llbmZvcmNlZW5nYWdlZW5naW5lZW5oYW5jZWVuam95ZW5saXN0ZW5vdWdoZW5yaWNoZW5yb2xsZW5zdXJlZW50ZXJlbnRpcmVlbnRyeWVudmVsb3BlZXBpc29kZWVxdWFsZXF1aXBlcmFlcmFzZWVyb2RlZXJvc2lvbmVycm9yZXJ1cHRlc2NhcGVlc3NheWVzc2VuY2Vlc3RhdGVldGVybmFsZXRoaWNzZXZpZGVuY2VldmlsZXZva2Vldm9sdmVleGFjdGV4YW1wbGVleGNlc3NleGNoYW5nZWV4Y2l0ZWV4Y2x1ZGVleGN1c2VleGVjdXRlZXhlcmNpc2VleGhhdXN0ZXhoaWJpdGV4aWxlZXhpc3RleGl0ZXhvdGljZXhwYW5kZXhwZWN0ZXhwaXJlZXhwbGFpbmV4cG9zZWV4cHJlc3NleHRlbmRleHRyYWV5ZWV5ZWJyb3dmYWJyaWNmYWNlZmFjdWx0eWZhZGVmYWludGZhaXRoZmFsbGZhbHNlZmFtZWZhbWlseWZhbW91c2ZhbmZhbmN5ZmFudGFzeWZhcm1mYXNoaW9uZmF0ZmF0YWxmYXRoZXJmYXRpZ3VlZmF1bHRmYXZvcml0ZWZlYXR1cmVmZWJydWFyeWZlZGVyYWxmZWVmZWVkZmVlbGZlbWFsZWZlbmNlZmVzdGl2YWxmZXRjaGZldmVyZmV3ZmliZXJmaWN0aW9uZmllbGRmaWd1cmVmaWxlZmlsbWZpbHRlcmZpbmFsZmluZGZpbmVmaW5nZXJmaW5pc2hmaXJlZmlybWZpcnN0ZmlzY2FsZmlzaGZpdGZpdG5lc3NmaXhmbGFnZmxhbWVmbGFzaGZsYXRmbGF2b3JmbGVlZmxpZ2h0ZmxpcGZsb2F0ZmxvY2tmbG9vcmZsb3dlcmZsdWlkZmx1c2hmbHlmb2FtZm9jdXNmb2dmb2lsZm9sZGZvbGxvd2Zvb2Rmb290Zm9yY2Vmb3Jlc3Rmb3JnZXRmb3JrZm9ydHVuZWZvcnVtZm9yd2FyZGZvc3NpbGZvc3RlcmZvdW5kZm94ZnJhZ2lsZWZyYW1lZnJlcXVlbnRmcmVzaGZyaWVuZGZyaW5nZWZyb2dmcm9udGZyb3N0ZnJvd25mcm96ZW5mcnVpdGZ1ZWxmdW5mdW5ueWZ1cm5hY2VmdXJ5ZnV0dXJlZ2FkZ2V0Z2FpbmdhbGF4eWdhbGxlcnlnYW1lZ2FwZ2FyYWdlZ2FyYmFnZWdhcmRlbmdhcmxpY2dhcm1lbnRnYXNnYXNwZ2F0ZWdhdGhlcmdhdWdlZ2F6ZWdlbmVyYWxnZW5pdXNnZW5yZWdlbnRsZWdlbnVpbmVnZXN0dXJlZ2hvc3RnaWFudGdpZnRnaWdnbGVnaW5nZXJnaXJhZmZlZ2lybGdpdmVnbGFkZ2xhbmNlZ2xhcmVnbGFzc2dsaWRlZ2xpbXBzZWdsb2JlZ2xvb21nbG9yeWdsb3ZlZ2xvd2dsdWVnb2F0Z29kZGVzc2dvbGRnb29kZ29vc2Vnb3JpbGxhZ29zcGVsZ29zc2lwZ292ZXJuZ293bmdyYWJncmFjZWdyYWluZ3JhbnRncmFwZWdyYXNzZ3Jhdml0eWdyZWF0Z3JlZW5ncmlkZ3JpZWZncml0Z3JvY2VyeWdyb3VwZ3Jvd2dydW50Z3VhcmRndWVzc2d1aWRlZ3VpbHRndWl0YXJndW5neW1oYWJpdGhhaXJoYWxmaGFtbWVyaGFtc3RlcmhhbmRoYXBweWhhcmJvcmhhcmRoYXJzaGhhcnZlc3RoYXRoYXZlaGF3a2hhemFyZGhlYWRoZWFsdGhoZWFydGhlYXZ5aGVkZ2Vob2doZWlnaHRoZWxsb2hlbG1ldGhlbHBoZW5oZXJvaGlkZGVuaGlnaGhpbGxoaW50aGlwaGlyZWhpc3Rvcnlob2JieWhvY2tleWhvbGRob2xlaG9saWRheWhvbGxvd2hvbWVob25leWhvb2Rob3BlaG9ybmhvcnJvcmhvcnNlaG9zcGl0YWxob3N0aG90ZWxob3VyaG92ZXJodWJodWdlaHVtYW5odW1ibGVodW1vcmh1bmRyZWRodW5ncnlodW50aHVyZGxlaHVycnlodXJ0aHVzYmFuZGh5YnJpZGljZWljb25pZGVhaWRlbnRpZnlpZGxlaWdub3JlaWxsaWxsZWdhbGlsbG5lc3NpbWFnZWltaXRhdGVpbW1lbnNlaW1tdW5laW1wYWN0aW1wb3NlaW1wcm92ZWltcHVsc2VpbmNoaW5jbHVkZWluY29tZWluY3JlYXNlaW5kZXhpbmRpY2F0ZWluZG9vcmluZHVzdHJ5aW5mYW50aW5mbGljdGluZm9ybWluaGFsZWluaGVyaXRpbml0aWFsaW5qZWN0aW5qdXJ5aW5tYXRlaW5uZXJpbm5vY2VudGlucHV0aW5xdWlyeWluc2FuZWluc2VjdGluc2lkZWluc3BpcmVpbnN0YWxsaW50YWN0aW50ZXJlc3RpbnRvaW52ZXN0aW52aXRlaW52b2x2ZWlyb25pc2xhbmRpc29sYXRlaXNzdWVpdGVtaXZvcnlqYWNrZXRqYWd1YXJqYXJqYXp6amVhbG91c2plYW5zamVsbHlqZXdlbGpvYmpvaW5qb2tlam91cm5leWpveWp1ZGdlanVpY2VqdW1wanVuZ2xlanVuaW9yanVua2p1c3RrYW5nYXJvb2tlZW5rZWVwa2V0Y2h1cGtleWtpY2traWRraWRuZXlraW5ka2luZ2RvbWtpc3NraXRraXRjaGVua2l0ZWtpdHRlbmtpd2lrbmVla25pZmVrbm9ja2tub3dsYWJsYWJlbGxhYm9ybGFkZGVybGFkeWxha2VsYW1wbGFuZ3VhZ2VsYXB0b3BsYXJnZWxhdGVybGF0aW5sYXVnaGxhdW5kcnlsYXZhbGF3bGF3bmxhd3N1aXRsYXllcmxhenlsZWFkZXJsZWFmbGVhcm5sZWF2ZWxlY3R1cmVsZWZ0bGVnbGVnYWxsZWdlbmRsZWlzdXJlbGVtb25sZW5kbGVuZ3RobGVuc2xlb3BhcmRsZXNzb25sZXR0ZXJsZXZlbGxpYXJsaWJlcnR5bGlicmFyeWxpY2Vuc2VsaWZlbGlmdGxpZ2h0bGlrZWxpbWJsaW1pdGxpbmtsaW9ubGlxdWlkbGlzdGxpdHRsZWxpdmVsaXphcmRsb2FkbG9hbmxvYnN0ZXJsb2NhbGxvY2tsb2dpY2xvbmVseWxvbmdsb29wbG90dGVyeWxvdWRsb3VuZ2Vsb3ZlbG95YWxsdWNreWx1Z2dhZ2VsdW1iZXJsdW5hcmx1bmNobHV4dXJ5bHlyaWNzbWFjaGluZW1hZG1hZ2ljbWFnbmV0bWFpZG1haWxtYWlubWFqb3JtYWtlbWFtbWFsbWFubWFuYWdlbWFuZGF0ZW1hbmdvbWFuc2lvbm1hbnVhbG1hcGxlbWFyYmxlbWFyY2htYXJnaW5tYXJpbmVtYXJrZXRtYXJyaWFnZW1hc2ttYXNzbWFzdGVybWF0Y2htYXRlcmlhbG1hdGhtYXRyaXhtYXR0ZXJtYXhpbXVtbWF6ZW1lYWRvd21lYW5tZWFzdXJlbWVhdG1lY2hhbmljbWVkYWxtZWRpYW1lbG9keW1lbHRtZW1iZXJtZW1vcnltZW50aW9ubWVudW1lcmN5bWVyZ2VtZXJpdG1lcnJ5bWVzaG1lc3NhZ2VtZXRhbG1ldGhvZG1pZGRsZW1pZG5pZ2h0bWlsa21pbGxpb25taW1pY21pbmRtaW5pbXVtbWlub3JtaW51dGVtaXJhY2xlbWlycm9ybWlzZXJ5bWlzc21pc3Rha2VtaXhtaXhlZG1peHR1cmVtb2JpbGVtb2RlbG1vZGlmeW1vbW1vbWVudG1vbml0b3Jtb25rZXltb25zdGVybW9udGhtb29ubW9yYWxtb3JlbW9ybmluZ21vc3F1aXRvbW90aGVybW90aW9ubW90b3Jtb3VudGFpbm1vdXNlbW92ZW1vdmllbXVjaG11ZmZpbm11bGVtdWx0aXBseW11c2NsZW11c2V1bW11c2hyb29tbXVzaWNtdXN0bXV0dWFsbXlzZWxmbXlzdGVyeW15dGhuYWl2ZW5hbWVuYXBraW5uYXJyb3duYXN0eW5hdGlvbm5hdHVyZW5lYXJuZWNrbmVlZG5lZ2F0aXZlbmVnbGVjdG5laXRoZXJuZXBoZXduZXJ2ZW5lc3RuZXRuZXR3b3JrbmV1dHJhbG5ldmVybmV3c25leHRuaWNlbmlnaHRub2JsZW5vaXNlbm9taW5lZW5vb2RsZW5vcm1hbG5vcnRobm9zZW5vdGFibGVub3Rlbm90aGluZ25vdGljZW5vdmVsbm93bnVjbGVhcm51bWJlcm51cnNlbnV0b2Frb2JleW9iamVjdG9ibGlnZW9ic2N1cmVvYnNlcnZlb2J0YWlub2J2aW91c29jY3Vyb2NlYW5vY3RvYmVyb2Rvcm9mZm9mZmVyb2ZmaWNlb2Z0ZW5vaWxva2F5b2xkb2xpdmVvbHltcGljb21pdG9uY2VvbmVvbmlvbm9ubGluZW9ubHlvcGVub3BlcmFvcGluaW9ub3Bwb3Nlb3B0aW9ub3Jhbmdlb3JiaXRvcmNoYXJkb3JkZXJvcmRpbmFyeW9yZ2Fub3JpZW50b3JpZ2luYWxvcnBoYW5vc3RyaWNob3RoZXJvdXRkb29yb3V0ZXJvdXRwdXRvdXRzaWRlb3ZhbG92ZW5vdmVyb3dub3duZXJveHlnZW5veXN0ZXJvem9uZXBhY3RwYWRkbGVwYWdlcGFpcnBhbGFjZXBhbG1wYW5kYXBhbmVscGFuaWNwYW50aGVycGFwZXJwYXJhZGVwYXJlbnRwYXJrcGFycm90cGFydHlwYXNzcGF0Y2hwYXRocGF0aWVudHBhdHJvbHBhdHRlcm5wYXVzZXBhdmVwYXltZW50cGVhY2VwZWFudXRwZWFycGVhc2FudHBlbGljYW5wZW5wZW5hbHR5cGVuY2lscGVvcGxlcGVwcGVycGVyZmVjdHBlcm1pdHBlcnNvbnBldHBob25lcGhvdG9waHJhc2VwaHlzaWNhbHBpYW5vcGljbmljcGljdHVyZXBpZWNlcGlncGlnZW9ucGlsbHBpbG90cGlua3Bpb25lZXJwaXBlcGlzdG9scGl0Y2hwaXp6YXBsYWNlcGxhbmV0cGxhc3RpY3BsYXRlcGxheXBsZWFzZXBsZWRnZXBsdWNrcGx1Z3BsdW5nZXBvZW1wb2V0cG9pbnRwb2xhcnBvbGVwb2xpY2Vwb25kcG9ueXBvb2xwb3B1bGFycG9ydGlvbnBvc2l0aW9ucG9zc2libGVwb3N0cG90YXRvcG90dGVyeXBvdmVydHlwb3dkZXJwb3dlcnByYWN0aWNlcHJhaXNlcHJlZGljdHByZWZlcnByZXBhcmVwcmVzZW50cHJldHR5cHJldmVudHByaWNlcHJpZGVwcmltYXJ5cHJpbnRwcmlvcml0eXByaXNvbnByaXZhdGVwcml6ZXByb2JsZW1wcm9jZXNzcHJvZHVjZXByb2ZpdHByb2dyYW1wcm9qZWN0cHJvbW90ZXByb29mcHJvcGVydHlwcm9zcGVycHJvdGVjdHByb3VkcHJvdmlkZXB1YmxpY3B1ZGRpbmdwdWxscHVscHB1bHNlcHVtcGtpbnB1bmNocHVwaWxwdXBweXB1cmNoYXNlcHVyaXR5cHVycG9zZXB1cnNlcHVzaHB1dHB1enpsZXB5cmFtaWRxdWFsaXR5cXVhbnR1bXF1YXJ0ZXJxdWVzdGlvbnF1aWNrcXVpdHF1aXpxdW90ZXJhYmJpdHJhY2Nvb25yYWNlcmFja3JhZGFycmFkaW9yYWlscmFpbnJhaXNlcmFsbHlyYW1wcmFuY2hyYW5kb21yYW5nZXJhcGlkcmFyZXJhdGVyYXRoZXJyYXZlbnJhd3Jhem9ycmVhZHlyZWFscmVhc29ucmViZWxyZWJ1aWxkcmVjYWxscmVjZWl2ZXJlY2lwZXJlY29yZHJlY3ljbGVyZWR1Y2VyZWZsZWN0cmVmb3JtcmVmdXNlcmVnaW9ucmVncmV0cmVndWxhcnJlamVjdHJlbGF4cmVsZWFzZXJlbGllZnJlbHlyZW1haW5yZW1lbWJlcnJlbWluZHJlbW92ZXJlbmRlcnJlbmV3cmVudHJlb3BlbnJlcGFpcnJlcGVhdHJlcGxhY2VyZXBvcnRyZXF1aXJlcmVzY3VlcmVzZW1ibGVyZXNpc3RyZXNvdXJjZXJlc3BvbnNlcmVzdWx0cmV0aXJlcmV0cmVhdHJldHVybnJldW5pb25yZXZlYWxyZXZpZXdyZXdhcmRyaHl0aG1yaWJyaWJib25yaWNlcmljaHJpZGVyaWRnZXJpZmxlcmlnaHRyaWdpZHJpbmdyaW90cmlwcGxlcmlza3JpdHVhbHJpdmFscml2ZXJyb2Fkcm9hc3Ryb2JvdHJvYnVzdHJvY2tldHJvbWFuY2Vyb29mcm9va2llcm9vbXJvc2Vyb3RhdGVyb3VnaHJvdW5kcm91dGVyb3lhbHJ1YmJlcnJ1ZGVydWdydWxlcnVucnVud2F5cnVyYWxzYWRzYWRkbGVzYWRuZXNzc2FmZXNhaWxzYWxhZHNhbG1vbnNhbG9uc2FsdHNhbHV0ZXNhbWVzYW1wbGVzYW5kc2F0aXNmeXNhdG9zaGlzYXVjZXNhdXNhZ2VzYXZlc2F5c2NhbGVzY2Fuc2NhcmVzY2F0dGVyc2NlbmVzY2hlbWVzY2hvb2xzY2llbmNlc2Npc3NvcnNzY29ycGlvbnNjb3V0c2NyYXBzY3JlZW5zY3JpcHRzY3J1YnNlYXNlYXJjaHNlYXNvbnNlYXRzZWNvbmRzZWNyZXRzZWN0aW9uc2VjdXJpdHlzZWVkc2Vla3NlZ21lbnRzZWxlY3RzZWxsc2VtaW5hcnNlbmlvcnNlbnNlc2VudGVuY2VzZXJpZXNzZXJ2aWNlc2Vzc2lvbnNldHRsZXNldHVwc2V2ZW5zaGFkb3dzaGFmdHNoYWxsb3dzaGFyZXNoZWRzaGVsbHNoZXJpZmZzaGllbGRzaGlmdHNoaW5lc2hpcHNoaXZlcnNob2Nrc2hvZXNob290c2hvcHNob3J0c2hvdWxkZXJzaG92ZXNocmltcHNocnVnc2h1ZmZsZXNoeXNpYmxpbmdzaWNrc2lkZXNpZWdlc2lnaHRzaWduc2lsZW50c2lsa3NpbGx5c2lsdmVyc2ltaWxhcnNpbXBsZXNpbmNlc2luZ3NpcmVuc2lzdGVyc2l0dWF0ZXNpeHNpemVza2F0ZXNrZXRjaHNraXNraWxsc2tpbnNraXJ0c2t1bGxzbGFic2xhbXNsZWVwc2xlbmRlcnNsaWNlc2xpZGVzbGlnaHRzbGltc2xvZ2Fuc2xvdHNsb3dzbHVzaHNtYWxsc21hcnRzbWlsZXNtb2tlc21vb3Roc25hY2tzbmFrZXNuYXBzbmlmZnNub3dzb2Fwc29jY2Vyc29jaWFsc29ja3NvZGFzb2Z0c29sYXJzb2xkaWVyc29saWRzb2x1dGlvbnNvbHZlc29tZW9uZXNvbmdzb29uc29ycnlzb3J0c291bHNvdW5kc291cHNvdXJjZXNvdXRoc3BhY2VzcGFyZXNwYXRpYWxzcGF3bnNwZWFrc3BlY2lhbHNwZWVkc3BlbGxzcGVuZHNwaGVyZXNwaWNlc3BpZGVyc3Bpa2VzcGluc3Bpcml0c3BsaXRzcG9pbHNwb25zb3JzcG9vbnNwb3J0c3BvdHNwcmF5c3ByZWFkc3ByaW5nc3B5c3F1YXJlc3F1ZWV6ZXNxdWlycmVsc3RhYmxlc3RhZGl1bXN0YWZmc3RhZ2VzdGFpcnNzdGFtcHN0YW5kc3RhcnRzdGF0ZXN0YXlzdGVha3N0ZWVsc3RlbXN0ZXBzdGVyZW9zdGlja3N0aWxsc3RpbmdzdG9ja3N0b21hY2hzdG9uZXN0b29sc3RvcnlzdG92ZXN0cmF0ZWd5c3RyZWV0c3RyaWtlc3Ryb25nc3RydWdnbGVzdHVkZW50c3R1ZmZzdHVtYmxlc3R5bGVzdWJqZWN0c3VibWl0c3Vid2F5c3VjY2Vzc3N1Y2hzdWRkZW5zdWZmZXJzdWdhcnN1Z2dlc3RzdWl0c3VtbWVyc3Vuc3VubnlzdW5zZXRzdXBlcnN1cHBseXN1cHJlbWVzdXJlc3VyZmFjZXN1cmdlc3VycHJpc2VzdXJyb3VuZHN1cnZleXN1c3BlY3RzdXN0YWluc3dhbGxvd3N3YW1wc3dhcHN3YXJtc3dlYXJzd2VldHN3aWZ0c3dpbXN3aW5nc3dpdGNoc3dvcmRzeW1ib2xzeW1wdG9tc3lydXBzeXN0ZW10YWJsZXRhY2tsZXRhZ3RhaWx0YWxlbnR0YWxrdGFua3RhcGV0YXJnZXR0YXNrdGFzdGV0YXR0b290YXhpdGVhY2h0ZWFtdGVsbHRlbnRlbmFudHRlbm5pc3RlbnR0ZXJtdGVzdHRleHR0aGFua3RoYXR0aGVtZXRoZW50aGVvcnl0aGVyZXRoZXl0aGluZ3RoaXN0aG91Z2h0dGhyZWV0aHJpdmV0aHJvd3RodW1idGh1bmRlcnRpY2tldHRpZGV0aWdlcnRpbHR0aW1iZXJ0aW1ldGlueXRpcHRpcmVkdGlzc3VldGl0bGV0b2FzdHRvYmFjY290b2RheXRvZGRsZXJ0b2V0b2dldGhlcnRvaWxldHRva2VudG9tYXRvdG9tb3Jyb3d0b25ldG9uZ3VldG9uaWdodHRvb2x0b290aHRvcHRvcGljdG9wcGxldG9yY2h0b3JuYWRvdG9ydG9pc2V0b3NzdG90YWx0b3VyaXN0dG93YXJkdG93ZXJ0b3dudG95dHJhY2t0cmFkZXRyYWZmaWN0cmFnaWN0cmFpbnRyYW5zZmVydHJhcHRyYXNodHJhdmVsdHJheXRyZWF0dHJlZXRyZW5kdHJpYWx0cmliZXRyaWNrdHJpZ2dlcnRyaW10cmlwdHJvcGh5dHJvdWJsZXRydWNrdHJ1ZXRydWx5dHJ1bXBldHRydXN0dHJ1dGh0cnl0dWJldHVpdGlvbnR1bWJsZXR1bmF0dW5uZWx0dXJrZXl0dXJudHVydGxldHdlbHZldHdlbnR5dHdpY2V0d2ludHdpc3R0d290eXBldHlwaWNhbHVnbHl1bWJyZWxsYXVuYWJsZXVuYXdhcmV1bmNsZXVuY292ZXJ1bmRlcnVuZG91bmZhaXJ1bmZvbGR1bmhhcHB5dW5pZm9ybXVuaXF1ZXVuaXR1bml2ZXJzZXVua25vd251bmxvY2t1bnRpbHVudXN1YWx1bnZlaWx1cGRhdGV1cGdyYWRldXBob2xkdXBvbnVwcGVydXBzZXR1cmJhbnVyZ2V1c2FnZXVzZXVzZWR1c2VmdWx1c2VsZXNzdXN1YWx1dGlsaXR5dmFjYW50dmFjdXVtdmFndWV2YWxpZHZhbGxleXZhbHZldmFudmFuaXNodmFwb3J2YXJpb3VzdmFzdHZhdWx0dmVoaWNsZXZlbHZldHZlbmRvcnZlbnR1cmV2ZW51ZXZlcmJ2ZXJpZnl2ZXJzaW9udmVyeXZlc3NlbHZldGVyYW52aWFibGV2aWJyYW50dmljaW91c3ZpY3Rvcnl2aWRlb3ZpZXd2aWxsYWdldmludGFnZXZpb2xpbnZpcnR1YWx2aXJ1c3Zpc2F2aXNpdHZpc3VhbHZpdGFsdml2aWR2b2NhbHZvaWNldm9pZHZvbGNhbm92b2x1bWV2b3Rldm95YWdld2FnZXdhZ29ud2FpdHdhbGt3YWxsd2FsbnV0d2FudHdhcmZhcmV3YXJtd2Fycmlvcndhc2h3YXNwd2FzdGV3YXRlcndhdmV3YXl3ZWFsdGh3ZWFwb253ZWFyd2Vhc2Vsd2VhdGhlcndlYndlZGRpbmd3ZWVrZW5kd2VpcmR3ZWxjb21ld2VzdHdldHdoYWxld2hhdHdoZWF0d2hlZWx3aGVud2hlcmV3aGlwd2hpc3BlcndpZGV3aWR0aHdpZmV3aWxkd2lsbHdpbndpbmRvd3dpbmV3aW5nd2lua3dpbm5lcndpbnRlcndpcmV3aXNkb213aXNld2lzaHdpdG5lc3N3b2xmd29tYW53b25kZXJ3b29kd29vbHdvcmR3b3Jrd29ybGR3b3JyeXdvcnRod3JhcHdyZWNrd3Jlc3RsZXdyaXN0d3JpdGV3cm9uZ3lhcmR5ZWFyeWVsbG93eW91eW91bmd5b3V0aHplYnJhemVyb3pvbmV6b2/UCxAABwAAANsLEAAHAAAA4gsQAAQAAADmCxAABQAAAOsLEAAFAAAA8AsQAAYAAAD2CxAABgAAAPwLEAAIAAAABAwQAAYAAAAKDBAABQAAAA8MEAAGAAAAFQwQAAgAAAAdDBAABwAAACQMEAAGAAAAKgwQAAcAAAAxDBAABAAAADUMEAAIAAAAPQwQAAcAAABEDBAABgAAAEoMEAADAAAATQwQAAYAAABTDBAABQAAAFgMEAAHAAAAXwwQAAYAAABlDBAABQAAAGoMEAADAAAAbQwQAAYAAABzDBAABwAAAHoMEAAGAAAAgAwQAAUAAACFDBAABQAAAIoMEAAHAAAAkQwQAAYAAACXDBAABwAA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AGEREAAEAAAAZREQAAQAAABpERAABgAAAG8REAAEAAAAcxEQAAMAAAB2ERAABQAAAHsREAAGAAAAgREQAAUAAACGERAABgAAAIwREAAFAAAAkREQAAYAAACXERAABgAAAJ0REAAHAAAApBEQAAcAAACrERAABwAAALIREAADAAAAtREQAAYAAAC7ERAABAAAAL8REAAFAAAAxBEQAAYAAADKERAABQAAAM8REAAEAAAA0xEQAAQAAADXERAABAAAANsREAAGAAAA4REQAAYAAADnERAABgAAAO0REAADAAAA8BEQAAcAAAD3ERAABQAAAPwREAAIAAAABBIQAAYAAAAKEhAABgAAABASEAAFAAAAFRIQAAcAAAAcEhAABAAAACASEAAHAAAAJxIQAAYAAAAtEhAABgAAADMSEAAGAAAAORIQAAcAAABAEhAABgAAAEYSEAAHAAAATRIQAAUAAABSEhAABQAAAFcSEAAIAAAAXxIQAAYAAABlEhAABQAAAGoSEAAHAAAAcRIQAAYAAAB3EhAABQAAAHwSEAAEAAAAgBIQAAUAAACFEhAABQAAAIoSEAAGAAAAkBIQAAQAAACUEhAABgAAAJoSEAAFAAAAnxIQAAcAAACmEhAABQAAAKsSEAAFAAAAsBIQAAcAAAC3EhAABgAAAL0SEAAGAAAAwxIQAAcAAADKEhAABwAAANESEAAFAAAA1hIQAAUAAADbEhAABQAAAOASEAAIAAAA6BIQAAYAAADuEhAABwAAAPUSEAAEAAAA+RIQAAUAAAD+EhAABQAAAAMTEAAEAAAABxMQAAcAAAAOExAABAAAABITEAAEAAAAFhMQAAUAAAAbExAABQAAACATEAAGAAAAJhMQAAUAAAArExAABgAAADETEAAFAAAANhMQAAUAAAA7ExAABgAAAEETEAAEAAAARRMQAAUAAABKExAABAAAAE4TEAAFAAAAUxMQAAUAAABYExAABQAAAF0TEAAFAAAAYhMQAAQAAABmExAABQAAAGsTEAAHAAAAchMQAAYAAAB4ExAABQAAAH0TEAAFAAAAghMQAAcAAACJExAABAAAAI0TEAAGAAAAkxMQAAQAAACXExAABAAAAJsTEAAHAAAAohMQAAUAAACnExAABgAAAK0TEAAHAAAAtBMQAAQAAAC4ExAABwAAAL8TEAAFAAAAxBMQ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ACgAAAApAAAAEAAAAAQAAAAqAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcaW90YS1jcnlwdG8tMC44LjBcc3JjXGtleXNcYmlwMzkucnMAAHx3EABiAAAAWwAAAB4AAAB8dxAAYgAAAGgAAAAnAAAAfHcQAGIAAABzAAAAJwAAAHx3EABiAAAAewAAACEAAAB8dxAAYgAAAHgAAAAjAAAAQ2hlY2tzdW1NaXNtYXRjaE5vU3VjaFdvcmQAACsAAAAEAAAABAAAACwAAABJbnZhbGlkRW50cm9weUNvdW50AC0AAAAEAAAABAAAAC4AAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlZWQyNTUxOSBzZWVkQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcaW90YS1jcnlwdG8tMC44LjBcc3JjXGtleXNcc2xpcDEwLnJzAAC3eBAAYwAAAEMAAAAMAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcaW90YS1jcnlwdG8tMC44LjBcc3JjXGhhc2hlc1xzaGEucnMAACx5EABiAAAAEAAAAAwAAABnZXRyYW5kb206OmdldHJhbmRvbUM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGhtYWMtMC4xMS4wXHNyY1xsaWIucnMAAAC0eRAAVQAAAJMAAAARAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcaW90YS1jcnlwdG8tMC44LjBcc3JjXG1hY3NcaG1hYy5ycwAAABx6EABhAAAAHgAAAAkAAABTb21lLwAAAAQAAAAEAAAAMAAAAE5vbmVDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1x0aW55dmVjLTEuNS4xXHNyY1xhcnJheXZlYy5yc6h6EABcAAAApQAAAAoAAABTeXN0ZW1FcnJvcmNhbGwAMQAAAAQAAAAEAAAAMgAAAHJhd19vc19lcnJvcjMAAAAEAAAABAAAADQAAABJbnZhbGlkQXJndW1lbnRFcnJvcmFsZ2V4cGVjdGVkUHJpdmF0ZUtleUVycm9yQ29udmVydEVycm9yZnJvbXRvQ2lwaGVyRXJyb3JCdWZmZXJTaXplbmFtZW5lZWRzAAA1AAAABAAAAAQAAAAuAAAAaGFzbW5lbW9uaWNDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xpb3RhLWNyeXB0by0wLjguMFxzcmNca2V5c1xiaXAzOS5ycwAAAMt7EABiAAAAGwAAAFQAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlADYAAAAUAAAABAAAACgAAAAvcnVzdGMvNzc3YmI4NmJjZGJjNTY4YmU3Y2ZmNmVlZWFhZjgxYTg5YjRhYTUwYi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAfHwQAEoAAABABAAAIgAAAHx8EABKAAAAXAQAABUAAAB8fBAASgAAAGoEAAAeAAAAfHwQAEoAAABzBAAAGAAAAHx8EABKAAAAdAQAABkAAAB8fBAASgAAAHcEAAAaAAAAfHwQAEoAAAB9BAAADQAAAHx8EABKAAAAfgQAABIAAAAEAAAAAAAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGhtYWMtMC4xMS4wXHNyY1xsaWIucnMAAABQfRAAVQAAAJMAAAARAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcdW5pY29kZS1ub3JtYWxpemF0aW9uLTAuMS4xOVxzcmNcZGVjb21wb3NlLnJzuH0QAGwAAABNAAAACQAAALh9EABsAAAAVgAAAB4AAAC4fRAAbAAAAFYAAAANAAAAuH0QAGwAAACPAAAAFwAAAG5vbi16ZXJvIGl0ZXJhdGlvbiBjb3VudFBCS0RGMi1ITUFDLVNIQTUxMkM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHRpbnl2ZWMtMS41LjFcc3JjXGFycmF5dmVjLnJzAACOfhAAXAAAAJ0AAAAGAAAAjn4QAFwAAAClAAAACgAAAAEAAAAAAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcZWQyNTUxOS16ZWJyYS0yLjIuMFxzcmNcc2lnbmluZ19rZXkucnMAAAAUfxAAZQAAAFAAAAAeAAAAFH8QAGUAAABaAAAAGAAAAAAAAAByO4z1xpMMAPYlw4Fx3wgAtkw+Cwv1CAAxTKSFkzIFAEs9o9P5fAgAPpFA1wU5AACic9YXKLoAAHzm9CcoPgIANBrC4NIzAQCBjyn50k8EAGiqeocFEgEAedWTWJV5BACgZ5swZg0FAO7lvg0t1AIAxvCJthfxBgDXcTyT/OcMAEOytv5BzwIAdhp9ChxYBwDwMk1TLRcHANKH+mPAkAUAqNW0QmClAQBT0Z4VzIkBAASuPKreuAUA2LURT/CqAgCSnGZaWbsGAF96m6WzqAIAfwjvWbOrAwCvBdvEqPUEAAVC0AeouQUAUOoTW68BBwAwl+5MqLAFAORVcckQHQYAEGoJyJwFBABPAaiNYHoMAA6oueFkoQcAZdL8pOgfAQDMqk83uLwHAE9N7/RaLwUAEI35mEAxBQC9VXVYkasCAInY0A0/kwYAlUJMu4ZDBACMUGIxbcsDAMaicrhoYwIAmyvxaoKiBQCfCfyOuVEDAA4Fp6S/jwYAG5edlUkqBAD9nkYa5ZMDAFgeMhDpgAYAvxhoBQoFBgC/MlUfzCoGACX6ycxBgQIAg+Zx9GFNAgBaRMf0M3kCAAn/dsTp+wMAQksumGuvAADleLpREq0AAIh87u2uFQcAUzX2y9D5BwAgu6UIRLwCAEJUoN3reAgAIkE1ErH/CgAshvWN7nULAB9uFM9clAoAutZHpMOCAQDy7zblZCkCAFMAVB+CkgEAXI54nvH5AgC1sT7np1QBAIWCKoHx2wMAl5c/uhf6AAAgOJy0nPYGAI2Fsw1aTQMAu7OW5qs6BAAxcRV36+4EAEEH8RUZIAEAVpxs2pxmCQBsNNsywF4EAMMsartXHgUApIx9e7YGAAAzKedE+oQAAIpvXeVOFQEAkHMuhF1CBAAX5BrEZIsDAHFL6gJnMgQAtTBgNzRoAACAw/kSBe8AAIQlUfKp8QAA1vCpkY4LAQC/o06U0FwKAGJNGrhzVgcA1MDRJblQCQATQSnZOD8JAMiDkqa+YQQAsSEyqposBwBN93REd2cCAIWAsumwZAAAySc79U7wAwAx5dLV7dYBAKKzuAHIbQMAMF6T1KfgAAB9DczOt94BACzdIE6pUwAA+aDGsfupBwB8Pt0EZlkPADWLBQ5R/A4ADMyyjQxnAwAvM86Z2JcCAM4bBnZekQgA2TSS8+1dBwBUPB+rNhwAANr1WO6P8AAAN9agE5bhAADgIBNKAqkDABqRosnZ9QEA+Pz6lHkRBwDFjeLKqNgCAIcMCbKxSgcAxOzCxQdpAgAdnC9jDt0EANmlIibRzgoA2UJHYemNCQDTtdtvqZwHAO4AmtQ33QYAXlGqSVRjAwCrXUfQeOEDABKXoRJHCwUArfQPhsLcAgAxPfDWdg0DAMfkBiEXRAQAiC3tr1ESAABaT+2b/DQFADRSzzla2AUAZOgScWkMAQDyx1iDoCoGAJThSAhEbwQAK/WocbdHBAAd02kyuncDAIBQ9br5OwgA3l++fSfEAwCSTNSvNaMFAD51mUAWwQAAI+RvAIcEBwBv1r7KYV4CAARmWMwo4QMA4sePLouWBQDPYb3Vo0kAAOb2HltQFgEAblg0htdmBQC9L1rGhUINAB90+MxiXgUARJCxYblrDAA4IHEFNBUJADp5NF+6TwkANAjBnJ+kBwDGIop4E7UCAFs58m5L/wUAvwf2Wo7sAgDD7KW8dTkDANT3hWkWRgcAmucKADmZAAB6+WR5TIQFAD1b+eEXNgEAxT+ozilIAQCl7HFOLwsHADxk/I4UKAcAdluZAz51CABmZ6uyX78NANY1RbzDXwgAwpXdl4R7AwDo/7TWSRUGADjRsS2iFwIAnrAuBs+5AABY9+VxnP0CAN3er1KuswAAl+QZZqedAQCOVdJUBvoGANRBXtIZggcAUcZ1dHZzAwCQZSQUy5UIAGespirYAggAUEi8g/FCDABDBgocT0YGAAcJcwVZvwYA2a3RQP2ZAgD35QSa3vIFAFkczLruwAcACin4saHMBACPscNW6vsBAIpbQeHxeAcA9MHvdFj3BgB/AhlAaYoCAE3ca6k3KwUANaZnzyElAADRXi93IGcEACLWWfPAMgYAUuKjKwmyAgCAJhF8JWIOANV8nz11AQgAlFKdCgvuBwAnykzr+4EDAJ1jPjofhAcAX0TDMOp2BgCCE+enAPoDADTbPZYtIwEAjQcL55JWAwAfencUykcCAND86GtV2wYAjgT64l8rAQCSHm+tJnwLAOR7InEJagQATJstDS9yBAA64E4gRtwDAGx5IDzp9wYATeP8lsT7AAA+rn1rvnUFAAnmzoUVowQA/zA5Auk3AAAS+5Zvt0kHAAWupq4E9gIA6yOTk9w3BgBHjQSbrf0DAPdaBNSwqAAAAh7wEOz8AABFTiTEndICAL5HwRt7kgYAOQisNIUwCABAPwNkNoUEAKv+ZpF3EwQARB7+SaZYBQCJzO+uNUYEALryh0hD/wEARC0OIoH5AABRPBinGpAEAPD4GoxUtwEAFoE2U4yEBwDpPTjnZBsAAI98WLD7CQEA0Sa3h7gbBACbkWZ8WUwLAMMPmbZQoQcAdCKSnesrBQAahmRx7Q4HAKnGcOBxqAgAvkZDdER9AAAdqGSltoICAGsjdfiA7QQAUAxFHb77BgDb/BKMcusEAImJvEuZtQEAYAZMqHtLBwC4rs3xeFYHAAzx1rAGMgIAXWjyAHPuAwAYdR6ER3kKAH7o2ohzLAsA6BuX060UBADxDi+DUBgIAIj7LGp81AcAt9Z9nuRVAgC6ntVjIYwDAEVYACofhgMAya7LTB7hAgASeSl2FTgBAODW8I4U0AIA+4fnjSpSAwDS+XReBe4CABMIMfY4QAYAnkzTWM9IAQBadeSafS8HAEr8D2kecQ8AFQ1bNaKCDQCztoXoz9wIAOnq1Lr+eAoAJ/A0efaSBADUKFWB0N4HABJmGlFhhAUARBXeUC7qBQDb1euhL/8DAGY5k4wfaAIANRaTIQWEAwBShjBK8XQGAJBIqYicvQMAxukv0E0QBAClagnbBk4JACOw5omcIQkA2qKG1Kt4CgAflWCSskAKAMnvSFpbFggAKkIkEV6/AgBWrlZnFHMGADDoh5rZSgEA/YCwZcrqAQD1+gqwY8gCAHZqhKB0pAAAMh6Y76WZAADmv0s8rqgCACyDFK80XAQA7P+bfbaRBQBdtRifcbMJADbTg4wxVAcAl5eRtxd8CgBgmwiEsEUJAAADZ/i0iQQA+pu0gBwNBwAlRpF9ftUDAEXlZSFywAMAT+AZOLnlBQD3qHzsAt4DAO+S6zotEAIARjoM1SKMBgBOiYWTqC4EAIzzVb+eXwcAy5aku1+fBAAbV5wejGIFAKsi6AixmAUAGjYpro9dBQAoe6nRyK0IAHSGKGwaaggA1M9bihCaBAASZn2OjBcGAHUDcXM08AEAmGBKYUk6BwCmv9yGSmAFALZkF3zU0QAAUS5qMQgcAABFUMlF27MCAAwwjYFPYwEAdOKf6IkJAgAb7OqFiycMAM3ie2VZ7wgAb4dYadEvDwAvCyYFsukKAFhwD5W5MA8Af8wtOv13BwAySRL7qZQFAPAVyoCOHwAAaTLsPNEUBwBnytDRPkAAAFLFToc1LQMAKbnxjQTzAQAjmxc71wADAAt9o+V75gYAA4MwVHS9BQAqeecVIZMMALcwubu5VwQAJjIZi12PBgBW1B6PThYEAH8GI7F9uwUAwkyyKJXRAgDzLzC4ZqwEAFGt/dnIAQcAJzdbXLPBBgAKOAeApzMBAL5iysZn9AEALMFdKiPEAgCHsBPAHVUHAM07sBEMaQAADo/VptxABwA8Q3gEV4wCAGOkcyhQ2AEAnNTefh5kBwBx9UzV7ewBALDCVlI/wAIATs7PUgfuAADp+xaB3WAGAOv/DxNnUQUAXJWFuILGAQDqY6lf0mEBAH2kU3t1GAcAIS8Pi+EZBgAE7MHk3/sFAJK7HsiY1wUAa9nbi0aZBgA1Galq5j0NABqbWRr4RQgAkkEhvaj3CwAZMxKkTR0HAKLE5sThkwoAz/7a9EYvBwCj9976j5QCAAS88/3NHgEAJe3+j+nCAwAFOUeaISUFAOESUZJLEwYA7Qa0K5S7BgDi3cBFxHAAAKPXxCLYEQQAMvBHxAW2BQA58Ofwxv4JAHxHLGm8zgMAXqkZaph3CAAOi3ehquoGAKvFTO8v8QoAiXzEIFmABQAsl/lxR5IBAEDAn9+9iwMAgbKSAAD3AQDriurcdkoCAEDHwN+yIgUASOGANBnoBwC5QUOg2T8DALwgimdjyAMAQ4pRsgfmBQABz5alHEMMAAQUgHzaFQgAtBCPb5s8CAAWQJMiaTQIAFbkOTHzAQoAGBjfbI8dAwAWSxRLbPgBAJ0+17h1mAMAs6f/2fD7AgDdzLbKegYFAFGdAwhrfwIAqt8AgC+ABAAlxWKgkpYAABdYB5HqugEAYCSGqMuXAwDneRPI+8MFAAIvXiW8GwQAUIaZVvejDgBBfODUfykJABseLAK0cQcAsllZ8JMwAQAYxi4vNb0BAIbqiJt4dQAAuUjqFxEdBgDmZgcynTMCAKcvOlGG2QUADxvhmTo/BgBtstbPDooCAI+N4TVoOwUAcZkhiaExAwCccnWdOi8JAMnEU+kADQkAiS9vEd8DBgCI4OB2wj0DAJpk/xmWrAkAxoBP+0VvBgCi/rnuOMwDAB/bcHJkBwEAyA106vEQBwDfO7jGZxEDAGgQS1JCOAMARf4wndN9BwDQoEEhQ4kBACXCuE7+iAAAi/BBY0MSBgAlJi0a40kDAGyxpn96EwgA2353kq6BDgBQ3PjFvyICAJCNF6MqUgkAjYlOh9tBBQAzG4T7gC0GAJf6J/BuPgAA6DOWnjygBwDv5Qkjvm4EADhJYWlTLwAAhwWireVWAwAC+WufyBsBANvIGWR0NgAAQ1JQD+dfBAB+FJXIIEkKAF1MlGHsBwkAHsAX4FInBwB66aLdtyIJAKFX2/YZZgkAjAsMlqZ1AABJG+TF4d0GAEGjbVE/LgQAnueo/QNqAQA5Djpi0SgEAP0IowFESgcACYFVudRuAABniKD28UYHACEjb1xvYwQA0wvWkhXYAQDVxYV7n7YNAOtQVhctegkAncG/bT7MBAAOvnM4HT4HAPgKG9X2pQsAX6wNplaHBgAm7Ip7dV0FAL2AX/Q9OAMAppafjD94BgDNnninNAICAFKyeHG2DQIA2g4s2qM6BwDTcBzARZAHAFkQJRV7swEA/s9TI2jNBwDg9KxoYM0FAMx0evyaBwsAs2QLZZeABQCZTpysq38EAM2yslMC7wsAtvqH2FukAQB8wW0HSFcGAKgRqgCAuQUAdAkIyeyhBADAvWOIjIMCADBQRkrPsAMALXr1rrgiAACtJel3Bq0CAHpF12dBCQQAgmpgissdAgC6MXe++gANAFAzEcNTzAcAgQ0I/mXPBwChGwFm2cUDAPbG9ttA2AUAyJ+djEYEAACMa3lUhdoFACUAlXC+uAMACaamLYnVBgAxShkIPbwAAIvhnzANOAYADe64LDzXBAC2wLqtgrgGAL5M3d2rbgMAGawyYiekAwC4fkTbcsEIAH6ntwXF+AMAED9/+VeoBgA64H9WwPwMABlOgp4MdwgA+oRwiixDAgBoqag893sEAGcoJnaRYwEAzhCAT9/oBQDeFup8F/8BAP21tUWa2QEA7JkkT2cjBQATJhgm+vgAAJiMBJhzjwUAABXUTyafAwDOewn+q0oLADI6JQP8OwwA8reR/sebAgAWSoTkYacIAF7DchJiXA4AnOLn2xc0BQD1lHOCc0UFAN1Q9qbuZQUASceNdFAgBACJiEZzLXEBAN2TMc74iQMA5XwXuCTUAgDNQDQN+nMAAJee1AwCOQEAzhmrAJgvAgCZ/W6a3Z8KAD8oKKmUxgcAOkvk7s33BgDDXLIHMloFAIxZOE0aFwwAy/iePoo2AgALrOIIqlQEAACnjz+SkAQAL1iknqpyAwBiR9ZsQT8BAIxMyZmqWAcARP8AFwD2BQC9AYxITmkHANbuSOn91QAAvXSlTyEIBQDDA9BTuxUKAMKoLHmeFwkAoUDIaumgAQC2OrvikyMKAMqGTIp1pwsAS/7WPhVpAgBAmPiuIyoHAJxpmVK+UgAAFiMT7+WlAwC6+sYOli8CAHZQrpP2EQEAkMqUqr/jAwCHuHaUeUUEAHlIRhIJSgIAf974Ff3ZBQALUtfuKk0EAOSnwtJlCAUAQOo4UltwCgCWO12ycGwMALh+pH8YvAsAf3JjbdMIBABiYKb2+PoFAGveqC2JuwIA5uLH8NRpBwD7+BRZ8zIDAAzChuoVAQcAqK0k2ohtAQDfKmYiBpgBAJ1aGbzrAQUA+wbpHNhQBAA/dK4cltgEAA66fYzDvQYAY7Thp7TTBwDzreLeS4QIAKpjlietywQAdVIgpqG2AwDPbdCRJ+gCAIc8qcpyPQIA9Kpoq7fwBQBFY7rUJd4CAM0f16AkkAEAGhBfEWVfAQAIlxRnkOkEAK+ly9HYGQEAByD+zvvXBwCUkMLzxV0MAK55tSBSRQsAiQYeY8FwCAAgmw5jwGsKAIzNbRnN+QQAAShrJmoeBwBd3+JzrpoAAKOxGbLYDQQADd4XRftGBQB1e+g1VJcFAGg3e2rYlwIAMmNML1qDBABgQUNfMHAAAK5WTgHdgwEAoIdDCN3MBwCAzGBnGIQEAGEzU2VWQwcAAbg2Y2gvCAAwQ/ZGVCINAAsZSKg8WQsAFwQmbSxCBgCUuxdIkBICAPVUuN4ZowUAfdpg4NSpBwAMHdYOvSgEAKeahF6aGAMAQrJZH7usBgAMY1NH7/YHAKktKilG8wEA1qKNMJhzAgBTJHAKTA4JADPXe6Ov2gQAYYk+3GufDADl2uzc//4BAMOSVJTCcgUAE9ReQyiNAwBYKJkZTwYEAM1D9b4PaAcAPI3Vg92qAQDD6Ot6WWkCAL4wzdZFxwcA73jfVXd8AgCjf5MzaHcBAFUYRBZRQAUAvAWMSYX5BwBQY78PUhUOAGnadL/puQgAaBEgCIP+DABC3idh93MJALBpzVMmDwsAF+ELn4jOAQAJB1GUam8DALQWAHJI8gcAkc/h0R6CAQAfo3DELmwHAIUMwao4yQAAQXF57WQbBABtXhjBsb4BAAcPYJBU7QEAR5YVPyfxAgDAC6dV14sIAAjmXIg6ngQA1lobiIVlCQBdT9NodcIDAF/cfpnBigMAER7ginz8AQDn6HNVTQkCANJJ9bs8ygUAQ0HF7CD5BAC2ha1y5dkFADuxUacXtQYAzICxcNPPAAAa9NEleTcFAKIIYFZWTgMAnv7L2fwtAgCO4DsQtFkEAN0qLT9LmgUA6467yDTXBwAJSlm+PDkCAN5MgneY/ggA2QwNw+DSAwC7cWZol/UDAJk5tn5YqgAAGcaStcfjAACMRAVskbIGADuRugrRNAMA28+Btc1FAAA2jzpV4OMFALL/HgSzCwUAAP8H8wPDBADtRNkNWAMEAD9lkn33jQwA6Umz45+KAwDhrwqFieoIAGlwq1GxFgwAhYyyF9Y7AgBhWn3nLucGAN5NF/9yqQEAD8ZzY2PiAwCrsniPG9YAALA2wenv1wAA1QpkiRyrAQCXH/Sugl8FAA3tF/NXaQQAfid0r6KRAQDoDkZPQysOAPvT+sDGlAIAD0x7k2iDBgBbhxAp+MkFAEUF4NvnNwoAMRQ8xUv3BgDC2btdDsQBAJdcrpz7yAYA2rfhXFyEBADMtVDk4OIHADC0AWftdQUAJgCif+HTBABTQoyI/JEHAMGKB5m68QIAFRGbafoaBwDDUDtHHDwCAEgd4h1n5wMA6KFHVfomAwDZr1/CTQ4NAIiPx/sxBwgAHbZTOZtvBgC5zDwo9FUFAOdgGftn3QcA1P6voQdHAQAcK5wuFCEAAIAY+EgYxwAAhjwj2NlLBAAwWP6OV+gGALVBcG1bBAQAFX4089bEBABdGY+Y/N0EAOFloz4X9gQAiEWu+dpFDgA6YttjN9QHAPmIClD5iwsAyR99wc/sBwAeg4IHKMoEANbXsX0zuAcA+5U4720RBQBHfqra/ZMBAG+H6Dc8yQIA+oPFKBpDAwB52IvaSZAEABzBekCotAQA1PDrmfumBgDGI+S2tSIJANXd8d9QHgoAv3VOMnY9BwCOQZVUSIgFAF4s9Kn9NgEA61UIVrvBBgBIrRN+Eh8HAOxakASzxgUAx5uIjmt1AwCJMUqRdl8HANG9BaOx3wQAKR+BBf+zAwAu2TwoYu0GAOFS7EMVXQYAjb4QNRgiAABsejBDAXECAKvzi7SP2AMAeo/BTutJCgBeKf9dETYJAAPUH0R8OAkAFC2tXjhmBwBeCQaLTxkAAGI7gvZ4hAAACHPTiYYBBgAGuBfOcaAGAPiKl4fRwwMAunaCyOGvBwBorciB8h0FAF0kpL0GSQYA7fGqJhsXAwDRR4qy2LcNAMA0nhTuwgIAU/yaYvV2BwCpSfxQ6vQBACREM6YUxQYAqExWl5AxBwAlNSO8ToQBAOHu/UNFHQIA0hv/qietAQAIz3NI/SECAEFjFTpPIAIAZKRlQEE3BQCDz+07DDwEACCmbnB+VQUAJLlvWaqNBACAl0zIXR0GAJ7CQDDofQQA5wdlst6JCQCZR9z65tQEAKfooH+DjA0Ax5ylXGaOAgDZDZQVx2UBAJUcoTpfeAAAaYTj15h7BQCErcxv3XYGAFiQ/JaFaAEAn2ED1GpvBgDvcneoWdcEAKS+c2FuhQcAV2osP/fEAQCENHz8bnAGAG027Dl4mAYAJn/PlR9zAAC85LyOda4LAPXat61ZBAcAu6BfML1PAgDPoXXMmAoEADN1CiLhjAcAl8HhEHohBgBkv9GArJUHALMrtJFJ2wEAckOZW2BpBABYmlxx4zEGAI9yz+/P6QcAIc5IKBb+BQD1sXxdLYUBAA/lXL4PDQYAdXvjRuKhBQCQ1f8F7hoNANl3NgRMtAoAGpaU4U8hAQDL6ak5ruEAAPf5JrXIQwUAHelngEkZAQAXyW9EnXgEAI63TgerhwQAQ+OMXjvTAQBGG+ufQT4BAKTmXVYfcgIAmrvy7lIMBgARba58wsULAARulZGUagsApR0TybokCQBcKyDe97YLAGWbjSR3DQcA8Yv9O7yJBQBrQaNqPvkGAEiuwdajwAQAalgLJodVBQD8zBLDyQsBAFugwj5L6AIAURU88KKdBgB7pmFGFzoCADjyiaK8CQIAb5c6vVU3BgC3rPGXGBAHALgHe7cs2AsA9Gl3PQiEBgAHzi1HKCsNAFF8c1E3dgIAUwjRKj6gBwCrNq3G3BMCANa91UDipgEA3/74/E/CBwAWvEgczNgAAKkZtG7TAgQAUqAUjPbOBwA50cJbJfEAAGoYMdTncwMAFq2n2C0MBwAAfu24fZYEADpSL9DuWgkAu5TQkZUUBgAGcMEE8nIGAFNqgROGKwsADuxvn1CUAQCsrDHK2CgFAPq5uHNtggcAs/ngmctKAgBIOTbG+uACAGTNSOS+9wcAPA/aEA/hBADpIKu5bJMDANBs6k/8oAcApDXHFZIXBAAhzWsouTMOAJSc27qzyg4A+b3ffjhOBwDZD4rFE0MJABskYlaoHwsAKu3c1+eUAACOEY5z+mgAACvuXwpkGwQA1BnwnXC7BgCZzTBKNAAHAPQiNi5CbAIA8LUFagbzAACmgASPROIEAJXw2+DNRAIAUpkqMbJLAgBYXPj1KgwIAD6I8kyfYAgAEsqhtW7oBgDRzO+iRIsOALT+n6/S0QgAw2feMhftAAA1FilpwwgDAFDS8kjzPgMAu6GhXkcEAACI4XHo4/4AAN8eYjKhigIAOzWvTCQrBACK4MJMBmsGANO9DAIguwYAMYVxec1qAQCttod4xcYJACpZ1x/yqw0AeYZTEtQLBQBRMSdxC4ALAGCBsTTtZAEAPR2bLa9yBwBbTotEhtQGAKgYjd1YzgIAizxQZ5+EAQACk2vv4CMBAJrmLxlM2QYAD2miIlJHBQCzuIadeJMGANxp+73D9QEAPwdh/KCNBwCBOgxo8YAHAFPU/DxdowoA993HzeUFCAAjrHiAiO4GADhrMUuqVAgAasYr5ShdAQB+y1EDHg4DAIwfsXQvCgMAA97XDBKdAwCxVrLuXdICALh8JhmNRgAA+fu1qdyMAwDioSxcsLsBADOVjnUVsAMA2rdqCmE0AQAV9dF352UKAKQ5Hkz18QgARSZSlRvwAgBt3p3b2P0EAMyXuoyHVAYA/rD2jceOAwAiaqO+rjwBAGpfTuXG6wUAuA49kAQoAwANsqLbLxACAKHmXAUF5AYA0zKlNUoCBQCd8tpUkPYBANWLeg0dXQEAy56yXXKtAACFbwWbDLwHANj/+r/+HAUASfVN6btKDAAgMePXu+wHAJkjMPV19gQAVyROg7FnAgCIu3jDGa4GABLV2V57RQcA+wU9eA0oAwADGrf//K4EAB4XFQQ2NgUAZXgHCTMxAgC8rzRDRFECAOhWN4XDsAIAhioqt8u8AACWEv5QTF4NAAzD7xPdXwgA7eWAw8bACQCnYvvjHeEDAPMIkdaPZwYAyKmx6i+WBgALo7mPoqwGAJifG8q3bQUA3RhwSVifAwBrnbUKTwIEAMJjaGMx+gYAsEJ+puUKAQAx2h/wu3oCALxP5rmngAMA1OoIIS7UAgCAdVMPDXsJAC2EycBjYgkAozlFfoKrBAA610PbDTcGACO0eTq/IAwAm9LflBUTBQD+Uo3pJ6YDAGFWhUFAFQEAhIOf0HWRAQAtjYtgsnYGAEcrWxxlugAAJxBwYyOGBQDbxhnC1sQAAN5Yhv898AAAz8Cp/9JFBwBXTtMhV98GAAYMenYv8wQAIG7H6qvVCQDj4QTh6RwMANvBVL4VbggAvcjJKx5aAgDqN7DzyAQBAJhsqW9XBQQAb4fjiGroAgDPYLnOI64BAEqZMhmHXQIAbgtWO9a5BgBy1MgUKN8CAO2kCuK++wAA7HgShu2NBQCVycK2qFsDAL+FMYul3gkAvbsjzVW0BAD4g0jAGewFANUxtZamiwgAXMVm8pM3BwACO8mpiLkAANslI6MOmwAAXnzBca58AwBfSIXeOf8CAHrF78PuPgUA/S4C6Z/6AgBUgRMsx5kGAPgfvR51KgcAz0dJO2MgAQD3DxJJRzEFAFfQwPfNrwUA7Y14G+epBwCIDDuPcO8FAJOzPL4zdAgAQgBhkXiYBAByAV1/nZ0HAMSeOwGTwgMAyso5X7jCAABZTZupMF0DAPSX6VzARAEA7380iguWBAD3dF3xEdoBAK3+wBmsTwUAba/n7XPYAgBu+V1O4QIKAEu1PrwC6gIAZDWIsnWIAwDd6TpRjCkJAP8VoBg2VAgACTQ3Q2QxAgCvIjtQld4FAN/i6hsgmQYAenP/SVjbAwD6B0dlc+cCAMEjTJf0vQIAvWHSyLmzBAAovKmy6GoCAFFcFhCCBgMAedBiM0SxBAC4nFIc6VQEAM9yv8aYTAoAmdjDlGVICAA7+tejE64HAGavjkE4cAkAeh9utse3BACY2e+Fob4EAPhVEHG8+gQAOP42eJ/7AQCmLXVG9IIFAORMMiDTewEAxph4EYkUBQALQaCSTWgBAKfFeA/Z5AYAKNq8xKHCAAAyab1pSIEEALhdpJHDtwcAQbY1rBZzBQBqCekd40EGAE0xCrOppg0ARwQfb9DHBQBJOgv4cNsHAHiayD5KywYAfTmBreg7BABkbxy9WMUHAD1GltMkFQQAHRqeRGtYAQCK7UqQfvECAI48HYbS4QcAuq+gXEpAAAC+b0EqG54MAFZsMQtqHA0A2xvXnqV1DQAd7B8aAkwHAI5/blEnlQsA1kOnCgdABwCDEd3LZGsBAEPrMntLPwIAszWCpasZAwDZrdy/lWMEAJyaXRot2wcAL0KFCyCaBwAW3XGqv1UDAKp4X+p3CwAALYKeonllBwDfNLRSE7UEAGcmHNB7MgkAoMhgO9c0BAC6Q5So2uALAHaisktRLAgAFyrASX6OBgC26G80lVcEAEY1j2wwiQAA9ogva5/YBgBb4MlNODoEAEW28Yva1QMACW1qqdbeBwBNL+5PScMGANRri5yYLAAASBWWIAkWAQC6TZs2FlYIAEZvrIar7AwAsQDXhQDGCwDp/A3hPiEIAG0eSdc39goAqs/aKWkWBQCJ9jFrgpABAH1KaWdV9QQAIuWx9/QFBwCYVrwl4VEDAL579hpGmwQAljoscRVZBwANDFjvZ5oGAPzPcO84TQUA4nxu0ILxBwAPdSGOcksFACgBG5eQmgYAo2Op8kAaDQC+phKs6QsJAMRBMgTMSgwA7GgBq2SOBABPb6i4vaICAClpLWs7NAcAo+mMqgTYAQDpQ8PISn0GAHdXek+7awUAjyN8YjCSAgD71ywSGq0FAGTjUG6l3gAA1yoxyNFWBQAO6BuxVmcIAD2we34UYgwA378+dBllCgC0KmhZ/IIHAMfIjOOrlwgAgjmNDONABwD9gkZ/tMIHABzcx7iRzQUAg+X5kKd/BwAk2NHGxkYHAKQtpX6HyQEAiWGog3uzAgClDTFJrzMHAPsEHBaBXgIA6L40SuF3BQAr1029vs4GAJ8yQuTBQAsAPqnR/0cjAwDguywliUoBAAmwj0swBQcACjunYaxoAgAcvr408gYCAOjry6cDtAUANUGf8GChBwB4/Zbupw8GAMZuKU01HQUAxxY7pvXLBwAUDM+zC/UCAFrGyoWz/gEANRbK4JgTAgDuVbe0+aoIAPJErrWRawIAyLF6jYDeBgCwMFVnaacGAPeYTij7uwkA8zMrOIoFBQA+kRYYqXUBAOiKa7nN9gQA0oHayUdzAQAjWtnZPqoFAGFl2cfpdwcArMwG8FiOAgBJrCy7u0EFAOxMmYIy5gMAlejlFH6gBACbpHfEzVgLAIDkAv6IzAsAauP0t6ohBwBTmUbJjEAIAPlK2K73CgUAmfkNmMsSBADcKe7YjecFAF1XjPbfcQEASe/20l0BAgAT05HDuvADAOVb9hUB3gcAyU02ISwkBACYYKZkW7cGAIXAAgE8AwAAva5rMRqSAQCLwfPZmq0KAOqaMzgW7AUAO6hZZTtwBQAS1gVNn/oLACsGyt5JsAcA/HC4334vAgAosXfW7mkFAK+lsNw3CQMAG+p4nANYBwA6Jx70jUUGAINERDV64wMAmXvSt/1hBgDkIdYddhcDAIlhAjA8MgcAUCm8zD0JBgBLA4Rgvu4GAHuNCvcBzwYACmfGVBq0CADaVbuZS8gGAEe2mAwY4wYAbXDghYWaAwD+YybnfBYDAJdC2+wUPQYAuHD53CG+BAB6goSgHn0FAHGwKKHntgIAz111EXWyBQBlBZPChIUAAFlBb9p7jAYAe9ndmeljAwCzrkvi3EgAAOMF7JVXtwIAyW3axaS/CwAdN55lyKoJAJpvvHn5MQoAxB/uNcFDAADV8hmZHKECAM26XcJMMwYA2gC0F9qVAgCgk4a36Y4EAMbzKsxL3gEAhuujEcQfBgDALsGa0T4FAOAEuMbbCQIAkoewqb95AAAyQtWigO0JAHheKsf+DgcALYIq1FEhBADoMda267UJAAVHWbFP7wkA9A0w2lE6AAByHFYrtWcEAJDlEAKS1QQAhZZ4nnbKAAAXSGh/xzgAAOx7FlvmXgYAqVC4GdpSAAApZGVlhkAAAEyab1k5qwcAv6Ckku51BQDu16QKRbwGAKgLO3em9AwAR7wOCxskBgAVkx1PnA0MAPSC4+ehAAoAzy8YipCAAACYurcTKVMAAMOFw3jP3AMAqate3QKABgA/zRJxTj0EAMU6+epnuQUAMQpYyqxgAwBi8sbVX8YBAKvswhV/HAcA5FEmpexQAADqaOZgdjkMAPTyklanwgcA72Zsfp6yCwCZ2rxYpisHABoT+gkcFQYAnAw/Rd4aAwBoeHMH7t8DABHUp/fsEQYA9mS9bH5jAgCPxSFs7rAEAJZd8P0NXAUAXkfPnVYFBAC7mHQnXFwAAInDXdmIhQEA8ACoT/L+AQBza5cw9a8KAFmEwEha2AgA30I2luuWBwAmtsRQ7gsGAECDbP4FgAoAljGnGvtTBgD6BoPs+gcGAFRSPshe6AQA/YQFkFafAACG/JKS1EQFAIiGUjSfugcAXS20D6KEAgD+b3DZLGUDALPm3a17/QYAFvMwKUcuBwAUdirTNfYLAP0A3qzsywgANanqQRFBAwCUy/NCHhwCAAb+APDn/gkATwiBl4wgBQDSJNyhaGQBAKhAxQp4vwcAAVPXzn6mAQA6c8Lo0qkFAOX32wPaBQMAyq63mYYiAQDJa5OyIyoBAOnmaqW9oQIAQOAeBZQPAABAl68Hu5MHAP361Oy25wkAQvtgFXssCAC2X8w0ZykKAD/dJf1/ewwAsjDTwyNrBQCm0WDjCHYDAC5yyPPgCgEAN7YYttmGAACrvujHeX0AABLdCLyc+wMA/3BT2D1cBwCsGSj+Bn8EAO0VkqsG2wUAZOo1ClLDAQBGwGshQG8IALTZD5tXogsAi+x+QCYcBwALT7VK2ioHABJttsNQhwsASqPLvKZTAgAacDMEBycEAA6H+ViOCwIAzADbYcg3AwDu0HVX0MMBABrlIpRA8QYAJS3OvmuFBwAcAy+ngDMBALrzp4AQPgQABDN9LB5iAADz8NuwlhcGAPXWMpwvPA8AvX5T0Y6qBgD0OBjJkk4HAAIQyonl2AUAjYNZgsxgAADzlVvz0zgAACOpQ8J4YAUAshskkzLeAgA6vZdgfQAAAEupQgiVHQcAF9jH5RFrBAANT8u+i0cFAF0cCksFwwcAy8GDdz1YAQDHKJ3MBEcDAADysZjl3gMAnm10mBxuAQDfr5VwCwUEAFU86GSAlQQA4XqiXe+iBgCdnS7grIoCAOjwZelZJAAAMwkV02S4BwDYHujypVICAA3oZlAmlAAApWGNkQ+mAADeD/P3S0QAAAY87akNxAEAO4S9cMF5AABW0NXAUM0OALl552pgtwUAod1rIr0PBwD5HzlTHmYFALgXcw2MdgYA/2/6ZOTsBgCgYKS8QMwDAAyN+wqp4wYAKBKhvBqABQCfrDRewN4GALPBVfHlJQYAljJyby/zBADO7wUBmKwFADbuXhZhegEA1dxN4UUUBQBCpL4rq0cBACYxJfJA8gkAiE4xnt7DCABepPykpR4KAPzkhgCZLgkAUUkUO0srAADqapZ3iWgFAP2fOW4XjgEAi5O0XlzkAgApOR7zhjEBAC6733+zlgQAIT5fnUPCAwBNan7+YG4BAB1im4jv1wQA6dMFPy57BwCRsN0SnGMIALJ6zZAEGA4Ae0aXgpHzAwCsgRe+aEUHAJXgUlEZeggA3sQunMWpBwAtZXme8OkHAIYt8iLkowYAi2yDO46uAgAyrcdfeTsGAMhfnjgCjwYABnWHvPFZAADsDEEOmQQFAOKu/tDXmwAA8DLQg/7oAwAp0e/ojUwIAA0h5gZ8xgkAaRR/jzeDAQCJ0q7OUkMGAFhimolgLQoAlKJwBbkVAwDxJakI4QwGAAnJUxL27wYAsHAtDu8DAADE+pe3o1sHAJbRzXDA2wEAR0xTsY9tAQAq+oOBSQAFAHXeI8RZLwcAeXe4B02QAAC5QPlIZi0CAIY+h6GllwkAu1QaxOQHCgDP1ks7CzYFAHKv66wKJAYAnJG63dQfBgCZVrWR6dgHAGzHPEcxGwYA1jHmMZYDBwDdwftDIT4EAKCVolucdAQABl9L+kZ5AwDxUVqrxSQHAPPTnXgzVgYAQNs48tprBQCfO53BbNMIAGEi13BE7AYArqkYcD2FBgDryMJNPqoDAOXhBxWjOggA6zM19eO5AgDFBqgn160CAKMVzshVaQUADikKB0+MAQBBN9iGStIBAB/O1P9IdgQAnZ6DkZUKBgCrF4Hz1SQEAA7BEmnELAQAtK7JHSY7BABRE5Vsiz0JACljj34BwAQAxPlTnlU+BQDqbohGAbIMAD8pJF5NKwgAu3m7iBkeAwCrvLNGL7gHAEF7gs6o9wAAMHEXFljhBQB2svVcBSYDAPKN0SjLVQEAlBahnA3DAAAZMasnDgkCALZJek5iCAIA0+WagGx6AgBBaT3ECicEAKVZVtlM7QIA+Sh1sw1cDwAzkiz9vMwCAMLYAzZQIQoAiLENH83rBgB0EX1L60wHAFxP32hh1QcAitFvF3m/AAAK9k8XZ8sCANDhCzn5zQYAPSt+nFGOAACBCKXSw1MCAD0zjkRBGwIAD4lzS9+xBwCM9fgHGCIGAOWLOoGS+gMAclWNw5jaBgCPRlRV2R4IAC01XSSYhgYAJKKys+DyAgCSHCyiasUAAHiy8Tns/QUABvHH9QrJBADFj2Xyzh8GAHoYGCqFXQEAdvuatdtwAgCrks8LEtsHAIdAcV2i5wAA8NpzxPRsBAAtgUnxp24EACeECmklBw8A+nnw6TqnCAAqxmFEkt0CAMzYUK5aBgkA+eXEnu0lBQBMaGAG0iIAAGh7OXArlwcAZfnTWDmgBwC1TtG8h5MCAFcNIN8lRQQAhUPpTPnXAgC37HDBAA0GAPDY8wMFiwMAzvFkjhmaBgDtysXcNEQJAB98Zp+QxwoAdbUfnYMaBgB2u8oAOPIMAH4mvZcmWwIAvHga2eCyAgAM8swSCpkDACImH+HCQQEAIDOl+s7fAAA6SZJqnjYHAGRomBP7PwcArBP3uCsoAwDvl/J47ZwEAO8dZidwaQYA5FTbgwZCAQDQWszBb7sGAJ1mkdXIMg0AMmyoTXmvCQDSJG3Y6eAIAAcdFrSDHgMAl9GdJB69AACPViAYywsAANQwiHGx6gIA5pdpgf2WAwCKUL++YwsGAE8rBp4SxwAA/RJbQSblAQA9kif9oGEEALelcPatiwEAUNVi6/FcBQA/jPV947UOAA3GhjnzvAsA5upcg7hPDACjcY7B3pkIAJ8rprpvpQkAWD3CZRAQAQAPizOQEqoFACF0Lp5+FQMAidQXIHHqAACJcEVWpmkGAOzJnVxQawYAh1Ljhu90BwBelcBE2dEEACAr1zlMLgUAWJx5Nkg8AQCA0ItdavsEAJtYCEnjig0AEq97l02VAwDcQXRZ6hMEAFuO3IfcCwUAueGzWkZdAgBHKOwn/vgAAAZP8Nvm1gIAdjIb/IwDAwB7YzrJgG8GABHh326DNwUADSx7NQK+AgD41MhY7twGAJJhHVgy1wIA/SVHRFbdAQCHyLoIAOYHAFIYfDhcPQoApzP18V2eBwDP8MXx+eYKAC869lCkowsAfRJiM/h/BAD0sYKvOY4AAKt98i4yiAQApKGiODeXAQD3GSKRReYAACdGOdgxLwcA8QCilNJ7AADGdOIAvmUGAIs2tvHoPQQAmjo52cgYAwCF0x2rKZ4GAKxrx7OFBgMAWUjyN89lBQD5/o7CKnsNAE9ZMhykCQ0AGf7/KgNdBABO3myb5C8BAPF8MrxjFgIA3fFpTF6KAQDVoXnGxyQCAOkl+abcbgAAuHfmY4OMBgDP++Ql+gwGAE5ACXbBxAEAEYoyAv9bAADkEsUN3aAJAA/NX7+UCAkANpw/AUkpBQDHNUe6D/UJABng3nwndgUAC+DKI3ATAgDGJuuZNVoBADwrUSFyaAAA6SQIOstTAgCkoj/MuIAHAF8wTyO8igMA3gPBu4CiBwD+XWk2qJgDABqKUkGv0AMAGycmh0H/BQAtlbYT6EcLALo8HMJkaAcAqHTN20ngCQCbdJMP1rQFAAwKyrhNnQoAnduJFwwIBgAxpx7vfL4EAICAnXYN9AIAA6ZETH1fAwCWWsI9oAYBANBTMzOvCgUANbs8YZq1BAB2muHA3yMCAGTFsisefQcAy1IQpTirBACJwN1f79EHANnauevqvgcA+6ygC9NYCACPrrXqks0FANJOsGscBAsAk9VoZyUrBABPe0JZhOgCAAEHY3Y4KwAA5eoF1HhIAwCKCNwa3ZwCAEjhVtn58gIA/sFlreazBgBdnrdyCbAFAK9dTCONPQUASUCB1rsEAQBQ8X/WX5oNACo10OqYqQsAma+kX8mDCABuJgH82/oOAHGwD6LyBAoAZ+3xaDH9AAA+SnjnDbsBAHcEsnjLSwMAgiEubqKkAACnknDFjL4FAHmw6zA9OwQAAhnGpaxXAwBVJNbFcLUFAMcYHp6yDwMAkSd8sQ9XAgBHJLgLVakGACUjGgryEQUA7psj1ySTCgDDFnXDPDQLABfgHfnFQQoAdRW2LH82AgDfh03AmsMGAL3l14uV1AYAMhWKY/RmBQAwMKVettwDAKps3kApFwAAG0VnLlsEBgCz/D5GB2wFAJFu/muLcgAA3/zV7SCEAAC7EPQETsMIAGqg0MDtRAMAbU3YhlTkDgD0YzjLLk4MALcdMk9lTQgASvpig6sgBwC/2c1HQ5wCAGOEX62Y5wAA/gvLi/H+BAB2wfs+pdkAANW1vd0WwQUAz6ulu7TRBgB6U6VIitIEAJkLBFuOawUAkYlh8qSnBABLKjevkbILAJdE/igwDgYACWpPynsmCgBCskLC7hkHAA4+IhRjqQQAlV+xXwIYBwCU/nGDa40GAHzZ90hEgAMAgEJ4/mYkBAAx3c3EUBsBANb/pAhEJwAA3TTbroLTBwBdOM7JzwoEAB5bpJm7KAYAvObc5Lz0BABvC53EbmECABzmYoRd+QkAxVmRmz6tCQD4TaB1pJsHAJUVVu4sBAMAhCUk4lrOBwDj1FOxXtICAMmpm9DzqAMAjusEDWnzAADAcUvRzT8HAEGsm0R5cAYAT0ghRpy3BQCNaxXyaRAGAK8QO1cm6wAAzqnJQOeJAwAVrA5X9ngFADc5nDPyRAYALGyVt0duBgDQVR/+MkgLAGJiXV5CXAoAzrncNK6zBACfrBUaaXwEAAxAXW7gGAMAsT742SLEAwCmZZQ3RRUGAG7e1/GmBgYA5wdhxMDxBADY5fvcsSkCACcTewrGrAMAhFSRCJpTBgAGSrsU1NsEALjb8UkIkw8A78pmpMUpAwCb609UJMgGAJsB7yBT9ggAc/fSw3QfAgA6vQiNuCQAAFFBBc945gYAfHQuJzE2BADRXKxKXhwBAMbg/cqx0QYAkDowasdiBACb/zxpTsoDAP2GV9QslQMAMMPee7zKBACJ0ng/j3gHABH4swkolA0Am8L4dzKXBQBn/sU7+RAIALGsZYFJ7gcALgqcCCSWBgBzBOfIXwcAABMjHauEPgEAO5X27QvBAgDIIQM/uTkGAMOhEZHjCAUAei+RDhKQAgBDrqxk9MsBAFdhV+lzUwEAYFvIk/TtAAAAQXaE0sQHAOysBr/+/gcAAEGCevuaAwBl/edHjrQJAPkdTcUATAgAaFqbWViBBADZ1UG8df0BADxdqR/82QIAEboO8ifaBwDUGTAuuQMEAPhcRouBLwIAuAn/HZBCAwDNg8ZdWR8DAILWX3RXegMAFyarErtVAwAYc4xax9oBAGA0QtV5tgsADUC2t/y4BgCdX76DN8cGACoFjq+OUQcA9LuTdMxkBgDjdBh2lD0DABP2lheeFwAAfYbiNQWJAQDsgiETuPkAADJsfxvEWQAAkRRTBoeeBwCCtTxkR8cGAOSU1AoM4gIAdbG7cTh8BACwZlDIUF0GAHwfNlN0FgYAErOLgaNrCAAhdaqb8q8GAEiNzgLqjwAASE/scZdTBAAoyq2LMbkHAMUW4K8ZDwcAI41gsXvuBABpZFe4iQsAANDq3mh23QUASXCkC20JBAAUkSGXWScGAK7mZ4ramwIAXfd0moJzBADJAjmtOlMJAHrkEWvg3QkAdguT0b6EBwBnyLmSCsgJAExO1LRoxgYAGMR5RnXaAgBaEL4xTBYDAF/vmCusHwEAVpJ3rxpaAwA8g8SEhgcCAAyCeHohzwAAaefS5yRQBgAqqN3vtTsCAMbTMrbUnwEApPhUYBpBBwC0dbEYPeUCAPNKIFRyPgsAxMSh1de8CwAOXfYqwscEAMNYJIea7AEAbciduTKdBQCsqSJeB6wGAHEzESCSCwMAbpY4ptl/AgATuE9XNsEHAJtQogDUpAYAHJdWEHlBAABcB26G1VUGAPhN5vMrMAIA1nxcititAwBGMDlZ1JgKALeQPcv+CwMA1vg96rjZAwB5FVGWDpADAGpAGhOhGwYA8tw1tnBXAQBxlfeDzZ4FAL1/CxxG2wIAXzSBqUI6BwB5yMyfkkkCACmQlRbxoAAAejSx10+XBQCt7QgczOABABMfrfi9cwYAjr3LEANiBQDWheJ39LUGAMhsMuyR7QwA/KMDdVPWDgDUiDl20yYGAM5YNm+E7AcAQ9Y0SUOTAQBRql5EotQAAOBv54pw0AcA4cfDtkeYAwDZ2aSidnYDAMcuoh0/jwYAa3OiOYDtBgB1PEzgfmICANHnR6aQ6gYAuZkzcq/aBgCPjq2svwQDAAeLEH2RAgUAD92mbBdDCACDHSyPFdUFADvrWJ5EtQoAR74962J1AgDnCxe015ECAOGo32fK0QUAopjyYYCoAgB9YnGeTjABAP6c3GrSFAAAE2+hG2nxBwCsbvAoGOcFAPz/8AftSQMA3cLX4o1GBAC7B2P4xtgKAHIJhaFrKA4A00SEsNzpBQCyYjNUaqkJAEYy5idk2g0AnkYZlF41AwA3iuq4e4QBAHGbz4hl/gEAImvb0smxBgBLtP/G58wGAMoirN6IxgQAUgP/w3X3BgC7GeQ+YGUFAEYcxlZEVAYA8nn+qymPBQD2zQ5xv2QKAGqJJ4XFCAcAlDPF5uosDABpK+ghGzgEALSFQXKTrwYAaD7njavPBgAhvdTO7+YDAL4NUAlmBQAA34WtJHgbBwBBf0qcYncFAIioxglFAgAARGYusWppAgDYgEt/oswAAJ4RG/HBxwAA7MqwW/IBBwATwb582fYAAKOTfPuXzgwAGigRWoM5CQBVkdp6kCgHAFUJBbylIAcA7Wxh5PiwAAB1uA+1xNMBAJgB3HOW8gIA+g+D8bD0BQBA3PsryeACADVagJtDCQcAh4F/VUjsBgAsOqEbTYoAAK75C4o0dgAA70Sxy7npAADbvrFd1ZsGAL0x90dO4QYArA4nR16jCQCN33hUIm8GANPPkUHUZgsArSBX+4/UAgB336Ehf3sFAEUGuv8OVQUAMamYQGrsBQA387NOECECABSMvPJDFwQAx3OHrbCWBwCbaLtc7p8CADSHF1xmIgEAk8VrTnoWBADbj874ZSYGAFeYxRoQnQoA+5+luzvZBAAXPzeXeHsJAOy3DDczSwsAACf2diidAwCHbB3NzgEAAHV2dBEa8AcAkIGhpQ01AgBSJeK3i5MHAMzWgYbukQUAuHnqtLCdAwBCCDgPIgICAKzgQrp28gIA5t/ixm8XAQClDndJieIAAHJ7FIieVQUAMO9jbh5eCwBu/6eaEFsDAJAmT+Wj9gkAm2GcW9BsBwCVFpCwVJYGACd/txA3pQcAdYHSpx6aBwDVd8akw48AAOo0B9OZwQQAFMyayyLGBgAWAgNVCmYFAPsRnxnxaAAAkGsR0PryBAAltju3HdkMAMQSgVOCXw0A3RWYJ1rYBgD5nM2wt0AHAE6U8pUZRQsAVE6ulEGyBgCXiO39CiMCAHFQfWESNAIAm5Y1D9PVAwDvcklKSEUEAHx96p/Q/AIAKtKeaxKWAgCyBSoBcaEEACNVTceS2wEAiUJgyokLAQBb8EVavkEJAKau7IuzrQUAu/JB20b9CwA4zrW7iNQOANPwnh0tfQkAnCgYl0lHAQCrx+RniqQAAOOvS1S8DwMAiuVfMQHHAAB1e1eNhwsCAGo+PwcYrwIA/iQNQuo6AwCU//SLAJgCAB6W23GRUwMAXMY89hQiBwC2KTv0ubcFALOj7jHqSQkACBZYE3e+BACYXjlgedgKAFOhVchK8gkAk6YHU0B/AwCctvJs5uUCAFOcrmZC2AUAuVPofevkBQAcF1iM9P0FAKoFlY4yCAYAmsQdhIIhAgAHIx2JluwDAAMu8v9j8wIAOa7iOacLAAAmu4jq9SYEAMh1f+eSMAMA5xnYQDmlAQAThoFPLhMJAIxRfd6XIgcA1pCHXN6YBgAl61tUuGgCAN/+lotk0gYAfLAdrYh5BADXeuajgzIAADm5DL7HHQQABAkQZmyxAQBtxssgTKIAAIGG5O/pogQAcWKElhJeAABQRSwkyLsHALc1OxAGmg0AMiDzSn4jBwB6U7MaQiYHAIwlOF3yjAcAWkmcLbPuAgBQly93JZ4HACO/O4NH1wYASdfVFtjNBgCYNsHJAJwDAGidSDGOawYAteIQfoVzBQByFKoW6DsBAPhLrdNkGQQA/7N2ILUGAAAtCM65Fn4LALg+hVcviAkAxB/QrJ7SBwAV57VZaucKAPapYZUu3gcAHHiVneHPAAA8RRxizBIDAHwH2uasRQEAuOmc7yuRAAB2vEM0ftUEAMtepbb01AAAzjtzu7DrBwBJBSAFaroHAGkg4uTt9gQAAqbxCqmyBgAK2LJbJPMLAPxu8yD35QgAbMBgz8y5CwAlefMj44QIAMF2giyBZQQAlx7mmvz0AwAkLfrrB7wDAKDUXLVEtwMA8yFXslMlBwDTEp1Oj/0FANliECqyvgMAqMmCOwanBgDtl8Fdo6UAAO89pQYMyAMAFsuxwjJbAACCgdV6LKQMAP6eeX5myAUAoVDIdF4uCACZhk5h2/ADADBnhaRxFwsA/ahN0sxeAAAYefD9u4AFAGo8h4Y15wcAPvl33+1MBwBxtDdqVbUDAILUTeEkxQAAVsaWdEWDAgBFzbbPa60AABQksOjRdQMAM6cnnQf8BAANxYYMRIsMAIU7ypySOQkALt9M5PL4CACxpnsRMoQOADuuKwwXQQIAfy+/ibA4AQA56jT9W6AEAPVekkyRAwIAPE7g/39JBwCYr+x8ViQBALRzxAqGqwEA/6eGfCLABQB3RMK/EhsHAHUwqHOlBgAAcMhmKWH4AwAAjQQ2+vwIAIKzuzNxbgYAdlakqEJLBgDPhZpPbuoMAKB46O5XbwoA3g0qeMkMAgCzqnAwTl0GADZ3VDGOvAcAmC1Dsb+eAAA2l2d3qgQFALHvh1bVLAMAlWEvXo9EBABFA0adkWgFACcareDCNAAAo9vZQxkEBADKqmyiQ3cBAGTJ+VaRjAQA0JoejSfvBwABvaeO5QwIAAyAKRSTLQkAlszrQ7ruAAB4+JVT3YQDAHLSNRoz3wEADvdK/ewHAgBDaJcdCkIBAE9ZN9OZdwYAGGCPVEcWAABF8XhVzn8FAHEqFAwiCQAAmjUUI/m0AQCxZpikMDAHAHkmC+krRAoAzn2U2NN7BwAoIFXBVfsJAKH5Vh0Z/wUAUQkViZ0QBADLRy0tvSUCAOo754DAfAUAyx9ydRDXBgAy8adytTkCAGiQLawz1AYAM3CkMPkrBwCtDqL0rE8GACpAuaL3ZQMA81inJsUgAAB2zELwWe8JACXddknCsQMAcmKxXGYdCwBWxXDkVoYKACtgpeDPUgwAvNvYnvg0AADzjo2UjzsHAKvKI9PBhgcAUW4mqdQ7BAATU2HErCoAAN93eGSg9wAA1PCTD8zhBACQEe8mR+wHAPgS9YvVvQMAuASz17fPBAAS74mXwpkGAFC8IePqOwYANbutQMMlCwD1K+Sh4WIFANM0xMvUsQUA/nWbuGw9BABWDpBbjTMDAFMaU30yjQMAnxvVYVyyAQB1kLMiRksBACafCswVJgMA37acuRF3BQA4POkUnKYFAJnFpICJ6AYAkoUlcY/5AgDuplRPRK4KAMHF+3o5FQYA+/jzg3cNDgC5hsRfZ6oKABN2ni4G2AkAVp4PtUynBACSAWTC0TEFANJ/bJ09wAAAwRBmFc18BQBqgJ0krqYDAFp8kKmF2gIAr0zsITeyBgCiOmik09IEAO/9DofG+QcAJe+KzriYAgDeZSEK6nIKAG7QPu95gQYAHqz+wLniDAC6YxsLKe4LAHw6gHFiugYAsgz371N5AgBSxQ6uIk8FACQnLqk9nwIAGL0iDMpCAgDO1QSEiksDADUzaYO17AYATbjfv3bsAwBPoFbPlcgCAFJN1UlRNQYA4WXUvWIdBwD1Xvex2rUFAKW5vgzW4gkAVv5dF8InBQAf9Y8rip4NALFiEmIzwwEAgN940yjMAwCmjJb0QSEHAA1t22tpBwQA+/wvsnHSBQByMX8xX00HAIHK2WdU5QcADfWGMWWlBgDxLebsiLEGAHFJhDZtxgQAnX5UxLyuBAD9tVRzno0AAGjBbQt1awIAyawBHohiAQClAR3zbZYHAB2a3J29cwkAyQFtJxsHAABeAo6R2LAAAOvinqfuWwcAuE0JhCnJAwDbo5W/j9gFAN9yWP4eDwAAaiUYI4faBQBgWWOB65wFAGTHk3bzjAEA6hk70RxuAABTA1ueYq8LAOToiKDxBAoALajunPwOCQBKoy88hokNADbYqKGm8wcAI28Wb1GtAAAayFdt9WMCAMo4RjgiNAEAUAqv8R8zAQAWblIDBggDAAuAPV05RAYA/N6+PSC5AgBVo1bmjLEEACwYvGY0PwAAE+XS3g8NAwA9R7hoHpcMAJXzeZfMLAUAyFWCrgTpCwA4k/NGruwEAFgcNYRQYQwAszMS8hpNAQALnLOJGd4BAJ5vb9xpJgUAxz+MsjQ0BACZwAJCIakAAC6gua7AGQAAkteVacCiAQBEHFexy2QGALKA+jYH/wYApVyJ0qC8AwC/Acyeto4IAIzzLZHItA0ADfLCi3/qBQCvr8oW5SAJACffOECL6gQApGJdPLwxAAAeCEwP/tkHACzyZxTVPgQACdEeDMzmAQDx6NrtHWMFAALSyvEKRgUAXWXQnZG0AABMwRh9acQHAKSiu5DIMQIAykIFk+BMAgCFC/P9VaEHAPmH1OXGxgkAWdxLE+FLCgAxbzJwWUAJAPMkc4qSSQUABsEG/fWQAAD9Qx4CsasGAKAR1/q8MgIAN38EPMGlAwBtoCg8Th0EAC4a7mOnMgYATV69/0v6BgCSR7qmNf0FAOid6R1etQcAzw3sbbaRBAChZNrQjkoIAL1uCUX87A0AsYi0k+7tDQCOvFEawbMFABhwC4trzwQApzLqxz2xBQAeE3Pbwo8BAONXjx9l4wcAZalfBVZWAgDuhQyNM48AAL1zGpkhqAMAcFiPQeY7AADwnqyOwd0BAMKNmZ7gTAUAeLAuqNQwBQCLv5psRXMJAKwNEBUgiQcAy/6VQOE+AwBkCXrWla0GAPvLAH4+2wgAJUj54TA2BAAJQGtqldEEAOC1+C3+EwIA5pERpONcAAB3AfFTp14GAGNjCeI+/AYArGdtuTbsBwCxWAdq7BAFAAkhAt+H7QAAGh6SwU4qAABMec/xYmEIALhe/srdJAsAFzJG4NUYCACNQpKQi+cHAGfA3rUSbQsAorgkO5olBgCcCxf0tYgBAOtd4d7AgQYARXTzZebfBACAJxHFQ9EDAFdFFXmRJwUATUJBB4+fAwA9klezbl4EAG90216bLAQAgrqFeFHvAgBRL1sw+78GAN0S17ISsQUA4uRPl3RXAwCj45Z6+EoIAJ+zCyloeQUA3K5YjE6XBwDGiDQIfnUHAIu85yrGAQYAdKvswnBTBAA6FKuPt/ECAAHhIApDuAIA4/6IHZ6kAQCWTc5Hu4sDADfUhLrn8AEAqsJd40PcBwAYlz4nXCoIAE6Lst/JKwsAGdvV+PSNBACPAmyXh0wFAFAt2IH7RAAAw9l9iGVmBgCysGoKdikGAGw+JMfmgQQAd/xGcOOXAADMWGcBcu8HANnjB6nFGAcAOzhrjMm5AwDczF4l7QYAAFmaIjhllwYADcP5I5j3BwC6h/Vo8B8EAFPNGxkKwAkAJJ4gnG+1BwC+qsxfHngLAGzAMQSbSgYA6BO1oznSBABmEBv1I5cCAMPZBM/0QgYAepugWgnaBABNeD034KQAABkpfVuh1gMA1qVGUKcaBADa08IedZEGAMQhZ6s4NgIAg+Gs0KdxAAAxROEgUjUEAIE5KCo24QAAVJY12Hx1CgCPDbF6zekKAHQXds+bxgcAC7qHyKotBwBg2l2s9LcAAKSYBCzavQMAYAEYqmdOBwCnbhTHvMMCAF8p6ATr1wAA/qBvHuqlBABgbENcY14EAIvR1Kj0jgIAyioyp6n1BgCrRNmj69QJAOTc8xUPEAgAJHg2DnAaBgAjPauSIpIFANPoDmi5KggAxcZBLwwAAQB0cXPfnyEAAOd9En9yFAMAHrgjfSflBwB6FC4a4pQEAJoN5d2FigQA9D1JNPfBAQCJaIZk23sEAOyOjwR9mgUAa6S+bNe1BgAiJXgeF0EBAB982iZtgAYAuZrHGx3zAwBoUZ9FIJ8IANI9wGm4bwEAlNkM7GxVBwAKUbcDmusFAHHLkd3RCgUAR4q0gFeqAQB3Umg/M64AAGIJtjOXGQYAEWUmfBWbBgDK8ZP4QEcGAIT2+wikOgAADfe4OB74AwARyBdfNX8LAFqBNFPoeggAjuTS3avjBwDlRR++6h4GAO3NNC0+rQgA/q/ZfswPAQDyb+mwjCQEAOJyUREcMQQAJWm/HNTJBABQTxD8EAUFAJ0kbjPFDwQA4S37OWY4AwB4e9Fx+LsHAASAfmt5XwcAoQ+/WMEnAQB0uVGuxI8KANPb0r+JbgoAzmV2oCLhDADCBTQgscoHAH0WnUeC7QQAonmYLkJ8AQDD/shGWYoCAHcrkS6zOgUApeCfoE20BwD0ftCH71QDAHXZxWAitQMA3B8XNmidBwC71EDxlNkHAFQYVgTEtgEAklMgLdkCAwBk8eDktm8EALdlUq2XNAUA/IYToNvrCQA7arMMLzAIAGxC6/XF7QgAPSikvKLBAwACL7vHMDQCAMKLtRvqowEAYVzeY1cmBwDK8XY7XQ4BAGeO2lPWvwMAiirIPpWEBQB7cKePKF4FAIEdk8NfOQUAy2ETxUZbBADR43+K3U0NANIZxkHMzgoAkE2sYmU6DADYvaespe8MACEh867AwQ0AoX9PMb8qAAAoFYqe0ZEDAMdfiRP6ogYAkaXq3Y6dAAC33Db6excCAI/befq8GwAA4WY260vYAwAEIoEdkgwCAM4yOz2E3QIAq9iHk2GuBACD+1uYRH4JACHMJsYyTg0AF4HzL0GWCABpJBrWQbIOAEK65auFVgcALqNEU6r2AwC7EQ9og5YGAKoj9oE1TAAApct1WK8BBwDze7GRDaABALLyYeszCQYA0k0q6T8ZBQA+9FClldkDAD2IOrlvVQMADjtim1I1AQDrgy7ivBYHALg+uDABPQMArK/QuiqVCACJG9NO9gkDAApZUaAulw0AGNXRrdfbAAAeI+Ij+BkBAOJ9Xm7WUQQAOPhwmcMABQCjXKaBW5sHABF4j9wgrAQA+gH1qYmVAgBKa2rSENgEAFmylg3g7QUA8wVZyen3BADrmVI1PUQIADjuWn19mwsA6zQvmlGSBgB4zyRJQOQOAEkUSuwulAkALjCBV7xLBwBM7IG7NTEHADxIYRtn7wcAKdfMFEYmBwA45pKtkxkDAJJJI64ZUwQAtU/SR50hAgD2bLCIRPAEABJKcp6qOgUAnO8UU6agAgAneRw8zRoOAOV5h7dGiwUA8nq+rJo2CwDTdDB0sAkFAKHetjncVQgAwif593+TBwC2pcYU+sIAAHzQbdu9VgUACNF5waz2BgDCR4Yhbs8EALZbjcJ8IgEAI3b1v+mOBwA6iR8ksowCAHJnPB5UWwIAogpxB6MhAQDJg3THPnEJAMr61XIF9wYAgf8iTvNeCgCHERRPlE0NANLOppS7JwUAl0oDn15dAwCbvIWXBiYBAPBPhcdORwUAykijAqOWAgAOpMd2/DMDAC5IW5kqmQUAxyoAB8eNBwBBF9CUY5MFABfvGiik+wQAegqyaZC4BgBk28e1jPoKAA+oKpjmGA8AGhoa+JWeCwD6bGTzlOcFADl2ijA9RwgADSJwYkGgAgAl0GmLJF8HACdqZRa8ywEAKGfi1v+5BQA+pzoQwjsCAAWeWAMmeQYAXVmSmNtIAgAILa08pQYAAHO691ABDQIAQ+D9O/cCAQCaHFG14NoMAFXU4P9/JQUAgCHr0QhBDQD5rpsPzJYIAOmkXXK99gMAxkVXf6u5AABjHdL48MoFACvqCKS+3gcAFm2Jk9ueAADApV7Sl2UDAKxYYBB7jQUAae4L0vjNAwBeAWW3TAoAAMl8fDMyaAMADaadwey3BwCI+nynUUoGALUNynD0nAoA2JgIbgu2BADH5v/dBF0FAFy/YcbtOwgADWlcaTw3AgAYzw1SyMAEALmUdEuvhAMAJSKijkqrBABDF2DXWiMEAPV1iQcNywAASwxTPjGSAgAJpSSRu40DAPERWmXQUAMABt8MK87nAADmcEvZ3/4GANS/RZc/OAoAAMPEJ66+BAA/P2pBpFoHAM6uOGElFQ4Ao4WMxDpkBACSuDUnjIcGAHfY9CM1pQMAne6L7QSlAwBG+9il4GYGAA3LcEhO9gMAV2VtsUgVBgDzljV3YaIHADpdJ19NcgcATVENgbzwBwCNE3JzrZ0MAHQQ0+XeRQcA4tt/XqWxBwChbhePmLoFAFrs3Qep0wkAbxP0JqRrAAAgtwYG/MoDANqcNaLwGAUAp+xv5OX6BQDtjs/b+NEAANyB0D4xkwYAQheQZqOwBQB+yqQshwwEAAGeAJSA8QYAvzFKtBEAAABcpwpqaR8GAMpCrVcKiwsAyP0Gt5rlCQDMv27UCBMIAFAoLYqYPQYADGzGP2ygBwD7R7rBuskBAI4DdcU1OQIAE5zFcb3wAwA16BbZSKwDAC4jva9TBwIAAmDQHrsfBwA6r6RHrpwDAMLZNAt8MwAAijayUq0/AwDozyLE0MgEAKVxWSe0YAcAPa0cvJXaCwB1c1v/UfEIAKaQy1w1zAMAFh7kxcZJBgCAqubuZwYGAJDhKxidFwQAeWl+VtlTBgBtJZpCD2wBADGRPpBDlAYANt35xkpvAQBTkuISSeoCAF3SaD5ktAIA57om9OoxBgDoDXCjuXUBAPtIqgBffAcAFwPKhXeRCwCYk8eyqVoIAPdl9sfyMQQAn/5m2hAEAQB91rTcgk0CAC11Fw7+5gMAj7DLHt7aBACR6rFIllkFABl7j4VEYwIAwFopSj30BQDUrFJcp0ICABANIoBEkwUAUxL5FUewBwDGuubEgMIGAG52YbOjrQsATjtcEuUvBAAirEpN2BEJAN18pc8KjQQAQ672rCi9BQB9kFaPq28BAPLVGBKxrAcA27QjIOAfBABlL1y/N5sFAHHmq33kJgcAwfZG50XsAgCGRsdTDlgGAHQ/ZwSh7QUA0zYTGTRiAQBAhvMf1pwJAKgbtMTGYAgAbjanDPdcBwAeAWzxqBgBALkDogdXogQA9n8m9t6ZBAA8dwiBhW4HACnL3cXKkwYA9J8K0BEDAAAFXc3+/c0CAGrt9lOKZgcAViUULroDAwAJCcGEBYgDAB0mCgAg/gQA5EjSlhhyBQA72tChkVANAAoFwce/9gQAvqkuzU5ODgBvvovysX4IAAJL/FqTPAgArhsY/RdVBgBtgXYsd+UDAIqJQJYYGQAAmXTehCrtAQDBY0/X7XgFAD0MK0nGdgIALpO/QPybAAALMx/x6IgFAG7CTWlu0QMAjCiQtSrsAwC40TKuCToBAOS0Wrge6AsAHq48pKx6CABzY1LXBS8GALqtxma/4QgAuXvY5HvSAAA0tF0jJ2wFADctpg5uLgcAOehu0ExnBQD8AKIlXN0CAH6ILHnp1QMAVbyrTXIZAwAACGh4fLkCAN3mNN3frwcAiK41i1QwBwA049ahSwkDAAsw46cm4QYAxfv8rsCJCACCZYMfoe4KAIOHfSeihQUA7rioy6NRBQCG2OIrQrYDALyJlkHhMAYAVamnBztlBADbEbRDNAQDAGKJ1DOCXwIAMfSvBI+9BgASY5r9B/kEAJvSN8fTDwQA+Q6VeGJlBwCKz4bqo3MIAC2c+6vi4AYA7jPqOCoOBgAY/vMpJAsLAD5hS0i/iwoAwMgf1VnPAwAYR97WoKAHAEu3bz46XAUA1U+IXxNTAwCEG4wKFvQDAHxsE29cLwEATN43otv+AABEq7/OvHkHAAlpTT+prgMAjxhYs5znAQBugeD12FMJAPwu27szhQgAMJQSlpcUCQBChhY2bnoJAB6d01KreAwA8eP37sM2BAAmAB/C0/8HAKktCvJ75wMA3nKE/L8YBACzo7NReV0GAFnRUpLTpAYA1OwAWeOQBwCGd5e/JQcDAFOgNRZcCgEAEqIRpIdtAQBwBU7V4tUEAHRfP7PX5QIAv36IP96lCwC2OWG9JO8GAKald7WQ+QkAFWIGQlp+BQB3NphEi6EBAI9vHt5S5gMA69gu4CtTBgA4XxbIh48CANb36ButTgQAZvQxT511BQBDefRJgTcAAClPK+M7nwYA1jQV/oJYBADkbzyUKZkEABVbVHJwNAwAxOfXzmsiCwDeie1MEzoIAF5AzkP43AcA1oN5dV00AQDNzDRC9SICALTbij1KeAEAzCuM7r5uAwBvYo9b/ogGAMAyR0pI1gAAki1Txkq5BwAPhVSHG3cFAMhhFN/ZjQQAcTLnh5ZzBgDAGgzIncwFAM3UhhRngwYAc4FeGl9vBwBK3/n109UOAObXaI8L2gcApnVWOBQgAADvHT21XxUGAHySiS6jfgMALqj1aKZZAADc1KGrFWEEAHbatcNTGQcAgXrTMyJkBgC9sXaAZckCAP8QMOaBpQUAdDboh/ilBQC5Q6ag0ygGANKTDGTYHAgAKw/XyrC3CAC9RIGpTYYLABtdLa43PgQAET2hcM8BAwDskRi6oaYCAOA6P/uR8gIAUupLgXsaAgDRRG5lm2YDADPhpu0GPwYADwdYJzQzAgB1wJxF4JgAABt8bK1e3wQAXv3UbB6iBgDQsplmEikJAOc9YKIR7ggAIEzH9cIKBgAIaBkqGZsFAOgBcLBxUwwAX+ZGMAoXBgA4nqRGGkAFAKjEYVXdCgIARp7e7bSrBwBfGRqfv4YFAAt5+F6NCAMA27T8JiGMAwDD40nhuoUGADDppAHWvAAAUg55A/vqAAAdrnUPXoAIACcKhlnMZAwA7guwt+VICgB0j+91ltkFADVUTDTjSgQALwRIN8FVBQDAMkJ1QdAEAAdphjC0IQUAOZz7QI4wAwAsoHXGrAkDAO5Dpbu5iQIAnlMoLlmrAwA62M2rgk0GACfjcsGOxwMARvm3IVItBgApevc6JtQFALCuiSLdPwoA67l+92TcBwAsQDiD0hsIACE5OKUpTwkAbZPQGJwpBABJikGDQZEFANWuIccYKgUAbZeCulGxAgBUx0ve78AFAPXXsiXcfgEA7hsIpjZzAwDD5YeIMbUHAOFbGkltnwQA4L7HZSPnBQA+swgvBjkLALHPV+bzuwQAZ1lu9fd6DgCO1p5/1tsMADO3XFUgCwcAfyFxRQf8AwDraiub0qADAJ3l3cx4ZAAA+t0bBU1eBQBOe8QEEX8HAEwsEVXFEwEAyrf5A1FTBwAIIZod7UABAK/COzMiJQAAZKD0mEPjAAAoGUs+CQsDABIDyH5+zgkAg4/3vXXlDAA47QsZeh8OAHijbO2t+AYA6L3OPtkiBQDP9uBF8CQAAKHPJjS2bQEA2A/THzq5AQBio2hTQOUFAJqyt/09EgAAaDxSVkM0BABf7iF5UpoHAH6BPsv8SwcAPY3sct6ABwByJ/QA8+oHAONMNYhRRQ0Aq8s9SsrcBADL67/QFNMLAFcr02r83gEAvOeaCEWFAgBcwaDpj+MBAHs34uBGIAEAhagKVhxyBgAoGWe/KOsAAKeVUe8avgMA67W9Yi/yBgBJMFK4aJcDAL39+8iUMwQA0o2/AdJnBACW53pWvfQGAIO3F5PIWgYAMon9IDt9CAAVaTII8gAIAIOjW1qc7woArU/vdJqRBgC/UhRh1J4FAO8J6gTskQYAhOkAJ8vLAwA8uvXEQxwHAM10nvr2bQUA31bP5JWcBwDiCcY7ZL4HAHjo2SrBSQEAXww5ylinBQCB3GEdi5EIAJvRDCZQ0wgA2LQ3TquiBwDXFFRz6h8CAJ1jfwI4pwgAlSRG2RAnBwBWdACqr1oCABuj6igf0gIA0F8A6nF2AQC3PkskrtsCAMzh/1cvSgcAAXMIczC8AQA0nAH0V+wHACSlHy4ITgMAahI1poxpAgAO2T1eL3AFAMfFcEqaHAMAJPx4qqU2CQAAe587L5kJAKKvxLAEwAMAeLqwMogxBQDsfPGfS/IGAMdg4DB/pAAA0MgNVISDBQCunMTcQ/sBACu49AasRgEAVXOe2AC1BAASinIcHjUDAOMvk2mfCwEA/dEc0D+0BgDzDnY+WEIPALcWMlfBPQcASnHX/UiuBAAD4ROKX/gEAA3/1rIgNAcARMWXRktdBwD0+Pf/4RsBAOH3V2jhGQEA1fVcNBSKAwAvtQVxjaYFAAYehZ7L9gQA5ZUYR8R4AgDkZD3Oze8HAExLXEVtTwYAS6P+MlbbAwDCJZiCsZAJAMglMlHT5wgArau34yvBCQClnB54d4cFAPJdSeqXkQ0A2Nld9yvuBgCNvjTrLMcGAMdeNMzJeQYApJho+Y2JBwB1nfStIUMAAK5a5eQZYAEAnCBd8sVPBwAN7Z2TalYEALfgFudjYAYAcE0f3K9eBADasczPJEYGAMG2coCrVwoACW9nJQcSCADtjk7QGKAMAGzVpe489wsAK9dFgIUBBAAwLcrg5VkEAOqLMBm3iAQAtTIbDUpvBQAtNoC87qUFAMaNTgrRvwcA9DZnNpnIBwABXPnqu14FAIo/kGCwbQQAIWYSiVhgAgAv5XbGPI4JAI+pldl5YAoAsQh5IXxKCABZZeYDdtwBAEQkC6Hf3ggABP9gg6YEBwA+i948zM4DAP9kD0fVHAIAiTmVjcGrBgAV5uTC0EoFACpSK7jVZwMAx309uPTTAACNxdtMfwYDADd5adpSBAIAqXeqK8suBgB0KLavNigHAECylCA8rwAAejV/KYXCCADi1oBWLcwHAGNWB9UTGQYAPSsVYVJ5BQC9PPq626EHANWIJcUxrQUAXGhkQTpfBABtlpqRn+UCANoxMho2LQYAuAFOAIRSBgBgHek7U1YGAJ+oAGwBrgYABRwTKrzdAwAUu5YnolcKAHQ+RPtg8wYA6uogcuSABgAYDPGl8vwKAB+DjbN/7gUAS8VezvkPBABbs2HihXEFAKlwDlRU4gMA+OMDQIG1AQBLwEoxaIkHAI5qREHL/QUAcSr/JmkoBQD2s5biMfIAAJNGyFejhAYAoLzJMwYdBgDfc/z4vCgLALOV/wbetAsApBG6J6QKCwCbbdq/Me4FAGeA38I6sgUAZiXb/zVJBABubBdtAS8BAK71Fg+w+wQAKkCZjbf6AwDteoT9ZekGAHtSgO5TuQIAWrOxzVtfBQBmPKI/CzoEAAqCizgHbgcAXdmdu5ubBwBhc5+Orn0JADLaAmH3GQcAi8qAKnwRDQA1CV22ZhoMAMqsYBSBugkAwiYxakBVAwB2fXIYGQ0FAA6OSQvq5QYA8hQyBrajAADSn4wVXwYFAFSZQgz7aQEAEO7s2e2aBQACGIXrFpkDADjFXFUXeQUAT4rlOR+YAwDLb+Ztpd8FAAhZBwmIBQgAk0qFy9jTBgDjsXDp9LIFAMHL7VJEDwsAkwojWXWKAwAfo4veHCwFAD1adNTypAIAiqLUQp1+AADNWnCDwI0DAECXdcWCJwUArZDZlzM/BQAVTejHOakDAOA5fiLENAIA8pOlodkyBgCUhAztEf0JAOBXJ+2zIQgAxcGP5R0+BwCrFkbIENEFAGSvKN+npQsApssHuBVrAwDX/hqeivcDAB+PYCycpQAAt4HLjt0rBQDUfoRIT7IAAMfqG1G+1AIAm1ue2aS9BgABTpGWaX4BAIDPf87wsQcAgVRHdM9PAwCFqs94qx0DALdUXm4h4wQAibZzOYJJCgCEiOSESVgKADb7QjCaEQgAymeXeEzgBwAyuM8oG2cBADfF4aJ+5QcAQUFE76r7AQCm32TBvdMDAH0Xwuic2AIA9CwYuhLNBgCXdprBigoCANlyzLL6OQUAIN4ejwhsBQDvjvMkrF8LAAKrl2Fc1wcApy+kwks+CwBEgbQQzccJAI81SOq3OAgAF26oEBE9BQBtRl+2bkEGACDOXyOmHAQAEruZivzDBQAIkbnGdJYAAPhvMZkh+AYA6fOp8VRdAABKJ73QxbwDAK3V0riEsgUAnpYlEOPlBgAPYgZjDvsEAGDmR5f1MAkAGdTsj4ZBCADFO5KMXhADADgYPdSKBQsA+5Plh/ViBAAtNs6nS9kDALdnJrX5MAMACvDgSFrUBQCNmngUUY8AANBjduX9DwQARwbC1EUUBwB8DxdoPmUCANZexePeTAYAPf5O+kllAgBuZj+vSYUGAGi71EEpngAAPP9dHzHoAgDS+x/5nkIOAOIsE/4NoQMA1vlrHkZaBQCDLrD07o4HAM8WjGRP0wEAMlG6Kup/AAAeQMYdbpIBAKDOF+qKTgcAD7w/+EPHAABVVL/EA8sHAJh+kamLigYA5WHYAR36AQCrlN/RAKwMABonvQEhugMAr8S5iIlXDwB9n/SJv/IIAJ/pjtHOPwcAMphZfZRVAACQGaQq/kYDAFsZeYBMFgAAJ7p7+8yZBwBcp8Y7VnMHALOcE2MI6QEA1qDZB7T4BABpT5LKJI4FAFZk57tGogcAZLgBtyb0AQA/JaGRyDUGAC/ejtPragIABa7d+shtBgCGN6BBfRwKAH36s7FrtwgAARyRQUwmAQD5vYRF9AIHAN6Oxh9RPAQA+TXtOixIAAAb03FSr+EEAJuTkn/5wQAAF8FtlYh6AQDHnfleAO4GAMwxsnKRqgQAKnfrYd22BwDH0gGr+asIAOUKY4cCiAMA2+1bBMouCwDPMl82Q38NAPW/WbapPwUAkj3zUOjBBQD19rmaEewBAOlj5m1v8QcAxt4Wy9anBwDS8eq86QMHAFVUiJTpyAQAgq2c2rXMBAB16RDGa1kDAF6f2w0MqAcAYUxcPtmYAwDy4+fSYHwHAHA4dlEQBgQAqtLs4MR7BgC5cxMflLsCADAsAMnJmQYA80jiM2fRAwCJ40vht+IAAEp49toNLAQAUHjGH+qJBQCR8d21CTsFAMzxRlkjpwYAYL4vu5y5BgBiXEjWpdMGAMAj6WaUgwQA3fzGMK8cBQC0VKwYmvkKAG7uYZajmAsA4s1AHjOEAwCmGd7EFc0EAI6fGJziKgkACuB0dkKnAwDBdH5PLxQGABU6jDGTzAQA5x4rrBvVBgA/OJKiSlAFAM8BDR/LwAYAM9X1nkaHAQC/RzeIOHECAOiQOuUq9QIAuo6V/hT9BQCOy5O/Xv4KAIfny4raJgIAoX77ooMIAQBEz0J4cJQIAFxyYPlz3QcALKtFKN8tBAC7djL9TyEGAEZSGhiNCwAAIOt51aZoAgBHhuUm/5MAACmYBWj+JAUAIbZ85HVbBgAZzNWlsF4BAFqdkrMJUgAAR2vIy5v1AgDuwpG2YNUJAAfO4/y69QcAbIAUFlbNDACHsXBhi1gMAIEQ0ONVqgoAXxMXmUJ9BABw8Hqgz+oDAERutEar3gEA32ykOz+lBwAa5eJCi0UFAE9EBwzmkgEAqh2iQ4iuBQA4FQuRIdcGAH5BppUaMgMAaKeoBJA+AQBshzsZyQAGAGV3DYobHAoAoY6zf5J5CwAa4Nt5dg0HAOmNiUBg9A0A284vg0WIBQBzbgx/zTUBAFvj6N/7PwUAW+UGXhkvAgDOS4HoNzkHAI30eykWcQMAIJcGDZ5aBADsRKca91oCAKOrisvwGgQAXh2JTorPAgCia9AXfkgFAJZlLQMqhwsA30iTwCheBgDCQM6ya3sKAGkdifL3pgcAZw8RB4f9AwCyLakWh28CACcwdRuqzQEAYSa1WL4EBQBSguXWmwQCAEnvmmqN/QEAoW8ht2fLBwCCucNT/3oGACiW2hCmDgIAWVT8rRoBBgB9+MsCyNAGAHtMVe2/QQkAYkLvZ7bbBgDcfoUmMY8FAECTd4vhnA4APPiVz22SBwDsKw4SJS4EABX68W3pPQYAzPnzUGvwBAAvtrDBXPwGAMt5mLIoVQcAPVoS0o+aBwC4anRLjXwCAAwhAj+J+AAAEFeus5ZVAQDKJFF+FjEHAD/hu+g4ewkAVZAvlFvVCwA+kb6VFJwIAGz7GiROqgMAonmRP9I5BwDE6Lnb+jIGAEgM/itSyAcAqVrvgwntBgD0tYd2I9IAAPUFMyq/OAEAmGXYJF30AQD+YCGtSycFACrRWB0EtgEAemjkpsovAwDfzIcnc6QHAEAGf3xCHgkAY4xfOFk2CAD6a3bZ6vQFAAAmbDP2RgcA9Zp9xY1uBQB4T74XvrMFAEsv+IySvwMAEW8KYFUuBQDW6++cfmIEAByXbKtF8wIA6edjbihTBgCtI4q3YRAFAAFFtayZSQEAZu0HcJG0BwDKolPdKBsMAIXqh1/oewMAQV6o0uNLBwCmbMn6h74JAMwI/iA20AkAZLCEq1z7BQCwhYJ3PlECAEPgJTE4VwQAPSJutaO9BgBPhG83uiIBAFTltKLNMgIAQPgPoytCAAD1Q3tm51EHAD5f2lUXJgYAjrZSv3AsAADhco1FvzINAJu1lueWDwwAop1vnfcuAgB3yr5nqwEFAEPrP35psAYAuy8LXUvsBwBQVFkQ6QACAF5xBXEFQgcAYA9TInDwAgDvCaTwNGMCAMCjYt9K8AAA2baLtO3gBQADwPukSsMHACSsXE5O1wcAskE09DfMAQCmrs7J8VYGAOxarawcAwcAV2xx0IwwAQBCGZRzExwMAJXxcvdGowsATzLHXFpWBwARSiTVoBwAABOHQWewFgEAru1VjH2lAAADOBCcgMYGAMhq2uISUQUAWro9Cj02BgAM9KaLyRkDAMduowNL6AIAfO/2uRFZAADc6i5R86wJAGgqaTmYYwoABgWDNKJpBgDUAwYMkosGALJkHJ3vVQ0Auw7f9YOZAwAmmJWJJeoBANbNA4djzgYABYWJeBYxBgBwoprPzrMGAAi9czu6cAcA1Ibh93UUAQC8K4nJGyUAAFrM/5urTgIAFzgT3vR1BgAKs9o72fYHACXUv6Ws8wEAYJccHFL6AgDN+SfOgCEGANMsiAtFDw4A/IIXawNSBADFgXawlS0AALIFkvkckAUAtOxebmiQAgBMFnDfmT0BAMrA5SHDXgMAKUD0N+M6AQCnLT+BjgAEADoMji8nQAYA2l7l6W3AAQCqaW3/QCsFAPp/NwmIGwsAK0zRXGI2BQDRFy4lrxYFACvT5/iWgAcA4sQ+o9Z6BwAh0xHcxRcHAOQjmFUUoQQAseKhUM4GAwDbwv6hOM8EAOdc+g1lqgIAFZTxqBZJBQB4EudvyQ0AALg+5oQnXwUAkWCi08pzAwCau92J+6gGADd+2dU1jAcAsizvdDZuBgCP3VOsR0MDACoRpe1HFQoAfPXJgk1jBABS1qZokiQEAPcvf2htMwYAoNkmTk/+BABBVJQ9DwQAANOGWf056QUA35sBRyEqAQCynNDnZsQEAN0D0pVb+gYAVKI0o1A1BgA2e1RyRVgCAHcTHIFYXAcAGxfMN8bTDADiNH10MD0DANen+rqSmgsAN89pte3WBwCgLNyllAEGAKYQXnRZrwUAdUgAPvWoBwB4r30spu4DAE4nk+YTxwQApLNuehvtBgAVjn1pzioGAHWwKim4ZgIAnFxmoDaEBgBpECDoF9MGAMqjLF2BkAgAoJkU6/E/CAAY41DwYDkKABAWyWk2Nw0AJz8vIOg1AgCAF7Yun0wEAANwHVuQMAYA0ep00sj8BAB4q2h/bnsBAFdSDpqrFAAApYt/VjmZAACCPEIqe7QEAC3EeuXXiAYAh49nWkvLAQDUB6CiYqoMAG0t9jgOHgYAgkfMj4gvCAD/G/KDK1YHAPYu2NIP3AoAbPxKOWvABADMNvZLG5MEAHgjMtBgKwcAJYuBxidRAgBD542nvDADAE50GRGE/wYABZPk6GDFAgB6peXvTyUHAN+nYMXiegYA8Wmz4RvDAwByQsv5k7wIACwYc9v5+AMAxOG66jWyCgAZVSmHv90CANXnlxDsHAQA7oqUCE2GBAAe9o1DN9IFAGdwH2CFsgIAU9fmurxdAgAtJjQRtjADAIqAbaLXGQYA8r6twrPDAwBSf+yefIcGAG224eu5vgMAh/KRzURrAgCDA3Nik/IHADacRVF5/QcA50ktUUxQBwBfxTt+7YcIACXHSQGx3gcAdXQ4j0dIAAA+imfZl5MGAPN2yVaBfAYAbCKJVU3rAgAKwcHmCccCAHruZodqrwIAbNmheaqKAACwL5vVki8EAAecAEAsdQEAzmL/6WiOAAD58rgK1QkNAOTleySruAkAheSy5rLZDQA4E5pHpfoMAHCPc70TywQArTDBSwpQBQCVhpN6oScBAG3jNPomKgAAKMweLtGEBQCj63748/ECAEq2FeV1jAQA8B4HUmlbBwAGVJZCbdQFAJ+fmAZhdAcA4go8NR6aAQC9vZbVzXIJAIMWiN8dcwgAFIFP1iYECQDZo6nYTxoHAGomkDm9NgcAwwX6umB1BACjL8yr3BgEAIKGz86RWQMAYIxLqXFDAgDDIByxRhUEALSzNJNQLQMAqnCuLBBsAQBF9BvVDXIBACGYry9mrgUA+ocrWikSBACz6pPiYVINAMtlm3UmZAgAR2oRrmUCBAC85boEI8AGAK2V0bgLdggA6dZ+9YibAQA5owQZv80EACxPTs1JKwQA2QkZdy4aBwDSUrs+FU4BAIqB5s0XGgYAJ4gQNK09BQC2VVzFMisDAKNHk18W+QIArDO86UuzBgDA8nFlZWkMAD5Cb85hqggAoCcb10D5CwBp0XOd8YUJANzmYnucGwgAssB4OmQvBwB7nk/ARd4DAFz6MI3WBgcAJC+OPvaWBgAtkvAYLAECACmdyFrlVQMAAXHsFLToAwCQDFJ8sJ0DAOHvd5se9AYAuuSEt/WKAABLLMyJ0hQLAE288eJQNAoA85IvOZPNCAB8a5RqDDcJAJf9Wh08QgYAMyUfiNyZBAAGxXZk8k4DAJcUdNIH0QQAs/1uvcRGAwChYxHXeSsDAGqz/O3Z+AUAkDm/3OjmAQAK84o0T5cHAHyc8U5y5gYA4hO876WABAAMIs5C5EwJAMsWJaeAiQkAdma4DfhyCABtUtofMwMHAMiRdtQxSwoAcSBiAQvnAQBqofi1Y/EBABfUGjSvagUA9zDYNZaYBwB7ywB2onoEAMP4FcDtHgQASoXvJ43PBwD5k0ZY44kCAKcJs1d4SgAA2k3RhbVFBQDhIbPj0OQEAECs0uMfRQcAjanuePZmBgCt/meGhTgIAIxM5sMt0gQADzrUoF4nBwD3zNd9E4EGADiat7qc5wEAaqaJRCEqAgClKzOcL/YAADlfO9aJZQQAlj/sefnqBwCouXIV6OsEAEppYV1/GwIAcWOjAfrAAQA9apOMDisIACDNtlg7uAYAgCbn09h+AwBiKp/bN6AIALvSsRlUAAwA/z2UIrYEBgBYGnT2mcgBAPsy8uIZAgYAy/mnkq5fAwDKsfMUNvoAAPCCvrm9/gMAABSSlUjnBQAGJ4I46lMFAIzIzyR8oQUACvSuGKL7AQCUAXs+BFcGAOfp71UbwQUA+3SgxntzBwDMVeMc5OoIAHX3P9E1xQYAPvXI+kiUBABqNejGdE8DAKLbBwZ4rQAAtj62fjohBwCGjKqs45IDAK81ij7pNAUAl8kC/RCLAAAFHriswmoCAHk7zpiMnQAArFBN/hdeAgCnIfF29X8HACty/LD55QwAxygNm5RvBAAm7xdd5s0MAJeW+CiouwYAdvYEHtebAABFofJByFoCAHE4gqx+pAEAGlhsw6ioAQD7qUIUdVUCAAE5/pBmvAEAWrxaLxMUAwAo1TJRgxEGAFeKtI5L8gUAt/b3BNVZBQD9ZtL255EIAIhzA+9gYAMAhhId7IiHCQCvjkccRIcCAL1UM2rqIwEA1VTrs3iDAwDulI+nqtQEAE2ndegCoAQAfLFnE4ULAQDjB1gtsRoAAJYt40GQGAUAMQIJKwZbAACPt+dmF8kAAOw4oVUPqgAAipEsHpajBAAePyPzRNYHAGTAAp6fxgkAl2gm5eVqAwB5i9PawY8IAEC92erOigYAoLvm+OA7BAA7TmH8348GAOA7W6sd6QQA8C8hydSxAwDbsT/Oa80CABDC1/MOyQQAFoeBoPWWBAC4OcKM+JwHANv4bDCcywIAj1BbDXaVBQCQJwL968sCAAUR7CqCuAgAy7wm0s/RDAC9cUn6shUFABVF9V0sywIAl2OqBOG/AQAlbJn/lBQBAABYPmJRQgYAvkTgxZ/UAAApy+1D+gkHAMoq/WOMXQIAYf3fKc3FBAAFr0jrwC4DAHy3+ZGTjwEAgQzPngIPBwC5sBBeqq8KAEwlVYPgHQYAjcLjfVjrCADUu32fu/AEAL10KlrKTgQAMz7tLrMHAwDC6DywinQGALwQuJoNfAUAjOkkomQsBAAUw6bY1bcAAEPVlXsySAQAuqTjgWYUAAAMTsOtFIcDADCOKQ5v8gQA3scSRSJyAgD8dalCirsLAO4Xa7TV8gYA5XAxIqm2BwDmt+M/cVMIAMFrf/01lwEALjTFSa+SBABXA1rfXDYCAGC7/6c4IQMA/kZG0fehAgDMRIrxXRsBAGZCyELQkAMAddyPKuPvAQA4Eq7nXpIGADLo0IGSrwQA+B0ZEfn+AAAAAAgAwgODAIoAAAApAQQAGwAAAAEAAAAAAFkAhgAkAQAAAAAAAAoAAwABACsAuQAAAAQAZQAAAAcABAAAAAAAAAABAAAAEgAAAGkAAgAGAAIABAAAAAEACgA/AAQAAAANAAMAAAAFAAQAAwCxACEAAAAnAEGc8MMAC6kBCQAAAAEABwAAAAAAJAAAAAAADQAPAAAAAAACABcAAwADAAEAAAAAAAAACgABAAAABAADAAoAAAAmAAAAXgAKAAIAAQAjAAoAAAAAAAIAAAAAAAcABAAAABsALgAPABAADwAZAAAAAAAEAAUAAAAFAAAASQAbAAgAJwAAAAAANQARAAAAAAAAAAQANwAiADMABgAAAAEAHAAAAAAADQAAAB8AAgAJAAAAEQBB0vHDAAvFAgEABQAgAA0ADwAEAAcABQAAABkABQADAAAAAAAFAAMAAgABAAAAAgABAAAAAAAZAA4AAAATAAAAAQAJAAcAAAAAAAcABAABAAwABwACABEAAgAKAAUAAAABAAMAAAAEAAAABQAAAA8AAQAAAAAAAgAAAAAABQAAABUAAAAAAAMAAAAmAAAAAAAAAAkACwABAAAABAAEAAAACwAAAAgACQAEAAEAHgAAAAEAAQAIAAQAGAAKAAAACQAAAAAABAAAAAUADQAAAAwAAAAAAAIAAAAAAAIABQACAAEABwAHABEAAQABAAAAAAAEABQACQABAAQABAANAAQACAAEAAAACQAIABEAAAACAAAAAgAAAAYABwAAAAMAAgAPAAAABAADAAEAFQAJAAEAAAAAAAEADwAAAAcAAwAJAAUAAAADAAAAAQALAAgAQaD0wwALQQIABQAAAAkAAQAAAAAAAgABAAAAAQAFAAMAAAADAAEAAQABAAgAAQAGAAoAAwACAAAAAgAAAAUAAgABAAAAAQAKAEHu9MMACwkFAAAAAAAAAAEAQYL1wwALTQEAAAAJAAAACAAAAAEAAQAHAAQAAwAAAAUABwAAAAAAAgABAAEAAwABAAAAAQAAAAcAAQAAAAYAAAACAAkACAADAAUABgANAAMABAADAEHe9cMAC7MCDQAAAAAAAAAQAAYAAAACAAAAAwAFAAkAAwAEAAAACAADAAEAEAACAAAAHAACAAYAAAABAAMAAQANAAcABwADAAAAAAACAAAABwAAAAAAAwAEAAEAAQADAAAAAAADAAEAAwAEAAAAAAACAAIAAQACAA8AAQAAAAIAAwAAAAoAAAAAAAkAAQAAAAAAAgAEAAAABwAAAAIAAgAAAAcAAgAEAAIAAQAEAAIAAAAHAAcAAAAAAAMAAQAAAAIABQAFAAAAAwAFAAAABAACAAIAAAAAAAAAAQALAAAAAQAFAAUACgABAAAAAQABAAAAAAABAAEABQAGAAYABQAAAA0AAAABAAAAAgAIAAAAAQABAAEAAAAAAAAAAQAFAAAAAQAFAAAAAgABAAYABQAAAAAAAAABAAAAAQBBnPjDAAtDAgACAAUAAgAAAAAABAABAAQAAAAVAAIAAQADAAAAAgACAAIAAwAAAAIABAAAAAEADAAIAAEAAAABAAIAEAACAAEABABB6PjDAAtzAQADAAMAAQAAAAAABgAFAAAAAAAEAAIAAAACABUAAAAEAAMABAABAAAACQADAAAAAgADAAQAAAADAAIABAABAAAAAQAFAAEAAAAAAAQAAQACAAEAAAAAAAMABQACAAEAAgADAAEACgABAAAACAABAAMAAQBB5vnDAAs9CQAAAAEAAwAGAAEAAgACAAQAAQADAAEAAgABAAAAAQAEAAMAAgAAAAEABAAAAAAAAAABAAAAAAAAAAEAAgBBrPrDAAsBBgBBtvrDAAvJAQQAAwABAAQABQAAAAEAAAACAAMAAQAGAAAAAQAEAAUAAQAAAAAAAQAAAAEAAgACAAUACAABAAEAAAADAAAACAACAAIAAgACAAIAAwAGAAMAAAAAAAIAAwABAAEAAwADAAAAAQAIAAIAAAAAAAIAAAAAAAYAAQAAAAEABAAAAAAAAQADAAAAAAACAAAABAABAAMAAwABAAIAAQAAAA0AAAADAAQAAgABAAIAAQABAAAAAwADAAEAAQABAAIAAgABAAYAAQAAAAAABABBlvzDAAvZHwIAAwADAAAABAAEAAIAAQABAAAAAwAAAA0AAAAAAAEAAQAAAAEAAQAAAAAAAwABAAEAAQAAAAEAAQABAAEAAwAAAAIAAQACAAEAAgAAAAAAAwAAAAAAAgABAOZKAwDcSAMA5m+mANw5AwDmfKYACU0KAGtJDgDmkwUA3OACAeYRBgDmJv4A5uEgAOZAAwAZwgUA5vCmANw4BwABnrwB5kMDAAlNDADmQQcAgoAPANwt/gDm8h0A5t4dAOYj4AHcOxkA5tUdAObdFwDmexoA5m0bAN6aBQDmDQMACc0KAMrQHQDcyh0A5iDgAebkqAABOQoB5uMtAOZH6QHmdRoA5irgAeYo4AEJmRoB3I0QAObsHQDmehoA3KMFAObpLQDm/QgA5kEDAOZLAwDm4qgAa0gOAOat0QEB2CAAW1YMANyL0QHmJQgA5qkFAMooAwDmIAgA5gYDAObxLQDm1gYA3B8DAObUIADc1xwA3DoKAea3qgDc7iAA3DsHAAm5EAHmhwQA5nATAebQHADmIP4A3FoIABG3BQDmGQgA3FUDAAHzagHm5R0A5t8dABe/BQBrSw4A2GXRAdxEBwDKJwMADrQFAOSuBQDcMQMA3DoDAObwLQDmFuAB5nMTAeZuGwAB6iAA5qsOAQfKEQEBaNEB3M8dANzW6AHmZwMA5ngaAObgHADm2AYA5tocAOY1BwASxwUA5lcGANy3GgDmC+AB6l4DAAe3FgHc6CAA5tIdAObhHQDmfBoACUQdAdyC0QHmdaYA3FsIAAlNDQAB6BwA3EYHAObgCADmeqYA5qrRAeaF0QHmhAQA5msDAOZXAwAJ4BkB5gsDAOY+AwDmOgcA5u8tAAmEDwDm8CAA3BcDAOaDBADm6AYA3CYDAOlcAwDmBeAB5tYdANwZAwDmDeAB5tcgANxSCQDcUwMA3BwDAOafpgDmAhEBCSyoAOZzGwB2uA4AB7wKAIJ8DwDmahMB5ibgAeb7CAAMsgUA5kTpAeZuAwAImTAA5vgIAObgqADqXQMA5gkDAOZqAwDm4h0A5oYPAObAHQDm8agA5kgPAR5OBgDcGAMA3OYIACFRBgDo9h0A5lsGAOar0QHmkgUA5uwGAAkzEQHmRNIB5noDAebRIAAjcAYA3KoFABxMBgDcRw8B5nYDAeYKAwDm1iAACTQRAebGHQDmBuABATYDAOZeEwDmwx0A5sGqAObnqADm5QoB3NwcAOaFBADmIwgA5vMdAObEHQDcRg8B5twGANhm0QEJRxoB5nIbAAHaIADmEuAB5kwPAeb1HQDmUQkA5ugtAObYCADmLv4AAdkgANwvAwAb8AgA5hHgAeboHQAgUAYA5tcGAAH0agHmdxoA5iT+AAlFHQHmgw8A5vQtAOZ0EwHmLAgA3Cn+ANweAwDm7S0A5lMGAAnSFwDcXAYA2HHRAeaG0QHmAwMA5hXgAQiaMADm5B0A5mgTAQHjHADm4QYAB8AVAdyWBQDcRwMA3E8PAQlGEAGCcg8A5sQFAOZJDwHm6qgA3CwDAAk7DQDmeRoACRQXAOb4HADm8i0A5toIAAc8CwDm8QcA3OYKAeZFBwDmKggA5iQNAeYj/gDm4i0A5vstAOaXBQDkKzAA5jThAQE1AwDmXhQB5loGAObhCADcogUA5i/+AObHHQDcpwUA5ucGAOZpAwDmHAgA6BoDANxIBwDoWAMAAfJqAeZABwDmEgYA5tIcAAdCHQHcuhoA5rQaANzS6AHmEOAB5gDgAQqwBQDcxQUAAdQcAAl/LQDmG+ABB0YUAdxaAwDmzB0A5usdAIJ9DwDmyB0ACTkQANyA0QHcMQcA5hIDAOZMAwDmKQgA5ggDAOYp4AHmngUA3LYaAOYe4AHmNeEB5lkGAOZ4AwHmMgcAFLsFAIJ7DwDm6wYA5m0DAObnCADp/B0A3DwHAObuHQDaKjAA5mQDANwrqQDcMgMA5mUDAObvqADm5yAA5twdANybBQDmMmsB5lMJAObgHQAB0iAA5nemAOYD4AEJyg0A3B0DAOYB4AHmdKYA4C4wAOZsEwEJ6hIB5vgtAAE4AwDmJOABZzkOANy1GgAJzQwA5u4tAOZUCQB6yg4A5oYEABjBBQDmXxMAH08GAOasDgEB0yAA3F8GAOZF6QHcVgMA5l0GAAkrFwEkEQcA3DkHAB3yCAAHPAkA5kcHANwkAwDm5x0A5jgKAdzVHADcTQ8BesgOAOrNHQDmvqoAIBoGAOYBAwDmLQgA2HLRAebu4gEHQxkB5jBrAeb0HAAVvAUA5votAOYAEQHcKP4A3MIdAOYVBgDmQgMA5hcaAOZD0gHmsKoA5rAaAObFHQDcJQMA5tsdAObjHQDmGwgA3DwDAHa5DgDm8aYA5tsIANzQ6AHcNQ8ACe2rANg5DwDm5i0A5uGoAOaH0QHcbBsA5iX+AAc0GwDc0+gBCT8WAebdCADmhw8A5vEsAOYAAwDc1OgB3O0GAAc6GAHm8B0A5v8tANx70QHmmQUA2G7RAebsBwDmF+ABCTwNAObtqADmFAYACcARAeYI4AHc+R0A3OkIAOb5LQAQtgUA5jFrAebRHADmrNEB5nETAeYYCADmidEBBvBvAebQIADcvxoAD7UFAOZKDwEJzQsA3BgaAAn2qgDcfxoA3O8gANzdHADcfNEB5q8FAOYmCADc3xwA3NkcAObVIADmFOAB5jZrAdz/HQAHs6kAAWfRAQlgGgDmSekB3A0KAQk5GAHmbxsA5t0dANxCBwDmbAMA5v0tAOYY4AHcTgMA5numANz6CADm5QgA5mYTAeYFAwDmNgcA5kbpAdwn/gDmDwoB5gLgAQnCFAHmHeABCVOpAObbIADcLKkACT4ZAeYQBgDcLP4A5namAAHwagHmiNEB5pwFANyB0QHYGwMA5icIAObwqADmoAUA5g8DABoe+wDm3wgA5gwDAOYCAwDmdhoA5uIGAObsLQAJlx0BBzccAOY9BwDm+RwA5l4GAOYWBgDmaxMB5vQIAObs4gHcLQMA5gzgAeYw4QHm/AgA5lQGAObsCAAJRBsA5tcdAOb8LQABadEB5ugIAOYUAwDm66gAATQDAOYK4AHmEwYA3E4PAeY0awHmUgMA5r+qAOaoBQDYcNEB3DsDANztHADqYAMA5v4JAOYc4AHm9y0A3CsDAOYy4QHm/h0ACaobAAHrIADm8wgA6V8DAAc2EgHmEQMA5t4IANzqBgDmFwYA5tkGAObmHQDm6SAA5uyoAB8ZBgDmJQ0B5v4tANz2CADm9wgA5todANy9GgDcuRoA5nimAOblLQDm6h0A5msbAOZdEwDmsxoACcSoANzWHADm1wgA5vMtAObcCADm9QgACasbAObkBgAH6RIB3MAaAOblqADctKoA3NXoAdwpAwDm7wcA3BkPAOYWCADcNw8A5tUIANxWBgDmMAcA3EkDAOYTAwDm9i0AB8MUAQHlIAANswUAZzgOAOphAwAJTQsA3jkZAAc3EAAJNRIBATcDAObUHQAHvAkA5mgDAOYXCADmRAMABvFvAebqLQAJNBcA6CwwAOb+CADm5C0A5g7gAXrLDgAJTQkAAfFqAea8GgDmHwgA5vMHANwqAwDmBAMA5h0IAOazqgDmnQUA5nAbANwtqQDc0egB5PcdANwYDwDcftEB3O0gAObv4gHmQtIB3FkDAOYh/gDmWwMAC7EFAOYrCADcPgcA5j8DAAm/FQHm6y0AB3MRAeaCDwDmM+EBErgFAOaYBQAJug4A5vUtAOYzawHmBwMACT8cAeZRAwAJthYB5tscAAnyGwDcMAMACToOAMoiAwDcSw8B5jHhAea4qgDm5y0A5mkTAYJ6DwDc/QcA3C4DAOJt0QHc3hwA5kkHAObkCADc+QgAa0oOAOZvAwAB4hwACU0TAQk6EADm8R0A5h/gAebvHQDmQwcA3MYPAOYT4AHm1AgA3NMIAOY1awHcWQgACX8QAebZCADm0R0A5mcTAeZjAwDk+B0AHhgGAAk/CgHm6ggA3O0IAOa7GgAB5hwAAeQcAOZYBgDm6wgAFr0FAOYE4AHm6wcAAeYgAOZKBwDcuBoA2G/RAQHnHADmUAMA5iIIAAdK6QHmEAMA5iEIAN6tBQDcpAUABzwKANbOHQDmMwcA5ukdANxVBgDm8AcA5uAtAObjqADmfaYA5gERAebwLADm7eIB5uioAObaBgDmqwUAAeUcANw3BwAiUgYA3OMGAAnzGwAc8QgA5sEdAOZxGwDm7gcA8EUDAOZ5AwHcKv4A3FQDANz9AQHcIwMA4C8wANyRBQDc2BwA5uEtAOYi/gDcFgMAHU0GAOYh4AHmD+ABCTQaAdwgAwDm3wYA5skdAOb7HQDm5qgA5gngAeb/CAAbSwYA5p8FAOb0HQDmdwMB6WIDAOaUBQDm7ywA3PIHANyK0QHmyx0A3O8IAHrJDgDcTQMA5qEFANwr/gCEdA8A5tsGAAc7EwHmZgMAB7wMAObWCABUVQwA5j0DAOYeCADm7R0A5ifgAegVAwDkqRgA5rEaAObYHQDmchMBCUIUAebTHQDcpgUACcCpANwzAwATugUA3OMIAAc8EwHmOhkA5icNAebpqADcpQUA3FAPAdz9HQDmsqoA5u6oAOaVBQDeLTAAgXEPAAe6EAHmeaYA5u0HAOasBQDm2R0A5iYNAebcIADmPwcA5uAGAOaepgDKIQMA5jbhAdzsIADmSOkB5g4DANzuCADcNAcA3H/RAQkGqAATuQUA3H3RAQnNCQAJPRkBB+YbAOayGgDmRgMArgwOAAAAAABaBD8CAADoASgAgAIAAAYATAEBAgYAIAADAAAAcQCLAQ0ATQHTAAAAAgCFAEUACgAEAOkAIQAAAAAAqgACAAUBAAC1AQ0AAAAAAAAAAQAAAAYAZwAIAAAAAgAAAAAARwAyAAAAAAA8AEUAAAAAAAEAAAACABAAAQAAAAAAAQAAAM4ALAAAAB0AAAASAAAAAAARAAMAHAAHAAAAAQBqAAEAFgAAAG8AAAABACUAAAAnABAAAAAiAAAAvAAAAAkAAAAAABUAAAAAABMAAACHAAAAOgAnAAAABQAWAAUAFAASACEABQACAAEAAAAVACYAAAAEAAAAAAABABcAGQAAAAQAAAADAAAAEAABAAEAAAAFAAEAAAAAACIAAAACAAQAEwAAABEAWgAFABMADQBOAAgABAAYAAkAZAAmAAAAEQAAAAUAMAAAAAEAAQAAAAIAAQA+AEYABQAAAAEAAAABADcAAAAAAAUAAwAAABMAAgAAAAEAAAAGAAAACwAcAAEAAAAFAC8AAQAAAAgAHQAwAAAAJQACABIAAAAAACMAAgAAAAAACwAYAA4AAAARAAwAFQACAAAAAAADAAAACAAIAAgAAAAAAAkADgAAAAEACQAsAAMAAQAWABEAQfybxAAL5wEEABgAAQAwAAQADAAOAAkAAAADAAsAAAACAAUAAAAQAAMAAgAGAAsACAAKAAAACAADAAEAJQADABsAAgASAAUABwASAAAAEAAAABEAAAAJAAAACQAAAAwAAAAAAAEAAAAAAAAACAAAAAAAAAADAAAAAAAAABcAAAAAAAMADAAAAAAAAgABAEMAAAAAAAsABQAJAAAAAAAiAAIABAACAAIAAQABABQAAQAxAAAABAAgAAkABwABACEAFgABAAIAAAAGAAAADgAAAAUAEgAOAAQAAAAAAB0AAAAAAAYAAAAKAAAAAAAAABYAQeydxAALcQgAAAABAAAACwAAAAEAAAAAAAAABAAAAAAAFgAAAAEAAAABAB0ABwAAAAEABgAEAAEAAwAOAAkAEAAIAAIAAQAAAAAAAwACAAIAIgAAAAAABAATABEAAAACAA0AAAABAAQADAABABYADgACAAAAAAAEAEHonsQAC20VAAAAAAADAAAAAAAAAAwAAAAFAAQAAAAAABEADQARAAAABAAAAAMAAgABAAMAAQACAAIAAgABAAEAAwABAAEAAAACAAIAAgABAA0AAAAAAAAAAQACAAYADQABAAEABAAMAAIABgAAAAQAJwAcAEHmn8QACwEKAEH0n8QAC4sBDwAHAAgAAAADAAAABAAAAAAAAQAAAA8AAQAAAAAAAAACAAMAAAAWAAsABQAAAAAAAgAIAAQAAAAIAAAAAAAAAAMABAAAAAEACwABAAAAAAAYAAkABAAHAAAAAQACAAEAAAAAAAEAHgAAAAIAAQAAAAAACQAAAAAAAwAKAAIAAwABAAAABAAAAAQAHwBBjqHEAAudASQABwAFAAIAAgAKAAEAAAAAAAMAAAABAAwAAAABAAAAAAABAAIAAQALAAAAAAABAAMABgACAAwADgAeAAAAAAAQAAAAAQACAA0AAwAAAAYAAAACAAoABAAAAA8AEAACAAEAAgAGAAAAAAALAAAABQANAAIAAAADAAcAAAAFAAQAAAAAAAYAAQAAAAAADwADAAAAAAAMAAAAFwACAAkAQbaixAALXQIAAAAHAAEAAwANAAAABQAHAAQACAAAAAsACAAJAAEAAAAAAAkABQAAAAgAAQAAAAYAAAAIAAAABwAAAAIAAgAFAAQABQAAAAAAAQATAAgAAAAAAAEAAAAKAAAABgBBnKPEAAuHAQwAAgAEAAIAAAAAAAMAAAAEAAAAAwACAAcAAQAAAAAAAAADAAAAAAAAAAMAAAAAAAAABAAAAAEAAAACAAAAAAACAAcAAAAEAAAAAQABAAEACQACAAIABgADAAAAAAAAAAEABgAFAAIAAAAAAAQAAQACABEAAQAAAAAAAQABAAUAAAABAAAABwBBrKTEAAttAwAOAAAAAAADAAAAAAAAAAIAAQAAABAAAAAAAAAAAgAAAAIAAgAGAAAACQAAAAYAAAABAAYABQABAAEAAgAIAAIAAwABAAQAAQAAAAAADQACAAAAAAABAC8AAQACAAEABgAVAAAAAAAAAAwABABBoqXEAAsBGgBBrKXEAAtzAwAHAAAACQACAAEAAAABAAEAAAAAAAAAAwAAAAIAAAAKAAAAAAABAAAADgACAAIACQACAAsAAgABAAMAAQAAAAAACgADAAEAAQACAAIAAgAAAAIACQAAAAAAAQAGAAEAAAAHABgAAQAAAAcAAQABAAAAGQBBsKbEAAsBAwBBvKbEAAtbBAACAAAAAAABAAAACwABAAUAAAAAAAAAAwACAAYAAgABAAUAAQAGAAMAAQACAAEAAQAcAAYAAgACAAMAAQAIAAAAAgAAAAEAAwABABYABgALAAAABAAEAAEAAgBBoKfEAAsNBAAAAAQAAAAAAAAAFgBBtqfEAAvPAQMAAAAAAAAAAQAAAAQACQAPAAUAAAABAAEACAAAAAEAAAAAAAEAAgABAAEAAQAAAAEAAAAIAAEAAgABAAMAAgAAAAIABAABAAEABAAAAA8AAAAAAAAAAgAJAAEAAAACAAAAAgAEAAEAAAAHAAUAAwACAAoAAgADAAAABQAAAAAAAAAGAAIACgAAAAEABgAFAAAAAgADAAEACAACAAAAAQAAABQAAAABAAIABQAAAAEAAQAAAAEAAAACAAkAAAADAAEAAAANAAEAAAAAAAEABABBkKnEAAttAgAOAAAAAgAXAAUAAAAAAAEAAgAIAAAAAQAJAAMAAAABAAcAAAAEAAEACAAAAAAAAAABAAAAAAAAAAIAAgAFAAAABQAEAAEAAAADAAAAAgACAAMAAQAPAAEAAwACAAAAAAAAAAEABQAAAAIABwBBhqrEAAtpAQAAAAAACAAGAAAAAAABAAAAAAAKAAQABQAAAAAAAAABAAAAAgAAAAAAAAAEAAAACQABAAEAAAAGAAAAAAAQAAEAAgAFAAEAAQAAAAAABAAAAAIAAgACAAAAAAABAAEAAwABAAMAAAADAEH4qsQAC+kBAQAGAAQAAQABAAIACAADAAMAAAAAAAQAAgABAA4AIAAAAAEAAQAMAAAAAAAAAAQAAAACAAAAAAAAAAQACgACAAEABAAGAAAAAAAAAAYABgAAAAMAAAAEAAEABwABAAYACAABAAcAAQABAAAAAQACAAMAAAAGAAAAAAABAAgAAAADAAEAAQAGAAIAAAACAAQABgABAAQAAwAGAAEAAwACAAQAAgAAAAYAAgAAAAUAAQABAAIAAAABAAIAAQABAAIAAgAHAAMAAwAAAAEABwABAA4AAAABAAAACwAAAAEAAgABAAEAAwAAAAEAQfKsxAALAQUAQf6sxAALYwEAAgAAAAAAAwAGAAMAAgAGAAAAAQADAAEAAgABAAIAAwAAAAMAAQACAAQAAwAAAAAAEAABAAIAAAABAAAAAwABAAIAAQABAAEAAAABAAAAAQAAAAAAAAACAAAAAAAFAAUAAQBB7K3EAAsDAQAFAEGCrsQAC10CAAQAAgABAAEAAAACAAAAAAABAAAABwALAAMAAQACAAEAAgABAAcAAQAEAAEAAQAAAAEAAAABAAMAAQACAAIABQABAAEACQABAAEAAQAAAAIAAwABAAAAAAAIAAEAQe6uxAALcwMAAAAAAAAABQAAAAQAAAAAAAAAAQADAAEAAAABAAEAAwABAAAAAAAAAAMABAAJAAYAAAAJAAYAAgABAAMAAQABAAIABAACAAMAAgAAAAYAAQAAAAIAAAAAAAUACgABAAAAAAAEAAAAAAAEAAAAAQACAAEAQeqvxAALAQEAQYCwxAAL+QENAAAAAAADAAMAAAABAAIAAQAAAAMAAAABAAAAAAAAAAMAAAABAAIAAQAAAAQAAgAAAAEAAwAAAAIAAwAFAAUAAAAAAAUAAQABABAAAQADAAIAAAABAAEAAwABAAYABQABAAIAAQACAAAAAwAAAAEAAAAAAAAAAQAAAAAAAwAHAAEAAgADAAAABgACAAEAAAAAAAEAAAACAAEAAAADAAEAAQADAAAAAgABAAEAAgABAAAAAAABAAAAAwAAAAAAAgADAAAAAgAAAAIAAQAAAAMAAAABAAAAAAAFAAIAAgACAAAAAgAHAAUAAwABAAAACgABAAEABAAAAAYAQYSyxAALRwEAAQABAAIAAAADAAEAAQABAAMAAwABAAQAAQAAAAEAAQABAAMAAQAFAAAAAgAAAAEAAQAAAAQAAAACAAEAAAAAAAAABAACAEHUssQACwUEAAIAAwBB4rLEAAtBAQAAAAoAAQACAAIAAQADAAAABgABAAMABgAAAAIAAAAAAAEAAAAEAAUABAABAAIAAAADAAAAAQACAAQAAQAAAAMAQayzxAALgwEBAAEAAQABAAEAAwAAAAEAAQAAAAMAAAABAAQACgAAAAMABAAFAAUABwADAAMAAgAAAAEAAgACAAQAAAABAAAAAAAAAAIAAAAAAAkAAwAQAAEAAAACAAAAAQAEAAAABQACAAAABQAAAAEAAQAEAAAABwAGAAQAAAAAAAEABwAAAAIAAwBBurTEAAsBAQBBxLTEAAtfAwAAAAEABQACAAYAAQACAAUABgACAAQAAAADAAEAAgABAAEAAAAAAAIAAQADAAYAAQABAAEAAwAHAAAAAAAAAAIABAAAAAEAAQADAAEAAQACAAAAAQAAAAUAAgAFAAEAQbq1xAALBQUAAAAHAEHItcQAC2UEAAAAAgAEAAAAAAAAAAEAAAAAAAIAAAAAAAEAAAABAAEAAQAEAAIACwABAAAAAAABAAQAAgAAAAEABAABAAIAAgABAAIAAgAAAAAAAAAFAAIAAgAAAAAABAAEAAUAAgAAAAAADQBBuLbEAAttAgAAAAYAAAADAAAAAAAAAAEAAgABAAEAAgAJAAMAAAAAAAMAAAABAAEAAQACAAAAAgADAAEABAAAAAIABwABAAAAAgABAAEAAQACAAAABQADAAAAAAABAAAABQAAAAEAAAAHAAAAAAACAAEAAQBBuLfEAAsBAgBBxrfEAAvFqAIEAAQAAAAAAAEAAgAGAAAAAAACAAEAAgAAAAEAAAACAAIAAgAGAAEAAQAHAAAAAQACAAUAAQACAAEAAQABAAMAAgACAAEABAAAAAAAAAAEAAEAAQAAAAIAAAABAAMAAAABAAIAAAAjBAAABAMAAAhbAACxMAAAmTAAAJcDAAATAwAAQgMAAEcAAAAHAwAAMk4AAOGIAABMAAAAMQMAAL9PAABlAAAAAwMAAPFTAABhAAAABAMAAK2VAAD0fQAAtwMAABQDAABFAwAANwQAAAgDAADGAAAABAMAAGUAAAAnAwAAVQAAABsDAAC2jwAAmQMAABQDAABVAAAABAMAAAgDAACpAwAAEwMAAAEDAAD0dgAAGTsAAEkAAAADAwAAkXgAAKRRAAC1ZwIA5YIAAGEAAAACAwAACQMAAMUDAAAUAwAAf1MAAL9sAACpAwAAAQMAAGhhAAB5ggAAvX8AABqSAgBzAAAAJwMAAGsAAAAxAwAA5wUAALwFAADGewAA2GAAAN5SAADDMwIAcQ8AAHIPAABlAAAABAMAAAADAABPAAAAAgMAAAEDAABBbQAAHgQAAAgDAADJAwAAEwMAAAADAABFAwAAHYMAALcDAAAAAwAARQMAAGw6AAABiwAAszAAAJkwAAAOhwAAdQAAACQDAADPYgAAJlYCAFeEAAAHGwAANRsAAAMiAAA4AwAAQQAAAAkDAABPAAAAKAMAAGkAAAADAwAAHp4AALEDAAAUAwAAAQMAAEUDAAB6AAAAIwMAAGtFAABGUgAAG40AAAiNAACwjwAATwAAAAcDAAAEAwAAdQAAAAYDAAB0AAAAJgMAAKuMAABY0QEAZdEBAG/RAQBWZwAAEwQAAAEDAABVAAAABAMAABUJAAA8CQAAUHIAAKB9AABsAAAAIwMAAAQDAADzWwAAQQAAAAYDAAABAwAAuQMAABQDAAABAwAAt5YAAFMAAAAnAwAAbQAAACMDAAAQVQAANJIAAC5iAABPAAAAIwMAAAIDAAD/lwAATwAAABsDAAAAAwAAlpQCAMtuAABpAAAACQMAAAgwAABoAAAAMQMAAFODAABemAAATQQAAAgDAABBAAAAAgMAAHUAAAADAwAAAQMAAEMEAAAIAwAAuQMAAAYDAAB5AAAAIwMAAGgAAAACAwAA6QUAALwFAADBBQAAtwAAAJh0AAAjlwAAVQAAAAsDAABkIgAAOAMAAGZ5AgAYggAAQlQAAJyfAAAxWAAAZQAAACMDAACcZgAAknwAABw5AABiXAAAbl0AAC2GAAC6bgAAJwQAAAgDAAA1BAAACAMAAKgiAAA4AwAASnAAAOoWAgAEawAAumsAAG8AAAAIAwAAaAAAAAgDAACfAwAAEwMAAKUDAAABAwAAdQAAACMDAABCaQAAZVwAAGEAAAAGAwAAAQMAAGptAACdVQAA7kICAEgAAAAHAwAAVQAAABsDAAAAAwAAB1IAAPqIAAB1UwAAMgoAADwKAABjAAAAJwMAAM9QAAB0ZgAAogkAALwJAACrVQAAqV8AANYFAAC8BQAAvn0AAHw4AABbMAAAmTAAALKAAABHAAAAJwMAAP6KAAD4ZgAAPlsAALEDAAAUAwAARQMAAEsAAAB6AAAADAMAAPlWAACccQAAP1MAAJJMAgBIYQAATQAAACMDAAAyEQEAJxEBAKkDAAATAwAARQMAAEEAAAAAAwAAIWcAAGeGAACpYwAAGJgAAHUAAAALAwAA0lIAAEyIAACpAwAAEwMAAAEDAABFAwAAYQAAAAoDAAABAwAA+IgAALUDAAAUAwAAYQAAAA8DAAA9YwAAO58AALFiAABXAAAAIwMAAJaJAACRZgAAbgAAAAEDAAB4AAAABwMAAO2FAgBvggAAKnkAALEDAAATAwAAQgMAALEDAAAAAwAARQMAALyNAADBAwAAEwMAAHKQAAB5AAAAAgMAAEp3AABFAAAACAMAAJcDAAAUAwAAQgMAAEUDAADyUAIAen8AAJeeAADFAwAAQgMAAFIAAAAnAwAAWQAAAAcDAABnbAAATgAAACMDAAADUgAAOAQAAAADAAC/HwAAQgMAAG8AAAAJAwAATgAAADEDAACcbgAAH3cAAEooAgBjAAAAAgMAAJIiAAA4AwAAUQ8AALcPAABLMAAAmTAAAPaWAABJAAAABgMAAON8AABrbQIAeDAAAJowAACGhwAAlQMAABQDAAAAAwAApQMAABQDAAABAwAAynMCAFRrAACZZQAAuJYAALEDAAABAwAARQMAAG8AAAAbAwAACQMAAG8AAAAHAwAAMwkAADwJAACcMwIApQMAAAYDAADMeAAABYAAADAEAAAIAwAAJSIAADgDAAAzSwAAVQAAACMDAAC5AwAAQgMAANNqAABxdAAAPnUAAKUDAAAEAwAAyQMAAAEDAABFAwAAyBkCAI4/AgAvCQAAPAkAAEkAAAABAwAAp1oCAJBhAABDAAAAJwMAAAEDAADyMAAAmTAAANgEAAAIAwAAiGYAAHUAAAAIAwAAAQMAAE8AAAAoAwAABAMAADlOAADkBQAAvwUAAEEAAAAKAwAA5h0CAAsbAAA1GwAA14gAAMBcAADmSQAATwAAAAkDAADZDQAAyg0AALEDAAATAwAARQMAAHIwAACaMAAAhyIAADgDAABpAAAADAMAAEEAAAAjAwAAAgMAAO5YAABPAAAAAwMAAAQDAACXAwAAEwMAAEIDAABFAwAAVYwAAB5tAACzXgAAtAAAAJEDAAAUAwAAAAMAAPiKAABXAAAAAQMAAC46AAC5AwAAEwMAALEDAAAUAwAAQgMAAEUDAAAFGwAANRsAANeSAABNUQAAsQMAABMDAADWfAAAQQAAABEDAABhAAAADAMAAAWhAgB0VgAAFgQAAAYDAAAoWwAA45YAANpQAAB1AAAACgMAAEUAAAAGAwAAxgwAANUMAAANGwAANRsAAIqLAABMAAAAAQMAAMpTAABHCwAAVgsAAPEwAACZMAAAVVUAAFcwAACZMAAANEMAAHpzAADGAAAAAQMAACMiAAA4AwAAUoMAAJ07AAD+HwAAAQMAAGcAAAAMAwAAZAAAAC0DAAByfwAAvx8AAAEDAABSAAAABwMAACdCAADtigAAZAAAADEDAABwdQAAZwAAAAIDAACJdAAAyngAAJkDAAAIAwAAc1kAAEsAAAABAwAAtQMAABMDAAABAwAAo5YAAKkDAAAUAwAARQMAAFMAAAAjAwAAGlkAAEh5AAC3AwAAEwMAAAADAABjCwIA1WwCAASTAADDlgAAwHsAAI1cAAB9UwAAT2UAAEMAAAAHAwAAaQAAABEDAAC5AwAAAQMAAO+DAAA+gQAAy3oAAIx4AADyYQAA6HwAADRiAABJAAAAAgMAAGEwAACZMAAAdQAAAAADAACxAwAABgMAAJILAADXCwAANUcCALEDAAATAwAAAQMAAEUDAABDBAAABAMAAJwPAAC3DwAATSIAADgDAACXAwAAEwMAAMVWAgB3IgAAOAMAAEGJAAAGhgAAOAQAAAYDAAA1GQEAMBkBAGkAAAACAwAAWgAAAAcDAABEAAAAIwMAAFQAAAAHAwAAVQAAAA8DAABWDwAAtw8AAMdSAAC5FAEAuhQBAEEAAAAEAwAARwAAAAwDAADjQAAAx0YAAAtEAACzIgAAOAMAAKkDAAAUAwAAAAMAAEwAAAAnAwAA2JIAAPErAgB3UgAAqHwCACNlAgArcgAAYQAAAAYDAAAAAwAATTAAAJkwAACRAwAAFAMAAAEDAABGDQAAPg0AANkFAAC8BQAAWTAAAJkwAABGgAAAFm0AAK0wAACZMAAAPmMCAEEAAAAKAwAAAQMAAEcAAAAEAwAA3nMAAM6eAABpdgAA1AUAALwFAACDIQIAZloAANhZAABpAAAAKAMAAO1MAABzAAAABwMAAOYAAAABAwAAIgECAMUDAAAIAwAAAQMAAIVoAADJAwAAEwMAAEIDAABFAwAAbwAAABEDAADJAwAAEwMAAAEDAABFAwAAxgwAAMIMAADVDAAAUHkAADxrAgBuAAAALQMAAAZ1AADrUwAAxQMAABQDAAABAwAASwAAACMDAAD6hQAAZQAAAAIDAAAAZwAAeGUAAHUAAAABAwAAawAAACMDAAB0AAAAMQMAAOdbAAAylwAAyVIAAH95AAAYBAAABAMAAHIAAAAxAwAANgQAAAYDAAA2BAAACAMAALkDAAAIAwAAAQMAAAhGAgAYBAAABgMAAKNpAAA6GwAANRsAAKgWAgBFAAAAAgMAAAADAABIAAAAAgMAADZMAgDQIQAAOAMAAN80AAC3AwAAFAMAAAEDAABFAwAAQX4AAOoFAAC8BQAAawAAACcDAAAFnwAAWAAAAAgDAAD4TAAAI28AAEqTAAA+AAAAOAMAAC9uAABhAAAAIwMAAMYwAACZMAAAWw8AALcPAAC5FAEAsBQBAPGZAADpBQAAvAUAADEjAgC50QEAZdEBACMEAAAGAwAAVgAAACMDAACxAwAAQgMAAFQAAAAMAwAApXMAAJkDAAAUAwAAAQMAAJEDAAABAwAAtwMAABMDAAABAwAAEpsAAMp2AABlAAAABAMAAAEDAADTXgAAXzMCALSdAADKXgAA0AUAALcFAADnUAAAkQMAABQDAACNUQAAuzQAAIF6AAB2SgAAyQMAABMDAAAAAwAAQwAAAAEDAABlAAAAAgMAAAEDAACZAwAAEwMAALcDAAATAwAAgFwCAAVTAABFAAAAAQMAAE4AAAAMAwAAYIgAAHIAAAARAwAAlwMAABQDAAABAwAARQMAALcDAAAUAwAAAQMAAGFFAAD6UgAACCIAADgDAACyDwAAgA8AABx6AACXAwAARQMAAMkDAAATAwAARQMAAGwAAAAnAwAAYQAAAAYDAAAJAwAAUgAAACMDAADVBQAAvAUAAItPAACLiQAAyQMAABQDAAABAwAARQMAAE8AAAAHAwAAVQAAABsDAAADAwAAVQAAAAgDAAAEAwAAUwAAAAIDAABhAAAAAwMAAHgwAACZMAAA2AUAALwFAACLVwAANXIAAE8AAAAGAwAAdQAAADADAAAabgAAcgAAAA8DAABMYQAAZQAAAAYDAADPMAAAmjAAAG4AAAAjAwAAhWcAAERZAACZAwAABgMAAFoAAAAjAwAA7jYAANkFAAC0BQAA0ooAAL+KAACEVQAAdgAAAAMDAABWlwAAQQAAACgDAABHBAAACAMAAM6gAgCgYwAAIn0AAPyYAAC1AwAAAQMAAOt5AABvAAAAGwMAAAADAACAcgAAOUAAANpkAgD0VwAAjmEAAGBhAADRBQAAvwUAAJkDAAAUAwAAAAMAAEEAAAAIAwAAmRABALoQAQABAwAAZAAAACMDAAAWBAAACAMAAFpYAAB1AAAAGwMAACMDAABpbQAAqAAAAAADAABgAAAAQQAAAAIDAAABAwAAaAAAAAwDAAAXZwAA1CYCAHtnAADCiAAAawAAAAEDAADIjAAA0gMAAAgDAACZUAAAYgAAADEDAACxAwAABAMAAOQ6AABkAAAAJwMAALkDAAAIAwAAAAMAAFfRAQBl0QEA81ACAFUAAAAbAwAAIwMAAE8AAAAbAwAAAwMAAFEwAACZMAAAbgAAAAwDAAC/AwAAEwMAAAEDAABkAAAABwMAAEhUAABGMAAAmTAAAHIAAAAjAwAAQHoAAFiLAABBAAAACAMAAAQDAABCAAAABwMAABGRAAD1UgAAxQMAAAQDAABpAAAAIwMAAFFTAACpAwAAFAMAAAEDAABPAAAAAwMAAAEDAABBAAAAJQMAALhPAgBjiAAAlwMAABQDAAABAwAAnwMAAAEDAAC5FQEArxUBAEBRAAC1WgAAkQMAABMDAAAAAwAAsQMAABQDAAAAAwAARQMAAG8AAAAbAwAAIwMAAPw/AADbagAA1UMAAMUDAAATAwAAAQMAAEUAAAAEAwAAAQMAADuYAABaAAAAAQMAAOkFAAC8BQAAwgUAAIdVAADeBQAAvAUAALFvAgAQcgAAVQAAAAkDAAAiWQAA2UMAAE0AAAAHAwAAtSIAADgDAAC/AwAAFAMAAAADAAA4BAAACAMAAB92AADJAwAAFAMAAAADAABFAwAAoEIAAElxAAC2XgAAaQAAAAEDAAAePQIA224AAHdtAADJAwAAQgMAAEUDAAAhCQAAPAkAABCJAAC5AwAACAMAAGlkAABJAAAAIwMAADd+AAB1AAAAKAMAAGODAABFfgAA8lgAAA6iAgDGZgAAOXAAAJAPAAC1DwAAapEAAEUAAAAJAwAA/l4AAIuAAABBAAAABgMAAAkDAADRbgAAdQAAAAgDAAAAAwAApQMAAAgDAAAPbwAA+mcAAJUDAAAUAwAAuzAAAJkwAABdMAAAmTAAAHcAAAAHAwAAwHIAABdTAAD1UQAAlGAAACmZAACoWAAAGAQAAAgDAADBjAAA0T4CAA1OAAAYQAAAyQMAAAADAABFAwAAVwAAAAcDAACGTwAAeQAAAAkDAABTXwAAzlcAAFl1AAANWAAAaAAAACMDAABlAAAAAgMAAAADAABvAAAAGwMAAAEDAABlAAAADwMAAFNVAAD2YQAAkQMAAAYDAADHCwAAvgsAAAZWAACuTwAAxwkAAL4JAACsWAAApQMAABQDAAAAAwAAwQYAAFQGAAAhCwAAPAsAAEl5AAC3AwAAFAMAAAADAABFAwAARVEAAKUDAAAUAwAAAKYCACZOAAA8eQAAYjgAAFBjAACjUgAAh3MAAH+eAACRAwAAFAMAAAEDAABFAwAAtwMAABQDAABCAwAARQMAAEQAAAAnAwAAb4AAAI95AAAWhQAAbQAAAAcDAADHbgAA7FkAAFMAAAAMAwAABwMAAFkAAAADAwAAs1UAACJfAAB2AAAAIwMAAJcDAAAUAwAAQQAAAAYDAAAAAwAAtwMAAAADAAB1AAAAGwMAAAEDAABUAAAAJwMAAE8AAAAAAwAAFTUAAHkAAAAEAwAAqyIAADgDAAChAwAAFAMAAFRZAACLdwAAaV4AAPmeAAAwCQAAPAkAAEkAAAAHAwAAagAAAAIDAAB1MAAAmTAAAKEPAAC3DwAAKwQAAAgDAAC3AwAAFAMAAEIDAADabQAAAAMAAL5GAABhAAAAJQMAAG8AAAACAwAAAAMAAGEAAAAGAwAAQQAAAA8DAAB6AAAABwMAAM6QAABEAAAALQMAANMFAAC8BQAAG2cAAG8AAAADAwAA8DAAAJkwAABSAAAADwMAAG8AAAABAwAAYE8AAMVjAABUAAAAJgMAAEUAAAAnAwAABgMAAEcAAAAGAwAAkQMAABQDAABCAwAARQMAAD55AAAcCQAAPAkAAElSAgBaUwAA7YEAALSRAABFAAAAEQMAALcDAABCAwAARQMAAMUDAAAIAwAAhpYAAG8AAAAIAwAABAMAALdRAABPAAAAGwMAACMDAACSowIAlkAAAGlfAADxkAAA6m0AAHMAAAACAwAASAAAACMDAAB8WQIAQQAAAAIDAAAAAwAAQQAAAAIDAAAJAwAA7zAAAJkwAACuTgAAmZEAAGRcAAB4bQAAul0AAOkEAAAIAwAAEoYAADRtAABFAAAAIwMAAAIDAACnmQAApRABALoQAQBtAAAAAQMAAIMiAAA4AwAAEwMAABdoAAD+mQAAu54AAEMEAAALAwAAZQAAAAQDAADFAwAAAQMAANIhAAA4AwAAxQMAAAADAABhAAAACgMAAHswAACaMAAAkaICAC6HAgADgQAAtwMAABMDAABFAwAAdwAAAAgDAABPAAAAAgMAAHwiAAA4AwAAtwMAAAEDAACvYQAAmXAAABdSAAB1AAAAEQMAAGEAAAAjAwAABgMAAHphAACoAAAAAQMAACpzAACUkAAAYQAAAAcDAAAEAwAAKZgAAFIAAAABAwAAsQMAAEIDAABFAwAAdQAAABsDAAADAwAA02IAAIuCAABPAAAABAMAAAEDAABIBgAAVAYAAL2DAAAvOAAAuQMAAAgDAABCAwAACXQAANiBAABQAAAABwMAALRmAABdeQAAWQAAACMDAADLjQAATAAAACMDAADSBgAAVAYAAAuYAABBAAAAAgMAAAMDAACkYQAAO48AANJ8AABXAAAAAAMAAG8AAAAMAwAAyQMAABQDAAAAAwAAqQMAABQDAAABAwAARQMAABtyAAAbWgAA2zAAAJowAABDBAAABgMAAK1wAABiAAAAIwMAAEUAAAAMAwAAyQMAABQDAAAWnwAA0oUCAEwAAAAMAwAA0gUAALwFAABhAAAAAgMAAAEDAADZDQAAzw0AAMoNAABFAAAAKAMAAGUAAAARAwAAqQMAAAADAAAIQAAAPV4AABNmAACoZQIAiGwAAEsAAAAnAwAACRsAADUbAAByMAAAmTAAANlwAACRIgAAOAMAAD0AAAA4AwAAyQMAABMDAABCAwAAVFEAAAMgAACRAwAAEwMAAEUDAACpAwAAEwMAAEIDAABFAwAAHXYAAJkDAAATAwAAAAMAAFJkAAAiCQAAPAkAAG1RAAA/GwAANRsAAMKMAABMAAAALQMAAI6fAAAVBAAAAAMAAAF3AABWAAAAAwMAANIDAAABAwAAVQAAACgDAABmAAAABwMAAK9yAAA8AAAAOAMAAHJSAABxDwAAdA8AABgbAgAcBQIAcyIAADgDAACZAwAAFAMAAEIDAADVMAAAmjAAAFUAAAAAAwAAmVUAABttAABlAAAAJwMAAAYDAABvAAAAKAMAAHpQAABrRAAAjnkAAD58AACeNAAA4pgAAHcAAAAAAwAAxGQAAF8wAACZMAAApQMAAAADAACZAwAAAQMAAAZZAACVAwAAAQMAADM9AABwcAAAbwAAAAQDAABY0QEAZdEBAHDRAQDNhQAAxzgAAG8AAAADAwAABAMAAFecAADBMAAAmTAAANIwAACaMAAAz5EAAMUDAAAIAwAAAAMAAGkAAAAAAwAAnwMAABQDAADEYwAA2mECAGEAAAAGAwAAAwMAALOCAABpAAAABAMAAE8AAAARAwAAVQAAAAMDAADFAwAAEwMAAEIDAACBYAAAjXkAAERQAgBVAAAAAQMAAEUAAAACAwAAAwMAAHoAAAAxAwAAyQMAABQDAABCAwAAAYgAAA9UAAA4VAAAHVQAADmLAABWBAAACAMAAMBVAAA+fwAATmwAAG4AAAAxAwAAgk4AAE8AAAAEAwAAAAMAANhYAABWZQAAgiIAADgDAABBAAAAIwMAAHUAAAADAwAASIwAAHUAAAAbAwAAAAMAAOJ1AAB8kgAAsmEAAAsdAgDGDAAA1gwAALtrAADMbAAAVAAAACMDAABBAAAAIwMAAAYDAABiXwAAQQAAAAMDAAB1AAAAGwMAALUDAAAUAwAAAAMAAHMAAAAjAwAARQAAAAQDAAAocgAAhVsAAEwAAAAjAwAABAMAALcDAAATAwAAAQMAAEUDAABggAAAUVYAAK5rAAChCQAAvAkAAHUAAAAIAwAAVQAAABsDAAAJAwAATwAAABsDAABchgAAxgsAAL4LAAAsCgIAQJwAAEOfAADEMAAAmTAAAMttAAAWVwAAUgAAADEDAAB3ZAAAoU8CAG8AAAALAwAAqQMAAEUDAABAWAAAYwAAACcDAAABAwAA7oQAABRpAAD8YgAAgTcAAGcAAAAnAwAA3AUAALwFAAB4AAAACAMAAEMAAAAMAwAAGDwAAFFZAAAidAAA84QAALtPAADPMAAAmTAAAHmHAADZYgIA/p4AAJMzAgBqmgAAJo8AAMlRAADrbwAAkQMAABMDAAABAwAARQMAALkDAAAUAwAAQgMAAOgFAAC8BQAAZjAAAJkwAADKdAAATwAAAAIDAAAAAwAATgAAAAMDAABIAAAAJwMAAFkAAAAIAwAAZIUAAHMAAAAMAwAARCgCABUEAAAIAwAAPCIAADgDAAA/XAAApzgCAG4AAAAHAwAARGEAABAEAAAIAwAASwAAADEDAAAfiAAAZQAAAAIDAAAJAwAASTsAAMyDAAAEXwAAeQAAAAcDAAAZXQAA7F4AAMUDAAATAwAAtwMAABMDAAAAAwAARQMAAHEPAACADwAATmEAAE54AACpAwAAFAMAAAADAABFAwAAVQAAAAgDAAAMAwAA5oIAAFgAAAAHAwAACX4AAKgAAABCAwAAq1sCAAgDAAABAwAAuQMAABMDAAABAwAA5E4AAHQAAAAnAwAA1QUAALkFAADHCQAA1wkAAHQAAAAtAwAAYQAAAAIDAACfngAA118AABtiAACfAwAAFAMAAAEDAAB5AAAAAwMAAHNTAADekAAAZ1EAANUzAgBlAAAAAgMAAAMDAACvCQAAvAkAADo5AABvmwAARQAAACcDAACSUQAAudEBAGXRAQBu0QEAsQMAABMDAABCAwAARQMAAPw2AABPAAAACAMAAAQDAABtNAIAFwoAADwKAACVAwAAAAMAAG8AAAAoAwAABAMAAMhwAACIhgAAOJIAAMuKAAB1AAAACAMAAAQDAADRBQAAvAUAAG4AAAAnAwAAWQAAAAADAADJAwAAFAMAAEUDAABFAAAALQMAAB5wAABiWgAAegAAAAEDAABsAAAAMQMAAFUAAAAwAwAAaAAAAAcDAAB3AAAAAgMAAE0AAAABAwAA2QQAAAgDAACSIQAAOAMAAFcAAAAIAwAAEH0AAE4AAAAHAwAARQAAADADAADJAwAAFAMAAAEDAABFIgAAOAMAACMEAAALAwAAQ10AAGkAAAAIAwAAAQMAAMJVAAAEggAAyoMAAEkAAAAJAwAAcgAAACcDAAAiZAAA4QUAALwFAABLBAAACAMAAL2CAABJAAAAKAMAAK55AABFAAAAAwMAAGcAAAAEAwAA9lQAAEUAAAAHAwAAMwQAAAEDAACzUgAAWNEBAGXRAQBy0QEAUmgAAIBRAADKjgAAl1EAAAZUAABkAAAADAMAAE8AAAABAwAAaDAAAJkwAABzAAAAAQMAAAcDAADjBQAAvAUAALkwAACZMAAAlwMAABQDAAAAAwAARQMAAFUAAAAGAwAAQwAAACcDAACGXwIAIHsAAFIAAAAMAwAAWNEBAGXRAQBx0QEAYQAAAAIDAAAAAwAAhiIAADgDAAD0ZgAAkQMAABMDAABCAwAARQMAADCbAgA1RgAARAAAADEDAAD3lgAAZQAAAAADAABuXAAAozYCAF5nAABTAAAAJgMAAGQwAACZMAAAsQMAABMDAAAAAwAARQMAAH8BAAAHAwAAaQAAAA8DAAC5AwAABAMAAOCXAACmMAAAmTAAAJUDAAATAwAAAAMAAFIAAAAjAwAABAMAAHVgAADUjgAALpYAAHUAAAAIAwAADAMAAJEDAAATAwAAQgMAAOd8AAB8kAAAZQAAAAcDAAB+gAAATwAAAAIDAAADAwAAJwYAAFUGAAAohwAASCIAADgDAAB1AAAADAMAALeVAACFdAAArD4AAOJVAADiXQAAIWsAAC99AACSDwAAtw8AAB53AABVMAAAmTAAABYJAAA8CQAAoiIAADgDAADJAwAAQgMAADhOAABQXQAANoMAADt1AABdYgAATwAAAA8DAABCdgAAAiAAAIVtAAAYBAAAAAMAAL8DAAABAwAAT3oAAFUAAAAkAwAAJQUCAE5nAACueAIAF1cAALEDAAAUAwAAAQMAANAFAAC8BQAApl4AAGkAAAAIAwAAutEBAGXRAQBv0QEAzE4AAEUAAAACAwAAlCEAADgDAABJAAAACAMAAAEDAADYMAAAmjAAAHxdAABVAAAACAMAAAADAAA+BAAACAMAAPdYAABqAAAADAMAAN6IAABTAAAAIwMAAAcDAABIWQAA2wUAAL8FAACfawAAhX8AAPlfAACXAwAAEwMAAAADAABFAwAACGEAALnRAQBl0QEAb9EBAG8wAACaMAAAJRAAAC4QAABleQAAYgAAAAcDAABZQwAARwsAAD4LAACVAwAAFAMAAAEDAAB0AAAADAMAANuXAAC4MgIAZ50AAF1FAABFAAAAAAMAAINjAAAAfQAACpQCAElmAADyBQAAtwUAAEZAAAB3UQAAFwkAADwJAADbMAAAmTAAALMPAACADwAAbm4AAKkiAAA4AwAAi18AABxkAABIAAAALgMAAEMAAAACAwAAoIoAAHUAAAAEAwAACAMAAONlAAA4jwAAWNEBAGXRAQBkiQAAqooAAE8AAAAbAwAACQMAAKdnAgC1AwAAAAMAAE8AAAACAwAACQMAABBiAADiZQAASgYAAFQGAACndwAAUIYAAHdwAAB4lgAAtVEAAJcDAAAUAwAAQgMAAG8AAAAjAwAAAgMAANAFAAC4BQAAU2cAAEEAAAAGAwAAAwMAADiQAADDWwAA6AQAAAgDAABvAAAAIwMAALEDAAAUAwAACDsAABB2AAAaBAAAAQMAAPqdAAA6UgAASAAAAAgDAACRAwAAEwMAALEDAAAUAwAAAAMAANN+AgD9XQAAEAQAAAYDAAC9MAAAmTAAALkDAAATAwAAAAMAAM5LAABaAAAADAMAAGwAAAAtAwAAKJkAAO56AAAjgwAAqQMAABQDAABCAwAA740AAORSAACXAwAAEwMAAAADAABADwAAtQ8AAGEAAAAAAwAAlX8AAHCAAACSAgAADAMAAEIbAAA1GwAAcgAAAAEDAAC3AwAAQgMAAEkAAAARAwAAdTAAAJowAABlAAAAMAMAACheAABvAAAADwMAAI2fAAB1cwAAdF4AAEwPAAC3DwAAcgAAAAwDAABvAAAAAgMAAL8DAAATAwAARZECAHt8AADeUQAAwpkAAE8AAAADAwAAaQAAADADAACRAwAAFAMAAEIDAABlIgAAOAMAALEDAAABAwAAIm8AAEcNAAA+DQAA35ECAJEDAAAEAwAA/ZAAAEoAAAACAwAAmmQAAFjRAQBl0QEAbtEBABxgAACZAwAABAMAAKhqAACwXgAA0nACAO5bAADvmAAAezAAAJkwAABnAAAAAQMAAL8DAAAAAwAAaFEAAHoiAAA4AwAAfXAAAGEAAAAIAwAAQU4AAK2AAAB2kgAAYwAAAAwDAADxgwAARQAAAAIDAAABAwAA0ZEAAG4AAAAAAwAARwsAAFcLAADFAwAAFAMAAEIDAABCAAAAMQMAAG8AAAACAwAAAQMAAMkDAABFAwAAaAAAAC4DAABFAAAAIwMAACJcAADfWAAAqQMAABMDAAAAAwAAQQAAAAcDAAAEAwAAHVQCAEYMAABWDAAAZFEAALkDAAATAwAAQgMAAHJrAAB5AAAAAQMAAAZcAAA7AAAAuocAAHyWAADNXwAAAkIAANJeAAACfgAAuQMAABQDAAAAAwAApQMAABQDAABCAwAAcwAAAAwDAAAHAwAA2DAAAJkwAAAjkAAAtCIAADgDAABFAAAADwMAAFUAAAAIAwAAlXIAAKJUAABaAAAAAgMAANkNAADPDQAAaFQAAGV1AADYWwAATwAAAAsDAAB5AAAACgMAAE8AAAAMAwAAlj0AAItzAACxAwAAEwMAAAEDAADJAwAAFAMAAEIDAABFAwAAYQAAAAgDAAAEAwAA5AUAALwFAABHAAAAAgMAAGwAAAABAwAAtQMAABMDAAB+ZAAAdAAAAAgDAADcUQAAPm0AAP0wAACZMAAAtTAAAJkwAACpAwAAFAMAALJzAAB1AAAALQMAAAGAAACyIgAAOAMAAJpfAABhAAAABwMAAJcDAAAUAwAAAAMAAPp/AACaVgIARgAAAAcDAABpdAAAH2gAAJ8DAAATAwAAAQMAANaKAAAkdQAA9V8AACgJAAA8CQAA4zgAAHcAAAABAwAAFZQAAMkDAAATAwAAJwYAAFQGAABUAAAAMQMAADERAQAnEQEAIgsAADwLAAB1AAAADwMAAGuHAABZAAAAAgMAAGEAAAACAwAAAwMAABuRAAAnWgAAuQMAABQDAABcdAAAO1IAAJkDAAAAAwAASVMAAL8DAAAUAwAAAQMAAMkDAAAAAwAAbwAAAAQDAAABAwAAKGICAA+fAAASYAAAVQAAAAgDAAABAwAAVQAAABsDAAABAwAAxgwAAMIMAAC/AwAAEwMAAAADAAC3AQAADAMAAJVRAABvAAAAAwMAAAEDAABPAAAACAMAALcDAAATAwAAQgMAAEUDAAA9hAAAmn8AALw8AgBTAAAABwMAABEbAAA1GwAAwE4AAPmTAABTAAAAAQMAAAcDAADpBQAAwgUAAMUDAAAGAwAAG3AAAP4fAAAAAwAA1GIAAHcAAAAjAwAA4WAAALEDAABFAwAA5gAAAAQDAAA4BAAABAMAAEkAAAAIAwAAbgAAAAMDAADXRQAAbGUAAEp6AADxhAAAbwAAABsDAAC9VAAA5gUAALwFAACJUgAAdAQAAA8DAABBAAAADAMAAAJqAABhAAAAIwMAAAIDAABhAAAAKAMAADZsAgBzAAAAAQMAAPNnAABlAAAAKAMAAGJyAABTMAAAmTAAAP2cAABJAAAADAMAALNYAABgfAAAvnwAAPlFAAD7eAAAcwAAACYDAAApUgAAkQMAABQDAAAAAwAARQMAAGEiAAA4AwAASJcAAMleAABPMAAAmTAAAEsAAAAMAwAA0jAAAJkwAADIMAAAmTAAAICLAACbUgAASwUCAD4bAAA1GwAAUgAAABEDAAB6AAAAAgMAAAZ0AACXAwAAEwMAAEUDAAA/hgAAL38CAGNCAgCXAwAAEwMAAAEDAABFAwAAVQAAAAIDAABZAAAABAMAAMp5AACoaAAAtwMAABQDAAAAAwAA2Q0AAN8NAABreAAAdQAAABsDAAAJAwAAkQMAABMDAAABAwAARXEAAK8wAACZMAAAAGIAAKkDAAATAwAAkQMAAEUDAACphgAAw1MAAE2WAAD4AAAAAQMAAF4/AgCyXQAAa10AAHIAAAAHAwAAuRQBAL0UAQBeWAAAqw8AALcPAACPkAAAOgYCABRIAgDfUwAAqzAAAJkwAABQAAAAAQMAAKkDAAATAwAAQgMAAIaJAADbBQAAvAUAAHeNAgA4CgAAPAoAAJEDAAAUAwAARQMAAE8AAAAjAwAAL0EAAHUAAAAEAwAAM1ECAPo6AgAGBAAACAMAAFkAAAAJAwAA3IMAAOFdAABHEwEAVxMBAKxRAADeCAIA04wAAN5hAAD6iwIA4pYAAJsQAQC6EAEAbwAAAAYDAACBaAAAHAoAADwKAAArCgAAPAoAAGtfAACfAwAAFAMAAAADAAD+bwAAdAAAACMDAAD5bQAACTAAAM5MAAA1BAAAAAMAALEDAAATAwAAAAMAALkDAAAAAwAAAUMAACtFAABhAAAACQMAAIZOAAC1AwAAFAMAAAEDAACpAwAAFAMAAEIDAABFAwAAUwAAAAwDAADJewAAyWIAAOiBAAC/MAAAmTAAAEgAAAAMAwAAbnEAANoFAAC8BQAAkQMAAAADAAC5AgAA3SoAADgDAACrQwIAvwwAANUMAAB5AAAAAAMAALcDAABFAwAA5GMAAGcAAAAGAwAApg8AALcPAACXZwAAxgsAANcLAACfAwAAEwMAAAADAACRggAASYQAAHl/AADlbAAAY1UAALk0AACpAwAAEwMAAAADAABFAwAAQQAAAAEDAAB0AAAABwMAAMEDAAAUAwAAAlAAAGJZAABOAAAAAAMAAHMAAAAjAwAABwMAAMUDAAAIAwAAQgMAAHAAAAAHAwAASQAAAAADAACtgwAAIwQAAAgDAADNbAAAZwAAAAcDAABvAAAAAAMAAJVJAAB1lgAARxMBAD4TAQC5AwAAutEBAGXRAQBu0QEAaGMAAI5oAABlAAAALQMAALg+AACXAwAAEwMAAAEDAABhAAAAAQMAAGmGAABijwAAXnkAAFMAAAABAwAAciIAADgDAAATagAAtwMAAAEDAABFAwAAuBUBAK8VAQAMKwIAtpUCAOppAAB3AAAACgMAAAGCAADwjQAAlwMAABQDAABFAwAAkQMAABMDAAAAAwAARQMAAJUDAAATAwAAAQMAAGhWAABWeQAAjToCAL8DAAAUAwAAZQAAACMDAAACAwAAVk0AAOQUAgBPAAAABAMAALGCAABsAAAADAMAAEkAAAAEAwAAnYIAAJcDAAAAAwAAlwMAAAEDAACATwAABAgCAE4AAAABAwAAsQMAABQDAABCAwAAZQAAAAkDAAAZUQIAFQQAAAYDAAC1AwAAEwMAAAADAABHAAAAAQMAAGwAAAAjAwAAbm8AAJUDAAATAwAAdQQAAA8DAABBAAAABgMAAD1OAABbfQAA1QYAAFQGAABlAAAACAMAAE8AAAAbAwAAAQMAAMkDAAABAwAAFgoAADwKAABOPAAAnTAAAJkwAADVMAAAmTAAAEd0AADndgAAx30AAHAAAAABAwAAeyIAADgDAABPAAAAAwMAAAgDAAD/WwAAskoAALrRAQBl0QEAbzAAAJkwAADMkQAAnlQAAG5KAADFAwAAEwMAAAADAACxegAAWgAAADEDAADQXAIA0HEAAEkAAAAwAwAAYQAAABEDAABgXAAAnwMAAAADAABrAAAADAMAANgAAAABAwAAY30AAG8AAAAEAwAAAAMAABcEAAAIAwAAe2MAAOAFAAC8BQAAJwYAAFMGAADngwAA/HIAAH0iAAA4AwAAVwAAAAIDAABOAAAALQMAAJ8hAgDbdgAArV8AAM+IAABjAAAAAQMAAHlrAAD+YgAAGz8AAPyEAABvAAAAGwMAAAMDAABVAAAADAMAAOkFAADBBQAAdQAAAAIDAABvAAAAAwMAAAgDAAC3AwAAEwMAAEIDAABZAAAAAQMAAEEAAAAHAwAAi5UAAMxRAABVAAAACgMAAMdgAABlAAAADAMAAFUAAAAtAwAARg0AAFcNAACZAwAAEwMAAAEDAABEAAAABwMAAFUAAAADAwAAAQMAAAZTAABpAAAABgMAAJ1kAACZAwAAEwMAAEIDAAC3AwAAFAMAAHeNAACxAwAAAAMAANleAABvAAAAAgMAAAkDAAB1AAAACQMAAHYiAAA4AwAAznEAAG8AAAACAwAAAwMAAAowAgA8GwAANRsAACxvAgArCQAAPAkAAAsiAAA4AwAA/h8AAEIDAABCAAAAIwMAADUEAAAGAwAAVQAAABEDAABUAAAALQMAADJYAABlAAAAAQMAAEuWAABvAAAABwMAAAQDAADFAwAAFAMAAAADAABFAAAABAMAAAADAADFZQAAK1AAAEdiAgB3awAASQAAAA8DAABAdwAAOgQAAAEDAAC3MAAAmTAAAEMiAAA4AwAAeQAAAAgDAAAwBAAABgMAAKkDAABjAAAABwMAAE4AAAAnAwAAaVEAAL8fAAAAAwAAxm8AAOGHAAAtBAAACAMAAEQAAAAMAwAAno8AAHIAAAAjAwAABAMAAEIPAAC3DwAAaAAAACcDAADJgwAAZ3YCANQhAAA4AwAA5B0CAOKGAABFAAAAAgMAAAkDAACQIQAAOAMAAMkDAAATAwAAAQMAAOVTAAAqjwAA7gQAACwcEQACAAAAafgCADQcEQABAAAAsjAAADgcEQACAAAALh8AAEAcEQADAAAAIAEAAEwcEQACAAAABfkAAFQcEQABAAAA6PkAAFgcEQABAAAAOh4AAFwcEQACAAAAZfkAAGQcEQABAAAAvR4AAGgcEQACAAAAOvgCAHAcEQABAAAAAQEAAHQcEQACAAAAhvkAAHwcEQABAAAAV/oAAIAcEQABAAAAkR8AAIQcEQADAAAA3wQAAJAcEQACAAAA4gEAAJgcEQACAAAAKQIAAKAcEQACAAAArwEAAKgcEQACAAAAZvoAALAcEQABAAAAOR8AALQcEQACAAAAeh4AALwcEQADAAAAbB8AAMgcEQADAAAAqPoAANQcEQABAAAAzvgCANgcEQABAAAAKAEAANwcEQACAAAAS/oAAOQcEQABAAAAGPgCAOgcEQABAAAAiPkCAOwcEQABAAAAdPkAAPAcEQABAAAAqR4AAPQcEQADAAAAUR8AAAAdEQACAAAAM/gCAAgdEQABAAAA/PgCAAwdEQABAAAAjwMAABAdEQACAAAAPvoAABgdEQABAAAAXvoAABwdEQABAAAAHvoAACAdEQABAAAA9/kCACQdEQABAAAAXwEAACgdEQACAAAANR4AADAdEQACAAAAR/sAADgdEQACAAAAYvkCAEAdEQABAAAAhvoAAEQdEQABAAAAL/kAAEgdEQABAAAA3fgCAEwdEQABAAAAcw8AAFAdEQACAAAAFR4AAFgdEQADAAAA0B4AAGQdEQADAAAAyvkAAHAdEQABAAAA5gQAAHQdEQACAAAAoh8AAHwdEQAEAAAAmfkCAIwdEQABAAAAwh8AAJAdEQADAAAAx/gCAJwdEQABAAAAvPoAAKAdEQABAAAAtDAAAKQdEQACAAAAufkCAKwdEQABAAAAcx4AALAdEQACAAAAW/kAALgdEQABAAAAUvkCALwdEQABAAAAX/oAAMAdEQABAAAACBsAAMQdEQACAAAABCIAAMwdEQACAAAAoh4AANQdEQACAAAA6gEAANwdEQACAAAAKQEAAOQdEQACAAAAIPkAAOwdEQABAAAAhR8AAPAdEQAEAAAAkx4AAAAeEQACAAAAsvkCAAgeEQABAAAAIfgCAAweEQABAAAA1vkCABAeEQABAAAAZfoAABQeEQABAAAAcfkAABgeEQABAAAAMAIAABweEQADAAAAbQEAACgeEQACAAAAGwIAADAeEQACAAAA1PkCADgeEQABAAAAYdEBADweEQADAAAAlPoAAEgeEQABAAAAAwQAAEweEQACAAAAagEAAFQeEQACAAAAWAkAAFweEQACAAAAIvkCAGQeEQABAAAAPfkAAGgeEQABAAAAOR4AAGweEQADAAAAcPgCAHgeEQABAAAArh4AAHweEQADAAAANR8AAIgeEQADAAAAL/oAAJQeEQABAAAAXgEAAJgeEQACAAAAQx4AAKAeEQACAAAAQvgCAKgeEQABAAAAsfkAAKweEQABAAAAXfoAABwdEQABAAAA0vkAALAeEQABAAAA2B4AALQeEQADAAAAyvoAAMAeEQABAAAA3B4AAMQeEQADAAAA/fkCANAeEQABAAAAC/kCANQeEQABAAAAyR4AANgeEQACAAAAKSMAAOAeEQABAAAAlh4AAOQeEQACAAAAoPkCAOweEQABAAAA0PkAAPAeEQABAAAA7QQAAPQeEQACAAAAwgAAAPweEQACAAAAeR4AAAQfEQADAAAA8QQAABAfEQACAAAA0B8AABgfEQACAAAA9R4AACAfEQACAAAAJQEAACgfEQACAAAALPsAADAfEQADAAAAhwMAADwfEQABAAAA7/kAAEAfEQABAAAA9fkCAEQfEQABAAAAcAEAAEgfEQACAAAAcCIAAFAfEQACAAAAzPkCAFgfEQABAAAAbfoAAFwfEQABAAAAgPkAAGAfEQABAAAAB/kAAGQfEQABAAAAV/gCAGgfEQABAAAAuR4AAGwfEQACAAAA1fgCAHQfEQABAAAA+fkAAHgfEQABAAAAovgCAHwfEQABAAAAS/kAAIAfEQABAAAAfvgCAIQfEQABAAAAH/kAAIgfEQABAAAA7PkAAIwfEQABAAAA9AQAAJAfEQACAAAAUQQAAJgfEQACAAAArSIAAKAfEQACAAAAF/kCAKgfEQABAAAAYfgCAKwfEQABAAAAHfkAALAfEQABAAAAlvoAALQfEQABAAAA9gAAALgfEQACAAAAJx4AAMAfEQACAAAASB8AAMgfEQACAAAA6x8AANAfEQACAAAA5R4AANgfEQACAAAAn/kCAMAdEQABAAAA6PgCAOAfEQABAAAA3/kAAOQfEQABAAAArx4AAOgfEQADAAAAKvkAAPQfEQABAAAAePoAAPgfEQABAAAAbPoAAPwfEQABAAAAIh4AAAAgEQACAAAA6h4AAAggEQADAAAAUPgCABQgEQABAAAAyfkCABggEQABAAAAHPkAABwgEQABAAAAMwoAACAgEQACAAAA5wAAACggEQACAAAAC/gCADAgEQABAAAAkfoAADQgEQABAAAA3QkAADggEQACAAAASPgCAEAgEQABAAAAZvkAAEQgEQABAAAANvsAAEggEQACAAAAV/kAAFAgEQABAAAAivgCAFQgEQABAAAAXDAAAFggEQACAAAAgvkCAGAgEQABAAAAIgEAAGQgEQACAAAAXfkAAGwgEQABAAAAzPgCAHAgEQABAAAAavgCAHQgEQABAAAAgR8AAHggEQADAAAAKiEAAIQgEQABAAAAfgEAAIggEQACAAAAqfkAAJAgEQABAAAAvfoAAGwgEQABAAAAHvkCAJQgEQABAAAA6/kAAJggEQABAAAAN/kCAJwgEQABAAAApvgCAKAgEQABAAAAQh4AAKQgEQACAAAALxEBAKwgEQACAAAAqB8AALQgEQADAAAAwAAAAMAgEQACAAAA2vgCAMggEQABAAAAtfkCAMwgEQABAAAAwfgCANAgEQABAAAAtPkAANQgEQABAAAAcQEAANggEQACAAAAUvkAAOAgEQABAAAACPoAAOQgEQABAAAArB8AAOggEQAEAAAA+wEAAPggEQADAAAAEvkAAAQhEQABAAAAER8AAAghEQACAAAAAQIAABAhEQACAAAAufgCABghEQABAAAAHPoCABwhEQABAAAAtfgCACAhEQABAAAAiB4AACQhEQACAAAAuPoAACwhEQABAAAAQ/oAADAhEQABAAAARAEAADQhEQACAAAAix4AADwhEQACAAAA4fkCAEQhEQABAAAAfPkAAEghEQABAAAAhfkAAEwhEQABAAAABh8AAFAhEQADAAAAsh8AAFwhEQADAAAA2/kCAGghEQABAAAA5B8AAGwhEQACAAAAw/oAAHQhEQABAAAAdwEAAHghEQACAAAASPkCAIAhEQABAAAAywAAAIQhEQACAAAAnx8AAIwhEQAEAAAAmfoAANQeEQABAAAAQvkCAJwhEQABAAAAdvkCAKAhEQABAAAAiPkAAKQhEQABAAAA5h8AAKghEQACAAAAVgEAALAhEQACAAAAjh4AALghEQACAAAA/vgCAMAhEQABAAAARh4AAMQhEQACAAAAHvgCAMwhEQABAAAAXQQAANAhEQACAAAAzx8AANghEQACAAAAzx4AAOAhEQACAAAASB4AAOghEQACAAAAy/kAAPAhEQABAAAARvkCAPQhEQABAAAAz/oAAPghEQABAAAACQEAAPwhEQACAAAA4yIAAAQiEQACAAAAUg8AAAwiEQACAAAATDAAABQiEQACAAAAsvkAABwiEQABAAAALAEAACAiEQACAAAAafkCACgiEQABAAAApfkCACwiEQABAAAAejAAADAiEQACAAAAvvkCADgiEQABAAAAGx8AADwiEQADAAAAXR8AAEgiEQADAAAAq/kCAFQiEQABAAAA8fgCAFgiEQABAAAAvvkAAFwiEQABAAAAuPkAAGAiEQABAAAAtB8AAGQiEQADAAAA3x4AAHAiEQADAAAALwIAAHwiEQACAAAANAkAAIQiEQACAAAAivkCAIwiEQABAAAA6B8AAJAiEQACAAAAq/oAAJgiEQABAAAAW/oAAJwiEQABAAAA0wQAAKAiEQACAAAAJiIAAKgiEQACAAAAA/oCALAiEQABAAAAEvoAADQgEQABAAAA5B4AALQiEQACAAAA1h8AALwiEQACAAAAMfkAAMQiEQABAAAAofoAAMgiEQABAAAANvkCAMwiEQABAAAA6R8AANAiEQACAAAA9B8AANgiEQADAAAAbPgCAOQiEQABAAAAEfkCAOgiEQABAAAAXwkAAOwiEQACAAAAzQAAAPQiEQACAAAAXvkCAPwiEQABAAAAj/kAAAAjEQABAAAACB4AAAQjEQADAAAA+jAAABAjEQACAAAA2gQAABgjEQACAAAAxfkAACAjEQABAAAA2AEAACQjEQADAAAA7AEAADAjEQADAAAAXvkAADwjEQABAAAATvsAAEAjEQACAAAAxQAAAEgjEQACAAAAffgCAFAjEQABAAAADBsAAFQjEQACAAAAxvkCAFwjEQABAAAAefgCAGAjEQABAAAA8vkCAGQjEQABAAAAzh4AAGgjEQACAAAA2g0AAHAjEQACAAAAgB8AAHgjEQADAAAAdDAAAIQjEQACAAAAiSIAAIwjEQACAAAA0AEAAJQjEQACAAAArB4AAJwjEQADAAAAUfgCAKgjEQABAAAALAIAAKwjEQADAAAAnh8AALgjEQAEAAAA0vkCAMgjEQABAAAABfoAAMwjEQABAAAAjPgCANAjEQABAAAA/R8AANQjEQABAAAACx8AANgjEQADAAAAuvoAAOQjEQABAAAAgh4AAOgjEQACAAAAwvgCAPAjEQABAAAAMB8AAPQjEQACAAAAhx8AAPwjEQAEAAAAYfoAACwhEQABAAAABhsAAAwkEQACAAAA6PkCABQkEQABAAAADvgCABgkEQABAAAAAB8AABwkEQACAAAAA/oAACQkEQABAAAAAgIAACgkEQACAAAAzgEAADAkEQACAAAAEvoCADgkEQABAAAAT/gCADwkEQABAAAAwQQAAEAkEQACAAAAgfoAAEgkEQABAAAAx/oAAEwkEQABAAAAu/kAAFAkEQABAAAAbwEAAFQkEQACAAAAFAEAAFwkEQACAAAAxwwAAGQkEQACAAAADhsAAGwkEQACAAAA0fkCAHQkEQABAAAAOQEAAHgkEQACAAAANvgCAIAkEQABAAAASAsAAIQkEQACAAAA+TAAAIwkEQACAAAAefoAAJQkEQABAAAAWDAAAJgkEQACAAAAcfkCAKAkEQABAAAAKPkCAKQkEQABAAAA/AEAAKgkEQACAAAAJCIAALAkEQACAAAAs/oAALgkEQABAAAA5/gCALwkEQABAAAA3h8AAMAkEQACAAAA5wEAAMgkEQACAAAAEx4AANAkEQACAAAAWvoAANgkEQABAAAAzh8AANwkEQACAAAAWB4AAOQkEQACAAAAZPkCAOwkEQABAAAAvvoAAPAkEQABAAAADx4AAPQkEQACAAAAOPkCAPwkEQABAAAAHQEAAAAlEQACAAAAlPkAAAglEQABAAAAR/kAAAwlEQABAAAAqgMAABAlEQACAAAAgfkAABglEQABAAAAMB4AABwlEQACAAAAFB8AACQlEQADAAAA8fkAADAlEQABAAAAqR8AADQlEQADAAAAYh4AAEAlEQACAAAAXfgCAEglEQABAAAATvoAAEwlEQABAAAAIh8AAFAlEQADAAAAOPgCAFwlEQABAAAApvkCAGAlEQABAAAAP/kAAGQlEQABAAAA8/kCAGglEQABAAAArfoAAGwlEQABAAAAevgCAHAlEQABAAAAMPgCAHQlEQABAAAAyPgCAHglEQABAAAACgEAAHwlEQACAAAACwIAAIQlEQACAAAAdx8AAIwlEQACAAAAtPoAAJQlEQABAAAAhfkCAJglEQABAAAA9/kAAJwlEQABAAAAT/kCAKAlEQABAAAAQPoAAKQlEQABAAAAaPkCAKglEQABAAAAjPoAAKwlEQABAAAAzgAAALAlEQACAAAAwPoAAHQkEQABAAAAYjAAALglEQACAAAA+QAAAMAlEQACAAAAsB8AAMglEQACAAAAlAsAANAlEQACAAAAJvkCANglEQABAAAAhB8AANwlEQAEAAAA7wQAAOwlEQACAAAAnQ8AAPQlEQACAAAAbSIAAPwlEQACAAAAKB8AAAQmEQACAAAAVfkCAAwmEQABAAAAeSIAABAmEQACAAAAtvoAABgmEQABAAAANfkAABwmEQABAAAAOQQAACAmEQACAAAAOBkBACgmEQACAAAA7gAAADAmEQACAAAAewEAADgmEQACAAAADB4AAEAmEQACAAAAah4AAEgmEQACAAAAFAIAAFAmEQACAAAAVw8AAFgmEQACAAAAJfgCAGAmEQABAAAAuxQBAGQmEQACAAAAAAEAAGwmEQACAAAA5gEAAHQmEQACAAAAUfkCAHwmEQABAAAAzvkCAIAmEQABAAAAhPkCAIQmEQABAAAA6yIAAIgmEQACAAAAax8AAJAmEQADAAAAOwEAAJwmEQACAAAA6fkCAKQmEQABAAAAvvgCAKgmEQABAAAAI/gCAKwmEQABAAAA0/kCALAmEQABAAAAfPkCALQmEQABAAAASfoAALgmEQABAAAAsR4AALwmEQADAAAAmPkCAPAcEQABAAAATjAAAMgmEQACAAAADR8AANAmEQADAAAASg0AANwmEQACAAAAOfsAAOQmEQACAAAAWjAAAOwmEQACAAAAsPkAAPQmEQABAAAA//gCAPgmEQABAAAArjAAAPwmEQACAAAAd/kCAAQnEQABAAAA+gEAAAgnEQADAAAAIB4AABQnEQACAAAAF/kAABwnEQABAAAAifkAACAnEQABAAAADvkAACQnEQABAAAANPsAACgnEQACAAAAifgCADAnEQABAAAAZvgCADQnEQABAAAAZfgCADgnEQABAAAALwEAADwnEQACAAAADvoCAEQnEQABAAAAYR4AAEgnEQACAAAA/QEAAFAnEQACAAAAA/gCAFgnEQABAAAA4x8AAFwnEQADAAAARPoAAGgnEQABAAAAph8AAGwnEQAEAAAADwIAAHwnEQACAAAApB8AAIQnEQAEAAAAywwAAJQnEQADAAAAT/oAAKAnEQABAAAAl/kCAKQnEQABAAAASx4AAKgnEQACAAAAovoAALAnEQABAAAAOfgCALQnEQABAAAAVR8AALgnEQADAAAAMh4AAMQnEQACAAAA8PkAAMwnEQABAAAA6gAAANAnEQACAAAA1PgCANgnEQABAAAAafkAANwnEQABAAAA+gAAAOAnEQACAAAAMx4AAOgnEQACAAAAbx4AAPAnEQACAAAAqvkAAPgnEQABAAAAOPkAAPwnEQABAAAAJvgCAAAoEQABAAAAPPkAAAQoEQABAAAA4gQAAAgoEQACAAAAXx4AABAoEQACAAAAwgQAABgoEQACAAAA3QQAACAoEQACAAAAkAMAACgoEQADAAAAI/kCADQoEQABAAAAGQQAADgoEQACAAAA6fgCAEAoEQABAAAAOxsAAEQoEQACAAAAYPgCAEwoEQABAAAAwB4AAFAoEQADAAAAJAEAAFwoEQACAAAANfkCAGQoEQABAAAAzSEAAGgoEQACAAAAH/gCAHAoEQABAAAAlR8AAHQoEQAEAAAAWfoAAIQoEQABAAAASvsAAIgoEQACAAAANwEAAJAoEQACAAAAGfoCAJgoEQABAAAAjB4AAJwoEQACAAAAEfoCAKQoEQABAAAAkvkAAKgoEQABAAAAm/kAAKwoEQABAAAAbyIAALAoEQACAAAACPkCALgoEQABAAAAoR4AALwoEQACAAAAxzAAAMQoEQACAAAAXA8AAMwoEQACAAAAvBQBANQoEQACAAAAGvkAANwoEQABAAAASfsAAOAoEQACAAAAkvgCAOgoEQABAAAAu9EBAOwoEQACAAAADgQAAPQoEQACAAAAfh4AAPwoEQACAAAA0x8AACgoEQADAAAAth8AAAQpEQACAAAAZAEAAAwpEQACAAAAK/kCABQpEQABAAAAPR8AABgpEQADAAAAhgMAACQpEQACAAAAJB8AACwpEQADAAAAzfoAADgpEQABAAAAF/oAADwpEQABAAAAFx4AAEApEQADAAAAC/oAAEwpEQABAAAAgPkCAFApEQABAAAALfoAAFQpEQABAAAAjvgCAFgpEQABAAAALvsAAFwpEQACAAAAMfoAAGQpEQABAAAACR8AAGgpEQACAAAAFfgCAHApEQABAAAAyvkCAHQpEQABAAAAVfoAAHgpEQABAAAA+fkCAHwpEQABAAAAYh8AAIApEQADAAAABgEAAIwpEQACAAAAvx4AAJQpEQADAAAAOB8AAKApEQACAAAAIB8AAKgpEQACAAAAZfkCALApEQABAAAAKfgCALQpEQABAAAA+x8AABAdEQACAAAAyQAAALgpEQACAAAARwEAAMApEQACAAAAw/kCAMgpEQABAAAAEwIAAMwpEQACAAAAnR8AANQpEQAEAAAAJR8AAOQpEQADAAAAr/kCAPApEQABAAAAd/oAAPQpEQABAAAACSIAAPgpEQACAAAAdg8AAAAqEQACAAAAVvkAAAgqEQABAAAAzB8AAAwqEQACAAAAoB8AABQqEQADAAAAPAEAACAqEQACAAAAsx4AACgqEQADAAAAWh4AADQqEQACAAAANfsAADwqEQACAAAAtfkAAEQqEQABAAAACvoAAEgqEQABAAAApR8AAEwqEQAEAAAALgIAAFwqEQACAAAA7h4AAGQqEQADAAAA1QEAAHAqEQADAAAAXAEAAHwqEQACAAAA4wAAAIQqEQACAAAAi/oAAKQlEQABAAAAeTAAAIwqEQACAAAAOPsAAJQqEQACAAAAVfgCAJwqEQABAAAAnvoAAKAqEQABAAAATgEAAKQqEQACAAAAdR4AAKwqEQACAAAARvoAALQqEQABAAAACvoCADgpEQABAAAAEQIAALgqEQACAAAAqfgCAMAqEQABAAAAFQEAAMQqEQACAAAA0TAAAMwqEQACAAAARx4AANQqEQACAAAA4PgCANwqEQABAAAAfvoAAOAqEQABAAAA2B8AAOQqEQACAAAAkh4AAOwqEQACAAAAZ/gCAPQqEQABAAAAHfsAAPgqEQACAAAAffkAAAArEQABAAAAufoAAAQrEQABAAAARvgCAAgrEQABAAAAfR4AAAwrEQACAAAAyPoAABQrEQABAAAABAEAABgrEQACAAAA9QQAACArEQACAAAAEPoCACgrEQABAAAAdfkAACwrEQABAAAAavkAADArEQABAAAAK/oAADQrEQABAAAAcx8AADgrEQACAAAAV/kCAEArEQABAAAA3R4AAEQrEQADAAAArQMAADgrEQACAAAAJPkCAFArEQABAAAA1PoAAFQrEQABAAAAe/kCAFgrEQABAAAAU/gCAFwrEQABAAAAP/oAAGArEQABAAAAivoAAGQrEQABAAAATPsAAGgrEQACAAAAOx8AAHArEQADAAAAxAAAAHwrEQACAAAAmhABAIQrEQACAAAAQQMAAIwrEQABAAAADR4AAJArEQACAAAA3AQAAJgrEQACAAAAEPoAAKArEQABAAAA8R4AAKQrEQADAAAAA/kCALArEQABAAAA7R8AALQrEQACAAAA7x8AALwrEQABAAAApB4AAMArEQADAAAAHwIAAMwrEQACAAAAkvoAANQrEQABAAAApPgCANgrEQABAAAAyPkAANwrEQABAAAAoPkAAOArEQABAAAAMR4AAOQrEQACAAAAA/kAAOwrEQABAAAA1AMAAPArEQACAAAACfgCAPgrEQABAAAABx4AAPwrEQACAAAAsR8AAAQsEQACAAAA0fgCAAwsEQABAAAAER4AABAsEQACAAAA0h8AABgsEQADAAAAXtEBACQsEQACAAAAQfkCACwsEQABAAAAYvkAAPwkEQABAAAA8B4AADAsEQADAAAA4B4AADwsEQADAAAAUjAAAEgsEQACAAAASAEAAFAsEQACAAAARB8AAFgsEQADAAAAMPkCAMgiEQABAAAACx4AAGQsEQACAAAAPvgCAGwsEQABAAAAlDAAAHAsEQACAAAAWx4AAHgsEQACAAAAVPoAAIAsEQABAAAA/PkAAIQsEQABAAAA3gEAAIgsEQADAAAAAh4AAJQsEQACAAAA5PkCAJwsEQABAAAAf/kAAKAsEQABAAAA4R8AAKQsEQACAAAAyx4AAKwsEQACAAAAR/kCAPQhEQABAAAALfgCALQsEQABAAAAbR8AALgsEQADAAAATB4AAMQsEQADAAAAAB4AANAsEQACAAAAPPkCANgsEQABAAAAxPkCANwsEQABAAAALR8AAOAsEQADAAAAjAMAAOwsEQACAAAAuxUBAPQsEQACAAAADPoAAPwsEQABAAAAhvkCAAAtEQABAAAACh8AAAQtEQADAAAAgx8AABAtEQAEAAAA4x4AACAtEQADAAAAPvkCACwtEQABAAAA7fgCADAtEQABAAAAgfkCADQtEQABAAAAVB8AADgtEQADAAAAFh4AAEQtEQADAAAAavoAAFAtEQABAAAAeQEAAFQtEQACAAAALfsAAFwtEQADAAAAC/kAAGgtEQABAAAAPvsAAGwtEQACAAAAsPkCAHQtEQABAAAAMvkAAHgtEQABAAAA5h4AAHwtEQACAAAAXvgCAIQtEQABAAAA1/gCAIgtEQABAAAAQB4AAIwtEQACAAAA7SIAAJQtEQACAAAAQx8AAJwtEQADAAAA5QQAAKgtEQACAAAApfoAALAtEQABAAAAox8AALQtEQAEAAAAZ/kCAMQtEQABAAAAk/kAAMgtEQABAAAAjfgCAMwtEQABAAAA7QAAANAtEQACAAAABvkCANgtEQABAAAAmPoAANwtEQABAAAAAfkCAOAtEQABAAAA9x8AAOQtEQADAAAAXAkAAPAtEQACAAAAYPoAAPgtEQABAAAAygMAAPwtEQACAAAAYvoAAKAdEQABAAAAw/gCAAQuEQABAAAAyh4AAAguEQACAAAAUPkAABAuEQABAAAAcwEAABQuEQACAAAAmvkCABwuEQABAAAAcPkCACAuEQABAAAAWvgCACQuEQABAAAAE/oCACguEQABAAAAi/kAACwuEQABAAAAE/kCADAuEQABAAAAuQ8AADQuEQACAAAAGfkAADwuEQABAAAAuh4AAEAuEQACAAAAkPgCAEguEQABAAAAU/kAAEwuEQABAAAAsh4AAFAuEQADAAAABPkAAFwuEQABAAAA3AEAAGAuEQADAAAAqwMAAGwuEQACAAAATvkAAHQuEQABAAAA3/gCAHguEQABAAAAGR8AAHwuEQACAAAAvDAAAIQuEQACAAAAXjAAAIwuEQACAAAAhx4AAJQuEQACAAAA+vkAAJwuEQABAAAAK/gCAKAuEQABAAAAHfgCAKQuEQABAAAAo/gCAKguEQABAAAABPoCAKwuEQABAAAAOvoAALAuEQABAAAA5AQAALQuEQACAAAA1fkCALwuEQABAAAADfkCAMAuEQABAAAAZ/kAAMQuEQABAAAA0/oAAMguEQABAAAA8h8AAMwuEQADAAAAhh4AANguEQACAAAALfkAAOAuEQABAAAA9x4AAOQuEQACAAAAifoAAGArEQABAAAAdPgCAOwuEQABAAAAUvgCAPAuEQABAAAAzfkAAPQuEQABAAAAVPgCAPguEQABAAAAJR4AAPwuEQACAAAAwR4AAAQvEQADAAAA2x4AABAvEQADAAAABQIAABwvEQACAAAAQ/gCACQvEQABAAAAsfgCACgvEQABAAAAuB8AACwvEQACAAAAywsAADQvEQACAAAATPgCADwvEQABAAAAMPoAAEAvEQABAAAAywkAAEQvEQACAAAAWPgCAEwvEQABAAAAWx8AAFAvEQADAAAAwgYAAFwvEQACAAAAUPkCAJgiEQABAAAAXAsAAGQvEQACAAAATfoAAGwvEQABAAAAkx8AAHAvEQAEAAAAdPoAAIAvEQABAAAAWR8AAIQvEQACAAAAHfoCAIwvEQABAAAAcPoAAJAvEQABAAAAGPoAAJQvEQABAAAAiPgCAJgvEQABAAAAt/gCAJwvEQABAAAAnfkAAKAvEQABAAAA2/kAAKQvEQABAAAAQPkAAKgvEQABAAAAjR8AAKwvEQAEAAAAlx8AALwvEQAEAAAAEB4AAMwvEQACAAAAl/kAANQvEQABAAAAVvkCANgvEQABAAAAqvkCANwvEQABAAAAQR4AAOAvEQACAAAADPkCAOgvEQABAAAAYvgCAOwvEQABAAAAZh4AAPAvEQADAAAA+B4AAPwvEQACAAAASfgCAAQwEQABAAAAlPgCAAgwEQABAAAAfx4AAAwwEQACAAAAKR8AABQwEQACAAAAHPoAABQrEQABAAAAsB4AABwwEQADAAAAdB8AACgwEQACAAAA6R4AADAwEQADAAAAux8AACQpEQACAAAAYgEAADwwEQACAAAA0gAAAEQwEQACAAAAl/oAAHAdEQABAAAAJPgCAEwwEQABAAAAMwIAAFAwEQACAAAAryIAAFgwEQACAAAA7B8AAGAwEQACAAAAf/oAAGgwEQABAAAASvkCAGwwEQABAAAAh/gCAHAwEQABAAAAF/oCAHQwEQABAAAAMQkAAHgwEQACAAAAMAEAAIAwEQACAAAANQEAAIgwEQACAAAAdjAAAJAwEQACAAAAog8AAJgwEQACAAAA+AQAAKAwEQACAAAAJx8AAKgwEQADAAAAY/kAAKAuEQABAAAATfkAALQwEQABAAAAQAMAALgwEQABAAAAzfkCALwwEQABAAAAAR4AAMAwEQACAAAA0x4AAMgwEQADAAAAAwEAANQwEQACAAAAAAIAANwwEQACAAAAfAEAAOQwEQACAAAALPkAAOwwEQABAAAAEh4AAPAwEQACAAAAM/sAAPgwEQACAAAAk/oAAAAxEQABAAAA9QAAAAQxEQACAAAA+DAAAAwxEQACAAAAEAIAABQxEQACAAAA8wAAABwxEQACAAAABPgCACQxEQABAAAAwPgCACgxEQABAAAAGgIAACwxEQACAAAAHB4AADQxEQADAAAAHgEAAEAxEQACAAAAjx8AAEgxEQAEAAAATPoAAFgxEQABAAAAWwkAAFwxEQACAAAARfoAAOAtEQABAAAA1foAAGQxEQABAAAALvgCAGgxEQABAAAAXPoAAGwxEQABAAAAt/kAAHAxEQABAAAABgIAAHQxEQACAAAAxx8AAHwxEQADAAAAywMAAIgxEQACAAAA3PkAAJAxEQABAAAAKwIAAJQxEQADAAAALvkAAKAxEQABAAAA4h4AAKQxEQADAAAAj/gCALAxEQABAAAATPkCALQxEQABAAAAhPoAALgxEQABAAAA4/kCALwxEQABAAAA1vkAAMAxEQABAAAAXQEAAMQxEQACAAAAJB4AAMwxEQACAAAAXPkCANQxEQABAAAAph4AANgxEQADAAAAqB4AAOQxEQADAAAA9zAAAPAxEQACAAAAd/kAAPgxEQABAAAAxPoAAPwxEQABAAAAO/oAAAAyEQABAAAABPkCAAQyEQABAAAAq/kAAAgyEQABAAAA6wQAAAwyEQACAAAAIPoAABQyEQABAAAAB/kCABgyEQABAAAAxh4AABwyEQADAAAABfoCACgyEQABAAAAqxABACwyEQACAAAAPx4AADQyEQACAAAAhSIAADwyEQACAAAAQwMAAEQyEQABAAAA2vkAAEgyEQABAAAAB/oCAEwyEQABAAAAFfoCAFAyEQABAAAA8wQAAFQyEQACAAAAEwEAAFwyEQACAAAAex8AAGQyEQACAAAAzyEAAGwyEQACAAAAeh8AAHQyEQACAAAA5QAAAHwyEQACAAAAfTAAAIQyEQACAAAAFPoCAIwyEQABAAAAkfgCAOgoEQABAAAA5fkCAJAyEQABAAAAg/kCAJQyEQABAAAAkB8AAJgy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EQABAAAAwvoAAJA/EQABAAAAX9EBAJQ/EQACAAAAJPkAAJw/EQABAAAAb/kAAKA/EQABAAAA3h4AAKQ/EQADAAAAh/kCALA/EQABAAAAch8AALQ/EQACAAAA1B4AALw/EQADAAAAsvgCAMg/EQABAAAAQvoAAMw/EQABAAAAJgYAANA/EQACAAAAnfoAANg/EQABAAAAs/kCANw/EQABAAAAGfkCAOA/EQABAAAA0/kAAOQ/EQABAAAAcfoAAOg/EQABAAAALx8AAOw/EQADAAAA2R4AAPg/EQADAAAAL/sAAARAEQACAAAA3PgCAAxAEQABAAAAtB4AABBAEQADAAAAJfoAABxAEQABAAAAbfgCACBAEQABAAAA6gQAACRAEQACAAAAzR4AACxAEQACAAAAAR8AADRAEQACAAAA0PgCADxAEQABAAAAOvkCAEBAEQABAAAADAQAAERAEQACAAAAOvkAAExAEQABAAAA//kAAFBAEQABAAAAJh4AAFRAEQACAAAACB8AAFxAEQACAAAAAx8AAGRAEQADAAAA1/oAAHBAEQABAAAAhPgCAHRAEQABAAAARfgCAAgrEQABAAAAjgMAANAfEQACAAAA0AQAAHhAEQACAAAAvjAAAIBAEQACAAAAMh8AAIhAEQADAAAACPoCAJRAEQABAAAAfQEAAJhAEQACAAAAPR4AAKBAEQACAAAALPoAAKhAEQABAAAAX/kCAKxAEQABAAAAnPkCALBAEQABAAAAbx8AALRAEQADAAAAN/kAAMBAEQABAAAANPoAAMRAEQABAAAAKh8AAMhAEQADAAAAaQ8AANRAEQACAAAA4AAAANxAEQACAAAAePkCAORAEQABAAAAf/kCAOhAEQABAAAA7wEAAOxAEQACAAAAQxsAAPRAEQACAAAAVQEAAPxAEQACAAAAxh8AAARBEQACAAAACgIAAAxBEQACAAAAdzAAABRBEQACAAAAGx4AABxBEQACAAAAhfgCACRBEQABAAAADQIAAChBEQACAAAAxPkAADBBEQABAAAAp/kAADRBEQABAAAAjvkAADhBEQABAAAATQ8AADxBEQACAAAABfgCAEAvEQABAAAAWQEAAERBEQACAAAA9AAAAExBEQACAAAAQB8AAFRBEQACAAAAAPoAABQgEQABAAAA9vkCAFxBEQABAAAArvoAAGBBEQABAAAAFfoAAGRBEQABAAAAKyEAAEgjEQACAAAABvoCAGhBEQABAAAA1QAAAGxBEQACAAAALR4AAHRBEQACAAAADx8AAHxBEQADAAAAcSIAAIhBEQACAAAAcR8AAJBBEQACAAAAR/oAAJhBEQABAAAASw0AAJxBEQACAAAAHPgCAKRBEQABAAAAuR8AAKhBEQACAAAAJvoAALBBEQABAAAA+R8AAOwsEQACAAAANAEAALRBEQACAAAAkfkAALxBEQABAAAAYNEBAMBBEQADAAAArPkAAMxBEQABAAAAKPgCAPQpEQABAAAA2R8AANBBEQACAAAA6/gCANhBEQABAAAAi/gCANxBEQABAAAAsfkCAOBBEQABAAAAvPkAAORBEQABAAAAKvoAAOhBEQABAAAAfDAAAOxBEQACAAAA9QEAAPRBEQACAAAAeB8AAPxBEQACAAAAcvoAAARCEQABAAAAgCIAAAhCEQACAAAAGPkCABBCEQABAAAA5AAAABRCEQACAAAAAvgCABxCEQABAAAA1vgCACBCEQABAAAAiAMAAMQ1EQACAAAAxfoAACRCEQABAAAADQEAAChCEQACAAAAWPkAADBCEQABAAAAvh4AADRCEQADAAAACvkAAEBCEQABAAAA+QEAAERCEQACAAAATAsAAExCEQACAAAAVx8AAFRCEQADAAAABh4AAGBCEQACAAAA0R4AAGhCEQADAAAA8x8AAHRCEQACAAAAKx4AAHxCEQACAAAAuB4AAIRCEQACAAAAdfgCAIxCEQABAAAAQvkAAJBCEQABAAAAah8AAJRCEQADAAAA4AEAAKBCEQADAAAATfkCAKxCEQABAAAASAwAALBCEQACAAAAEPgCALhCEQABAAAANh8AALxCEQADAAAA8/gCAMhCEQABAAAA/QAAAMxCEQACAAAAYfkAAKQvEQABAAAAc/gCANRCEQABAAAAfgMAANhCEQABAAAAEfkAANxCEQABAAAAxvoAAOBCEQABAAAAnfgCAORCEQABAAAAYPkCAOhCEQABAAAAgvoAAOxCEQABAAAAb/kCAPBCEQABAAAAMx8AAPRCEQADAAAAXx8AAABDEQADAAAAZx4AAAxDEQADAAAA2TAAABhDEQACAAAAmvkAACBDEQABAAAA7CIAACRDEQACAAAABAIAACxDEQACAAAA3AAAADRDEQACAAAAJfkCADxDEQABAAAAaPoAAEwkEQABAAAAQPgCAEBDEQABAAAAzQMAAGQyEQACAAAAkB4AAERDEQACAAAAdR8AALwyEQACAAAA3A0AAExDEQACAAAAP/gCAFRDEQABAAAAdvkAAFhDEQABAAAAbvgCAFxDEQABAAAAUAEAAGBDEQACAAAAmR4AAGhDEQACAAAA0QEAAHBDEQACAAAAFvkCAHhDEQABAAAAKfkCAHxDEQABAAAABB8AAIBDEQADAAAApx8AAIxDEQAEAAAA3wEAAJxDEQADAAAARPsAAKhDEQACAAAAHAEAALBDEQACAAAAOgEAALhDEQACAAAAEB8AAMBDEQACAAAAxPgCAMhDEQABAAAAlx4AAMxDEQACAAAAVPkAANRDEQABAAAAAPkCANhDEQABAAAA/jAAANxDEQACAAAAtjAAAORDEQACAAAAaR8AAOxDEQACAAAArfkAAPRDEQABAAAAdx4AAPhDEQACAAAAN/oAADwvEQABAAAANPkAAABEEQABAAAAsPoAAIAcEQABAAAA6iIAAAREEQACAAAAnPgCAAxEEQABAAAAJwIAABBEEQACAAAAKx8AABhEEQADAAAAefkCACREEQABAAAAVPkCAChEEQABAAAAHh4AACxEEQACAAAArvkAADREEQABAAAA5fgCADhEEQABAAAArwMAAIwlEQACAAAATB8AADxEEQADAAAAQfkAAEhEEQABAAAANPkCAExEEQABAAAAo/kAAFBEEQABAAAAKQkAAFREEQACAAAAm/gCAFxEEQABAAAAsPgCAKQlEQABAAAAgx4AAGBEEQACAAAA7PkCAGhEEQABAAAAYB8AAGxEEQACAAAAIwYAAHREEQACAAAAbh4AAHxEEQACAAAALhEBAIREEQACAAAAXQsAAIxEEQACAAAAFQIAAJREEQACAAAAvfkCAJxEEQABAAAAdgEAAKBEEQACAAAAqx4AAKhEEQADAAAA5vkCALREEQABAAAAZPgCALhEEQABAAAAMR8AALxEEQACAAAAL/kCAMREEQABAAAAIPgCAMhEEQABAAAA2h8AAMxEEQACAAAALPgCANREEQABAAAARR8AANhEEQADAAAAfB8AAOREEQACAAAAUx4AAOxEEQADAAAAcvkCAPhEEQABAAAAGvoCAPxEEQABAAAAYPkAAABFEQABAAAA1wEAAARFEQADAAAA6B4AABBFEQADAAAAygwAABxFEQACAAAAQh8AACRFEQADAAAAXfkCAPwiEQABAAAA7gEAADBFEQACAAAA0/gCADhFEQABAAAATR4AADxFEQADAAAA1gAAAEhFEQACAAAAlh8AAFBFEQAEAAAAGPkAAGBFEQABAAAAr/kAAGRFEQABAAAA+/gCAGhFEQABAAAAYB4AAGxFEQACAAAAEhsAAHRFEQACAAAA/fkAAHxFEQABAAAA6/kCAIBFEQABAAAAZB4AAIRFEQADAAAAK/sAAJBFEQACAAAA4B8AAJhFEQACAAAAFfkCAKBFEQABAAAAG/gCAOg/EQABAAAA3R8AAKRFEQACAAAAtvgCAKxFEQABAAAAiR4AALBFEQACAAAAufkAALhFEQABAAAAsx8AALxFEQACAAAA4wEAAMRFEQACAAAA4wQAAMxFEQACAAAAzwAAANRFEQACAAAA8QAAANxFEQACAAAAv/kCAORFEQABAAAAyfgCAOhFEQABAAAAqPgCAHA5EQABAAAAWvkCAOxFEQABAAAAqPkCAPBFEQABAAAAoQEAAPRFEQACAAAAnvkAAPxFEQABAAAARvsAAABGEQACAAAAx/kAAAhGEQABAAAAdgQAAAxGEQACAAAAzQEAABRGEQACAAAAv/kAABxGEQABAAAArR4AACBGEQADAAAABQEAACxGEQACAAAApPkCADRGEQABAAAAWwEAADhGEQACAAAAyfkAAEBGEQABAAAAGQEAAERGEQACAAAARvkAAExGEQABAAAAVDAAAFBGEQACAAAADPoCAFhGEQABAAAAzwEAAFxGEQACAAAAffoAAGRGEQABAAAARPkAAGhGEQABAAAAHfoAAGxGEQABAAAAwvkCAHBGEQABAAAAZPkAAHRGEQABAAAAGQIAAHhGEQACAAAA3fkAAIBGEQABAAAAix8AAIRGEQAEAAAAYiIAAJRGEQACAAAAs/kAAJxGEQABAAAAovkAAKBGEQABAAAAUDAAAKRGEQACAAAA6AEAAKxGEQACAAAA0zAAALRGEQACAAAAyTAAALxGEQACAAAAWvkAAMRGEQABAAAAivkAAMhGEQABAAAAdvoAAGAmEQABAAAAFvgCAMxGEQABAAAAQBsAANBGEQACAAAAEgIAANhGEQACAAAAkR4AAOBGEQACAAAA5PkAAOhGEQABAAAAmB8AAOxGEQADAAAAEPkAAPhGEQABAAAA2PkCAPxGEQABAAAAHfkCAABHEQABAAAAnB8AAARHEQAEAAAA2wAAABRHEQACAAAAMgIAABxHEQACAAAAlfkAACRHEQABAAAA4vkAAChHEQABAAAAIx8AACxHEQADAAAA3g0AADhHEQACAAAAzvkAAEBHEQABAAAA7R4AAERHEQADAAAADB8AAFBHEQADAAAAHPkCAFxHEQABAAAAsDAAAGBHEQACAAAAkPkAAGhHEQABAAAAaB8AAGxHEQACAAAAvB8AAHRHEQACAAAAt/kCAHxHEQABAAAAa/kAAIBHEQABAAAACfoAAIRHEQABAAAA/wEAAIhHEQACAAAAEPkCAJBHEQABAAAA9PkCAJRHEQABAAAAf/gCAJhHEQABAAAAWR4AAJxHEQACAAAAvhQBAKRHEQACAAAAbPkAAKxHEQABAAAArA8AALBHEQACAAAAE/kAALhHEQABAAAADfgCALxHEQABAAAAJ/kCAMBHEQABAAAAN/gCAMRHEQABAAAArDAAAMhHEQACAAAA7h8AAOgyEQACAAAAofkAAKA/EQABAAAAVB4AANBHEQACAAAAbh8AANhHEQADAAAAt/oAAORHEQABAAAAO/sAAOhHEQACAAAA8fkCAPBHEQABAAAANgoAAPRHEQACAAAAiR8AAPxHEQADAAAAzB4AAAhIEQACAAAAWPkCABBIEQABAAAAawEAABRIEQACAAAARPkCABxIEQABAAAA+fgCACBIEQABAAAABwQAACRIEQACAAAA9h4AACxIEQACAAAAo/kCADRIEQABAAAAgfgCADhIEQABAAAATBMBADxIEQACAAAAGvgCAERIEQABAAAA3fkCAEhIEQABAAAAZPoAAExIEQABAAAAr/gCAFBIEQABAAAA7fkCAFRIEQABAAAA6vkAAFhIEQABAAAAnBABAFxIEQACAAAATwEAAGRIEQACAAAAevkAAGxIEQABAAAASfkCAFQrEQABAAAAWwoAAHBIEQACAAAANvkAAMg3EQABAAAAXgoAAHhIEQACAAAAmvgCAIBIEQABAAAASx8AAIRIEQADAAAAhPkAAJBIEQABAAAAbR4AAJRIEQACAAAADvkCAJxIEQABAAAAKiMAAKBIEQABAAAADfoCAKRIEQABAAAAsvoAAJwiEQABAAAAUAQAAKhIEQACAAAAAh8AALBIEQADAAAAMvoAABgkEQABAAAAdh8AALxIEQACAAAAbfkCAMRIEQABAAAAp/kCAMhIEQABAAAAox4AAMxIEQACAAAAuvkAANRIEQABAAAAFR8AANhIEQADAAAArx8AAORIEQAEAAAAYAEAAPRIEQACAAAAY/kCAPxIEQABAAAAJfkAAABJEQABAAAA9vkAAARJEQABAAAAwDAAAAhJEQACAAAAHgIAABBJEQACAAAAnPoAABhJEQABAAAAOvsAABxJEQACAAAAuh8AACRJEQACAAAAdAMAACxJEQABAAAA3CoAADBJEQACAAAAH/kCADhJEQABAAAAwAwAADxJEQACAAAA8x4AAERJEQACAAAAwx8AAExJEQACAAAAvfgCAFRJEQABAAAAHwEAAFhJEQACAAAApw8AAGBJEQACAAAA9PkAAGhJEQABAAAAzAsAAGxJEQACAAAAR/gCAGg1EQABAAAASh8AAHRJEQADAAAAj/kCAIBJEQABAAAAbvkAAIRJEQABAAAA5vkAAIhJEQABAAAA4/kAAIxJEQABAAAARPgCAJBJEQABAAAAE/gCAJRJEQABAAAAtfoAAGw4EQABAAAAqh8AAJhJEQAEAAAAwQAAAKhJEQACAAAAax4AALBJEQACAAAA5R8AALhJEQACAAAAB/gCAMBJEQABAAAAX/gCAMRJEQABAAAAO/kAAKAlEQABAAAA+AEAAMhJEQACAAAAaR4AANBJEQADAAAA5x8AANxJEQADAAAAVx4AAOhJEQACAAAAzAAAAPBJEQACAAAAm/kCAPhJEQABAAAA8AQAAPxJEQACAAAA/fgCAARKEQABAAAAIQEAAAhKEQACAAAA8gAAABBKEQACAAAAmvoAAJhBEQABAAAA7/kCABhKEQABAAAAePgCAKg8EQABAAAAWfkAABxKEQABAAAASxMBACBKEQACAAAAvh8AAChKEQABAAAAVvoAAGwlEQABAAAAvtEBACxKEQADAAAAu/gCADhKEQABAAAA5PgCADxKEQABAAAAGR4AAEBKEQACAAAALfkCAEhKEQABAAAALB8AAExKEQADAAAA4QAAAFhKEQACAAAAtvkCAGBKEQABAAAAjfkAAGRKEQABAAAAFPkAABxGEQABAAAAGfoAAGhKEQABAAAAzvoAAGQfEQABAAAAWgEAAGxKEQACAAAAdCIAAHRKEQACAAAATPkAAHxKEQABAAAAxB8AAIBKEQADAAAAuhUBAIxKEQACAAAAuPgCAJRKEQABAAAAAfoCAJhKEQABAAAA6vgCAJxKEQABAAAAmB4AAKBKEQACAAAAi/kCAKhKEQABAAAA3PkCAKxKEQABAAAAmR8AALBKEQADAAAAih8AALxKEQAEAAAAHB8AAMxKEQADAAAAOPoAANhKEQABAAAAU/kCANxKEQABAAAA9/gCAOBKEQABAAAAQR8AAORKEQACAAAAxx4AAOxKEQADAAAAFvoCAPhKEQABAAAAWfgCAPxKEQABAAAAWfkCAIAsEQABAAAAz/gCADAhEQABAAAATAEAAABLEQACAAAAk/kCAAhLEQABAAAAPgEAAAxLEQACAAAAKgEAABRLEQACAAAAkfkCABxLEQABAAAAyh8AACBLEQACAAAAiQMAAChLEQACAAAAc/oAADBLEQABAAAA2fkCADRLEQABAAAAQwEAADhLEQACAAAAk/gCAKhKEQABAAAAJ/gCAMRAEQABAAAAY/oAALA2EQABAAAArAMAAJBBEQACAAAABx8AAEBLEQADAAAAux4AAExLEQACAAAAQ/kCAFRLEQABAAAAZ/oAABxAEQABAAAA1gQAAFhLEQACAAAAEh8AAGBLEQADAAAA9AEAAGxLEQACAAAANx4AAHRLEQACAAAAD/kCAHxLEQABAAAAGB8AAIBLEQACAAAAdwQAAIhLEQACAAAAAgEAAJBLEQACAAAAAPgCAJhLEQABAAAAr/oAAJxLEQABAAAAwAYAAKBLEQACAAAA6wAAAKhLEQACAAAA2h4AALBLEQADAAAAfR8AALxLEQACAAAAWQoAAMRLEQACAAAA8vgCAMxLEQABAAAAnjAAANBLEQACAAAA1jAAANhLEQACAAAALvkCAOBLEQABAAAAM/kAAORLEQABAAAAbvkCAOhLEQABAAAAVR4AAOxLEQACAAAAgSIAAPRLEQACAAAATh4AAPxLEQADAAAAcvgCAAhMEQABAAAA/PkCAAxMEQABAAAAvNEBABBMEQACAAAAUPoAANxKEQABAAAALPkCAEhKEQABAAAAcDAAABhMEQACAAAA6fkAACBMEQABAAAAPPgCACRMEQABAAAA+PkCAChMEQABAAAAUh8AACxMEQADAAAArPoAADhMEQABAAAAlB4AADxMEQACAAAA1voAAERMEQABAAAAyx8AAChLEQACAAAAM/oAAAAoEQABAAAAG/oAANgvEQABAAAA7vkAAEhMEQABAAAALB4AAExMEQACAAAAAwIAAFRMEQACAAAAd/gCAFxMEQABAAAA+B8AAGBMEQACAAAA6QEAAGhMEQACAAAA/gEAAHBMEQACAAAAbPkCAHhMEQABAAAAUR4AAHxMEQADAAAA3gQAAIhMEQACAAAApPkAAJBMEQABAAAAQPsAAJRMEQACAAAAIgYAAJxMEQACAAAAzAMAAOg9EQACAAAAnvkCAKRMEQABAAAAK/kAAKhMEQABAAAA4SIAAKxMEQACAAAAdAEAALRMEQACAAAASh4AALxMEQACAAAAOfkCAMRMEQABAAAAzgMAALxLEQACAAAAp/oAAMhMEQABAAAAhfoAAMxMEQABAAAA5/kAANBMEQABAAAABwEAANRMEQACAAAAlfoAANxMEQABAAAAc/kAAOBMEQABAAAAM/kCAORMEQABAAAAwvkAAOhMEQABAAAA4R4AAOxMEQADAAAA0wEAAPhMEQACAAAA0PkCAPAkEQABAAAAKvsAAABNEQACAAAA+wAAAAhNEQACAAAATx4AABBNEQADAAAAJh8AABxNEQADAAAA3QAAAChNEQACAAAAJgIAADBNEQACAAAAMfgCAAgdEQABAAAA7vkCADhNEQABAAAAVfkAADxNEQABAAAAbgEAAEBNEQACAAAApfgCAEhNEQABAAAAGwEAAExNEQACAAAAdh4AAFRNEQACAAAATA0AAFxNEQACAAAAPB8AAGRNEQADAAAACh4AAHBNEQACAAAAeB4AAHhNEQADAAAAKvgCAIRNEQABAAAALQEAAIhNEQACAAAAxfgCAJBNEQABAAAAPh8AAJRNEQADAAAAXPkAABxGEQABAAAAIR8AAKBNEQACAAAA1/kCAKhNEQABAAAAcB8AAKxNEQACAAAAFPkCANw6EQABAAAAg/oAALRNEQABAAAA1R4AALhNEQADAAAA5x4AAMRNEQACAAAAeCIAAMxNEQACAAAAwPkAANRNEQABAAAA1x4AANhNEQADAAAAyvgCAORNEQABAAAAPRsAAOhNEQACAAAArfkCAPBNEQABAAAAXgkAAPRNEQACAAAADCIAAPxNEQACAAAA3x8AAAROEQACAAAASPoAABhJEQABAAAABB4AAAxOEQACAAAA1wQAABROEQACAAAAFgIAABxOEQACAAAAcB4AACROEQACAAAAVvgCACxOEQABAAAA6QAAADBOEQACAAAAUfkAADhOEQABAAAAMQIAADxOEQADAAAAUx8AAEhOEQADAAAAFB4AAFROEQADAAAAg/kAAGBOEQABAAAA1PkAAGROEQABAAAAc/kCAGhOEQABAAAA3/kCAJA/EQABAAAAjPkAAGxOEQABAAAACAIAAHBOEQACAAAAlfgCAAgwEQABAAAAqvoAAHhOEQABAAAAXAQAAHxOEQACAAAAuDAAAIROEQACAAAARCIAAIxOEQACAAAA/wAAAJROEQACAAAA0QQAAJxOEQACAAAAJiEAAKROEQABAAAACwEAAKhOEQACAAAARQEAALBOEQACAAAAePkAALhOEQABAAAAzR8AALxOEQACAAAAEvkCAMROEQABAAAANvoAAPgfEQABAAAAwPkCAMhOEQABAAAA7AQAAMxOEQACAAAADgEAANROEQACAAAAjfkCANxOEQABAAAAXR4AAOBOEQADAAAAQw8AAOxOEQACAAAAKR4AAPROEQACAAAAPvkAAPxOEQABAAAAxfkCAABPEQABAAAAziEAAARPEQACAAAAe/gCAAxPEQABAAAAuvkCABBPEQABAAAAwh4AABRPEQADAAAAmiEAACBPEQACAAAAZB8AAChPEQADAAAABvkAADRPEQABAAAA1/kAADhPEQABAAAAAAAAAAEAAAAAADoDQQF2AwMAJwAJAAAAAAAuAQkBAgAFAAcAAACXAgAA3gEAAAoA7AVnAEGU4MYAC6ECBwAPAAAAygIDANcCAABvAAAALAADAAYAMQAAAI4A1gAIABoBAAAAAAUACAAAAAAAcwDCAAQAYgAAAAAACAABAI0AAAADACkBngAFAAAAaQAKALoAKwAAAAAAAQADAAMAAAACAFsBVACMAAAAGgABADYADgAAAAAANgANAIwASgAAAFIAAAAJAQAABAAAAAIARAAFACgBAwANABwAAAAHAAUAAAAAABMADwBPABEAAAAPAEMAEAAhAQEAAAAAAA0AAAAOAAEApgB6ADUADQAAAAAAAAAgAE0AAAAAAAAABQAGAAAACgAMAAEA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AAUAAQAGAAUAAwAIAAIAAQACAAEAAQACAAEABgACAAAABwAAAAAAAQAKAAUAAQADAAIAAAAAAAAAAgABAAAAAQAAAAsAAAADAAIAAAAFAAAAAQABAAAAAAACAAAAAwAAAAUAAgABAAAAAgABAAAABAAAAAQAAAAKAAAAAAAAAAEAAAABAAEAAgAUAAEAAgAAAAEABAAAAAEABgABAAAAAQAAAAEAAgAAABEABAAAAAAAAgACAAMAEwAAAAMAAAAAAAIAAgAAAAIAAwADAAoABAAAAAMAAgABAAEAAwACAAEAAgABAAAAEgABAAIAAQAEAAYAAQABAAAAAAAAAAUAAAAAAAkAAgABAAMAAQAAAAMAAAAEAAYAAwAFAAAAAQAFAAAAAQAIAAAAAgAJAAAABwAHAAEAAgAAAAAAAAAKAAAAAAACAAEAAgADAAEAAgABAAEABAAFAAIAQZaBxwALCQIAAAAAAAIAAQBBqIHHAAubAwQAAAAEAAMAAgAKAAAAAAABAAAAAAACAAIABwAHAAEABwAAAAQABQACAAMAAwAFAAMAAAAFAAEAAgAEAAQABQACAAAABgACAAAAAAADAAEAAAAHAAUAAQAAAAEAAAAAAAEADwAAAAQAAAAAAAgAAAAOAAAAAwABAAIAAAAEAAQAAAACAAYABAAAAAEAAwAAAAAABAABAAAAAQABAAEAAwABABYAAwAAAAUAAgACAAIAAwAEAAAABAABAAEABQAGAAAAAAAAAAEAAQAAAAEABAAAAAEABQAKAAIABAABAAwAAQABAAYAAAAAAAEAAwAFAAAACAABAAAAAQAAAAIABAABAAEAAQABAAIAAgABAAMAAgAFAAAAAgAAAAAABAAAAAEAAQAAAAEABgACAAAACwAAAAUAAAAAAAAAAQAAAAMACgACAAIAAAAAAAEAAAAGAAAAAQAAAAEAAgABAAEAAAAAAAIABAADAAIAAAABAAQAAwADAAAAAwAAAAIABAAEAAEAAQACAAEAAAAAAAcAAgAAAAAAAQAAAAMAAQBBzITHAAtHAQAGAAEAAAAAAAIACQAAAAAAAQABABIAAAABAAUAAgAAAAEAAAAAAAEAAAAHAAAAAQAAAAAABAADAAEAAgACAAEAAgAAAAEAQaCFxwALIwMAAgABAAQAAQACAAMAAAAEAAIAAwAAAAIAAAADAAUAAQADAEHMhccAC48BAwAAAAAABQADAAQAAAAAAAAAAgAAAAIABgAAAAkAAQACAAUAAAABAAEAAAAEAAEABAAAAAEAAQADAAMAAgAEAAAAAAACAAUAAQABAAAAAQAAAAAAAwACAAAAAgAGAAAAAgAAAAEAAgABAAAAAgABAAAAAQAAAAAABAAAAAAAAAABAAEAAAABAAEAAAAAAAEAQeSGxwALpQEEAAEAAAAAAAgABQAAAAIAAAAAAAAAAwABAAAAAQABAAIABwABAAAABAAAAAEAAgAAAAEAAgADAAAAAQAMAAEAAgAAAAIAAAACAAIABgAAAAEAAQABAAUAAAADAAMAAQACAAgAAQACAAEAAAACAAAAAgAAAAEAAQAAAAAAAQAAAAIAAAAAAAAABAACAAAAAAABAAIAAgAFAAgAAwAAAAQAAQABAAIAQZKIxwALNwQAFAADAAIAAAAAAAIAAQABAAQAAQAAAAEAAQAAAAAAAgACAAIABAABAAEACwAAAAEAAQAAAAYAQdKIxwALIQMAAgABAAIAAAAAAAEAAQABAAEAAAABAAoAAgABAAAAAQBB/IjHAAtDAQAFAAEAAwADAAEABgABAAEACgAAAAUAAQAAAAEAAAAAAAAACgACAAYAAQACAAEAAgAAAAQAAgAAAAAABgAAAAAACABByInHAAvXAQMAAAAEAAAADQACAAMABQADAAMAAQAAAAMAAgAAAAYAAAALAAAAAAADAAEAAgABAAMAAQAAAAMAAQABAAQAAQABAAAABAACAAIAAQABAAMAAgAAAAEAAAAFAAEAAAAQAAEAAAACAAUAAQAEAAEAAQAAAAAABAAAAAMAAwABAAAAAgAGAAIAAAAAAAQAAAADAAEAAAABAAIAAQAAAAIAAAAIAAUAAgAAAAIAAgAGAAIAAQAAAAAAAwAAAAEAAAAAAAEAAAAAAAgAAQACAAIAAAACAAEAAAABAEGqi8cAC3EBAAEAAgACAAAAAQAHAAIAAAAIAAAAAAAEAAAAAAACAAIAAAAAAAEAAAAAAAMAAAABAAAAAAABAAAABAAGAAQAAAAAAAEAAAACAAMAAQABAAQAAgADAAEAAAABAAIAAAADAAEAAQABAAAAAgACAAEAAQBBpIzHAAv/AgMAAgACAAQAAAABAAIAAAACAAEAAAAAAAEAAQAGAAAAAwAFAAAAAgAAAAAAAgAAAAEABAAAAAUAAQAGAAEAAQAAAAEAAAACAAsAAQABAAAAAAABAAAABQACAAAABQADAAEAAwAGAAEAAQAFAAEAAQAAAAAAAQAAAAMABQAAAAAAAQACAAIAAAAAAAEAAwABAAAAAQABAAMAAAADAAAAAQABAAEAAQABAAQAAAACAAMACAABAAIAAAAAAAAABwADAAEAAQABAAEAAQAFAAUAAQAAAAIAAAAAAAIABAACAAAAAQABAAAAAQACAAEABQAAAAAAAQADAAAAAQAHABQAAAABAAAAAgABAAIAAAAEAAEAAAAHAAMAAAABAAEAAAAAAAUAAQAAAAIAAAAAAAAABQACAAAAAAABAAAAAQAAAAUAAAABAAAAAAABAAAAAAAAAAQAAQACAAIAAgAAAAEAAwAAAAEAAAAAAAAABAAAAAAAAgAEAAAAAwABAAAAAAABAEGuj8cAC7kDAQABAAAAAAACAAAAAQAAAAQAAgAAAAIAAgAAAAAAAQAAAAAAAQAEAAAAAgACAAAAAQAFAAEAAQACAAcAAAAAAAAACAAAAAAAAAABAAUAAQAIAAIAAQAEAAEABwABAAAAAQACAAMAAQADAAAAAAADAAMAAQABAAAAAQAAAAAAAAADAAEAAQABAAMAAQAFAAEAAAAAAAMAAgAAAAAAAAAEAAEABQAAAAIAAAABAAQABgACAAMAAAABAAAABQABAAQAAAABAAEAAQACAAgAAQADAAUAAAADAAIAAgAHAAAAAwAGAAgAAAABAAAAAwAKAAIAAQADAAAAAQABAAAAAgAAAAAAAgABAAAAAgAAAAIAAAABAAEAAAABAAAAAQABAAIAAQABAAAAAQABAAMAAQADAAAAAQAFAAIAAQAAAAQAAQABAAIAAQABAAIAAQAJAAMAAAACAAEABAAAAAIAAAACAAAAAAACAAEAAAAAAAEAAgAAAAMAAAACAAMAAAAAAAIAAAACAAUAAQAAAAAAAAACAAAAAQAEAAQAAAAAAAAAAQAAAAkAAAAAAAAACQAAAAIAAAACAAEAAQAFAEHykscACykBAAIAAQAAAAIAAQACAAAAAQAAAAAAAQAAAAIAAgACAAEABAABAAIAAQBBpJPHAAuBAgIAAgABAAgAAwABAAYAAgABAAAAAwADAAAAAQADAAsAAAACAAAAAgAAAAIAAgAA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ADYAAAC5cAAAOgAAADoAAAA9AAAALgYAAEUGAACqEQAAyjAAAEEGAABFBgAASgYAAEQAAAB6AAAAKgYAAEUGAAAzAAAARCAAADUAAAC6AwAAKwYAAEUGAADbMAAAmTAAAOswAADIMAAALQYAAEUGAABJBgAAKAAAAEwAAAApAAAARwAAAHkAAAAzBgAAszAAAOswAADKMAAAZREAAGwRAABjAgAARAAAAFoAAAAMAwAAYQAAAC8AAABjAAAAagAAAEUGAAAtBgAATgAAAC0GAACBAgAA81MAAGtwAABlUQAAIAAAAAUDAAAlAAAAoAMAAEEGAAAuBgAARQYAAAIRAABhEQAAFVkAAEQGAABJBgAApZ4AAGkRAAAgAAAAUAYAAFEGAABjawAAbAAAAG4AAACkZQAAV1sAAPERAABPAAAAdwAAADYAAADIAwAAZgAAAGYAAABpAAAAfwYAAFQAAABSAAAAMQAAAGMAAABjAAAAgJUAAMOeAACJgAAANAYAAEUGAABlAAAAcgAAAGcAAABZAAAAAjAAADEAAAA1AAAALgAAAFcAAABIAAAAegAAAG4AAABGAAAAOQYAAEkGAABGBgAASgYAAEIGAADmMAAAXwAAACsGAAAyBgAAggIAAKgwAAD8MAAAqzAAAPwwAAAUMAAACU4AABUwAABCAAAANAYAAEoGAAC+AwAAkQYAADYGAAAuBgAAKAAAAONOAAApAAAAcwAAALgDAADSMAAAmjAAALMwAABkAAAANAAAAOwwAAB0AAAANwYAAC0GAADrWAAAKAAAAGUAAAApAAAAEhEAAGERAAA6BgAALAYAACgGAAAsBgAAKAAAAAsRAABpEQAAEhEAAG4RAAApAAAAVgAAAL0DAAAMMAAAx4wAABQwAABTAAAAFTAAACoGAABFBgAALAYAAGYCAADpMAAApjAAADEAAAAyAAAACGcAADEAAAAxAAAACGcAADkGAADbMAAAmjAAAKQwAADzMAAAyDAAAClZAAAxAAAANwAAALlwAABDAAAAFSIAAGsAAABnAAAAKgYAAEUGAAAtBgAAhikAAEYGAAAtBgAASgYAAK8GAAAgAAAAFAMAAEIDAACNAgAAYBEAABoRAAAwBgAAZxEAACgAAABWAAAAKQAAAG0AAABXAAAAsgMAAGwAAABvAAAAZwAAAMEDAAAhcQAAO1MAAAdjAAABMAAACk4AALh5AAAoBgAAKAAAAAURAAApAAAA2DAAAOswAADEMAAAqjAAAPMwAAC5MAAAKAYAAEkGAAANEQAA43YAAFgAAAA1BgAALQYAAC0GAABmEQAASgQAAMslAADvUwAARAYAAGmQAACEBgAA3jAAAMMwAADPMAAAl18AAIBuAABDBgAARQYAACICAAAsBgAARQYAAC0GAAA6BgAASgYAAHMCAAAqAAAARAAAAHoAAAAMAwAAOgYAAEkGAACcAwAAxwMAACwGAABEBgAAIAAAACwGAABEBgAAJwYAAEQGAABHBgAA3QUAAGUAAAAcEQAAbgAAAHMAAAAJEQAAbQAAAG0AAABzEQAAywYAADQGAAAtBgAArAAAADIAAAAxAAAAuXAAADEAAAAwAAAALgAAAPOXAAByAAAAYQAAAGQAAAAVIgAAcwAAADIAAAA1BgAARQYAAEoGAAAyBgAAMQAAADcAAADSMAAAKAAAAAIRAABhEQAAKQAAALIPAABxDwAAgA8AAC4AAAAuAAAALgAAAHUAAAAqBgAALgYAAEoGAABEBgAALAYAAEUGAAAuBgAALQYAAG0AAABnAAAAxjAAACwGAABFBgAASgYAADMAAAA1AAAAMQAAADMAAAC5cAAAYgAAAKMAAAAsAAAArQYAAOswAAD8MAAA1TAAAJkwAADrMAAASgYAAG8RAAC2AwAA3jAAAPMwAAC3MAAA5zAAAPMwAAAyAAAAMwAAAEoGAAAtBgAAMQYAAMwGAAAnBgAARAYAAMkGAAAoAAAA0ZEAACkAAAA3AAAAlgMAAL8wAABGBgAALgYAAMQwAAAsBgAAtQMAAEYGAAAsBgAALQYAACsGAABKBgAAawAAAGcAAABmAAAAZgAAAGwAAABNAAAAAU4AAF8CAABGBgAARwYAAEoGAABUBgAARwYAAIsCAAAyAAAALREAADMAAAAzAAAAqw4AAKEOAACscgAAESIAAGtRAAAnBgAARAYAAEQGAABHBgAAyDAAAPMwAAB0BQAAawUAAEYGAADoMAAApQMAAGsAAABXAAAAOFwAACgAAABDAAAAKQAAADOAAADfMAAA6jAAAM8wAACZMAAA/DAAAOswAAAfdQAAiDAAAIowAADolgAAWwAAAA0wAABBBgAACBEAADYAAADlZQAANAYAAC4GAAA2cgAAqwEAAA4RAAAtBgAALAYAAEoGAAAoAAAAKGcAACkAAAC8AwAAVwAAAJcDAAA1AAAALgAAAKwRAAAzBgAASgYAACgAAAAPEQAAYREAACkAAAA1BgAARAYAAEkGAABkAAAAegAAAAwDAADcdAAAMQAAADYAAAC5cAAAyzAAAEQGAABHBgAAKAAAADkAAAApAAAAagIAACgAAABdeQAAKQAAAC4GAABJBgAARAYAAEoGAABABgAATgYAAFEGAADjUwAANQAAAEQgAAA4AAAAawAAAEEAAAA/AAAAPwAAANIwAACaMAAAojAAALkwAADIMAAA6zAAALMGAACxBgAAoREAAEgAAABQAAAAWU4AAG+nAAAhEQAANgYAACwGAAAUMAAA3VIAABUwAABLAAAASwAAADYGAAAqBgAASQYAAGYAAABmAAAA4ncAACoGAAAsBgAAJwYAAEMGAAAoBgAAMQYAAGwAAAB4AAAAFTAAAMgwAAAUMAAAAxEAANwFAABwAAAAVgAAADcAAAC5cAAAEhEAAIMGAABKBgAARQYAABQwAACJWwAAFTAAADoGAABFBgAAxgAAADEAAADlZQAA0QUAANgwAACvMAAAvzAAAPwwAADrMAAA7DAAAOAwAAChAwAAEDAAAEoGAABUBgAA1QYAACgAAAByAAAAKQAAALUwAACkMAAArzAAAOswAABABgAASwYAAKswAAAxAAAARCAAADIAAAAJEQAAYREAADkGAABFBgAASQYAANh5AAAoZwAA2DAAAJowAAC9MAAAIAAAACcDAAA3BgAARQYAAEUGAABKBgAAVAYAAMYGAABsAAAAbQAAAEYGAAAsBgAAzzAAAJowAAD8MAAAuzAAAPMwAADIMAAANgYAAC0GAACpMAAAMQAAADkAAADlZQAAIAAAAFIGAAAHEQAA7ZcAACkAAAAnEQAAKAAAAAcRAAApAAAAAE4AAEUAAAAxAAAANwAAAC4AAADXVgAAOQYAACwGAACwZQAARgYAAEUGAABJBgAAvAMAAGwAAAC0AwAAex0AAEcGAABFBgAARQYAADEAAAAwAAAAs40AAFMAAABEAAAAUAAAAGEAAABKBgAALAYAAEoGAACudgAAMQAAADQAAAC5cAAANAYAAEUGAAAuBgAAkwMAACgAAADbVgAAKQAAAM4wAADDMAAAyDAAAOQwAAD8MAAAyDAAAJkwAABEBgAAJwYAAEEGAABKBgAAewYAAKiYAADEAwAARQYAAC4GAAAsBgAAMgAAADAAAAAuAAAA3zAAAK8wAADtMAAA8zAAAEUGAAAuBgAASgYAAEYAAABBAAAAWAAAAKyZAACkAwAAKAAAAKGMAAApAAAAmjAAAEEGAAAuBgAAKAAAAAsRAABpEQAADBEAAGURAACrEQAAKQAAAG8AAABWAAAASgYAAFQGAABFBgAAMQAAADgAAAAuAAAALAYAAC0GAABKBgAALgAAABERAABmAAAAaQAAAHlyAAAoAAAACWcAACkAAAAoAAAAYwAAACkAAAAUIAAAS2IAACgAAAAJTgAAKQAAAEoGAAAxBgAAMwYAAEkGAAAxAAAANAAAADJ1AACPewAARQYAACcGAACYBgAAqAMAAGsAAABtAAAAxQYAAL8DAAAnBgAAP04AAFMBAAAWHQAAMQAAADIAAAC5cAAAkyEAACAAAABMBgAAUQYAAMgRAAAQIAAAKAAAAHUAAAApAAAAzDAAACgAAABTAAAAKQAAAMuXAAC1MAAA8zAAAMEwAAD8MAAA4DAAALARAABLAAAATQAAADQAAAA4AAAAR3IAAAURAAA0AAAAMgAAALAAAABDAAAAtFIAADEAAAA1AAAAQgYAAEQGAADSBgAA2DAAAEEAAAAVIgAAbQAAAEgAAAC7BgAACzAAAGJrAAA4UwAABBEAAEcGAABFBgAAPgAAADIAAAAyAAAA5WUAAEkGAAAoAAAAAxEAACkAAAAzBgAALAYAAEMGAAAtBgAANAAAALlwAABUAAAATQAAAKIwAADPMAAAmjAAAPwwAADIMAAASQYAAHAGAACmAAAAMQYAAC4AAAAuAAAA8AAAAOMwAAB+BgAAQwYAAEQGAABFBgAARQYAAEAGAABQBgAAUQYAALswAAAGEQAAkQMAAC4GAAAsBgAAgXkAACgAAABwAAAAKQAAADQAAAAzAAAAABEAAMwGAABSAAAAcwAAACAAAABOBgAAUQYAAOwwAADzMAAAyDAAALEwAACZMAAA8zAAANAGAAA0BgAARQYAAEUGAABCBgAARQYAAEoGAABHBgAAcAYAACoGAAAtBgAALAYAAJ8CAABzXgAAEGIAAGMAAABtAAAAMgAAAC0GAABFBgAAjAYAADUAAAAIZwAAzQ4AALIOAACFEQAAMwAAADEAAADlZQAARQYAAC4GAAA0BgAALAYAAKQGAAB1ngAASgYAAEUGAABKBgAAqzAAAOkwAADDMAAAyDAAADYGAABFBgAASwAAAEIAAACtMAAAUwAAAFMAAAB0BQAAbQUAAEcAAABCAAAAKgYAAC4GAAA0AAAA5WUAADEAAAA4AAAAuXAAAFkRAAAoAAAA6oEAACkAAADbawAANAYAAL4GAACjAwAAi3UAAE0OAAAyDgAAJAAAAC0GAABFBgAASgYAADEAAAAzAAAALgAAAH+AAADtMAAANGwAAOQwAAD8MAAA6zAAACAAAACaMAAAbQAAABUiAABzAAAAMgAAAHoGAAAxAAAAMwAAAOVlAAByAAAAYQAAAGQAAAAVIgAAcwAAADMGAAAuBgAASgYAACBrAAAhBgAAKAAAAGtwAAApAAAAKAAAAHoAAAApAAAAQBEAAGIRAACnAwAAKAAAABARAAApAAAAKAAAADYAAAApAAAAFDAAAFNiAAAVMAAAtlMAADEAAAAuAAAAKAAAAA1UAAApAAAAlQMAAKYwAACpMAAA8zAAADIAAAAwAAAAcgIAACgAAAAJEQAAYREAACkAAAAzAAAACGcAADIAAAA1AAAA5WUAACgAAABIBgAAq44AAIAGAAAoAAAAagAAACkAAAAoAAAAH1cAACkAAABmAAAAbQAAADEAAABEIAAAOAAAADcAAAAuAAAAAiIAADUGAABFBgAARQYAAIYGAABhLQAAeAIAAM4wAAAoAAAAdAAAACkAAAAoAAAATgAAACkAAAAsBgAARQYAAFtyAAAgAAAAFAMAAAADAABplwAAiAYAALsDAABGBgAARQYAAC0GAAAsBgAACWcAAFYAAABJAAAASQAAAEkAAAB2dgAA6gUAAEkAAABJAAAAKAYAAEUGAADbMAAA/DAAAOswAABwAAAAVwAAACgAAAAxAAAANQAAACkAAADxXQAA1xEAAAsRAABuEQAAIQAAAEgAAABWAAAApTAAAOBRAABjAAAAZAAAACsGAADTBQAAPwAAAAFPAADJAwAATgAAAG8AAADmdAAAPAAAADIGAAAxAQAAqzAAAKQwAADqMAAAvnkAAEoGAABUBgAALQYAALoGAABYAAAASQAAADcGAABFBgAAXAAAAOIwAABGBgAALQYAAEkGAAA1BgAALQYAAEoGAAArAAAAojAAAJAhAABAAAAAjgEAAEQAAABaAAAASZEAAEoGAABUBgAAyAYAAM4RAAAiEQAAFBEAAAyCAABHBgAASgYAAM8wAACZMAAA/DAAAOwwAADrMAAA2zAAAPwwAADzMAAAMiAAADIgAAAoAAAABxEAAGERAAApAAAAUAAAAFAAAABWAAAARowAAPOBAAAxAAAANAAAAC4AAADSMAAAmjAAAK8wAADrMAAABhEAAGERAABkjQAAMwYAAEUGAAAsBgAARgYAAEkGAAAKWQAAaQAAAHYAAAATIAAAKE4AACgAAABXAAAAKQAAAGgAAABQAAAAYQAAACgAAAB5cgAAKQAAANUwAADpMAAA8zAAAC4iAAAuIgAAIwAAACgAAABhAAAAKQAAAG8GAAAgAAAAMwMAACgAAABSAAAAKQAAAEkAAABKAAAAGU4AACpoAAAPXwAAGk8AAD55AAA6AAAA1GsAADUGAABEBgAASQYAACAAAAAnBgAARAYAAEQGAABHBgAAIAAAADkGAABEBgAASgYAAEcGAAAgAAAASAYAADMGAABEBgAARQYAADIAAAAsAAAAaAAAAGEAAABilwAAMgAAAAhnAABzAAAAdAAAAKkgAABWAAAASQAAABQwAABXZQAAFTAAAG4AAABWAAAA83cAACgAAAALEQAAKQAAABKAAAAyAAAAOAAAACgAAABzAAAAKQAAAA8RAAAyAAAANAAAAHeVAAAoAAAARgAAACkAAAAzBgAALgYAAHIRAABuEQAADzAAAHCNAACiAAAAMgAAADYAAADlZQAALQYAAEoGAACRIQAAvAMAAHMAAAAqBgAARwYAAEYGAAAxBgAAMwAAADYAAAAqUQAA25gAADUgAAA1IAAAIAAAABMDAABEBgAALQYAACoGAABFBgAALgYAAJIRAAA1BgAARAYAADkGAABFBgAAkgMAABURAABwAAAARgAAACgAAAAGEQAAKQAAAFYAAAAVIgAAbQAAAEIGAABFBgAALQYAAAcRAABhEQAAKAYAAC4GAAB5BgAAQVMAAGwAAABqAAAAKAAAAEIAAAApAAAAIAAAABQDAAABAwAAQwYAACcGAABtAAAAMwAAAMcGAABDBgAALAYAAEoGAABUBgAAMgYAACAAAAALAwAAOQAAACwAAABjAAAAYQAAAGwAAAAgAAAAUQYAAHAGAABBBgAARQYAACgAAABkAAAAKQAAAGUCAAAKMAAANk4AADIAAAA0AAAA5WUAAIBbAABjAAAAbQAAAG4AAABqAAAAA04AABcwAAAoAAAAVAAAACkAAABABgAATgYAAEoGAABUBgAAxwYAACgAAABuAAAAKQAAAFICAACrMAAAmTAAAPMwAADeMAAAKAAAAEoAAAApAAAASgYAAFQGAAAsBgAAKAAAAFoAAAApAAAA5TAAAGsAAABWAAAAmQMAACgAAAA+eQAAKQAAANQFAAACWQAALAYAAC0GAAC2lgAAMwYAAEcGAACxAwAAZlsAAFBbAACDAgAA6GwAACoGAABFBgAASQYAACYBAAAtBgAASQYAADEAAAAsAAAAMiAAADIgAAAyIAAAYxEAAGgRAADvMAAAwzAAAMgwAABmAAAAbAAAABARAAAoAAAAbAAAACkAAABUAgAAKwYAAEkGAAAhAAAAPwAAAGkAAAB4AAAAQwYAAC4GAADhMAAAqzAAAJkwAAAxAAAAuXAAAB0dAAAoAAAAEREAACkAAACzMAAAszAAAHJeAABABgAATwYAAK0RAAB4jAAAoQYAADIAAAAwAAAA5WUAADQAAAAsAAAALQAAAAsRAABxAgAAEU8AAEIGAAAtBgAAIAAAAE0GAADkMAAATQAAAFcAAADqMAAA8FgAADIAAAA0AAAAuXAAAAciAABFBgAALAYAAC0GAACwAAAARgAAAFUCAAD4WwAARAYAACwGAABtAAAAbQAAADIAAADIMAAAmTAAAOswAAAzAAAANwAAAGoRAAAyAAAANwAAAOVlAABCBgAASgYAAE0AAABIAAAAegAAACcGAABLBgAAKAAAADEAAAApAAAAOQYAAEUGAABKBgAAKAAAABARAABhEQAAKQAAALMwAABKBgAAVAYAACcGAACCUQAAWBEAACAAAAATAwAAAQMAAEUGAABFBgAASgYAADUAAAC5cAAAxgYAADMGAAAtBgAAKAAAADEAAAAyAAAAKQAAAIVOAABDBgAASgYAADYGAAAuBgAARQYAADgAAAAuAAAAMhEAADEAAAA2AAAA5WUAADEAAAA5AAAAuXAAAEQGAAAsBgAASgYAAMhTAABKkAAAKAYAAEYGAAA0ZQAAUZcAAKsOAACZDgAANQYAAEoGAADRngAAEjAAAI4GAADfEQAAQgYAAEUGAABFBgAA/l0AAG8CAABwAAAAQQAAAL92AABKBgAALQYAAEoGAAAxAAAAMQAAAC1mAACMVAAANgYAAEoGAAAnBgAAdAYAAEAGAABPBgAAUQYAAFkCAABGBgAALAYAAEkGAAAoAAAATQAAACkAAABFBgAALAYAADgAAAC5cAAANAAAAEQgAAA1AAAAbQIAACgAAAAOEQAAKQAAAIJTAACZUQAAn58AADAAAAAsAAAASgYAAFQGAABJBgAAKAAAAFgAAAApAAAAbREAAG4AAABtAAAAMwYAADEGAABKBgAAVAYAANAGAABIBgAAdAYAADUAAADlZQAATYYAACpyAABtAAAAYgAAADQGAAAtBgAARQYAAMUDAABKBgAALAYAADYGAAAtBgAASQYAAOAwAABUAAAASAAAAHoAAAAoAAAANAAAACkAAAA2BgAALQYAAEoGAAAUMAAAjE4AABUwAABlBQAAggUAAK0wAACZMAAAyzAAAPwwAABABgAAUgYAAH12AABABgAAUQYAADQGAABHBgAAKAAAAFRTAAApAAAARQYAACwGAABFBgAAeAAAAGkAAAA1AAAARCAAADYAAADbMAAAmjAAAPMwAADIMAAAmTAAAAARAABhEQAALxEAAAwRAABuEQAACxEAAHQRAABEBgAARQYAAEoGAAAyAAAAMwAAALlwAAClAAAAdAUAAHYFAAA0BgAAMQYAADIAAAA4AAAA5WUAAPIRAACQAgAAMgAAADUAAACbjwAACxEAAGERAABxEQAAMQAAADUAAAC5cAAAMwAAAEQgAAA0AAAAIAAAAE4GAACJcwAAKAAAADEAAAAxAAAAKQAAAFgAAABJAAAASQAAADMAAAA4AAAARgYAAEUGAABKBgAAFG8AAKgwAAAoAAAAbwAAACkAAAAMEQAAYREAAEYGAABGBgAAVxEAAEIGAABJBgAAKgYAAC4GAABFBgAALBEAAJERAAAyAAAAOQAAAOVlAAAyAAAAMgAAALlwAAAOEQAAYREAALcRAAAAEQAAaREAAGgCAABDBgAARQYAAEUGAAA3jAAAKAAAAEQAAAApAAAAszAAAMgwAADdAwAAcVwAAFlyAAAoAAAARQAAACkAAACgnwAASAAAAGcAAABKBgAAdAYAAEoGAABUBgAASAYAACwGAAAtBgAASQYAAGkAAABpAAAAaQAAAGsAAABtAAAAMgAA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ALAzAABM0BEAAgAAAK/VAQBU0BEAAQAAACEzAABY0BEABQAAAPf+AABs0BEAAwAAAL4kAAB40BEAAQAAAJokAAB80BEAAwAAABD8AADQzxEAAgAAAHf9AACI0BEAAwAAACH7AACU0BEAAQAAAO/WAQCY0BEAAQAAAO4zAACc0BEAAwAAAB/8AACo0BEAAgAAANLUAQAczhEAAQAAAIoyAAAozREAAQAAAKf7AACw0BEAAQAAALnXAQC00BEAAQAAAMTVAQC40BEAAQAAALbWAQAIzhEAAQAAAHgdAAC80BEAAQAAAOrXAQDIzBEAAQAAABUvAADA0BEAAQAAAJT+AADE0BEAAQAAANkzAADI0BEAAwAAAOcyAADU0BEAAQAAABHXAQDY0BEAAQAAACjXAQDc0BEAAQAAAF4zAADg0BEAAgAAAHQqAADo0BEAAwAAABv8AAD00BEAAgAAADMxAAD80BEAAQAAAHH9AADMzBEAAwAAAIX/AAAA0REAAQAAAMH9AAAE0REAAwAAAPIBAAAQ0REAAgAAAHL8AAAY0REAAgAAAFchAAAg0REAAwAAAAXXAQAs0REAAQAAAHj8AAAw0REAAgAAAD4zAAA40REABAAAAFv9AABI0REAAwAAABvxAQBU0REAAwAAADbxAQDgzREAAQAAAMkzAABg0REAAgAAABjXAQAs0REAAQAAALP+AABo0REAAQAAAB0zAABs0REAAwAAAMb/AAB40REAAQAAAFoxAAB80REAAQAAAOACAACA0REAAQAAAHrUAQDczBEAAQAAAMQBAACE0REAAwAAAAAhAACQ0REAAwAAAPPUAQCc0REAAQAAAM/8AACg0REAAgAAAHXUAQCo0REAAQAAAKH+AACs0REAAQAAALYCAACw0REAAQAAANfWAQDY0BEAAQAAAC7yAQC00REAAQAAAFUvAAC40REAAQAAALICAACc0REAAQAAAKLWAQAszhEAAQAAAAYgAABgzREAAQAAAGPXAQCY0BEAAQAAAPrVAQCUzREAAQAAAAovAAC80REAAQAAAEr+AADA0REAAgAAAGr+AADI0REAAQAAAGXXAQDM0REAAQAAAH39AADQ0REAAwAAAG8yAADc0REAAgAAAHjUAQB4zxEAAQAAACMvAADk0REAAQAAAIb8AADo0REAAgAAAMYvAADw0REAAQAA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AI4xAADg2BEAAQAAAMszAADk2BEAAgAAANkkAACc0REAAQAAAJoxAADs2BEAAQAAABLUAQDczBEAAQAAAHCnAADw2BEAAQAAAEQxAAD02BEAAQAAALT8AAD42BEAAgAAABn/AADQzREAAQAAADjVAQAwzxEAAQAAAELWAQDgzREAAQAAAEfyAQAA2REAAwAAABT/AAAc0xEAAQAAAM0zAAAM2REAAgAAAN/+AADM1BEAAQAAAHnuAQAU2REAAQAAAIDUAQBw0hEAAQAAAHT8AAAY2REAAgAAAJDUAQDUzREAAQAAAMXXAQAI0xEAAQAAABfUAQCs1BEAAQAAAN3XAQB4zREAAQAAAAD7AAAg2REAAgAAAG4vAAAo2REAAQAAAErUAQCE0hEAAQAAAJX7AAAQ1BEAAQAAAAv8AAAs2REAAgAAAPP9AAA02REABAAAANMzAABE2REAAgAAAKLuAQDY1hEAAQAAAKPVAQCUzxEAAQAAAF7+AABM2REAAQAAAOMyAABQ2REAAQAAADn+AABU2REAAQAAAJ/WAQB0zREAAQAAADcxAABY2REAAQAAAFbUAQAAzhEAAQAAADnUAQCEzxEAAQAAACLuAQDY1hEAAQAAACvVAQB8zxEAAQAAAAz/AABU1hEAAQAAACX7AABc2REAAQAAAFD/AADEzBEAAQAAALQzAABg2REAAgAAAF8zAABo2REAAgAAAE4xAABw2REAAQAAAHj7AAB02REAAQAAAOb+AABw1xEAAQAAAJP8AAB42REAAgAAAEPyAQCA2REAAwAAAGAdAADY0BEAAQAAACz8AACM2REAAgAAAIjUAQAczREAAQAAANL+AADI1xEAAQAAAC0dAACU2REAAQAAADDXAQB41xEAAQAAAOAzAACY2REAAgAAADYhAACg2REAAQAAADYzAACk2REABQAAAFUzAAC42REAAgAAAPLWAQDA2REAAQAAADv+AADE2REAAQAAAO37AADI2REAAwAAAK0kAADU2REAAwAAAHHUAQAszxEAAQAAAB8zAADg2REABAAAAHH+AADw2REAAgAAAF3WAQDYzREAAQAAAGvVAQDMzhEAAQAAANUyAAD42REAAQAAAHwhAABUzREAAQAAAOTXAQAs1xEAAQAAAIbVAQAgzhEAAQAAAL0AAAD82REAAwAAAHQyAAAI2hEAAgAA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AEDXAQBg4REAAQAAABwvAAA06REAAQAAACvyAQA46REAAQAAAG38AAA86REAAgAAAEEvAABE6REAAQAAAK0vAABI6REAAQAAANP/AACs5BEAAQAAANwOAABM6REAAgAAAAb9AABU6REAAgAAAMovAABc6REAAQAAAOP7AACw1hEAAQAAAOoyAADQ1REAAQAAADYwAABg6REAAQAAADYxAACc5xEAAQAAAIf7AABk6REAAQAAAJf+AAD0zhEAAQAAAHTuAQCI3xEAAQAAACj/AABw3REAAQAAAFLVAQAgzhEAAQAAACPUAQCc0REAAQAAAHAxAABo6REAAQAAAH/9AABs6REAAwAAANLWAQBY1BEAAQAAAF3UAQDEzBEAAQAAAOT7AACE3hEAAQAAADEvAAB46REAAQAAAFodAAB86REAAQAAANv8AACY1hEAAgAAABTyAQAMzxEAAQAAAKf8AADA5hEAAgAAAIAzAACA6REAAgAAAI/uAQC80xEAAQAAAPTUAQC40BEAAQAAAObUAQCE0hEAAQAAAGsvAACI6REAAQAAAOb7AACE3hEAAQAAAK79AACM6REAAwAAANfXAQDQzREAAQAAAIjWAQBw0hEAAQAAABPUAQA80hEAAQAAAGokAACY6REAAgAAAI/XAQC00BEAAQAAAHsvAAAgHREAAQAAAHwzAACg6REAAgAAAAj9AACo6REAAgAAAHUGAACw6REAAgAAADDVAQAE0xEAAQAAAP/VAQAIzREAAQAAAIDuAQC03BEAAQAAAPP8AAC46REAAwAAAEodAADE6REAAQAAAJn9AADI6REAAwAAAKnWAQA05REAAQAAADvUAQBw3REAAQAAAC39AAAA3xEAAgAAABzxAQDU6REAAwAAAM78AADg6REAAgAAAGAzAADo6REAAgAAAFghAADw6REAAwAAAG3VAQDc0hEAAQAAAKkdAAD86REAAQAAAAkyAAAA6hEAAwAAAAjuAQBEzxEAAQAAABovAAAM6hEAAQAAAOfVAQA80hEAAQAAALHWAQDEzhEAAQAAAM3UAQAg0BEAAQAAAHLUAQCEIBEAAQAAAEzXAQAs1REAAQAAAKIyAAAQ6hEAAQAAAHkhAAAg0BEAAQAAAJMxAAAMzxEAAQAAAM/+AAC0zREAAQAAAPMuAAAU6hEAAQAAAAHxAQAY6hEAAgAA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Y2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xlZDI1NTE5LWRhbGVrLTEuMC4xXHNyY1xwdWJsaWMucnMAAADtsRIAYAAAAIkAAAAOAAAALK4SAFEAAADGAQAADQAAACyuEgBRAAAAxwEAACwAAAAsrhIAUQAAAMgBAAAFAAAALK4SAFEAAADJAQAABQAAACyuEgBRAAAA0AEAACQAAABFZDI1NTE5T0tQAAAsrhIAUQAAAPUBAAAOAAAALK4SAFEAAAD3AQAAOAAAAHN0cnVjdCBFbmNyeXB0ZWRNZXNzYWdlc3RydWN0IFJlS2V5c3RydWN0IFJlRW5jcnlwdGVkTWVzc2FnZVBhcnRpYWxKV0tjcnZ4a3R5Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZT4AAAAAAAAAAQAAAD8AAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAEAAAAAEAAAABAAAAEEAAABCAAAAGAAAAAQAAABDAAAARAAAAAgAAAAEAAAARQAAAEYAAAAEAAAABAAAAAQAAAAMAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcZ2VuZXJpYy1hcnJheS0wLjE0LjRcc3JjXGxpYi5ycwAA1LMSAF4AAAAvAgAACQAAABAAAAAgAAAAc2lnbmF0dXJlIG9wZXJhdGlvbiBmYWlsZWRDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xzaWduYXR1cmUtMS40LjBcc3JjXHNpZ25lci5ycwAAZrQSAFwAAAAQAAAAHAAAAEcAAAAEAAAABAAAAEgAAABJAAAABAAAAAQAAABKAAAASwAAAAgAAAAEAAAARQAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGN0ci0wLjguMFxzcmNcZmxhdm9yc1xjdHIzMi5ycwAAAAS1EgBdAAAAJAAAACMAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xjaXBoZXItMC4zLjBcc3JjXHN0cmVhbS5ycwAAAHS1EgBZAAAAPgAAABwAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xhZXMtMC43LjVcc3JjXHNvZnQucnPgtRIAVAAAAHcAAAABAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcY3RyLTAuOC4wXHNyY1xsaWIucnMARLYSAFMAAACXAAAAHAAAAES2EgBTAAAAnQAAABkAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAEwAAAAAAAAAAQAAAE0AAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xhZWFkLTAuNC4zXHNyY1xsaWIucnP0thIAVAAAAB0BAAAJAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYWVzLWdjbS0wLjkuNFxzcmNcbGliLnJzAFi3EgBXAAAANwEAABkAAABYtxIAVwAAAFIBAAAUAAAAWLcSAFcAAABTAQAAFAAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGNpcGhlci0wLjMuMFxzcmNcc3RyZWFtLnJzAAAA4LcSAFkAAAAVAAAAKAAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGN0ci0wLjguMFxzcmNcZmxhdm9yc1xjdHIzMi5ycwAAAEy4EgBdAAAALQAAADoAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xhZXMtMC43LjVcc3JjXHNvZnQucnO8uBIAVAAAAHcAAAABAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQBOAAAAAAAAAAEAAABNAAAATwAAAAAAAAABAAAAUAAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpAAEAAAAAAAAAAgAAAAAAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xiYXNlNjQtMC4xMy4wXHNyY1xlbmNvZGUucnNJbnZhbGlkIFVURjgAAKC5EgBaAAAANAAAABwAAABpbnRlZ2VyIG92ZXJmbG93IHdoZW4gY2FsY3VsYXRpbmcgYnVmZmVyIHNpemUAAACguRIAWgAAAC8AAAARAAAAUQAAABQAAAAEAAAAEgAAAHNlcmlhbGl6ZV92YWx1ZSBjYWxsZWQgYmVmb3JlIHNlcmlhbGl6ZV9rZXlDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xzZXJkZV9qc29uLTEuMC43OFxzcmNcdmFsdWVcc2VyLnJzk7oSAGEAAACdAQAAHwAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHVuaXZlcnNhbC1oYXNoLTAuNC4xXHNyY1xsaWIucnMAAAS7EgBeAAAATwAAACcAAABFcnJvcnVua25vd25fY29kZQAAAFIAAAAEAAAABAAAAFMAAABpbnRlcm5hbF9jb2RlZGVzY3JpcHRpb25UAAAACAAAAAQAAABVAAAAb3NfZXJyb3JWAAAABAAAAAQAAABXAAAATm9kZS5qcyBBUEkgY3J5cHRvLnJhbmRvbUZpbGxTeW5jIGlzIHVuYXZhaWxhYmxlTm9kZS5qcyBjcnlwdG8gbW9kdWxlIGlzIHVuYXZhaWxhYmxlcmFuZFNlY3VyZTogVnhXb3JrcyBSTkcgbW9kdWxlIGlzIG5vdCBpbml0aWFsaXplZFdlYiBBUEkgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpcyB1bmF2YWlsYWJsZVdlYiBDcnlwdG8gQVBJIGlzIHVuYXZhaWxhYmxlUkRSQU5EOiBpbnN0cnVjdGlvbiBub3Qgc3VwcG9ydGVkUkRSQU5EOiBmYWlsZWQgbXVsdGlwbGUgdGltZXM6IENQVSBpc3N1ZSBsaWtlbHlSdGxHZW5SYW5kb206IFdpbmRvd3Mgc3lzdGVtIGZ1bmN0aW9uIGZhaWx1cmVTZWNSYW5kb21Db3B5Qnl0ZXM6IGlPUyBTZWN1cml0eSBmcmFtZXdvcmsgZmFpbHVyZWVycm5vOiBkaWQgbm90IHJldHVybiBhIHBvc2l0aXZlIHZhbHVlZ2V0cmFuZG9tOiB0aGlzIHRhcmdldCBpcyBub3Qgc3VwcG9ydGVkACcAAAAmAAAAAAAAADIAAAAtAAAALwAAACEAAAAdAAAALQBB0PvKAAsvMQAAACQAAAAwAAAAfL0SAFa9EgAAAAAAJL0SAPe8EgDIvBIAp7wSAIq8EgBdvBIAQYj8ygAL0QwsvBIACLwSANi7EgBjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwAAAFq+EgBPAAAAhQEAABoAAABYAAAAAAAAAAEAAAAjAAAAWgAAAGNyeXB0b0M6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGpzLXN5cy0wLjMuNTVcc3JjXGxpYi5ycwAAAFwAAAByZXR1cm4gdGhpcwDWvhIAVwAAAFMWAAABAAAAY2Fubm90IGFjY2VzcyBhIFRocmVhZCBMb2NhbCBTdG9yYWdlIHZhbHVlIGR1cmluZyBvciBhZnRlciBkZXN0cnVjdGlvbi9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAAACWvxIATwAAAIUBAAAaAAAAXQAAAAAAAAABAAAAIwAAAF4AAAAEAAAABAAAAF8AAAAvcnVzdGMvNzc3YmI4NmJjZGJjNTY4YmU3Y2ZmNmVlZWFhZjgxYTg5YjRhYTUwYi9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzVHJpZWQgdG8gc2hyaW5rIHRvIGEgbGFyZ2VyIGNhcGFjaXR5ZMASACQAAAAYwBIATAAAAKsBAAAJAAAAY2xvc3VyZSBpbnZva2VkIHJlY3Vyc2l2ZWx5IG9yIGRlc3Ryb3llZCBhbHJlYWR5BAAAAAAAAABudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0SnNWYWx1ZSgpAELBEgAIAAAASsESAAEAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xyZWdleC0xLjUuNFxzcmNccmVfdW5pY29kZS5yc1zBEgBcAAAARQIAACAAAABcwRIAXAAAAEYCAAAbAAAAXMESAFwAAABKAgAAFwAAAFzBEgBcAAAAMAIAAB8AAABcwRIAXAAAADQCAAAbAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZUM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGhleC0wLjQuM1xzcmNcbGliLnJzAAAzwhIAUwAAAMcAAAAlAAAAM8ISAFMAAADHAAAAQQAAAAEAAAAAAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZUM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHNlcmRlX2pzb24tMS4wLjc4XHNyY1xzZXIucnMA2MISAFsAAAA7BgAAEgAAAG51bGx0cnVlZmFsc2UiW10se3062MISAFsAAAAzCAAAOwAAANjCEgBbAAAAPQgAADcAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xjYW5vbmljYWxfanNvbi0wLjQuMFxzcmNcc2VyLnJzXHRcclxuXGZcYlwvXFxcIjAxMjM0NTY3ODlhYmNkZWYAAPjDEgAAAAAAJ1wnKD86RSg/OlsrXTAqfCgtfCkwKyl8ZSg/OlsrXXwoLXwpKTAqKShbMC05XSkAeMMSAF4AAABrAAAASQAAAEUkMSQyJDNcdXsAAAAAAAAwAAAAAAAAAAIAQeSIywALgw4GAAAAAQAAAHjDEgBeAAAAmwAAADYAAAB4wxIAXgAAAJwAAAAtAAAAeMMSAF4AAACdAAAALQAAAEfEEgACAAAAMHt9SlNPTkVycm9yeAAAAAQAAAAEAAAAeQAAAFV0ZjhFcnJvcgAAAHoAAAAEAAAABAAAAHsAAAABAAAAAAAAAG51bGx0cnVlZmFsc2V9AAB8AAAADAAAAAQAAAB9AAAAfgAAAB8AAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAABDxRIASwAAAF8JAAAOAAAAfwAAAAAAAAABAAAAIQAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAgAAAABAAAAAEAAAAgQAAAC9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMA7MUSAE8AAAAcBAAAFwAAAOzFEgBPAAAAjAUAACEAAADsxRIATwAAAJgFAAAUAAAA7MUSAE8AAACYBQAAIQAAAC9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvaXRlci5ycwAAfMYSAE4AAACGBQAAFQAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSBieSB6ZXJvAAAAAQAAAAAAAACCAAAABAAAAAQAAACDAAAAhAAAAIUAAAAwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OXJlY3Vyc2lvbiBsaW1pdCBleGNlZWRlZHVuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGV0cmFpbGluZyBjaGFyYWN0ZXJzdHJhaWxpbmcgY29tbWFsb25lIGxlYWRpbmcgc3Vycm9nYXRlIGluIGhleCBlc2NhcGVrZXkgbXVzdCBiZSBhIHN0cmluZ2NvbnRyb2wgY2hhcmFjdGVyIChcdTAwMDAtXHUwMDFGKSBmb3VuZCB3aGlsZSBwYXJzaW5nIGEgc3RyaW5naW52YWxpZCB1bmljb2RlIGNvZGUgcG9pbnRudW1iZXIgb3V0IG9mIHJhbmdlaW52YWxpZCBudW1iZXJpbnZhbGlkIGVzY2FwZWV4cGVjdGVkIHZhbHVlZXhwZWN0ZWQgaWRlbnRleHBlY3RlZCBgLGAgb3IgYH1gZXhwZWN0ZWQgYCxgIG9yIGBdYGV4cGVjdGVkIGA6YEVPRiB3aGlsZSBwYXJzaW5nIGEgdmFsdWVFT0Ygd2hpbGUgcGFyc2luZyBhIHN0cmluZ0VPRiB3aGlsZSBwYXJzaW5nIGFuIG9iamVjdEVPRiB3aGlsZSBwYXJzaW5nIGEgbGlzdEVycm9yKCwgbGluZTogLCBjb2x1bW46ICkAAACsyRIABgAAALLJEgAIAAAAuskSAAoAAADEyRIAAQAAAC9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwCHAAAADAAAAAQAAACIAAAAiQAAAB8AAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AOjJEgBLAAAAXwkAAA4AAAABAAAAAAAAAIoAAAAAAAAAAQAAACEAAAAvcnVzdGMvNzc3YmI4NmJjZGJjNTY4YmU3Y2ZmNmVlZWFhZjgxYTg5YjRhYTUwYi9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzVHJpZWQgdG8gc2hyaW5rIHRvIGEgbGFyZ2VyIGNhcGFjaXR5+MoSACQAAACsyhIATAAAAKsBAAAJAAAAMDEyMzQ1Njc4OWFiY2RlZnV1dXV1dXV1YnRudWZydXV1dXV1dXV1dXV1dXV1dXV1AAAiAEGgl8sACwFcAEHEmMsAC40+L3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnMARMwSAF8AAAD/AQAALwAAAETMEgBfAAAAPwIAAFYAAAAvcnVzdGMvNzc3YmI4NmJjZGJjNTY4YmU3Y2ZmNmVlZWFhZjgxYTg5YjRhYTUwYi9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9ub2RlLnJzYXNzZXJ0aW9uIGZhaWxlZDogZWRnZS5oZWlnaHQgPT0gc2VsZi5oZWlnaHQgLSAxAMTMEgBbAAAAfwIAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBpZHggPCBDQVBBQ0lUWcTMEgBbAAAAgwIAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBlZGdlLmhlaWdodCA9PSBzZWxmLm5vZGUuaGVpZ2h0IC0gMQAAAMTMEgBbAAAAnwMAAAkAAADEzBIAWwAAAE0EAAAWAAAAxMwSAFsAAACKBAAAFgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNyYy5sZW4oKSA9PSBkc3QubGVuKCnEzBIAWwAAAMoGAAAFAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZS9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25hdmlnYXRlLnJzAABbzhIAXwAAAJQAAAAkAAAAW84SAF8AAAC4AAAAJwAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvcnVzdGMvNzc3YmI4NmJjZGJjNTY4YmU3Y2ZmNmVlZWFhZjgxYTg5YjRhYTUwYi9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9tYXAvZW50cnkucnMAB88SAGAAAABGAQAALgAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvcnVzdGMvNzc3YmI4NmJjZGJjNTY4YmU3Y2ZmNmVlZWFhZjgxYTg5YjRhYTUwYi9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzVHJpZWQgdG8gc2hyaW5rIHRvIGEgbGFyZ2VyIGNhcGFjaXR5AO/PEgAkAAAAo88SAEwAAACrAQAACQAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LTEuNS40XHNyY1xjb21waWxlLnJzAAAALNASAFkAAACuAAAAGgAAAGFzc2VydGlvbiBmYWlsZWQ6IGNscy5pc19hbGxfYXNjaWkoKSzQEgBZAAAAEgEAABUAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmNvbXBpbGVkLnVzZXNfYnl0ZXMoKSzQEgBZAAAACgEAABEAAAAs0BIAWQAAAJUBAAAOAAAALNASAFkAAACcAQAADgAAAGFzc2VydGlvbiBmYWlsZWQ6ICFyYW5nZXMuaXNfZW1wdHkoKSzQEgBZAAAAtAEAAAkAAAAs0BIAWQAAANIBAAATAAAALNASAFkAAAAUAgAAEwAAACzQEgBZAAAA3AIAABEAAAAs0BIAWQAAAA0DAAAlAAAALNASAFkAAAD1AgAAFQAAACzQEgBZAAAA+QIAABUAAAAs0BIAWQAAAP0CAAAVAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogAADM0RIAKgAAAGF0IGxlYXN0IG9uZSBvZiB0aGUgc3BsaXQgaG9sZXMgbXVzdCBiZSBmaWxsZWQAAADSEgAuAAAALNASAFkAAAAAAwAAIQAAAG11c3QgYmUgY2FsbGVkIG9uIHNpbmdsZSBob2xlAAAASNISAB0AAAAs0BIAWQAAAEMDAAARAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogbm90IGFsbCBpbnN0cnVjdGlvbnMgd2VyZSBjb21waWxlZCEgZm91bmQgdW5jb21waWxlZCBpbnN0cnVjdGlvbjoggNISAGwAAAAs0BIAWQAAAGUDAAASAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogbXVzdCBiZSBjYWxsZWQgb24gU3BsaXQgaW5zdHJ1Y3Rpb24sIGluc3RlYWQgaXQgd2FzIGNhbGxlZCBvbjogAAAABNMSAGkAAAAs0BIAWQAAAHMDAAASAAAALNASAFkAAAB/AwAAEgAAACzQEgBZAAAAiwMAABIAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBtdXN0IGJlIGNhbGxlZCBvbiBhIGNvbXBpbGVkIGluc3RydWN0aW9uLCBpbnN0ZWFkIGl0IHdhcyBjYWxsZWQgb246IAAAqNMSAG4AAAAs0BIAWQAAAJcDAAASAAAALNASAFkAAADIAwAANQAAACzQEgBZAAAA6gMAAEIAAAAs0BIAWQAAABYEAAA7AAAALNASAFkAAABoBAAACQAAAGF0dGVtcHQgdG8gY2FsY3VsYXRlIHRoZSByZW1haW5kZXIgd2l0aCBhIGRpdmlzb3Igb2YgemVybwAAACzQEgBZAAAAlAQAAA0AAAAs0BIAWQAAAJkEAAAuAAAAjgAAAI8AAAAEAAAABAAAAJAAAABTcGxpdDJTcGxpdDFTcGxpdFVuY29tcGlsZWQAkQAAAAQAAAAEAAAAkgAAAENvbXBpbGVkkwAAAAQAAAAEAAAAlAAAAEJ5dGVzc3RhcnQAAJUAAAAEAAAABAAAAJYAAABlbmRSYW5nZXNyYW5nZXMAlwAAAAQAAAAEAAAAmAAAAENoYXJjAAAAmQAAAAQAAAAEAAAAmgAAAEVtcHR5TG9va2xvb2sAAACbAAAABAAAAAQAAACcAAAAU2F2ZXNsb3QEAAAAAAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVfX05vbmV4aGF1c3RpdmVDb21waWxlZFRvb0JpZ58AAAAEAAAABAAAAKAAAABTeW50YXgoCgDWEgAIAAAACgAAABDWEgAAAAAAENYSAAEAAAApAAAAJNYSAAEAAABhc3NlcnRpb24gZmFpbGVkOiBpIDwgc2VsZi5jYXBhY2l0eSgpQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNccmVnZXgtMS41LjRcc3JjXHNwYXJzZS5ycwAAAFXWEgBYAAAAMQAAAAkAAABV1hIAWAAAADMAAAAJAAAAVdYSAFgAAAA3AAAAEQAAAC9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9yaW5nX3NsaWNlcy5ycwAA4NYSAGYAAAAgAAAADgAAAODWEgBmAAAAIwAAABEAAABhc3NlcnRpb24gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKQChAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNccmVnZXgtMS41LjRcc3JjXHBvb2wucnMAAJDXEgBWAAAA6QAAACsAAACQ1xIAVgAAAPUAAAArAAAAcmVnZXg6IHRocmVhZCBJRCBhbGxvY2F0aW9uIHNwYWNlIGV4aGF1c3RlZACQ1xIAVgAAAFEAAAANAAAABAAAAAAAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAKIAAAAIAAAABAAAAKMAAACkAAAABAAAAAQAAAClAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNccmVnZXgtMS41LjRcc3JjXGlucHV0LnJzAJjYEgBXAAAArAAAABsAAACY2BIAVwAAANQAAAAYAAAAmNgSAFcAAAAFAQAAFgAAAJjYEgBXAAAACQEAABsAAACY2BIAVwAAAEUBAAAYAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNccmVnZXgtMS41LjRcc3JjXGxpdGVyYWxcaW1wLnJzAAAAQNkSAF0AAABPAQAAGgAAAEDZEgBdAAAATwEAACkAAABA2RIAXQAAAE8BAAA4AAAAQNkSAF0AAABOAQAAGgAAAEDZEgBdAAAATgEAACkAAABA2RIAXQAAAE0BAAAZAAAApgAAAAQAAAAEAAAAmgAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LTEuNS40XHNyY1xkZmEucnMAAAAQ2hIAVQAAAMYBAAAfAAAAENoSAFUAAADkAQAAHwAAABDaEgBVAAAAvAIAACcAAAAQ2hIAVQAAAJECAAA0AAAAENoSAFUAAAAqAwAAJwAAABDaEgBVAAAAbAUAAA8AAAAQ2hIAVQAAAHwFAAAJAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogAADY2hIAKgAAAEJVRzogUmVnZXhTZXQgY2Fubm90IGJlIHVzZWQgd2l0aCBmaW5kAAAM2xIAJgAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LTEuNS40XHNyY1xleGVjLnJzAAA82xIAVgAAAEACAAARAAAAPNsSAFYAAADSAgAAEgAAADzbEgBWAAAASwMAAC0AAAA82xIAVgAAAFQDAAASAAAAQlVHOiByZXZlcnNlIG1hdGNoIGltcGxpZXMgZm9yd2FyZCBtYXRjaDzbEgBWAAAAhQMAABsAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xyZWdleC0xLjUuNFxzcmNcbGl0ZXJhbFxpbXAucnMAAAAM3BIAXQAAAE8BAAAaAAAADNwSAF0AAABPAQAAKQAAAAzcEgBdAAAATwEAADgAAAAM3BIAXQAAAE4BAAAaAAAADNwSAF0AAABOAQAAKQAAAAzcEgBdAAAATQEAABkAAACnAAAAL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnMA0NwSAF8AAAC4AAAAJwAAAEJ5dGVzAAAAqAAAAAQAAAAEAAAAqQAAAFJhbmdlcwAAqgAAAAQAAAAEAAAAqwAAAENoYXKsAAAABAAAAAQAAACtAAAARW1wdHlMb29rAAAArgAAAAQAAAAEAAAArwAAAFNwbGl0AAAAsAAAAAQAAAAEAAAAsQAAAFNhdmWyAAAABAAAAAQAAACzAAAATWF0Y2gAAAC0AAAABAAAAAQAAACQAAAASW5zdFNhdmVnb3Rvc2xvdEluc3RTcGxpdGdvdG8xZ290bzJJbnN0RW1wdHlMb29rbG9va7UAAAAEAAAABAAAAJwAAABOb3RXb3JkQm91bmRhcnlBc2NpaVdvcmRCb3VuZGFyeUFzY2lpTm90V29yZEJvdW5kYXJ5V29yZEJvdW5kYXJ5RW5kVGV4dFN0YXJ0VGV4dEVuZExpbmVTdGFydExpbmVJbnN0Q2hhcmMAAAC2AAAABAAAAAQAAACaAAAASW5zdFJhbmdlc3Jhbmdlc7cAAAAEAAAABAAAALgAAABJbnN0Qnl0ZXNzdGFydAAAuQAAAAQAAAAEAAAAlgAAAGVuZGFscmVhZHkgYm9ycm93ZWQABAAAAAAAAABQb2lzb25FcnJvcmNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAALoAAAAAAAAAAQAAACUAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYWhvLWNvcmFzaWNrLTAuNy4xOFxzcmNcYXV0b21hdG9uLnJzAHDfEgBjAAAAngEAADsAAABw3xIAYwAAALkBAAA6AAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYWhvLWNvcmFzaWNrLTAuNy4xOFxzcmNcZGZhLnJzAAAA9N8SAF0AAADGAAAACQAAAPTfEgBdAAAAAwEAAAkAAAD03xIAXQAAAEYBAAAJAAAA9N8SAF0AAACKAQAACQAAAPTfEgBdAAAA4AEAAAkAAAD03xIAXQAAAOcBAAAJAAAAY2FuJ3Qgc3dhcCBzdGF0ZXMgaW4gcHJlbXVsdGlwbGllZCBERkEAAPTfEgBdAAAA7AEAAAkAAAD03xIAXQAAAPEBAAAYAAAA9N8SAF0AAADzAQAAFgAAAGNhbm5vdCBzaHVmZmxlIG1hdGNoIHN0YXRlcyBvZiBwcmVtdWx0aXBsaWVkIERGQfTfEgBdAAAAAgIAAAkAAAD03xIAXQAAAA0CAAAQAAAA9N8SAF0AAAAVAgAAEAAAAPTfEgBdAAAAGgIAABEAAAD03xIAXQAAABsCAAARAAAA9N8SAF0AAAAfAgAAGAAAAPTfEgBdAAAAKQIAAB4AAAD03xIAXQAAACoCAAAUAAAA9N8SAF0AAAAvAgAADAAAAPTfEgBdAAAAQgIAAB4AAAD03xIAXQAAAIgCAAANAAAABAAAAAAAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYWhvLWNvcmFzaWNrLTAuNy4xOFxzcmNcYXV0b21hdG9uLnJzABziEgBjAAAAngEAADsAAAAc4hIAYwAAALkBAAA6AAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYWhvLWNvcmFzaWNrLTAuNy4xOFxzcmNcbmZhLnJzAAAAoOISAF0AAACBAAAACgAAAKDiEgBdAAAAjgAAAAkAAACg4hIAXQAAAJMAAAAJAAAAoOISAF0AAACbAAAACQAAAKDiEgBdAAAAnwAAAAoAAACg4hIAXQAAAKMAAAAOAAAAoOISAF0AAADxAAAACQAAAKDiEgBdAAAAEAEAABoAAACg4hIAXQAAAJ8BAAAuAAAAoOISAF0AAACsAQAAEQAAAKDiEgBdAAAAzwEAAB4AAACg4hIAXQAAAOMBAAAeAAAAoOISAF0AAAAIAgAADwAAAKDiEgBdAAAAFwIAAB4AAABzdGF0ZXMgdGhhdCBhcmUgbWF0Y2ggc3RhdGVzIG9yIGZvbGxvdyBtYXRjaCBzdGF0ZXMgc2hvdWxkIG5ldmVyIGhhdmUgYSBmYWlsdXJlIHRyYW5zaXRpb24gYmFjayB0byB0aGUgc3RhcnQgc3RhdGUgaW4gbGVmdG1vc3Qgc2VhcmNoaW5n4OMSAIgAAACg4hIAXQAAADkEAAAVAAAAIG11c3Qgbm90IGJlIGVxdWFsIHRvIAAAcOQSAAAAAACA5BIAFgAAAKDiEgBdAAAAOgUAAAUAAACg4hIAXQAAADwFAAAiAAAAoOISAF0AAAA9BQAAHwAAAKDiEgBdAAAAPwUAACIAAACg4hIAXQAAAEAFAAAPAAAAoOISAF0AAABABQAAHgAAAC9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9yaW5nX3NsaWNlcy5ycwAACOUSAGYAAAAgAAAADgAAAAjlEgBmAAAAIwAAABEAAAAEAAAAAAAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYWhvLWNvcmFzaWNrLTAuNy4xOFxzcmNcYXV0b21hdG9uLnJzAAC75RIAYwAAAOwAAAA8AAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZbvlEgBjAAAAOgIAACsAAABjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwAAAK7mEgBPAAAAhQEAABoAAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xyZWdleC0xLjUuNFxzcmNccGlrZXZtLnJzEOcSAFgAAABiAAAAHwAAABDnEgBYAAAArAAAABoAAAAQ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aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LTEuNS40XHNyY1xyZV91bmljb2RlLnJzcO4SAFwAAAA6AAAACgAAAAEAAAAAAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQDEAAAACAAAAAQAAADFAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQDGAAAADAAAAAQAAADHAAAAL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnMAXO8SAF8AAAA/AgAAVgAAAC9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25vZGUucnNhc3NlcnRpb24gZmFpbGVkOiBlZGdlLmhlaWdodCA9PSBzZWxmLmhlaWdodCAtIDEAzO8SAFsAAAB/AgAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IGlkeCA8IENBUEFDSVRZzO8SAFsAAACDAgAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IGVkZ2UuaGVpZ2h0ID09IHNlbGYubm9kZS5oZWlnaHQgLSAxAAAAzO8SAFsAAACfAwAACQAAAMzvEgBbAAAATQQAABYAAADM7xIAWwAAAIoEAAAWAAAAYXNzZXJ0aW9uIGZhaWxlZDogc3JjLmxlbigpID09IGRzdC5sZW4oKczvEgBbAAAAygYAAAUAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNccmVnZXgtMS41LjRcc3JjXGJhY2t0cmFjay5ycwAAY/ESAFsAAABdAAAAHwAAAGPxEgBbAAAA0AAAABMAAABj8RIAWwAAAOEAAAAZAAAAY/ESAFsAAAASAQAADAAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYucGF0dGVybnMubGVuKCkgPD0gdTE2OjpNQVggYXMgdXNpemVDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xhaG8tY29yYXNpY2stMC43LjE4XHNyY1xwYWNrZWRcYXBpLnJzAAA68hIAZAAAADIBAAAJAAAAL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbWFwL2VudHJ5LnJzsPISAGAAAABGAQAALgAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LTEuNS40XHNyY1x1dGY4LnJzAAAg8xIAVgAAAIMAAAAaAAAAIPMSAFYAAACHAAAAGAAAAC9ydXN0Yy83NzdiYjg2YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9tb2QucnNhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmNhcCgpID09IG9sZF9jYXAgKiAyAAAAmPMSAF4AAACvCAAACQAAAGFscmVhZHkgYm9ycm93ZWQvcnVzdGMvNzc3YmI4NmJjZGJjNTY4YmU3Y2ZmNmVlZWFhZjgxYTg5YjRhYTUwYi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAARPQSAEoAAADTAAAAEQAAAAQAAAAAAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQDIAAAAAAAAAAEAAAAlAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNccmVnZXgtMS41LjRcc3JjXGRmYS5ycwAAAOT0EgBVAAAAxgEAAB8AAADk9BIAVQAAAOQBAAAfAAAA5PQSAFUAAAC8AgAAJwAAAOT0EgBVAAAAkQIAADQAAADk9BIAVQAAACoDAAAnAAAA5PQSAFUAAABsBQAADwAAAOT0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AAABAAAAhPwSAIT8EgCE/BIA/wAAAJD8EgAAAQAAAQEAAAIBAAADAQAABAEAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGFoby1jb3Jhc2ljay0wLjcuMThcc3JjXHByZWZpbHRlci5yc3NldFJhcmVCeXRlT2Zmc2V0cwAAAAUBAAAMAAAABAAAAAYBAADU/BIAYwAAACwCAAARAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZdT8EgBjAAAAQQIAABIAAADU/BIAYwAAAH0CAAAvAAAA1PwSAGMAAAChAgAAHQAAANT8EgBjAAAA3QIAACoAAADU/BIAYwAAAOECAAAvAAAA1PwSAGMAAAAFAwAANgAAANT8EgBjAAAACQMAAC8AAADU/BIAYwAAAFQDAAARAAAA1PwSAGMAAABgAwAADQAAANT8EgBjAAAAbwMAABIAAADU/BIAYwAAAIQDAAANAAAA1PwSAGMAAACZAwAAHQAAANT8EgBjAAAAtQMAACoAAADU/BIAYwAAANIDAAA2AAAANzQzMjEwLy4tZ/JCQ+UsKyopKCcmJSQjIiE4IB8eHRz/lKSViKCbrd3ehnroytfg0NzMu7ezsaiyyOLDmriufni/ncKqvaKhlsGOiauwuae6cK/AvJyMj3uFgJOKknLfl/nY7uz949rm94e08en29OeL9fP768nE8NaYts21fxvU09LV5MWpn4OsaVBiYGFRz5F0c5CCmXlrhG1ufG9SbHaNcYF3faV1XGpTSGNdQU+m7aPHvuHRy8bZ287q+J7v/////////////////////////////////////////////////////////////////////////////////////1BhY2tlZAAABwEAAAQAAAAEAAAACAEAAAkBAAAEAAAABAAAAAoBAABSYXJlQnl0ZU9mZnNldG1heAAAAAsBAAAEAAAABAAAAJYAAABSYXJlQnl0ZXNPbmVieXRlMW9mZnNldAAMAQAABAAAAAQAAAANAQAAUmFyZUJ5dGVzVHdvb2Zmc2V0c2J5dGUyUmFyZUJ5dGVzVGhyZWVieXRlM1N0YXJ0Qnl0ZXNPbmVTdGFydEJ5dGVz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aW9uIGZhaWxlZDogIWJ5dGVzLmlzX2VtcHR5KClDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xhaG8tY29yYXNpY2stMC43LjE4XHNyY1xwYWNrZWRccGF0dGVybi5ycwBPBxMAaAAAAEoAAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5ieV9pZC5sZW4oKSA8PSB1MTY6Ok1BWCBhcyB1c2l6ZQBPBxMAaAAAAEsAAAAJAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZU8HEwBoAAAAZgAAACsAAABPBxMAaAAAAIwAAAAJAAAATwcTAGgAAACfAAAAEgAAAE8HEwBoAAAA2QAAABIAAABQYXR0ZXJuc2tpbmQ2AQAABAAAAAQAAAAiAQAAYnlfaWQAAAA3AQAABAAAAAQAAAA4AQAAb3JkZXIAAAA5AQAABAAAAAQAAAA6AQAAbWluaW11bV9sZW4AOwEAAAQAAAAEAAAAkAAAAG1heF9wYXR0ZXJuX2lkAAA8AQAABAAAAAQAAAAVAQAAdG90YWxfcGF0dGVybl9ieXRlcwAEAAAAAAAAAAIAAAAAAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZUM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGFoby1jb3Jhc2ljay0wLjcuMThcc3JjXGFob2NvcmFzaWNrLnJzAAAATAkTAGUAAABHCAAAKwAAAEVycm9ya2luZAAAAD0BAAAEAAAABAAAAD4BAABQcmVtdWx0aXBseU92ZXJmbG93bWF4AAA/AQAABAAAAAQAAACQAAAAcmVxdWVzdGVkX21heFN0YXRlSURPdmVyZmxvd0M6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXG1lbWNoci0yLjQuMVxzcmNcbWVtbWVtXHR3b3dheS5ycyQKEwBgAAAApgAAACYAAAAkChMAYAAAAK4AAAApAAAAJAoTAGAAAACzAAAANAAAACQKEwBgAAAAuwAAACQAAAAkChMAYAAAALsAAAAxAAAAJAoTAGAAAAC+AAAAIgAAACQKEwBgAAAAvgAAADMAAAAkChMAYAAAANUAAAAmAAAAJAoTAGAAAADcAAAAKQAAACQKEwBgAAAA4QAAADQAAAAkChMAYAAAAOgAAAAYAAAAJAoTAGAAAADoAAAAJQAAAEEBAAAEAAAABAAAAJYAAABCAQAABAAAAAQAAACWAAAAQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcbWVtY2hyLTIuNC4xXHNyY1xtZW1tZW1cdHdvd2F5LnJzZAsTAGAAAAC+AQAAHQAAAGQLEwBgAAAAvwEAAB4AAABkCxMAYAAAAAgCAAAbAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKClDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xtZW1jaHItMi40LjFcc3JjXG1lbW1lbVxyYXJlYnl0ZXMucnMAABcMEwBjAAAAVAAAAAkAAAAXDBMAYwAAAFwAAAAKAAAAFwwTAGMAAABcAAAAKAAAADc0MzIxMC8uLWfyQkPlLCsqKSgnJiUkIyIhOCAfHh0c/5SklYigm63d3oZ66MrX4NDczLu3s7Gossjiw5q4rn54v53Cqr2ioZbBjomrsLmnunCvwLycjI97hYCTipJy35f52O7s/ePa5veHtPHp9vTni/Xz++vJxPDWmLbNtX8b1NPS1eTFqZ+DrGlQYmBhUc+RdHOQgpl5a4RtbnxvUmx2jXGBd32ldVxqU0hjXUFPpu2jx77h0cvG2dvO6vie7/////////////////////////////////////////////////////////////////////////////////////9DOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xtZW1jaHItMi40LjFcc3JjXG1lbW1lbVxwcmVmaWx0ZXJcZmFsbGJhY2sucnOsDRMAbAAAAD4AAAArAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZUM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LXN5bnRheC0wLjYuMjVcc3JjXGFzdFxtb2QucnNiYWNrcmVmZXJlbmNlcyBhcmUgbm90IHN1cHBvcnRlZGludmFsaWQgVW5pY29kZSBjaGFyYWN0ZXIgY2xhc3NyZXBldGl0aW9uIG9wZXJhdG9yIG1pc3NpbmcgZXhwcmVzc2lvbnVuY2xvc2VkIGNvdW50ZWQgcmVwZXRpdGlvbnVub3BlbmVkIGdyb3VwdW5jbG9zZWQgZ3JvdXB1bmNsb3NlZCBjYXB0dXJlIGdyb3VwIG5hbWVlbXB0eSBjYXB0dXJlIGdyb3VwIG5hbWVkdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1ldW5yZWNvZ25pemVkIGZsYWdkdXBsaWNhdGUgZmxhZ2RhbmdsaW5nIGZsYWcgbmVnYXRpb24gb3BlcmF0b3J1bnJlY29nbml6ZWQgZXNjYXBlIHNlcXVlbmNlaW52YWxpZCBoZXhhZGVjaW1hbCBkaWdpdHVuY2xvc2VkIGNoYXJhY3RlciBjbGFzc2ludmFsaWQgcmFuZ2UgYm91bmRhcnksIG11c3QgYmUgYSBsaXRlcmFsUA4TAGEAAAA5AQAAEgAAAGxvb2stYXJvdW5kLCBpbmNsdWRpbmcgbG9vay1haGVhZCBhbmQgbG9vay1iZWhpbmQsIGlzIG5vdCBzdXBwb3J0ZWQAYBATAEMAAACxDhMAIAAAANEOEwAfAAAA8A4TACYAAAAWDxMAGwAAAHJlcGV0aXRpb24gcXVhbnRpZmllciBleHBlY3RzIGEgdmFsaWQgZGVjaW1hbAAAAMwQEwAtAAAAaW52YWxpZCByZXBldGl0aW9uIGNvdW50IHJhbmdlLCB0aGUgc3RhcnQgbXVzdCBiZSA8PSB0aGUgZW5kBBETADwAAABleGNlZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5lc3RlZCBwYXJlbnRoZXNlcy9icmFja2V0cyAoKQBIERMAOgAAAIIREwABAAAAMQ8TAA4AAAA/DxMADgAAAE0PEwAbAAAAaW52YWxpZCBjYXB0dXJlIGdyb3VwIGNoYXJhY3RlcgCsERMAHwAAAGgPEwAYAAAAgA8TABwAAACcDxMAEQAAAGV4cGVjdGVkIGZsYWcgYnV0IGdvdCBlbmQgb2YgcmVnZXgAAOwREwAiAAAAZmxhZyBuZWdhdGlvbiBvcGVyYXRvciByZXBlYXRlZAAYEhMAHwAAAK0PEwAOAAAAuw8TAB8AAADaDxMAHAAAAGluY29tcGxldGUgZXNjYXBlIHNlcXVlbmNlLCByZWFjaGVkIGVuZCBvZiBwYXR0ZXJuIHByZW1hdHVyZWx5AABYEhMAPgAAAPYPEwAZAAAAaGV4YWRlY2ltYWwgbGl0ZXJhbCBpcyBub3QgYSBVbmljb2RlIHNjYWxhciB2YWx1ZQAAAKgSEwAxAAAAaGV4YWRlY2ltYWwgbGl0ZXJhbCBlbXB0eQAAAOQSEwAZAAAAZGVjaW1hbCBsaXRlcmFsIGludmFsaWQACBMTABcAAABkZWNpbWFsIGxpdGVyYWwgZW1wdHkAAAAoExMAFQAAAA8QEwAYAAAAJxATACkAAABpbnZhbGlkIGNoYXJhY3RlciBjbGFzcyByYW5nZSwgdGhlIHN0YXJ0IG11c3QgYmUgPD0gdGhlIGVuZABYExMAOwAAAGludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGZvdW5kIGluIGNoYXJhY3RlciBjbGFzc5wTEwAwAAAAZXhjZWVkZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNhcHR1cmluZyBncm91cHMgKAAAANQTEwAxAAAAghETAAEAAAD/////UA4TAGEAAAA5AgAAIgAAAFAOEwBhAAAAUQIAACIAAABhbG51bWFscGhhYXNjaWlibGFua2NudHJsZGlnaXRncmFwaGxvd2VycHJpbnRwdW5jdHNwYWNldXBwZXJ4ZGlnaXQAAFAOEwBhAAAAHwQAACMAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNccmVnZXgtc3ludGF4LTAuNi4yNVxzcmNcYXN0XHBhcnNlLnJzAAC7FBMAYwAAAGgBAAAXAAAAuxQTAGMAAABpAQAAGgAAALsU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AAB+BQAAfwUAAIAFAACBBQAAggUAAIMFAACEBQAAhQUAAIYFAAAxBQAAMgUAADMFAAA0BQAANQUAADYFAAA3BQAAOAUAADkFAAA6BQAAOwUAADwFAAA9BQAAPgUAAD8FAABABQAAQQUAAEIFAABDBQAARAUAAEUFAABGBQAARwUAAEgFAABJBQAASgUAAEsFAABMBQAATQUAAE4FAABPBQAAUAUAAFEFAABSBQAAUwUAAFQFAABVBQAAVgUAAAAtAAABLQAAAi0AAAMtAAAELQAABS0AAAYtAAAHLQAACC0AAAktAAAKLQAACy0AAAwtAAANLQAADi0AAA8tAAAQLQAAES0AABItAAATLQAAFC0AABUtAAAWLQAAFy0AABgtAAAZLQAAGi0AABstAAAcLQAAHS0AAB4tAAAfLQAAIC0AACEtAAAiLQAAIy0AACQtAAAlLQAAJy0AAC0tAACQHAAAkRwAAJIcAACTHAAAlBwAAJUcAACWHAAAlxwAAJgcAACZHAAAmhwAAJscAACcHAAAnRwAAJ4cAACfHAAAoBwAAKEcAACiHAAAoxwAAKQcAAClHAAAphwAAKccAACoHAAAqRwAAKocAACrHAAArBwAAK0cAACuHAAArxwAALAcAACxHAAAshwAALMcAAC0HAAAtRwAALYcAAC3HAAAuBwAALkcAAC6HAAAvRwAAL4cAAC/HAAAcKsAAHGrAAByqwAAc6sAAHSrAAB1qwAAdqsAAHerAAB4qwAAeasAAHqrAAB7qwAAfKsAAH2rAAB+qwAAf6sAAICrAACBqwAAgqsAAIOrAACEqwAAhasAAIarAACHqwAAiKsAAImrAACKqwAAi6sAAIyrAACNqwAAjqsAAI+rAACQqwAAkasAAJKrAACTqwAAlKsAAJWrAACWqwAAl6sAAJirAACZqwAAmqsAAJurAACcqwAAnasAAJ6rAACfqwAAoKsAAKGrAACiqwAAo6sAAKSrAAClqwAApqsAAKerAACoqwAAqasAAKqrAACrqwAArKsAAK2rAACuqwAAr6sAALCrAACxqwAAsqsAALOrAAC0qwAAtasAALarAAC3qwAAuKsAALmrAAC6qwAAu6sAALyrAAC9qwAAvqsAAL+rAAD4EwAA+RMAAPoTAAD7EwAA/BMAAP0TAADwEwAA8RMAAPITAADzEwAA9BMAAPUT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AACcHwAAnR8AAJ4fAACfHwAAkB8AAJEfAACSHwAAkx8AAJQfAACVHwAAlh8AAJcfAACoHwAAqR8AAKofAACrHwAArB8AAK0fAACuHwAArx8AAKAfAAChHwAAoh8AAKMfAACkHwAApR8AAKYfAACnHwAAuB8AALkfAAC8HwAAsB8AALEfAABwHwAAcR8AALMfAABFAwAAmQMAALkDAADMHwAAch8AAHMfAAB0HwAAdR8AAMMfAADYHwAA2R8AANAfAADRHwAAdh8AAHcfAADoHwAA6R8AAOwfAADgHwAA4R8AAHofAAB7HwAA5R8AAPwfAAB4HwAAeR8AAHwfAAB9HwAA8x8AAKkDAADJAwAASwAAAGsAAADFAAAA5QAAAE4hAAAyIQAAcCEAAHEhAAByIQAAcyEAAHQhAAB1IQAAdiEAAHchAAB4IQAAeSEAAHohAAB7IQAAfCEAAH0hAAB+IQAAfyEAAGAhAABhIQAAYiEAAGMhAABkIQAAZSEAAGYhAABnIQAAaCEAAGkhAABqIQAAayEAAGwhAABtIQAAbiEAAG8hAACEIQAAgyEAANAkAADRJAAA0iQAANMkAADUJAAA1SQAANYkAADXJAAA2CQAANkkAADaJAAA2yQAANwkAADdJAAA3iQAAN8kAADgJAAA4SQAAOIkAADjJAAA5CQAAOUkAADmJAAA5yQAAOgkAADpJAAAtiQAALckAAC4JAAAuSQAALokAAC7JAAAvCQAAL0kAAC+JAAAvyQAAMAkAADBJAAAwiQAAMMkAADEJAAAxSQAAMYkAADHJAAAyCQAAMkkAADKJAAAyyQAAMwkAADNJAAAziQAAM8kAAAwLAAAMSwAADIsAAAzLAAANCwAADUsAAA2LAAANywAADgsAAA5LAAAOiwAADssAAA8LAAAPSwAAD4sAAA/LAAAQCwAAEEsAABCLAAAQywAAEQsAABFLAAARiwAAEcsAABILAAASSwAAEosAABLLAAATCwAAE0sAABOLAAATywAAFAsAABRLAAAUiwAAFMsAABULAAAVSwAAFYsAABXLAAAWCwAAFksAABaLAAAWywAAFwsAABdLAAAXiwAAAAsAAABLAAAAiwAAAMsAAAELAAABSwAAAYsAAAHLAAACCwAAAksAAAKLAAACywAAAwsAAANLAAADiwAAA8sAAAQLAAAESwAABIsAAATLAAAFCwAABUsAAAWLAAAFywAABgsAAAZLAAAGiwAABssAAAcLAAAHSwAAB4sAAAfLAAAICwAACEsAAAiLAAAIywAACQsAAAlLAAAJiwAACcsAAAoLAAAKSwAACosAAArLAAALCwAAC0sAAAuLAAAYSwAAGAsAABrAgAAfR0AAH0CAAA6AgAAPgIAAGgsAABnLAAAaiwAAGksAABsLAAAaywAAFECAABxAgAAUAIAAFICAABzLAAAciwAAHYsAAB1LAAAPwIAAEACAACBLAAAgCwAAIMsAACCLAAAhSwAAIQsAACHLAAAhiwAAIksAACILAAAiywAAIosAACNLAAAjCwAAI8sAACOLAAAkSwAAJAsAACTLAAAkiwAAJUsAACULAAAlywAAJYsAACZLAAAmCwAAJssAACaLAAAnSwAAJwsAACfLAAAniwAAKEsAACgLAAAoywAAKIsAAClLAAApCwAAKcsAACmLAAAqSwAAKgsAACrLAAAqiwAAK0sAACsLAAArywAAK4sAACxLAAAsCwAALMsAACyLAAAtSwAALQsAAC3LAAAtiwAALksAAC4LAAAuywAALosAAC9LAAAvCwAAL8sAAC+LAAAwSwAAMAsAADDLAAAwiwAAMUsAADELAAAxywAAMYsAADJLAAAyCwAAMssAADKLAAAzSwAAMwsAADPLAAAziwAANEsAADQLAAA0ywAANIsAADVLAAA1CwAANcsAADWLAAA2SwAANgsAADbLAAA2iwAAN0sAADcLAAA3ywAAN4sAADhLAAA4CwAAOMsAADiLAAA7CwAAOssAADuLAAA7SwAAPMsAADyLAAAoBAAAKEQAACiEAAAoxAAAKQQAAClEAAAphAAAKcQAACoEAAAqRAAAKoQAACrEAAArBAAAK0QAACuEAAArxAAALAQAACxEAAAshAAALMQAAC0EAAAtRAAALYQAAC3EAAAuBAAALkQAAC6EAAAuxAAALwQAAC9EAAAvhAAAL8QAADAEAAAwRAAAMIQAADDEAAAxBAAAMUQAADHEAAAzRAAAEGmAABApgAAQ6YAAEKmAABFpgAARKYAAEemAABGpgAASaYAAEimAACIHAAAS6YAAIgcAABKpgAATaYAAEymAABPpgAATqYAAFGmAABQpgAAU6YAAFKmAABVpgAAVKYAAFemAABWpgAAWaYAAFimAABbpgAAWqYAAF2mAABcpgAAX6YAAF6mAABhpgAAYKYAAGOmAABipgAAZaYAAGSmAABnpgAAZqYAAGmmAABopgAAa6YAAGqmAABtpgAAbKYAAIGmAACApgAAg6YAAIKmAACFpgAAhKYAAIemAACGpgAAiaYAAIimAACLpgAAiqYAAI2mAACMpgAAj6YAAI6mAACRpgAAkKYAAJOmAACSpgAAlaYAAJSmAACXpgAAlqYAAJmmAACYpgAAm6YAAJqmAAAjpwAAIqcAACWnAAAkpwAAJ6cAACanAAAppwAAKKcAACunAAAqpwAALacAACynAAAvpwAALqcAADOnAAAypwAANacAADSnAAA3pwAANqcAADmnAAA4pwAAO6cAADqnAAA9pwAAPKcAAD+nAAA+pwAAQacAAECnAABDpwAAQqcAAEWnAABEpwAAR6cAAEanAABJpwAASKcAAEunAABKpwAATacAAEynAABPpwAATqcAAFGnAABQpwAAU6cAAFKnAABVpwAAVKcAAFenAABWpwAAWacAAFinAABbpwAAWqcAAF2nAABcpwAAX6cAAF6nAABhpwAAYKcAAGOnAABipwAAZacAAGSnAABnpwAAZqcAAGmnAABopwAAa6cAAGqnAABtpwAAbKcAAG+nAABupwAAeqcAAHmnAAB8pwAAe6cAAHkdAAB/pwAAfqcAAIGnAACApwAAg6cAAIKnAACFpwAAhKcAAIenAACGpwAAjKcAAIunAABlAgAAkacAAJCnAACTpwAAkqcAAMSnAACXpwAAlqcAAJmnAACYpwAAm6cAAJqnAACdpwAAnKcAAJ+nAACepwAAoacAAKCnAACjpwAAoqcAAKWnAACkpwAAp6cAAKanAACppwAAqKcAAGYCAABcAgAAYQIAAGwCAABqAgAAngIAAIcCAACdAgAAU6sAALWnAAC0pwAAt6cAALanAAC5pwAAuKcAALunAAC6pwAAvacAALynAAC/pwAAvqcAAMOnAADCpwAAlKcAAIICAACOHQAAyKcAAMenAADKpwAAyacAAPanAAD1pwAAs6cAAKATAAChEwAAohMAAKMTAACkEwAApRMAAKYTAACnEwAAqBMAAKkTAACqEwAAqxMAAKwTAACtEwAArhMAAK8TAACwEwAAsRMAALITAACzEwAAtBMAALUTAAC2EwAAtxMAALgTAAC5EwAAuhMAALsTAAC8EwAAvRMAAL4TAAC/EwAAwBMAAMETAADCEwAAwxMAAMQTAADFEwAAxhMAAMcTAADIEwAAyRMAAMoTAADLEwAAzBMAAM0TAADOEwAAzxMAANATAADREwAA0hMAANMTAADUEwAA1RMAANYTAADXEwAA2BMAANkTAADaEwAA2xMAANwTAADdEwAA3hMAAN8TAADgEwAA4RMAAOITAADjEwAA5BMAAOUTAADmEwAA5xMAAOgTAADpEwAA6hMAAOsTAADsEwAA7RMAAO4TAADvEwAAQf8AAEL/AABD/wAARP8AAEX/AABG/wAAR/8AAEj/AABJ/wAASv8AAEv/AABM/wAATf8AAE7/AABP/wAAUP8AAFH/AABS/wAAU/8AAFT/AABV/wAAVv8AAFf/AABY/wAAWf8AAFr/AAAh/wAAIv8AACP/AAAk/wAAJf8AACb/AAAn/wAAKP8AACn/AAAq/wAAK/8AACz/AAAt/wAALv8AAC//AAAw/wAAMf8AADL/AAAz/wAANP8AADX/AAA2/wAAN/8AADj/AAA5/wAAOv8AACgEAQApBAEAKgQBACsEAQAsBAEALQQBAC4EAQAvBAEAMAQBADEEAQAyBAEAMwQBADQEAQA1BAEANgQBADcEAQA4BAEAOQQBADoEAQA7BAEAPAQBAD0EAQA+BAEAPwQBAEAEAQBBBAEAQgQBAEMEAQBEBAEARQQBAEYEAQBHBAEASAQBAEkEAQBKBAEASwQBAEwEAQBNBAEATgQBAE8EAQAABAEAAQQBAAIEAQADBAEABAQBAAUEAQAGBAEABwQBAAgEAQAJBAEACgQBAAsEAQAMBAEADQQBAA4EAQAPBAEAEAQBABEEAQASBAEAEwQBABQEAQAVBAEAFgQBABcEAQAYBAEAGQQBABoEAQAbBAEAHAQBAB0EAQAeBAEAHwQBACAEAQAhBAEAIgQBACMEAQAkBAEAJQQBACYEAQAnBAEA2AQBANkEAQDaBAEA2wQBANwEAQDdBAEA3gQBAN8EAQDgBAEA4QQBAOIEAQDjBAEA5AQBAOUEAQDmBAEA5wQBAOgEAQDpBAEA6gQBAOsEAQDsBAEA7QQBAO4EAQDvBAEA8AQBAPEEAQDyBAEA8wQBAPQEAQD1BAEA9gQBAPcEAQD4BAEA+QQBAPoEAQD7BAEAsAQBALEEAQCyBAEAswQBALQEAQC1BAEAtgQBALcEAQC4BAEAuQQBALoEAQC7BAEAvAQBAL0EAQC+BAEAvwQBAMAEAQDBBAEAwgQBAMMEAQDEBAEAxQQBAMYEAQDHBAEAyAQBAMkEAQDKBAEAywQBAMwEAQDNBAEAzgQBAM8EAQDQBAEA0QQBANIEAQDTBAEAwAwBAMEMAQDCDAEAwwwBAMQMAQDFDAEAxgwBAMcMAQDIDAEAyQwBAMoMAQDLDAEAzAwBAM0MAQDODAEAzwwBANAMAQDRDAEA0gwBANMMAQDUDAEA1QwBANYMAQDXDAEA2AwBANkMAQDaDAEA2wwBANwMAQDdDAEA3gwBAN8MAQDgDAEA4QwBAOIMAQDjDAEA5AwBAOUMAQDmDAEA5wwBAOgMAQDpDAEA6gwBAOsMAQDsDAEA7QwBAO4MAQDvDAEA8AwBAPEMAQDyDAEAgAwBAIEMAQCCDAEAgwwBAIQMAQCFDAEAhgwBAIcMAQCIDAEAiQwBAIoMAQCLDAEAjAwBAI0MAQCODAEAjwwBAJAMAQCRDAEAkgwBAJMMAQCUDAEAlQwBAJYMAQCXDAEAmAwBAJkMAQCaDAEAmwwBAJwMAQCdDAEAngwBAJ8MAQCgDAEAoQwBAKIMAQCjDAEApAwBAKUMAQCmDAEApwwBAKgMAQCpDAEAqgwBAKsMAQCsDAEArQwBAK4MAQCvDAEAsAwBALEMAQCyDAEAwBgBAMEYAQDCGAEAwxgBAMQYAQDFGAEAxhgBAMcYAQDIGAEAyRgBAMoYAQDLGAEAzBgBAM0YAQDOGAEAzxgBANAYAQDRGAEA0hgBANMYAQDUGAEA1RgBANYYAQDXGAEA2BgBANkYAQDaGAEA2xgBANwYAQDdGAEA3hgBAN8YAQCgGAEAoRgBAKIYAQCjGAEApBgBAKUYAQCmGAEApxgBAKgYAQCpGAEAqhgBAKsYAQCsGAEArRgBAK4YAQCvGAEAsBgBALEYAQCyGAEAsxgBALQYAQC1GAEAthgBALcYAQC4GAEAuRgBALoYAQC7GAEAvBgBAL0YAQC+GAEAvxgBAGBuAQBhbgEAYm4BAGNuAQBkbgEAZW4BAGZuAQBnbgEAaG4BAGluAQBqbgEAa24BAGxuAQBtbgEAbm4BAG9uAQBwbgEAcW4BAHJuAQBzbgEAdG4BAHVuAQB2bgEAd24BAHhuAQB5bgEAem4BAHtuAQB8bgEAfW4BAH5uAQB/bgEAQG4BAEFuAQBCbgEAQ24BAERuAQBFbgEARm4BAEduAQBIbgEASW4BAEpuAQBLbgEATG4BAE1uAQBObgEAT24BAFBuAQBRbgEAUm4BAFNuAQBUbgEAVW4BAFZuAQBXbgEAWG4BAFluAQBabgEAW24BAFxuAQBdbgEAXm4BAF9uAQAi6QEAI+kBACTpAQAl6QEAJukBACfpAQAo6QEAKekBACrpAQAr6QEALOkBAC3pAQAu6QEAL+kBADDpAQAx6QEAMukBADPpAQA06QEANekBADbpAQA36QEAOOkBADnpAQA66QEAO+kBADzpAQA96QEAPukBAD/pAQBA6QEAQekBAELpAQBD6QEAAOkBAAHpAQAC6QEAA+kBAATpAQAF6QEABukBAAfpAQAI6QEACekBAArpAQAL6QEADOkBAA3pAQAO6QEAD+kBABDpAQAR6QEAEukBABPpAQAU6QEAFekBABbpAQAX6QEAGOkBABnpAQAa6QEAG+kBABzpAQAd6QEAHukBAB/pAQAg6QEAIekBAEEAAAD4IRMAAQAAAEIAAAD8IRMAAQAAAEMAAAAAIhMAAQAAAEQAAAAEIhMAAQAAAEUAAAAIIhMAAQAAAEYAAAAMIhMAAQAAAEcAAAAQIhMAAQAAAEgAAAAUIhMAAQAAAEkAAAAYIhMAAQAAAEoAAAAcIhMAAQAAAEsAAAAgIhMAAgAAAEwAAAAoIhMAAQAAAE0AAAAsIhMAAQAAAE4AAAAwIhMAAQAAAE8AAAA0IhMAAQAAAFAAAAA4IhMAAQAAAFEAAAA8IhMAAQAAAFIAAABAIhMAAQAAAFMAAABEIhMAAgAAAFQAAABMIhMAAQAAAFUAAABQIhMAAQAAAFYAAABUIhMAAQAAAFcAAABYIhMAAQAAAFgAAABcIhMAAQAAAFkAAABgIhMAAQAAAFoAAABkIhMAAQAAAGEAAABoIhMAAQAAAGIAAABsIhMAAQAAAGMAAABwIhMAAQAAAGQAAAB0IhMAAQAAAGUAAAB4IhMAAQAAAGYAAAB8IhMAAQAAAGcAAACAIhMAAQAAAGgAAACEIhMAAQAAAGkAAACIIhMAAQAAAGoAAACMIhMAAQAAAGsAAACQIhMAAgAAAGwAAACYIhMAAQAAAG0AAACcIhMAAQAAAG4AAACgIhMAAQAAAG8AAACkIhMAAQAAAHAAAACoIhMAAQAAAHEAAACsIhMAAQAAAHIAAACwIhMAAQAAAHMAAAC0IhMAAgAAAHQAAAC8IhMAAQAAAHUAAADAIhMAAQAAAHYAAADEIhMAAQAAAHcAAADIIhMAAQAAAHgAAADMIhMAAQAAAHkAAADQIhMAAQAAAHoAAADUIhMAAQAAALUAAADYIhMAAgAAAMAAAADgIhMAAQAAAMEAAADkIhMAAQAAAMIAAADoIhMAAQAAAMMAAADsIhMAAQAAAMQAAADwIhMAAQAAAMUAAAD0IhMAAgAAAMYAAAD8IhMAAQAAAMcAAAAAIxMAAQAAAMgAAAAEIxMAAQAAAMkAAAAIIxMAAQAAAMoAAAAMIxMAAQAAAMsAAAAQIxMAAQAAAMwAAAAUIxMAAQAAAM0AAAAYIxMAAQAAAM4AAAAcIxMAAQAAAM8AAAAgIxMAAQAAANAAAAAkIxMAAQAAANEAAAAoIxMAAQAAANIAAAAsIxMAAQAAANMAAAAwIxMAAQAAANQAAAA0IxMAAQAAANUAAAA4IxMAAQAAANYAAAA8IxMAAQAAANgAAABAIxMAAQAAANkAAABEIxMAAQAAANoAAABIIxMAAQAAANsAAABMIxMAAQAAANwAAABQIxMAAQAAAN0AAABUIxMAAQAAAN4AAABYIxMAAQAAAN8AAABcIxMAAQAAAOAAAABgIxMAAQAAAOEAAABkIxMAAQAAAOIAAABoIxMAAQAAAOMAAABsIxMAAQAAAOQAAABwIxMAAQAAAOUAAAB0IxMAAgAAAOYAAAB8IxMAAQAAAOcAAACAIxMAAQAAAOgAAACEIxMAAQAAAOkAAACIIxMAAQAAAOoAAACMIxMAAQAAAOsAAACQIxMAAQAAAOwAAACUIxMAAQAAAO0AAACYIxMAAQAAAO4AAACcIxMAAQAAAO8AAACgIxMAAQAAAPAAAACkIxMAAQAAAPEAAACoIxMAAQAAAPIAAACsIxMAAQAAAPMAAACwIxMAAQAAAPQAAAC0IxMAAQAAAPUAAAC4IxMAAQAAAPYAAAC8IxMAAQAAAPgAAADAIxMAAQAAAPkAAADEIxMAAQAAAPoAAADIIxMAAQAAAPsAAADMIxMAAQAAAPwAAADQIxMAAQAAAP0AAADUIxMAAQAAAP4AAADYIxMAAQAAAP8AAADcIxMAAQAAAAABAADgIxMAAQAAAAEBAADkIxMAAQAAAAIBAADoIxMAAQAAAAMBAADsIxMAAQAAAAQBAADwIxMAAQAAAAUBAAD0IxMAAQAAAAYBAAD4IxMAAQAAAAcBAAD8IxMAAQAAAAgBAAAAJBMAAQAAAAkBAAAEJBMAAQAAAAoBAAAIJBMAAQAAAAsBAAAMJBMAAQAAAAwBAAAQJBMAAQAAAA0BAAAUJBMAAQAAAA4BAAAYJBMAAQAAAA8BAAAcJBMAAQAAABABAAAgJBMAAQAAABEBAAAkJBMAAQAAABIBAAAoJBMAAQAAABMBAAAsJBMAAQAAABQBAAAwJBMAAQAAABUBAAA0JBMAAQAAABYBAAA4JBMAAQAAABcBAAA8JBMAAQAAABgBAABAJBMAAQAAABkBAABEJBMAAQAAABoBAABIJBMAAQAAABsBAABMJBMAAQAAABwBAABQJBMAAQAAAB0BAABUJBMAAQAAAB4BAABYJBMAAQAAAB8BAABcJBMAAQAAACABAABgJBMAAQAAACEBAABkJBMAAQAAACIBAABoJBMAAQAAACMBAABsJBMAAQAAACQBAABwJBMAAQAAACUBAAB0JBMAAQAAACYBAAB4JBMAAQAAACcBAAB8JBMAAQAAACgBAACAJBMAAQAAACkBAACEJBMAAQAAACoBAACIJBMAAQAAACsBAACMJBMAAQAAACwBAACQJBMAAQAAAC0BAACUJBMAAQAAAC4BAACYJBMAAQAAAC8BAACcJBMAAQAAADIBAACgJBMAAQAAADMBAACkJBMAAQAAADQBAACoJBMAAQAAADUBAACsJBMAAQAAADYBAACwJBMAAQAAADcBAAC0JBMAAQAAADkBAAC4JBMAAQAAADoBAAC8JBMAAQAAADsBAADAJBMAAQAAADwBAADEJBMAAQAAAD0BAADIJBMAAQAAAD4BAADMJBMAAQAAAD8BAADQJBMAAQAAAEABAADUJBMAAQAAAEEBAADYJBMAAQAAAEIBAADcJBMAAQAAAEMBAADgJBMAAQAAAEQBAADkJBMAAQAAAEUBAADoJBMAAQAAAEYBAADsJBMAAQAAAEcBAADwJBMAAQAAAEgBAAD0JBMAAQAAAEoBAAD4JBMAAQAAAEsBAAD8JBMAAQAAAEwBAAAAJRMAAQAAAE0BAAAEJRMAAQAAAE4BAAAIJRMAAQAAAE8BAAAMJRMAAQAAAFABAAAQJRMAAQAAAFEBAAAUJRMAAQAAAFIBAAAYJRMAAQAAAFMBAAAcJRMAAQAAAFQBAAAgJRMAAQAAAFUBAAAkJRMAAQAAAFYBAAAoJRMAAQAAAFcBAAAsJRMAAQAAAFgBAAAwJRMAAQAAAFkBAAA0JRMAAQAAAFoBAAA4JRMAAQAAAFsBAAA8JRMAAQAAAFwBAABAJRMAAQAAAF0BAABEJRMAAQAAAF4BAABIJRMAAQAAAF8BAABMJRMAAQAAAGABAABQJRMAAQAAAGEBAABUJRMAAQAAAGIBAABYJRMAAQAAAGMBAABcJRMAAQAAAGQBAABgJRMAAQAAAGUBAABkJRMAAQAAAGYBAABoJRMAAQAAAGcBAABsJRMAAQAAAGgBAABwJRMAAQAAAGkBAAB0JRMAAQAAAGoBAAB4JRMAAQAAAGsBAAB8JRMAAQAAAGwBAACAJRMAAQAAAG0BAACEJRMAAQAAAG4BAACIJRMAAQAAAG8BAACMJRMAAQAAAHABAACQJRMAAQAAAHEBAACUJRMAAQAAAHIBAACYJRMAAQAAAHMBAACcJRMAAQAAAHQBAACgJRMAAQAAAHUBAACkJRMAAQAAAHYBAACoJRMAAQAAAHcBAACsJRMAAQAAAHgBAACwJRMAAQAAAHkBAAC0JRMAAQAAAHoBAAC4JRMAAQAAAHsBAAC8JRMAAQAAAHwBAADAJRMAAQAAAH0BAADEJRMAAQAAAH4BAADIJRMAAQAAAH8BAADMJRMAAgAAAIABAADUJRMAAQAAAIEBAADYJRMAAQAAAIIBAADcJRMAAQAAAIMBAADgJRMAAQAAAIQBAADkJRMAAQAAAIUBAADoJRMAAQAAAIYBAADsJRMAAQAAAIcBAADwJRMAAQAAAIgBAAD0JRMAAQAAAIkBAAD4JRMAAQAAAIoBAAD8JRMAAQAAAIsBAAAAJhMAAQAAAIwBAAAEJhMAAQAAAI4BAAAIJhMAAQAAAI8BAAAMJhMAAQAAAJABAAAQJhMAAQAAAJEBAAAUJhMAAQAAAJIBAAAYJhMAAQAAAJMBAAAcJhMAAQAAAJQBAAAgJhMAAQAAAJUBAAAkJhMAAQAAAJYBAAAoJhMAAQAAAJcBAAAsJhMAAQAAAJgBAAAwJhMAAQAAAJkBAAA0JhMAAQAAAJoBAAA4JhMAAQAAAJwBAAA8JhMAAQAAAJ0BAABAJhMAAQAAAJ4BAABEJhMAAQAAAJ8BAABIJhMAAQAAAKABAABMJhMAAQAAAKEBAABQJhMAAQAAAKIBAABUJhMAAQAAAKMBAABYJhMAAQAAAKQBAABcJhMAAQAAAKUBAABgJhMAAQAAAKYBAABkJhMAAQAAAKcBAABoJhMAAQAAAKgBAABsJhMAAQAAAKkBAABwJhMAAQAAAKwBAAB0JhMAAQAAAK0BAAB4JhMAAQAAAK4BAAB8JhMAAQAAAK8BAACAJhMAAQAAALABAACEJhMAAQAAALEBAACIJhMAAQAAALIBAACMJhMAAQAAALMBAACQJhMAAQAAALQBAACUJhMAAQAAALUBAACYJhMAAQAAALYBAACcJhMAAQAAALcBAACgJhMAAQAAALgBAACkJhMAAQAAALkBAACoJhMAAQAAALwBAACsJhMAAQAAAL0BAACwJhMAAQAAAL8BAAC0JhMAAQAAAMQBAAC4JhMAAgAAAMUBAADAJhMAAgAAAMYBAADIJhMAAgAAAMcBAADQJhMAAgAAAMgBAADYJhMAAgAAAMkBAADgJhMAAgAAAMoBAADoJhMAAgAAAMsBAADwJhMAAgAAAMwBAAD4JhMAAgAAAM0BAAAAJxMAAQAAAM4BAAAEJxMAAQAAAM8BAAAIJxMAAQAAANABAAAMJxMAAQAAANEBAAAQJxMAAQAAANIBAAAUJxMAAQAAANMBAAAYJxMAAQAAANQBAAAcJxMAAQAAANUBAAAgJxMAAQAAANYBAAAkJxMAAQAAANcBAAAoJxMAAQAAANgBAAAsJxMAAQAAANkBAAAwJxMAAQAAANoBAAA0JxMAAQAAANsBAAA4JxMAAQAAANwBAAA8JxMAAQAAAN0BAABAJxMAAQAAAN4BAABEJxMAAQAAAN8BAABIJxMAAQAAAOABAABMJxMAAQAAAOEBAABQJxMAAQAAAOIBAABUJxMAAQAAAOMBAABYJxMAAQAAAOQBAABcJxMAAQAAAOUBAABgJxMAAQAAAOYBAABkJxMAAQAAAOcBAABoJxMAAQAAAOgBAABsJxMAAQAAAOkBAABwJxMAAQAAAOoBAAB0JxMAAQAAAOsBAAB4JxMAAQAAAOwBAAB8JxMAAQAAAO0BAACAJxMAAQAAAO4BAACEJxMAAQAAAO8BAACIJxMAAQAAAPEBAACMJxMAAgAAAPIBAACUJxMAAgAAAPMBAACcJxMAAgAAAPQBAACkJxMAAQAAAPUBAACoJxMAAQAAAPYBAACsJxMAAQAAAPcBAACwJxMAAQAAAPgBAAC0JxMAAQAAAPkBAAC4JxMAAQAAAPoBAAC8JxMAAQAAAPsBAADAJxMAAQAAAPwBAADEJxMAAQAAAP0BAADIJxMAAQAAAP4BAADMJxMAAQAAAP8BAADQJxMAAQAAAAACAADUJxMAAQAAAAECAADYJxMAAQAAAAICAADcJxMAAQAAAAMCAADgJxMAAQAAAAQCAADkJxMAAQAAAAUCAADoJxMAAQAAAAYCAADsJxMAAQAAAAcCAADwJxMAAQAAAAgCAAD0JxMAAQAAAAkCAAD4JxMAAQAAAAoCAAD8JxMAAQAAAAsCAAAAKBMAAQAAAAwCAAAEKBMAAQAAAA0CAAAIKBMAAQAAAA4CAAAMKBMAAQAAAA8CAAAQKBMAAQAAABACAAAUKBMAAQAAABECAAAYKBMAAQAAABICAAAcKBMAAQAAABMCAAAgKBMAAQAAABQCAAAkKBMAAQAAABUCAAAoKBMAAQAAABYCAAAsKBMAAQAAABcCAAAwKBMAAQAAABgCAAA0KBMAAQAAABkCAAA4KBMAAQAAABoCAAA8KBMAAQAAABsCAABAKBMAAQAAABwCAABEKBMAAQAAAB0CAABIKBMAAQAAAB4CAABMKBMAAQAAAB8CAABQKBMAAQAAACACAABUKBMAAQAAACICAABYKBMAAQAAACMCAABcKBMAAQAAACQCAABgKBMAAQAAACUCAABkKBMAAQAAACYCAABoKBMAAQAAACcCAABsKBMAAQAAACgCAABwKBMAAQAAACkCAAB0KBMAAQAAACoCAAB4KBMAAQAAACsCAAB8KBMAAQAAACwCAACAKBMAAQAAAC0CAACEKBMAAQAAAC4CAACIKBMAAQAAAC8CAACMKBMAAQAAADACAACQKBMAAQAAADECAACUKBMAAQAAADICAACYKBMAAQAAADMCAACcKBMAAQAAADoCAACgKBMAAQAAADsCAACkKBMAAQAAADwCAACoKBMAAQAAAD0CAACsKBMAAQAAAD4CAACwKBMAAQAAAD8CAAC0KBMAAQAAAEACAAC4KBMAAQAAAEECAAC8KBMAAQAAAEICAADAKBMAAQAAAEMCAADEKBMAAQAAAEQCAADIKBMAAQAAAEUCAADMKBMAAQAAAEYCAADQKBMAAQAAAEcCAADUKBMAAQAAAEgCAADYKBMAAQAAAEkCAADcKBMAAQAAAEoCAADgKBMAAQAAAEsCAADkKBMAAQAAAEwCAADoKBMAAQAAAE0CAADsKBMAAQAAAE4CAADwKBMAAQAAAE8CAAD0KBMAAQAAAFACAAD4KBMAAQAAAFECAAD8KBMAAQAAAFICAAAAKRMAAQAAAFMCAAAEKRMAAQAAAFQCAAAIKRMAAQAAAFYCAAAMKRMAAQAAAFcCAAAQKRMAAQAAAFkCAAAUKRMAAQAAAFsCAAAYKRMAAQAAAFwCAAAcKRMAAQAAAGACAAAgKRMAAQAAAGECAAAkKRMAAQAAAGMCAAAoKRMAAQAAAGUCAAAsKRMAAQAAAGYCAAAwKRMAAQAAAGgCAAA0KRMAAQAAAGkCAAA4KRMAAQAAAGoCAAA8KRMAAQAAAGsCAABAKRMAAQAAAGwCAABEKRMAAQAAAG8CAABIKRMAAQAAAHECAABMKRMAAQAAAHICAABQKRMAAQAAAHUCAABUKRMAAQAAAH0CAABYKRMAAQAAAIACAABcKRMAAQAAAIICAABgKRMAAQAAAIMCAABkKRMAAQAAAIcCAABoKRMAAQAAAIgCAABsKRMAAQAAAIkCAABwKRMAAQAAAIoCAAB0KRMAAQAAAIsCAAB4KRMAAQAAAIwCAAB8KRMAAQAAAJICAACAKRMAAQAAAJ0CAACEKRMAAQAAAJ4CAACIKRMAAQAAAEUDAACMKRMAAwAAAHADAACYKRMAAQAAAHEDAACcKRMAAQAAAHIDAACgKRMAAQAAAHMDAACkKRMAAQAAAHYDAACoKRMAAQAAAHcDAACsKRMAAQAAAHsDAACwKRMAAQAAAHwDAAC0KRMAAQAAAH0DAAC4KRMAAQAAAH8DAAC8KRMAAQAAAIYDAADAKRMAAQAAAIgDAADEKRMAAQAAAIkDAADIKRMAAQAAAIoDAADMKRMAAQAAAIwDAADQKRMAAQAAAI4DAADUKRMAAQAAAI8DAADYKRMAAQAAAJEDAADcKRMAAQAAAJIDAADgKRMAAgAAAJMDAADoKRMAAQAAAJQDAADsKRMAAQAAAJUDAADwKRMAAgAAAJYDAAD4KRMAAQAAAJcDAAD8KRMAAQAAAJgDAAAAKhMAAwAAAJkDAAAMKhMAAwAAAJoDAAAYKhMAAgAAAJsDAAAgKhMAAQAAAJwDAAAkKhMAAgAAAJ0DAAAsKhMAAQAAAJ4DAAAwKhMAAQAAAJ8DAAA0KhMAAQAAAKADAAA4KhMAAgAAAKEDAABAKhMAAgAAAKMDAABIKhMAAgAAAKQDAABQKhMAAQAAAKUDAABUKhMAAQAAAKYDAABYKhMAAgAAAKcDAABgKhMAAQAAAKgDAABkKhMAAQAAAKkDAABoKhMAAgAAAKoDAABwKhMAAQAAAKsDAAB0KhMAAQAAAKwDAAB4KhMAAQAAAK0DAAB8KhMAAQAAAK4DAACAKhMAAQAAAK8DAACEKhMAAQAAALEDAACIKhMAAQAAALIDAACMKhMAAgAAALMDAACUKhMAAQAAALQDAACYKhMAAQAAALUDAACcKhMAAgAAALYDAACkKhMAAQAAALcDAACoKhMAAQAAALgDAACsKhMAAwAAALkDAAC4KhMAAwAAALoDAADEKhMAAgAAALsDAADMKhMAAQAAALwDAADQKhMAAgAAAL0DAADYKhMAAQAAAL4DAADcKhMAAQAAAL8DAADgKhMAAQAAAMADAADkKhMAAgAAAMEDAADsKhMAAgAAAMIDAAD0KhMAAgAAAMMDAAD8KhMAAgAAAMQDAAAEKxMAAQAAAMUDAAAIKxMAAQAAAMYDAAAMKxMAAgAAAMcDAAAUKxMAAQAAAMgDAAAYKxMAAQAAAMkDAAAcKxMAAgAAAMoDAAAkKxMAAQAAAMsDAAAoKxMAAQAAAMwDAAAsKxMAAQAAAM0DAAAwKxMAAQAAAM4DAAA0KxMAAQAAAM8DAAA4KxMAAQAAANADAAA8KxMAAgAAANEDAABEKxMAAwAAANUDAABQKxMAAgAAANYDAABYKxMAAgAAANcDAABgKxMAAQAAANgDAABkKxMAAQAAANkDAABoKxMAAQAAANoDAABsKxMAAQAAANsDAABwKxMAAQAAANwDAAB0KxMAAQAAAN0DAAB4KxMAAQAAAN4DAAB8KxMAAQAAAN8DAACAKxMAAQAAAOADAACEKxMAAQAAAOEDAACIKxMAAQAAAOIDAACMKxMAAQAAAOMDAACQKxMAAQAAAOQDAACUKxMAAQAAAOUDAACYKxMAAQAAAOYDAACcKxMAAQAAAOcDAACgKxMAAQAAAOgDAACkKxMAAQAAAOkDAACoKxMAAQAAAOoDAACsKxMAAQAAAOsDAACwKxMAAQAAAOwDAAC0KxMAAQAAAO0DAAC4KxMAAQAAAO4DAAC8KxMAAQAAAO8DAADAKxMAAQAAAPADAADEKxMAAgAAAPEDAADMKxMAAgAAAPIDAADUKxMAAQAAAPMDAADYKxMAAQAAAPQDAADcKxMAAwAAAPUDAADoKxMAAgAAAPcDAADwKxMAAQAAAPgDAAD0KxMAAQAAAPkDAAD4KxMAAQAAAPoDAAD8KxMAAQAAAPsDAAAALBMAAQAAAP0DAAAELBMAAQAAAP4DAAAILBMAAQAAAP8DAAAMLBMAAQAAAAAEAAAQLBMAAQAAAAEEAAAULBMAAQAAAAIEAAAYLBMAAQAAAAMEAAAcLBMAAQAAAAQEAAAgLBMAAQAAAAUEAAAkLBMAAQAAAAYEAAAoLBMAAQAAAAcEAAAsLBMAAQAAAAgEAAAwLBMAAQAAAAkEAAA0LBMAAQAAAAoEAAA4LBMAAQAAAAsEAAA8LBMAAQAAAAwEAABALBMAAQAAAA0EAABELBMAAQAAAA4EAABILBMAAQAAAA8EAABMLBMAAQAAABAEAABQLBMAAQAAABEEAABULBMAAQAAABIEAABYLBMAAgAAABMEAABgLBMAAQAAABQEAABkLBMAAgAAABUEAABsLBMAAQAAABYEAABwLBMAAQAAABcEAAB0LBMAAQAAABgEAAB4LBMAAQAAABkEAAB8LBMAAQAAABoEAACALBMAAQAAABsEAACELBMAAQAAABwEAACILBMAAQAAAB0EAACMLBMAAQAAAB4EAACQLBMAAgAAAB8EAACYLBMAAQAAACAEAACcLBMAAQAAACEEAACgLBMAAgAAACIEAACoLBMAAwAAACMEAAC0LBMAAQAAACQEAAC4LBMAAQAAACUEAAC8LBMAAQAAACYEAADALBMAAQAAACcEAADELBMAAQAAACgEAADILBMAAQAAACkEAADMLBMAAQAAACoEAADQLBMAAgAAACsEAADYLBMAAQAAACwEAADcLBMAAQAAAC0EAADgLBMAAQAAAC4EAADkLBMAAQAAAC8EAADoLBMAAQAAADAEAADsLBMAAQAAADEEAADwLBMAAQAAADIEAAD0LBMAAgAAADMEAAD8LBMAAQAAADQEAAAALRMAAgAAADUEAAAILRMAAQAAADYEAAAMLRMAAQAAADcEAAAQLRMAAQAAADgEAAAULRMAAQAAADkEAAAYLRMAAQAAADoEAAAcLRMAAQAAADsEAAAgLRMAAQAAADwEAAAkLRMAAQAAAD0EAAAoLRMAAQAAAD4EAAAsLRMAAgAAAD8EAAA0LRMAAQAAAEAEAAA4LRMAAQAAAEEEAAA8LRMAAgAAAEIEAABELRMAAwAAAEMEAABQLRMAAQAAAEQEAABULRMAAQAAAEUEAABYLRMAAQAAAEYEAABcLRMAAQAAAEcEAABgLRMAAQAAAEgEAABkLRMAAQAAAEkEAABoLRMAAQAAAEoEAABsLRMAAgAAAEsEAAB0LRMAAQAAAEwEAAB4LRMAAQAAAE0EAAB8LRMAAQAAAE4EAACALRMAAQAAAE8EAACELRMAAQAAAFAEAACILRMAAQAAAFEEAACMLRMAAQAAAFIEAACQLRMAAQAAAFMEAACULRMAAQAAAFQEAACYLRMAAQAAAFUEAACcLRMAAQAAAFYEAACgLRMAAQAAAFcEAACkLRMAAQAAAFgEAACoLRMAAQAAAFkEAACsLRMAAQAAAFoEAACwLRMAAQAAAFsEAAC0LRMAAQAAAFwEAAC4LRMAAQAAAF0EAAC8LRMAAQAAAF4EAADALRMAAQAAAF8EAADELRMAAQAAAGAEAADILRMAAQAAAGEEAADMLRMAAQAAAGIEAADQLRMAAgAAAGMEAADYLRMAAgAAAGQEAADgLRMAAQAAAGUEAADkLRMAAQAAAGYEAADoLRMAAQAAAGcEAADsLRMAAQAAAGgEAADwLRMAAQAAAGkEAAD0LRMAAQAAAGoEAAD4LRMAAQAAAGsEAAD8LRMAAQAAAGwEAAAALhMAAQAAAG0EAAAELhMAAQAAAG4EAAAILhMAAQAAAG8EAAAMLhMAAQAAAHAEAAAQLhMAAQAAAHEEAAAULhMAAQAAAHIEAAAYLhMAAQAAAHMEAAAcLhMAAQAAAHQEAAAgLhMAAQAAAHUEAAAkLhMAAQAAAHYEAAAoLhMAAQAAAHcEAAAsLhMAAQAAAHgEAAAwLhMAAQAAAHkEAAA0LhMAAQAAAHoEAAA4LhMAAQAAAHsEAAA8LhMAAQAAAHwEAABALhMAAQAAAH0EAABELhMAAQAAAH4EAABILhMAAQAAAH8EAABMLhMAAQAAAIAEAABQLhMAAQAAAIEEAABULhMAAQAAAIoEAABYLhMAAQAAAIsEAABcLhMAAQAAAIwEAABgLhMAAQAAAI0EAABkLhMAAQAAAI4EAABoLhMAAQAAAI8EAABsLhMAAQAAAJAEAABwLhMAAQAAAJEEAAB0LhMAAQAAAJIEAAB4LhMAAQAAAJMEAAB8LhMAAQAAAJQEAACALhMAAQAAAJUEAACELhMAAQAAAJYEAACILhMAAQAAAJcEAACMLhMAAQAAAJgEAACQLhMAAQAAAJkEAACULhMAAQAAAJoEAACYLhMAAQAAAJsEAACcLhMAAQAAAJwEAACgLhMAAQAAAJ0EAACkLhMAAQAAAJ4EAACoLhMAAQAAAJ8EAACsLhMAAQAAAKAEAACwLhMAAQAAAKEEAAC0LhMAAQAAAKIEAAC4LhMAAQAAAKMEAAC8LhMAAQAAAKQEAADALhMAAQAAAKUEAADELhMAAQAAAKYEAADILhMAAQAAAKcEAADMLhMAAQAAAKgEAADQLhMAAQAAAKkEAADULhMAAQAAAKoEAADYLhMAAQAAAKsEAADcLhMAAQAAAKwEAADgLhMAAQAAAK0EAADkLhMAAQAAAK4EAADoLhMAAQAAAK8EAADsLhMAAQAAALAEAADwLhMAAQAAALEEAAD0LhMAAQAAALIEAAD4LhMAAQAAALMEAAD8LhMAAQAAALQEAAAALxMAAQAAALUEAAAELxMAAQAAALYEAAAILxMAAQAAALcEAAAMLxMAAQAAALgEAAAQLxMAAQAAALkEAAAULxMAAQAAALoEAAAYLxMAAQAAALsEAAAcLxMAAQAAALwEAAAgLxMAAQAAAL0EAAAkLxMAAQAAAL4EAAAoLxMAAQAAAL8EAAAsLxMAAQAAAMAEAAAwLxMAAQAAAMEEAAA0LxMAAQAAAMIEAAA4LxMAAQAAAMMEAAA8LxMAAQAAAMQEAABALxMAAQAAAMUEAABELxMAAQAAAMYEAABILxMAAQAAAMcEAABMLxMAAQAAAMgEAABQLxMAAQAAAMkEAABULxMAAQAAAMoEAABYLxMAAQAAAMsEAABcLxMAAQAAAMwEAABgLxMAAQAAAM0EAABkLxMAAQAAAM4EAABoLxMAAQAAAM8EAABsLxMAAQAAANAEAABwLxMAAQAAANEEAAB0LxMAAQAAANIEAAB4LxMAAQAAANMEAAB8LxMAAQAAANQEAACALxMAAQAAANUEAACELxMAAQAAANYEAACILxMAAQAAANcEAACMLxMAAQAAANgEAACQLxMAAQAAANkEAACULxMAAQAAANoEAACYLxMAAQAAANsEAACcLxMAAQAAANwEAACgLxMAAQAAAN0EAACkLxMAAQAAAN4EAACoLxMAAQAAAN8EAACsLxMAAQAAAOAEAACwLxMAAQAAAOEEAAC0LxMAAQAAAOIEAAC4LxMAAQAAAOMEAAC8LxMAAQAAAOQEAADALxMAAQAAAOUEAADELxMAAQAAAOYEAADILxMAAQAAAOcEAADMLxMAAQAAAOgEAADQLxMAAQAAAOkEAADULxMAAQAAAOoEAADYLxMAAQAAAOsEAADcLxMAAQAAAOwEAADgLxMAAQAAAO0EAADkLxMAAQAAAO4EAADoLxMAAQAAAO8EAADsLxMAAQAAAPAEAADwLxMAAQAAAPEEAAD0LxMAAQAAAPIEAAD4LxMAAQAAAPMEAAD8LxMAAQAAAPQEAAAAMBMAAQAAAPUEAAAEMBMAAQAAAPYEAAAIMBMAAQAAAPcEAAAMMBMAAQAAAPgEAAAQMBMAAQAAAPkEAAAUMBMAAQAAAPoEAAAYMBMAAQAAAPsEAAAcMBMAAQAAAPwEAAAgMBMAAQAAAP0EAAAkMBMAAQAAAP4EAAAoMBMAAQAAAP8EAAAsMBMAAQAAAAAFAAAwMBMAAQAAAAEFAAA0MBMAAQAAAAIFAAA4MBMAAQAAAAMFAAA8MBMAAQAAAAQFAABAMBMAAQAAAAUFAABEMBMAAQAAAAYFAABIMBMAAQAAAAcFAABMMBMAAQAAAAgFAABQMBMAAQAAAAkFAABUMBMAAQAAAAoFAABYMBMAAQAAAAsFAABcMBMAAQAAAAwFAABgMBMAAQAAAA0FAABkMBMAAQAAAA4FAABoMBMAAQAAAA8FAABsMBMAAQAAABAFAABwMBMAAQAAABEFAAB0MBMAAQAAABIFAAB4MBMAAQAAABMFAAB8MBMAAQAAABQFAACAMBMAAQAAABUFAACEMBMAAQAAABYFAACIMBMAAQAAABcFAACMMBMAAQAAABgFAACQMBMAAQAAABkFAACUMBMAAQAAABoFAACYMBMAAQAAABsFAACcMBMAAQAAABwFAACgMBMAAQAAAB0FAACkMBMAAQAAAB4FAACoMBMAAQAAAB8FAACsMBMAAQAAACAFAACwMBMAAQAAACEFAAC0MBMAAQAAACIFAAC4MBMAAQAAACMFAAC8MBMAAQAAACQFAADAMBMAAQAAACUFAADEMBMAAQAAACYFAADIMBMAAQAAACcFAADMMBMAAQAAACgFAADQMBMAAQAAACkFAADUMBMAAQAAACoFAADYMBMAAQAAACsFAADcMBMAAQAAACwFAADgMBMAAQAAAC0FAADkMBMAAQAAAC4FAADoMBMAAQAAAC8FAADsMBMAAQAAADEFAADwMBMAAQAAADIFAAD0MBMAAQAAADMFAAD4MBMAAQAAADQFAAD8MBMAAQAAADUFAAAAMRMAAQAAADYFAAAEMRMAAQAAADcFAAAIMRMAAQAAADgFAAAMMRMAAQAAADkFAAAQMRMAAQAAADoFAAAUMRMAAQAAADsFAAAYMRMAAQAAADwFAAAcMRMAAQAAAD0FAAAgMRMAAQAAAD4FAAAkMRMAAQAAAD8FAAAoMRMAAQAAAEAFAAAsMRMAAQAAAEEFAAAwMRMAAQAAAEIFAAA0MRMAAQAAAEMFAAA4MRMAAQAAAEQFAAA8MRMAAQAAAEUFAABAMRMAAQAAAEYFAABEMRMAAQAAAEcFAABIMRMAAQAAAEgFAABMMRMAAQAAAEkFAABQMRMAAQAAAEoFAABUMRMAAQAAAEsFAABYMRMAAQAAAEwFAABcMRMAAQAAAE0FAABgMRMAAQAAAE4FAABkMRMAAQAAAE8FAABoMRMAAQAAAFAFAABsMRMAAQAAAFEFAABwMRMAAQAAAFIFAAB0MRMAAQAAAFMFAAB4MRMAAQAAAFQFAAB8MRMAAQAAAFUFAACAMRMAAQAAAFYFAACEMRMAAQAAAGEFAACIMRMAAQAAAGIFAACMMRMAAQAAAGMFAACQMRMAAQAAAGQFAACUMRMAAQAAAGUFAACYMRMAAQAAAGYFAACcMRMAAQAAAGcFAACgMRMAAQAAAGgFAACkMRMAAQAAAGkFAACoMRMAAQAAAGoFAACsMRMAAQAAAGsFAACwMRMAAQAAAGwFAAC0MRMAAQAAAG0FAAC4MRMAAQAAAG4FAAC8MRMAAQAAAG8FAADAMRMAAQAAAHAFAADEMRMAAQAAAHEFAADIMRMAAQAAAHIFAADMMRMAAQAAAHMFAADQMRMAAQAAAHQFAADUMRMAAQAAAHUFAADYMRMAAQAAAHYFAADcMRMAAQAAAHcFAADgMRMAAQAAAHgFAADkMRMAAQAAAHkFAADoMRMAAQAAAHoFAADsMRMAAQAAAHsFAADwMRMAAQAAAHwFAAD0MRMAAQAAAH0FAAD4MRMAAQAAAH4FAAD8MRMAAQAAAH8FAAAAMhMAAQAAAIAFAAAEMhMAAQAAAIEFAAAIMhMAAQAAAIIFAAAMMhMAAQAAAIMFAAAQMhMAAQAAAIQFAAAUMhMAAQAAAIUFAAAYMhMAAQAAAIYFAAAcMhMAAQAAAKAQAAAgMhMAAQAAAKEQAAAkMhMAAQAAAKIQAAAoMhMAAQAAAKMQAAAsMhMAAQAAAKQQAAAwMhMAAQAAAKUQAAA0MhMAAQAAAKYQAAA4MhMAAQAAAKcQAAA8MhMAAQAAAKgQAABAMhMAAQAAAKkQAABEMhMAAQAAAKoQAABIMhMAAQAAAKsQAABMMhMAAQAAAKwQAABQMhMAAQAAAK0QAABUMhMAAQAAAK4QAABYMhMAAQAAAK8QAABcMhMAAQAAALAQAABgMhMAAQAAALEQAABkMhMAAQAAALIQAABoMhMAAQAAALMQAABsMhMAAQAAALQQAABwMhMAAQAAALUQAAB0MhMAAQAAALYQAAB4MhMAAQAAALcQAAB8MhMAAQAAALgQAACAMhMAAQAAALkQAACEMhMAAQAAALoQAACIMhMAAQAAALsQAACMMhMAAQAAALwQAACQMhMAAQAAAL0QAACUMhMAAQAAAL4QAACYMhMAAQAAAL8QAACcMhMAAQAAAMAQAACgMhMAAQAAAMEQAACkMhMAAQAAAMIQAACoMhMAAQAAAMMQAACsMhMAAQAAAMQQAACwMhMAAQAAAMUQAAC0MhMAAQAAAMcQAAC4MhMAAQAAAM0QAAC8MhMAAQAAANAQAADAMhMAAQAAANEQAADEMhMAAQAAANIQAADIMhMAAQAAANMQAADMMhMAAQAAANQQAADQMhMAAQAAANUQAADUMhMAAQAAANYQAADYMhMAAQAAANcQAADcMhMAAQAAANgQAADgMhMAAQAAANkQAADkMhMAAQAAANoQAADoMhMAAQAAANsQAADsMhMAAQAAANwQAADwMhMAAQAAAN0QAAD0MhMAAQAAAN4QAAD4MhMAAQAAAN8QAAD8MhMAAQAAAOAQAAAAMxMAAQAAAOEQAAAEMxMAAQAAAOIQAAAIMxMAAQAAAOMQAAAMMxMAAQAAAOQQAAAQMxMAAQAAAOUQAAAUMxMAAQAAAOYQAAAYMxMAAQAAAOcQAAAcMxMAAQAAAOgQAAAgMxMAAQAAAOkQAAAkMxMAAQAAAOoQAAAoMxMAAQAAAOsQAAAsMxMAAQAAAOwQAAAwMxMAAQAAAO0QAAA0MxMAAQAAAO4QAAA4MxMAAQAAAO8QAAA8MxMAAQAAAPAQAABAMxMAAQAAAPEQAABEMxMAAQAAAPIQAABIMxMAAQAAAPMQAABMMxMAAQAAAPQQAABQMxMAAQAAAPUQAABUMxMAAQAAAPYQAABYMxMAAQAAAPcQAABcMxMAAQAAAPgQAABgMxMAAQAAAPkQAABkMxMAAQAAAPoQAABoMxMAAQAAAP0QAABsMxMAAQAAAP4QAABwMxMAAQAAAP8QAAB0MxMAAQAAAKATAAB4MxMAAQAAAKETAAB8MxMAAQAAAKITAACAMxMAAQAAAKMTAACEMxMAAQAAAKQTAACIMxMAAQAAAKUTAACMMxMAAQAAAKYTAACQMxMAAQAAAKcTAACUMxMAAQAAAKgTAACYMxMAAQAAAKkTAACcMxMAAQAAAKoTAACgMxMAAQAAAKsTAACkMxMAAQAAAKwTAACoMxMAAQAAAK0TAACsMxMAAQAAAK4TAACwMxMAAQAAAK8TAAC0MxMAAQAAALATAAC4MxMAAQAAALETAAC8MxMAAQAAALITAADAMxMAAQAAALMTAADEMxMAAQAAALQTAADIMxMAAQAAALUTAADMMxMAAQAAALYTAADQMxMAAQAAALcTAADUMxMAAQAAALgTAADYMxMAAQAAALkTAADcMxMAAQAAALoTAADgMxMAAQAAALsTAADkMxMAAQAAALwTAADoMxMAAQAAAL0TAADsMxMAAQAAAL4TAADwMxMAAQAAAL8TAAD0MxMAAQAAAMATAAD4MxMAAQAAAMETAAD8MxMAAQAAAMITAAAANBMAAQAAAMMTAAAENBMAAQAAAMQTAAAINBMAAQAAAMUTAAAMNBMAAQAAAMYTAAAQNBMAAQAAAMcTAAAUNBMAAQAAAMgTAAAYNBMAAQAAAMkTAAAcNBMAAQAAAMoTAAAgNBMAAQAAAMsTAAAkNBMAAQAAAMwTAAAoNBMAAQAAAM0TAAAsNBMAAQAAAM4TAAAwNBMAAQAAAM8TAAA0NBMAAQAAANATAAA4NBMAAQAAANETAAA8NBMAAQAAANITAABANBMAAQAAANMTAABENBMAAQAAANQTAABINBMAAQAAANUTAABMNBMAAQAAANYTAABQNBMAAQAAANcTAABUNBMAAQAAANgTAABYNBMAAQAAANkTAABcNBMAAQAAANoTAABgNBMAAQAAANsTAABkNBMAAQAAANwTAABoNBMAAQAAAN0TAABsNBMAAQAAAN4TAABwNBMAAQAAAN8TAAB0NBMAAQAAAOATAAB4NBMAAQAAAOETAAB8NBMAAQAAAOITAACANBMAAQAAAOMTAACENBMAAQAAAOQTAACINBMAAQAAAOUTAACMNBMAAQAAAOYTAACQNBMAAQAAAOcTAACUNBMAAQAAAOgTAACYNBMAAQAAAOkTAACcNBMAAQAAAOoTAACgNBMAAQAAAOsTAACkNBMAAQAAAOwTAACoNBMAAQAAAO0TAACsNBMAAQAAAO4TAACwNBMAAQAAAO8TAAC0NBMAAQAAAPATAAC4NBMAAQAAAPETAAC8NBMAAQAAAPITAADANBMAAQAAAPMTAADENBMAAQAAAPQTAADINBMAAQAAAPUTAADMNBMAAQAAAPgTAADQNBMAAQAAAPkTAADUNBMAAQAAAPoTAADYNBMAAQAAAPsTAADcNBMAAQAAAPwTAADgNBMAAQAAAP0TAADkNBMAAQAAAIAcAADoNBMAAgAAAIEcAADwNBMAAgAAAIIcAAD4NBMAAgAAAIMcAAAANRMAAgAAAIQcAAAINRMAAwAAAIUcAAAUNRMAAwAAAIYcAAAgNRMAAgAAAIccAAAoNRMAAgAAAIgcAAAwNRMAAgAAAJAcAAA4NRMAAQAAAJEcAAA8NRMAAQAAAJIcAABANRMAAQAAAJMcAABENRMAAQAAAJQcAABINRMAAQAAAJUcAABMNRMAAQAAAJYcAABQNRMAAQAAAJccAABUNRMAAQAAAJgcAABYNRMAAQAAAJkcAABcNRMAAQAAAJocAABgNRMAAQAAAJscAABkNRMAAQAAAJwcAABoNRMAAQAAAJ0cAABsNRMAAQAAAJ4cAABwNRMAAQAAAJ8cAAB0NRMAAQAAAKAcAAB4NRMAAQAAAKEcAAB8NRMAAQAAAKIcAACANRMAAQAAAKMcAACENRMAAQAAAKQcAACINRMAAQAAAKUcAACMNRMAAQAAAKYcAACQNRMAAQAAAKccAACUNRMAAQAAAKgcAACYNRMAAQAAAKkcAACcNRMAAQAAAKocAACgNRMAAQAAAKscAACkNRMAAQAAAKwcAACoNRMAAQAAAK0cAACsNRMAAQAAAK4cAACwNRMAAQAAAK8cAAC0NRMAAQAAALAcAAC4NRMAAQAAALEcAAC8NRMAAQAAALIcAADANRMAAQAAALMcAADENRMAAQAAALQcAADINRMAAQAAALUcAADMNRMAAQAAALYcAADQNRMAAQAAALccAADUNRMAAQAAALgcAADYNRMAAQAAALkcAADcNRMAAQAAALocAADgNRMAAQAAAL0cAADkNRMAAQAAAL4cAADoNRMAAQAAAL8cAADsNRMAAQAAAHkdAADwNRMAAQAAAH0dAAD0NRMAAQAAAI4dAAD4NRMAAQAAAAAeAAD8NRMAAQAAAAEeAAAANhMAAQAAAAIeAAAENhMAAQAAAAMeAAAINhMAAQAAAAQeAAAMNhMAAQAAAAUeAAAQNhMAAQAAAAYeAAAUNhMAAQAAAAceAAAYNhMAAQAAAAgeAAAcNhMAAQAAAAkeAAAgNhMAAQAAAAoeAAAkNhMAAQAAAAseAAAoNhMAAQAAAAweAAAsNhMAAQAAAA0eAAAwNhMAAQAAAA4eAAA0NhMAAQAAAA8eAAA4NhMAAQAAABAeAAA8NhMAAQAAABEeAABANhMAAQAAABIeAABENhMAAQAAABMeAABINhMAAQAAABQeAABMNhMAAQAAABUeAABQNhMAAQAAABYeAABUNhMAAQAAABceAABYNhMAAQAAABgeAABcNhMAAQAAABkeAABgNhMAAQAAABoeAABkNhMAAQAAABseAABoNhMAAQAAABweAABsNhMAAQAAAB0eAABwNhMAAQAAAB4eAAB0NhMAAQAAAB8eAAB4NhMAAQAAACAeAAB8NhMAAQAAACEeAACANhMAAQAAACIeAACENhMAAQAAACMeAACINhMAAQAAACQeAACMNhMAAQAAACUeAACQNhMAAQAAACYeAACUNhMAAQAAACceAACYNhMAAQAAACgeAACcNhMAAQAAACkeAACgNhMAAQAAACoeAACkNhMAAQAAACseAACoNhMAAQAAACweAACsNhMAAQAAAC0eAACwNhMAAQAAAC4eAAC0NhMAAQAAAC8eAAC4NhMAAQAAADAeAAC8NhMAAQAAADEeAADANhMAAQAAADIeAADENhMAAQAAADMeAADINhMAAQAAADQeAADMNhMAAQAAADUeAADQNhMAAQAAADYeAADUNhMAAQAAADceAADYNhMAAQAAADgeAADcNhMAAQAAADkeAADgNhMAAQAAADoeAADkNhMAAQAAADseAADoNhMAAQAAADweAADsNhMAAQAAAD0eAADwNhMAAQAAAD4eAAD0NhMAAQAAAD8eAAD4NhMAAQAAAEAeAAD8NhMAAQAAAEEeAAAANxMAAQAAAEIeAAAENxMAAQAAAEMeAAAINxMAAQAAAEQeAAAMNxMAAQAAAEUeAAAQNxMAAQAAAEYeAAAUNxMAAQAAAEceAAAYNxMAAQAAAEgeAAAcNxMAAQAAAEkeAAAgNxMAAQAAAEoeAAAkNxMAAQAAAEseAAAoNxMAAQAAAEweAAAsNxMAAQAAAE0eAAAwNxMAAQAAAE4eAAA0NxMAAQAAAE8eAAA4NxMAAQAAAFAeAAA8NxMAAQAAAFEeAABANxMAAQAAAFIeAABENxMAAQAAAFMeAABINxMAAQAAAFQeAABMNxMAAQAAAFUeAABQNxMAAQAAAFYeAABUNxMAAQAAAFceAABYNxMAAQAAAFgeAABcNxMAAQAAAFkeAABgNxMAAQAAAFoeAABkNxMAAQAAAFseAABoNxMAAQAAAFweAABsNxMAAQAAAF0eAABwNxMAAQAAAF4eAAB0NxMAAQAAAF8eAAB4NxMAAQAAAGAeAAB8NxMAAgAAAGEeAACENxMAAgAAAGIeAACMNxMAAQAAAGMeAACQNxMAAQAAAGQeAACUNxMAAQAAAGUeAACYNxMAAQAAAGYeAACcNxMAAQAAAGceAACgNxMAAQAAAGgeAACkNxMAAQAAAGkeAACoNxMAAQAAAGoeAACsNxMAAQAAAGseAACwNxMAAQAAAGweAAC0NxMAAQAAAG0eAAC4NxMAAQAAAG4eAAC8NxMAAQAAAG8eAADANxMAAQAAAHAeAADENxMAAQAAAHEeAADINxMAAQAAAHIeAADMNxMAAQAAAHMeAADQNxMAAQAAAHQeAADUNxMAAQAAAHUeAADYNxMAAQAAAHYeAADcNxMAAQAAAHceAADgNxMAAQAAAHgeAADkNxMAAQAAAHkeAADoNxMAAQAAAHoeAADsNxMAAQAAAHseAADwNxMAAQAAAHweAAD0NxMAAQAAAH0eAAD4NxMAAQAAAH4eAAD8NxMAAQAAAH8eAAAAOBMAAQAAAIAeAAAEOBMAAQAAAIEeAAAIOBMAAQAAAIIeAAAMOBMAAQAAAIMeAAAQOBMAAQAAAIQeAAAUOBMAAQAAAIUeAAAYOBMAAQAAAIYeAAAcOBMAAQAAAIceAAAgOBMAAQAAAIgeAAAkOBMAAQAAAIkeAAAoOBMAAQAAAIoeAAAsOBMAAQAAAIseAAAwOBMAAQAAAIweAAA0OBMAAQAAAI0eAAA4OBMAAQAAAI4eAAA8OBMAAQAAAI8eAABAOBMAAQAAAJAeAABEOBMAAQAAAJEeAABIOBMAAQAAAJIeAABMOBMAAQAAAJMeAABQOBMAAQAAAJQeAABUOBMAAQAAAJUeAABYOBMAAQAAAJseAABcOBMAAgAAAJ4eAABkOBMAAQAAAKAeAABoOBMAAQAAAKEeAABsOBMAAQAAAKIeAABwOBMAAQAAAKMeAAB0OBMAAQAAAKQeAAB4OBMAAQAAAKUeAAB8OBMAAQAAAKYeAACAOBMAAQAAAKceAACEOBMAAQAAAKgeAACIOBMAAQAAAKkeAACMOBMAAQAAAKoeAACQOBMAAQAAAKseAACUOBMAAQAAAKweAACYOBMAAQAAAK0eAACcOBMAAQAAAK4eAACgOBMAAQAAAK8eAACkOBMAAQAAALAeAACoOBMAAQAAALEeAACsOBMAAQAAALIeAACwOBMAAQAAALMeAAC0OBMAAQAAALQeAAC4OBMAAQAAALUeAAC8OBMAAQAAALYeAADAOBMAAQAAALceAADEOBMAAQAAALgeAADIOBMAAQAAALkeAADMOBMAAQAAALoeAADQOBMAAQAAALseAADUOBMAAQAAALweAADYOBMAAQAAAL0eAADcOBMAAQAAAL4eAADgOBMAAQAAAL8eAADkOBMAAQAAAMAeAADoOBMAAQAAAMEeAADsOBMAAQAAAMIeAADwOBMAAQAAAMMeAAD0OBMAAQAAAMQeAAD4OBMAAQAAAMUeAAD8OBMAAQAAAMYeAAAAORMAAQAAAMceAAAEORMAAQAAAMgeAAAIORMAAQAAAMkeAAAMORMAAQAAAMoeAAAQORMAAQAAAMseAAAUORMAAQAAAMweAAAYORMAAQAAAM0eAAAcORMAAQAAAM4eAAAgORMAAQAAAM8eAAAkORMAAQAAANAeAAAoORMAAQAAANEeAAAsORMAAQAAANIeAAAwORMAAQAAANMeAAA0ORMAAQAAANQeAAA4ORMAAQAAANUeAAA8ORMAAQAAANYeAABAORMAAQAAANceAABEORMAAQAAANgeAABIORMAAQAAANkeAABMORMAAQAAANoeAABQORMAAQAAANseAABUORMAAQAAANweAABYORMAAQAAAN0eAABcORMAAQAAAN4eAABgORMAAQAAAN8eAABkORMAAQAAAOAeAABoORMAAQAAAOEeAABsORMAAQAAAOIeAABwORMAAQAAAOMeAAB0ORMAAQAAAOQeAAB4ORMAAQAAAOUeAAB8ORMAAQAAAOYeAACAORMAAQAAAOceAACEORMAAQAAAOgeAACIORMAAQAAAOkeAACMORMAAQAAAOoeAACQORMAAQAAAOseAACUORMAAQAAAOweAACYORMAAQAAAO0eAACcORMAAQAAAO4eAACgORMAAQAAAO8eAACkORMAAQAAAPAeAACoORMAAQAAAPEeAACsORMAAQAAAPIeAACwORMAAQAAAPMeAAC0ORMAAQAAAPQeAAC4ORMAAQAAAPUeAAC8ORMAAQAAAPYeAADAORMAAQAAAPceAADEORMAAQAAAPgeAADIORMAAQAAAPkeAADMORMAAQAAAPoeAADQORMAAQAAAPseAADUORMAAQAAAPweAADYORMAAQAAAP0eAADcORMAAQAAAP4eAADgORMAAQAAAP8eAADkORMAAQAAAAAfAADoORMAAQAAAAEfAADsORMAAQAAAAIfAADwORMAAQAAAAMfAAD0ORMAAQAAAAQfAAD4ORMAAQAAAAUfAAD8ORMAAQAAAAYfAAAAOhMAAQAAAAcfAAAEOhMAAQAAAAgfAAAIOhMAAQAAAAkfAAAMOhMAAQAAAAofAAAQOhMAAQAAAAsfAAAUOhMAAQAAAAwfAAAYOhMAAQAAAA0fAAAcOhMAAQAAAA4fAAAgOhMAAQAAAA8fAAAkOhMAAQAAABAfAAAoOhMAAQAAABEfAAAsOhMAAQAAABIfAAAwOhMAAQAAABMfAAA0OhMAAQAAABQfAAA4OhMAAQAAABUfAAA8OhMAAQAAABgfAABAOhMAAQAAABkfAABEOhMAAQAAABofAABIOhMAAQAAABsfAABMOhMAAQAAABwfAABQOhMAAQAAAB0fAABUOhMAAQAAACAfAABYOhMAAQAAACEfAABcOhMAAQAAACIfAABgOhMAAQAAACMfAABkOhMAAQAAACQfAABoOhMAAQAAACUfAABsOhMAAQAAACYfAABwOhMAAQAAACcfAAB0OhMAAQAAACgfAAB4OhMAAQAAACkfAAB8OhMAAQAAACofAACAOhMAAQAAACsfAACEOhMAAQAAACwfAACIOhMAAQAAAC0fAACMOhMAAQAAAC4fAACQOhMAAQAAAC8fAACUOhMAAQAAADAfAACYOhMAAQAAADEfAACcOhMAAQAAADIfAACgOhMAAQAAADMfAACkOhMAAQAAADQfAACoOhMAAQAAADUfAACsOhMAAQAAADYfAACwOhMAAQAAADcfAAC0OhMAAQAAADgfAAC4OhMAAQAAADkfAAC8OhMAAQAAADofAADAOhMAAQAAADsfAADEOhMAAQAAADwfAADIOhMAAQAAAD0fAADMOhMAAQAAAD4fAADQOhMAAQAAAD8fAADUOhMAAQAAAEAfAADYOhMAAQAAAEEfAADcOhMAAQAAAEIfAADgOhMAAQAAAEMfAADkOhMAAQAAAEQfAADoOhMAAQAAAEUfAADsOhMAAQAAAEgfAADwOhMAAQAAAEkfAAD0OhMAAQAAAEofAAD4OhMAAQAAAEsfAAD8OhMAAQAAAEwfAAAAOxMAAQAAAE0fAAAEOxMAAQAAAFEfAAAIOxMAAQAAAFMfAAAMOxMAAQAAAFUfAAAQOxMAAQAAAFcfAAAUOxMAAQAAAFkfAAAYOxMAAQAAAFsfAAAcOxMAAQAAAF0fAAAgOxMAAQAAAF8fAAAkOxMAAQAAAGAfAAAoOxMAAQAAAGEfAAAsOxMAAQAAAGIfAAAwOxMAAQAAAGMfAAA0OxMAAQAAAGQfAAA4OxMAAQAAAGUfAAA8OxMAAQAAAGYfAABAOxMAAQAAAGcfAABEOxMAAQAAAGgfAABIOxMAAQAAAGkfAABMOxMAAQAAAGofAABQOxMAAQAAAGsfAABUOxMAAQAAAGwfAABYOxMAAQAAAG0fAABcOxMAAQAAAG4fAABgOxMAAQAAAG8fAABkOxMAAQAAAHAfAABoOxMAAQAAAHEfAABsOxMAAQAAAHIfAABwOxMAAQAAAHMfAAB0OxMAAQAAAHQfAAB4OxMAAQAAAHUfAAB8OxMAAQAAAHYfAACAOxMAAQAAAHcfAACEOxMAAQAAAHgfAACIOxMAAQAAAHkfAACMOxMAAQAAAHofAACQOxMAAQAAAHsfAACUOxMAAQAAAHwfAACYOxMAAQAAAH0fAACcOxMAAQAAAIAfAACgOxMAAQAAAIEfAACkOxMAAQAAAIIfAACoOxMAAQAAAIMfAACsOxMAAQAAAIQfAACwOxMAAQAAAIUfAAC0OxMAAQAAAIYfAAC4OxMAAQAAAIcfAAC8OxMAAQAAAIgfAADAOxMAAQAAAIkfAADEOxMAAQAAAIofAADIOxMAAQAAAIsfAADMOxMAAQAAAIwfAADQOxMAAQAAAI0fAADUOxMAAQAAAI4fAADYOxMAAQAAAI8fAADcOxMAAQAAAJAfAADgOxMAAQAAAJEfAADkOxMAAQAAAJIfAADoOxMAAQAAAJMfAADsOxMAAQAAAJQfAADwOxMAAQAAAJUfAAD0OxMAAQAAAJYfAAD4OxMAAQAAAJcfAAD8OxMAAQAAAJgfAAAAPBMAAQAAAJkfAAAEPBMAAQAAAJofAAAIPBMAAQAAAJsfAAAMPBMAAQAAAJwfAAAQPBMAAQAAAJ0fAAAUPBMAAQAAAJ4fAAAYPBMAAQAAAJ8fAAAcPBMAAQAAAKAfAAAgPBMAAQAAAKEfAAAkPBMAAQAAAKIfAAAoPBMAAQAAAKMfAAAsPBMAAQAAAKQfAAAwPBMAAQAAAKUfAAA0PBMAAQAAAKYfAAA4PBMAAQAAAKcfAAA8PBMAAQAAAKgfAABAPBMAAQAAAKkfAABEPBMAAQAAAKofAABIPBMAAQAAAKsfAABMPBMAAQAAAKwfAABQPBMAAQAAAK0fAABUPBMAAQAAAK4fAABYPBMAAQAAAK8fAABcPBMAAQAAALAfAABgPBMAAQAAALEfAABkPBMAAQAAALMfAABoPBMAAQAAALgfAABsPBMAAQAAALkfAABwPBMAAQAAALofAAB0PBMAAQAAALsfAAB4PBMAAQAAALwfAAB8PBMAAQAAAL4fAACAPBMAAwAAAMMfAACMPBMAAQAAAMgfAACQPBMAAQAAAMkfAACUPBMAAQAAAMofAACYPBMAAQAAAMsfAACcPBMAAQAAAMwfAACgPBMAAQAAANAfAACkPBMAAQAAANEfAACoPBMAAQAAANgfAACsPBMAAQAAANkfAACwPBMAAQAAANofAAC0PBMAAQAAANsfAAC4PBMAAQAAAOAfAAC8PBMAAQAAAOEfAADAPBMAAQAAAOUfAADEPBMAAQAAAOgfAADIPBMAAQAAAOkfAADMPBMAAQAAAOofAADQPBMAAQAAAOsfAADUPBMAAQAAAOwfAADYPBMAAQAAAPMfAADcPBMAAQAAAPgfAADgPBMAAQAAAPkfAADkPBMAAQAAAPofAADoPBMAAQAAAPsfAADsPBMAAQAAAPwfAADwPBMAAQAAACYhAAD0PBMAAgAAACohAAD8PBMAAgAAACshAAAEPRMAAgAAADIhAAAMPRMAAQAAAE4hAAAQPRMAAQAAAGAhAAAUPRMAAQAAAGEhAAAYPRMAAQAAAGIhAAAcPRMAAQAAAGMhAAAgPRMAAQAAAGQhAAAkPRMAAQAAAGUhAAAoPRMAAQAAAGYhAAAsPRMAAQAAAGchAAAwPRMAAQAAAGghAAA0PRMAAQAAAGkhAAA4PRMAAQAAAGohAAA8PRMAAQAAAGshAABAPRMAAQAAAGwhAABEPRMAAQAAAG0hAABIPRMAAQAAAG4hAABMPRMAAQAAAG8hAABQPRMAAQAAAHAhAABUPRMAAQAAAHEhAABYPRMAAQAAAHIhAABcPRMAAQAAAHMhAABgPRMAAQAAAHQhAABkPRMAAQAAAHUhAABoPRMAAQAAAHYhAABsPRMAAQAAAHchAABwPRMAAQAAAHghAAB0PRMAAQAAAHkhAAB4PRMAAQAAAHohAAB8PRMAAQAAAHshAACAPRMAAQAAAHwhAACEPRMAAQAAAH0hAACIPRMAAQAAAH4hAACMPRMAAQAAAH8hAACQPRMAAQAAAIMhAACUPRMAAQAAAIQhAACYPRMAAQAAALYkAACcPRMAAQAAALckAACgPRMAAQAAALgkAACkPRMAAQAAALkkAACoPRMAAQAAALokAACsPRMAAQAAALskAACwPRMAAQAAALwkAAC0PRMAAQAAAL0kAAC4PRMAAQAAAL4kAAC8PRMAAQAAAL8kAADAPRMAAQAAAMAkAADEPRMAAQAAAMEkAADIPRMAAQAAAMIkAADMPRMAAQAAAMMkAADQPRMAAQAAAMQkAADUPRMAAQAAAMUkAADYPRMAAQAAAMYkAADcPRMAAQAAAMckAADgPRMAAQAAAMgkAADkPRMAAQAAAMkkAADoPRMAAQAAAMokAADsPRMAAQAAAMskAADwPRMAAQAAAMwkAAD0PRMAAQAAAM0kAAD4PRMAAQAAAM4kAAD8PRMAAQAAAM8kAAAAPhMAAQAAANAkAAAEPhMAAQAAANEkAAAIPhMAAQAAANIkAAAMPhMAAQAAANMkAAAQPhMAAQAAANQkAAAUPhMAAQAAANUkAAAYPhMAAQAAANYkAAAcPhMAAQAAANckAAAgPhMAAQAAANgkAAAkPhMAAQAAANkkAAAoPhMAAQAAANokAAAsPhMAAQAAANskAAAwPhMAAQAAANwkAAA0PhMAAQAAAN0kAAA4PhMAAQAAAN4kAAA8PhMAAQAAAN8kAABAPhMAAQAAAOAkAABEPhMAAQAAAOEkAABIPhMAAQAAAOIkAABMPhMAAQAAAOMkAABQPhMAAQAAAOQkAABUPhMAAQAAAOUkAABYPhMAAQAAAOYkAABcPhMAAQAAAOckAABgPhMAAQAAAOgkAABkPhMAAQAAAOkkAABoPhMAAQAAAAAsAABsPhMAAQAAAAEsAABwPhMAAQAAAAIsAAB0PhMAAQAAAAMsAAB4PhMAAQAAAAQsAAB8PhMAAQAAAAUsAACAPhMAAQAAAAYsAACEPhMAAQAAAAcsAACIPhMAAQAAAAgsAACMPhMAAQAAAAksAACQPhMAAQAAAAosAACUPhMAAQAAAAssAACYPhMAAQAAAAwsAACcPhMAAQAAAA0sAACgPhMAAQAAAA4sAACkPhMAAQAAAA8sAACoPhMAAQAAABAsAACsPhMAAQAAABEsAACwPhMAAQAAABIsAAC0PhMAAQAAABMsAAC4PhMAAQAAABQsAAC8PhMAAQAAABUsAADAPhMAAQAAABYsAADEPhMAAQAAABcsAADIPhMAAQAAABgsAADMPhMAAQAAABksAADQPhMAAQAAABosAADUPhMAAQAAABssAADYPhMAAQAAABwsAADcPhMAAQAAAB0sAADgPhMAAQAAAB4sAADkPhMAAQAAAB8sAADoPhMAAQAAACAsAADsPhMAAQAAACEsAADwPhMAAQAAACIsAAD0PhMAAQAAACMsAAD4PhMAAQAAACQsAAD8PhMAAQAAACUsAAAAPxMAAQAAACYsAAAEPxMAAQAAACcsAAAIPxMAAQAAACgsAAAMPxMAAQAAACksAAAQPxMAAQAAACosAAAUPxMAAQAAACssAAAYPxMAAQAAACwsAAAcPxMAAQAAAC0sAAAgPxMAAQAAAC4sAAAkPxMAAQAAADAsAAAoPxMAAQAAADEsAAAsPxMAAQAAADIsAAAwPxMAAQAAADMsAAA0PxMAAQAAADQsAAA4PxMAAQAAADUsAAA8PxMAAQAAADYsAABAPxMAAQAAADcsAABEPxMAAQAAADgsAABIPxMAAQAAADksAABMPxMAAQAAADosAABQPxMAAQAAADssAABUPxMAAQAAADwsAABYPxMAAQAAAD0sAABcPxMAAQAAAD4sAABgPxMAAQAAAD8sAABkPxMAAQAAAEAsAABoPxMAAQAAAEEsAABsPxMAAQAAAEIsAABwPxMAAQAAAEMsAAB0PxMAAQAAAEQsAAB4PxMAAQAAAEUsAAB8PxMAAQAAAEYsAACAPxMAAQAAAEcsAACEPxMAAQAAAEgsAACIPxMAAQAAAEksAACMPxMAAQAAAEosAACQPxMAAQAAAEssAACUPxMAAQAAAEwsAACYPxMAAQAAAE0sAACcPxMAAQAAAE4sAACgPxMAAQAAAE8sAACkPxMAAQAAAFAsAACoPxMAAQAAAFEsAACsPxMAAQAAAFIsAACwPxMAAQAAAFMsAAC0PxMAAQAAAFQsAAC4PxMAAQAAAFUsAAC8PxMAAQAAAFYsAADAPxMAAQAAAFcsAADEPxMAAQAAAFgsAADIPxMAAQAAAFksAADMPxMAAQAAAFosAADQPxMAAQAAAFssAADUPxMAAQAAAFwsAADYPxMAAQAAAF0sAADcPxMAAQAAAF4sAADgPxMAAQAAAGAsAADkPxMAAQAAAGEsAADoPxMAAQAAAGIsAADsPxMAAQAAAGMsAADwPxMAAQAAAGQsAAD0PxMAAQAAAGUsAAD4PxMAAQAAAGYsAAD8PxMAAQAAAGcsAAAAQBMAAQAAAGgsAAAEQBMAAQAAAGksAAAIQBMAAQAAAGosAAAMQBMAAQAAAGssAAAQQBMAAQAAAGwsAAAUQBMAAQAAAG0sAAAYQBMAAQAAAG4sAAAcQBMAAQAAAG8sAAAgQBMAAQAAAHAsAAAkQBMAAQAAAHIsAAAoQBMAAQAAAHMsAAAsQBMAAQAAAHUsAAAwQBMAAQAAAHYsAAA0QBMAAQAAAH4sAAA4QBMAAQAAAH8sAAA8QBMAAQAAAIAsAABAQBMAAQAAAIEsAABEQBMAAQAAAIIsAABIQBMAAQAAAIMsAABMQBMAAQAAAIQsAABQQBMAAQAAAIUsAABUQBMAAQAAAIYsAABYQBMAAQAAAIcsAABcQBMAAQAAAIgsAABgQBMAAQAAAIksAABkQBMAAQAAAIosAABoQBMAAQAAAIssAABsQBMAAQAAAIwsAABwQBMAAQAAAI0sAAB0QBMAAQAAAI4sAAB4QBMAAQAAAI8sAAB8QBMAAQAAAJAsAACAQBMAAQAAAJEsAACEQBMAAQAAAJIsAACIQBMAAQAAAJMsAACMQBMAAQAAAJQsAACQQBMAAQAAAJUsAACUQBMAAQAAAJYsAACYQBMAAQAAAJcsAACcQBMAAQAAAJgsAACgQBMAAQAAAJksAACkQBMAAQAAAJosAACoQBMAAQAAAJssAACsQBMAAQAAAJwsAACwQBMAAQAAAJ0sAAC0QBMAAQAAAJ4sAAC4QBMAAQAAAJ8sAAC8QBMAAQAAAKAsAADAQBMAAQAAAKEsAADEQBMAAQAAAKIsAADIQBMAAQAAAKMsAADMQBMAAQAAAKQsAADQQBMAAQAAAKUsAADUQBMAAQAAAKYsAADYQBMAAQAAAKcsAADcQBMAAQAAAKgsAADgQBMAAQAAAKksAADkQBMAAQAAAKosAADoQBMAAQAAAKssAADsQBMAAQAAAKwsAADwQBMAAQAAAK0sAAD0QBMAAQAAAK4sAAD4QBMAAQAAAK8sAAD8QBMAAQAAALAsAAAAQRMAAQAAALEsAAAEQRMAAQAAALIsAAAIQRMAAQAAALMsAAAMQRMAAQAAALQsAAAQQRMAAQAAALUsAAAUQRMAAQAAALYsAAAYQRMAAQAAALcsAAAcQRMAAQAAALgsAAAgQRMAAQAAALksAAAkQRMAAQAAALosAAAoQRMAAQAAALssAAAsQRMAAQAAALwsAAAwQRMAAQAAAL0sAAA0QRMAAQAAAL4sAAA4QRMAAQAAAL8sAAA8QRMAAQAAAMAsAABAQRMAAQAAAMEsAABEQRMAAQAAAMIsAABIQRMAAQAAAMMsAABMQRMAAQAAAMQsAABQQRMAAQAAAMUsAABUQRMAAQAAAMYsAABYQRMAAQAAAMcsAABcQRMAAQAAAMgsAABgQRMAAQAAAMksAABkQRMAAQAAAMosAABoQRMAAQAAAMssAABsQRMAAQAAAMwsAABwQRMAAQAAAM0sAAB0QRMAAQAAAM4sAAB4QRMAAQAAAM8sAAB8QRMAAQAAANAsAACAQRMAAQAAANEsAACEQRMAAQAAANIsAACIQRMAAQAAANMsAACMQRMAAQAAANQsAACQQRMAAQAAANUsAACUQRMAAQAAANYsAACYQRMAAQAAANcsAACcQRMAAQAAANgsAACgQRMAAQAAANksAACkQRMAAQAAANosAACoQRMAAQAAANssAACsQRMAAQAAANwsAACwQRMAAQAAAN0sAAC0QRMAAQAAAN4sAAC4QRMAAQAAAN8sAAC8QRMAAQAAAOAsAADAQRMAAQAAAOEsAADEQRMAAQAAAOIsAADIQRMAAQAAAOMsAADMQRMAAQAAAOssAADQQRMAAQAAAOwsAADUQRMAAQAAAO0sAADYQRMAAQAAAO4sAADcQRMAAQAAAPIsAADgQRMAAQAAAPMsAADkQRMAAQAAAAAtAADoQRMAAQAAAAEtAADsQRMAAQAAAAItAADwQRMAAQAAAAMtAAD0QRMAAQAAAAQtAAD4QRMAAQAAAAUtAAD8QRMAAQAAAAYtAAAAQhMAAQAAAActAAAEQhMAAQAAAAgtAAAIQhMAAQAAAAktAAAMQhMAAQAAAAotAAAQQhMAAQAAAAstAAAUQhMAAQAAAAwtAAAYQhMAAQAAAA0tAAAcQhMAAQAAAA4tAAAgQhMAAQAAAA8tAAAkQhMAAQAAABAtAAAoQhMAAQAAABEtAAAsQhMAAQAAABItAAAwQhMAAQAAABMtAAA0QhMAAQAAABQtAAA4QhMAAQAAABUtAAA8QhMAAQAAABYtAABAQhMAAQAAABctAABEQhMAAQAAABgtAABIQhMAAQAAABktAABMQhMAAQAAABotAABQQhMAAQAAABstAABUQhMAAQAAABwtAABYQhMAAQAAAB0tAABcQhMAAQAAAB4tAABgQhMAAQAAAB8tAABkQhMAAQAAACAtAABoQhMAAQAAACEtAABsQhMAAQAAACItAABwQhMAAQAAACMtAAB0QhMAAQAAACQtAAB4QhMAAQAAACUtAAB8QhMAAQAAACctAACAQhMAAQAAAC0tAACEQhMAAQAAAECmAACIQhMAAQAAAEGmAACMQhMAAQAAAEKmAACQQhMAAQAAAEOmAACUQhMAAQAAAESmAACYQhMAAQAAAEWmAACcQhMAAQAAAEamAACgQhMAAQAAAEemAACkQhMAAQAAAEimAACoQhMAAQAAAEmmAACsQhMAAQAAAEqmAACwQhMAAgAAAEumAAC4QhMAAgAAAEymAADAQhMAAQAAAE2mAADEQhMAAQAAAE6mAADIQhMAAQAAAE+mAADMQhMAAQAAAFCmAADQQhMAAQAAAFGmAADUQhMAAQAAAFKmAADYQhMAAQAAAFOmAADcQhMAAQAAAFSmAADgQhMAAQAAAFWmAADkQhMAAQAAAFamAADoQhMAAQAAAFemAADsQhMAAQAAAFimAADwQhMAAQAAAFmmAAD0QhMAAQAAAFqmAAD4QhMAAQAAAFumAAD8QhMAAQAAAFymAAAAQxMAAQAAAF2mAAAEQxMAAQAAAF6mAAAIQxMAAQAAAF+mAAAMQxMAAQAAAGCmAAAQQxMAAQAAAGGmAAAUQxMAAQAAAGKmAAAYQxMAAQAAAGOmAAAcQxMAAQAAAGSmAAAgQxMAAQAAAGWmAAAkQxMAAQAAAGamAAAoQxMAAQAAAGemAAAsQxMAAQAAAGimAAAwQxMAAQAAAGmmAAA0QxMAAQAAAGqmAAA4QxMAAQAAAGumAAA8QxMAAQAAAGymAABAQxMAAQAAAG2mAABEQxMAAQAAAICmAABIQxMAAQAAAIGmAABMQxMAAQAAAIKmAABQQxMAAQAAAIOmAABUQxMAAQAAAISmAABYQxMAAQAAAIWmAABcQxMAAQAAAIamAABgQxMAAQAAAIemAABkQxMAAQAAAIimAABoQxMAAQAAAImmAABsQxMAAQAAAIqmAABwQxMAAQAAAIumAAB0QxMAAQAAAIymAAB4QxMAAQAAAI2mAAB8QxMAAQAAAI6mAACAQxMAAQAAAI+mAACEQxMAAQAAAJCmAACIQxMAAQAAAJGmAACMQxMAAQAAAJKmAACQQxMAAQAAAJOmAACUQxMAAQAAAJSmAACYQxMAAQAAAJWmAACcQxMAAQAAAJamAACgQxMAAQAAAJemAACkQxMAAQAAAJimAACoQxMAAQAAAJmmAACsQxMAAQAAAJqmAACwQxMAAQAAAJumAAC0QxMAAQAAACKnAAC4QxMAAQAAACOnAAC8QxMAAQAAACSnAADAQxMAAQAAACWnAADEQxMAAQAAACanAADIQxMAAQAAACenAADMQxMAAQAAACinAADQQxMAAQAAACmnAADUQxMAAQAAACqnAADYQxMAAQAAACunAADcQxMAAQAAACynAADgQxMAAQAAAC2nAADkQxMAAQAAAC6nAADoQxMAAQAAAC+nAADsQxMAAQAAADKnAADwQxMAAQAAADOnAAD0QxMAAQAAADSnAAD4QxMAAQAAADWnAAD8QxMAAQAAADanAAAARBMAAQAAADenAAAERBMAAQAAADinAAAIRBMAAQAAADmnAAAMRBMAAQAAADqnAAAQRBMAAQAAADunAAAURBMAAQAAADynAAAYRBMAAQAAAD2nAAAcRBMAAQAAAD6nAAAgRBMAAQAAAD+nAAAkRBMAAQAAAECnAAAoRBMAAQAAAEGnAAAsRBMAAQAAAEKnAAAwRBMAAQAAAEOnAAA0RBMAAQAAAESnAAA4RBMAAQAAAEWnAAA8RBMAAQAAAEanAABARBMAAQAAAEenAABERBMAAQAAAEinAABIRBMAAQAAAEmnAABMRBMAAQAAAEqnAABQRBMAAQAAAEunAABURBMAAQAAAEynAABYRBMAAQAAAE2nAABcRBMAAQAAAE6nAABgRBMAAQAAAE+nAABkRBMAAQAAAFCnAABoRBMAAQAAAFGnAABsRBMAAQAAAFKnAABwRBMAAQAAAFOnAAB0RBMAAQAAAFSnAAB4RBMAAQAAAFWnAAB8RBMAAQAAAFanAACARBMAAQAAAFenAACERBMAAQAAAFinAACIRBMAAQAAAFmnAACMRBMAAQAAAFqnAACQRBMAAQAAAFunAACURBMAAQAAAFynAACYRBMAAQAAAF2nAACcRBMAAQAAAF6nAACgRBMAAQAAAF+nAACkRBMAAQAAAGCnAACoRBMAAQAAAGGnAACsRBMAAQAAAGKnAACwRBMAAQAAAGOnAAC0RBMAAQAAAGSnAAC4RBMAAQAAAGWnAAC8RBMAAQAAAGanAADARBMAAQAAAGenAADERBMAAQAAAGinAADIRBMAAQAAAGmnAADMRBMAAQAAAGqnAADQRBMAAQAAAGunAADURBMAAQAAAGynAADYRBMAAQAAAG2nAADcRBMAAQAAAG6nAADgRBMAAQAAAG+n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AQBoSBMAAQAAABEEAQBsSBMAAQAAABIEAQBwSBMAAQAAABMEAQB0SBMAAQAAABQEAQB4SBMAAQAAABUEAQB8SBMAAQAAABYEAQCASBMAAQAAABcEAQCESBMAAQAAABgEAQCISBMAAQAAABkEAQCMSBMAAQAAABoEAQCQSBMAAQAAABsEAQCUSBMAAQAAABwEAQCYSBMAAQAAAB0EAQCcSBMAAQAAAB4EAQCgSBMAAQAAAB8EAQCkSBMAAQAAACAEAQCoSBMAAQAAACEEAQCsSBMAAQAAACIEAQCwSBMAAQAAACMEAQC0SBMAAQAAACQEAQC4SBMAAQAAACUEAQC8SBMAAQAAACYEAQDASBMAAQAAACcEAQDESBMAAQAAACgEAQDISBMAAQAAACkEAQDMSBMAAQAAACoEAQDQSBMAAQAAACsEAQDUSBMAAQAAACwEAQDYSBMAAQAAAC0EAQDcSBMAAQAAAC4EAQDgSBMAAQAAAC8EAQDkSBMAAQAAADAEAQDoSBMAAQAAADEEAQDsSBMAAQAAADIEAQDwSBMAAQAAADMEAQD0SBMAAQAAADQEAQD4SBMAAQAAADUEAQD8SBMAAQAAADYEAQAASRMAAQAAADcEAQAESRMAAQAAADgEAQAISRMAAQAAADkEAQAMSRMAAQAAADoEAQAQSRMAAQAAADsEAQAUSRMAAQAAADwEAQAYSRMAAQAAAD0EAQAcSRMAAQAAAD4EAQAgSRMAAQAAAD8EAQAkSRMAAQAAAEAEAQAoSRMAAQAAAEEEAQAsSRMAAQAAAEIEAQAwSRMAAQAAAEMEAQA0SRMAAQAAAEQEAQA4SRMAAQAAAEUEAQA8SRMAAQAAAEYEAQBASRMAAQAAAEcEAQBESRMAAQAAAEgEAQBISRMAAQAAAEkEAQBMSRMAAQAAAEoEAQBQSRMAAQAAAEsEAQBUSRMAAQAAAEwEAQBYSRMAAQAAAE0EAQBcSRMAAQAAAE4EAQBgSRMAAQAAAE8EAQBkSRMAAQAAALAEAQBoSRMAAQAAALEEAQBsSRMAAQAAALIEAQBwSRMAAQAAALMEAQB0SRMAAQAAALQEAQB4SRMAAQAAALUEAQB8SRMAAQAAALYEAQCASRMAAQAAALcEAQCESRMAAQAAALgEAQCISRMAAQAAALkEAQCMSRMAAQAAALoEAQCQSRMAAQAAALsEAQCUSRMAAQAAALwEAQCYSRMAAQAAAL0EAQCcSRMAAQAAAL4EAQCgSRMAAQAAAL8EAQCkSRMAAQAAAMAEAQCoSRMAAQAAAMEEAQCsSRMAAQAAAMIEAQCwSRMAAQAAAMMEAQC0SRMAAQAAAMQEAQC4SRMAAQAAAMUEAQC8SRMAAQAAAMYEAQDASRMAAQAAAMcEAQDESRMAAQAAAMgEAQDISRMAAQAAAMkEAQDMSRMAAQAAAMoEAQDQSRMAAQAAAMsEAQDUSRMAAQAAAMwEAQDYSRMAAQAAAM0EAQDcSRMAAQAAAM4EAQDgSRMAAQAAAM8EAQDkSRMAAQAAANAEAQDoSRMAAQAAANEEAQDsSRMAAQAAANIEAQDwSRMAAQAAANMEAQD0SRMAAQAAANgEAQD4SRMAAQAAANkEAQD8SRMAAQAAANoEAQAAShMAAQAAANsEAQAEShMAAQAAANwEAQAIShMAAQAAAN0EAQAMShMAAQAAAN4EAQAQShMAAQAAAN8EAQAUShMAAQAAAOAEAQAYShMAAQAAAOEEAQAcShMAAQAAAOIEAQAgShMAAQAAAOMEAQAkShMAAQAAAOQEAQAoShMAAQAAAOUEAQAsShMAAQAAAOYEAQAwShMAAQAAAOcEAQA0ShMAAQAAAOgEAQA4ShMAAQAAAOkEAQA8ShMAAQAAAOoEAQBAShMAAQAAAOsEAQBEShMAAQAAAOwEAQBIShMAAQAAAO0EAQBMShMAAQAAAO4EAQBQShMAAQAAAO8EAQBUShMAAQAAAPAEAQBYShMAAQAAAPEEAQBcShMAAQAAAPIEAQBgShMAAQAAAPMEAQBkShMAAQAAAPQEAQBoShMAAQAAAPUEAQBsShMAAQAAAPYEAQBwShMAAQAAAPcEAQB0ShMAAQAAAPgEAQB4ShMAAQAAAPkEAQB8ShMAAQAAAPoEAQCAShMAAQAAAPsEAQCEShMAAQAAAIAMAQCIShMAAQAAAIEMAQCMShMAAQAAAIIMAQCQShMAAQAAAIMMAQCUShMAAQAAAIQMAQCYShMAAQAAAIUMAQCcShMAAQAAAIYMAQCgShMAAQAAAIcMAQCkShMAAQAAAIgMAQCoShMAAQAAAIkMAQCsShMAAQAAAIoMAQCwShMAAQAAAIsMAQC0ShMAAQAAAIwMAQC4ShMAAQAAAI0MAQC8ShMAAQAAAI4MAQDAShMAAQAAAI8MAQDEShMAAQAAAJAMAQDIShMAAQAAAJEMAQDMShMAAQAAAJIMAQDQShMAAQAAAJMMAQDUShMAAQAAAJQMAQDYShMAAQAAAJUMAQDcShMAAQAAAJYMAQDgShMAAQAAAJcMAQDkShMAAQAAAJgMAQDoShMAAQAAAJkMAQDsShMAAQAAAJoMAQDwShMAAQAAAJsMAQD0ShMAAQAAAJwMAQD4ShMAAQAAAJ0MAQD8ShMAAQAAAJ4MAQAASxMAAQAAAJ8MAQAESxMAAQAAAKAMAQAISxMAAQAAAKEMAQAMSxMAAQAAAKIMAQAQSxMAAQAAAKMMAQAUSxMAAQAAAKQMAQAYSxMAAQAAAKUMAQAcSxMAAQAAAKYMAQAgSxMAAQAAAKcMAQAkSxMAAQAAAKgMAQAoSxMAAQAAAKkMAQAsSxMAAQAAAKoMAQAwSxMAAQAAAKsMAQA0SxMAAQAAAKwMAQA4SxMAAQAAAK0MAQA8SxMAAQAAAK4MAQBASxMAAQAAAK8MAQBESxMAAQAAALAMAQBISxMAAQAAALEMAQBMSxMAAQAAALIMAQBQSxMAAQAAAMAMAQBUSxMAAQAAAMEMAQBYSxMAAQAAAMIMAQBcSxMAAQAAAMMMAQBgSxMAAQAAAMQMAQBkSxMAAQAAAMUMAQBoSxMAAQAAAMYMAQBsSxMAAQAAAMcMAQBwSxMAAQAAAMgMAQB0SxMAAQAAAMkMAQB4SxMAAQAAAMoMAQB8SxMAAQAAAMsMAQCASxMAAQAAAMwMAQCESxMAAQAAAM0MAQCISxMAAQAAAM4MAQCMSxMAAQAAAM8MAQCQSxMAAQAAANAMAQCUSxMAAQAAANEMAQCYSxMAAQAAANIMAQCcSxMAAQAAANMMAQCgSxMAAQAAANQMAQCkSxMAAQAAANUMAQCoSxMAAQAAANYMAQCsSxMAAQAAANcMAQCwSxMAAQAAANgMAQC0SxMAAQAAANkMAQC4SxMAAQAAANoMAQC8SxMAAQAAANsMAQDASxMAAQAAANwMAQDESxMAAQAAAN0MAQDISxMAAQAAAN4MAQDMSxMAAQAAAN8MAQDQSxMAAQAAAOAMAQDUSxMAAQAAAOEMAQDYSxMAAQAAAOIMAQDcSxMAAQAAAOMMAQDgSxMAAQAAAOQMAQDkSxMAAQAAAOUMAQDoSxMAAQAAAOYMAQDsSxMAAQAAAOcMAQDwSxMAAQAAAOgMAQD0SxMAAQAAAOkMAQD4SxMAAQAAAOoMAQD8SxMAAQAAAOsMAQAATBMAAQAAAOwMAQAETBMAAQAAAO0MAQAITBMAAQAAAO4MAQAMTBMAAQAAAO8MAQAQTBMAAQAAAPAMAQAUTBMAAQAAAPEMAQAYTBMAAQAAAPIMAQAcTBMAAQAAAKAYAQAgTBMAAQAAAKEYAQAkTBMAAQAAAKIYAQAoTBMAAQAAAKMYAQAsTBMAAQAAAKQYAQAwTBMAAQAAAKUYAQA0TBMAAQAAAKYYAQA4TBMAAQAAAKcYAQA8TBMAAQAAAKgYAQBATBMAAQAAAKkYAQBETBMAAQAAAKoYAQBITBMAAQAAAKsYAQBMTBMAAQAAAKwYAQBQTBMAAQAAAK0YAQBUTBMAAQAAAK4YAQBYTBMAAQAAAK8YAQBcTBMAAQAAALAYAQBgTBMAAQAAALEYAQBkTBMAAQAAALIYAQBoTBMAAQAAALMYAQBsTBMAAQAAALQYAQBwTBMAAQAAALUYAQB0TBMAAQAAALYYAQB4TBMAAQAAALcYAQB8TBMAAQAAALgYAQCATBMAAQAAALkYAQCETBMAAQAAALoYAQCITBMAAQAAALsYAQCMTBMAAQAAALwYAQCQTBMAAQAAAL0YAQCUTBMAAQAAAL4YAQCYTBMAAQAAAL8YAQCcTBMAAQAAAMAYAQCgTBMAAQAAAMEYAQCkTBMAAQAAAMIYAQCoTBMAAQAAAMMYAQCsTBMAAQAAAMQYAQCwTBMAAQAAAMUYAQC0TBMAAQAAAMYYAQC4TBMAAQAAAMcYAQC8TBMAAQAAAMgYAQDATBMAAQAAAMkYAQDETBMAAQAAAMoYAQDITBMAAQAAAMsYAQDMTBMAAQAAAMwYAQDQTBMAAQAAAM0YAQDUTBMAAQAAAM4YAQDYTBMAAQAAAM8YAQDcTBMAAQAAANAYAQDgTBMAAQAAANEYAQDkTBMAAQAAANIYAQDoTBMAAQAAANMYAQDsTBMAAQAAANQYAQDwTBMAAQAAANUYAQD0TBMAAQAAANYYAQD4TBMAAQAAANcYAQD8TBMAAQAAANgYAQAATRMAAQAAANkYAQAETRMAAQAAANoYAQAITRMAAQAAANsYAQAMTRMAAQAAANwYAQAQTRMAAQAAAN0YAQAUTRMAAQAAAN4Y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AQBvEAEA8BABAPkQAQA2EQEAPxEBANARAQDZEQEA8BIBAPkSAQBQFAEAWRQBANAUAQDZFAEAUBYBAFkWAQDAFgEAyRYBADAXAQA5FwEA4BgBAOkYAQBQGQEAWRkBAFAcAQBZHAEAUB0BAFkdAQCgHQEAqR0BAGBqAQBpagEAUGsBAFlrAQDO1wEA/9cBAEDhAQBJ4QEA8OIBAPniAQBQ6QEAWekBAPD7AQD5+wEAYW55QW55QXNzaWduZWRhc2NpaUFTQ0lJWNITAGEAAAC8AQAAQAAAAFjSEwBhAAAAwwEAAC4AAABhZ2VhaGV4QVNDSUlfSGV4X0RpZ2l0YWxwaGFBbHBoYWJldGljYWxwaGFiZXRpY2FzY2lpaGV4ZGlnaXRiY0JpZGlfQ2xhc3NiaWRpY0JpZGlfQ29udHJvbGJpZGljbGFzc2JpZGljb250cm9sYmlkaW1CaWRpX01pcnJvcmVkYmlkaW1pcnJvcmVkYmlkaW1pcnJvcmluZ2dseXBoQmlkaV9NaXJyb3JpbmdfR2x5cGhiaWRpcGFpcmVkYnJhY2tldEJpZGlfUGFpcmVkX0JyYWNrZXRiaWRpcGFpcmVkYnJhY2tldHR5cGVCaWRpX1BhaXJlZF9CcmFja2V0X1R5cGVibGtCbG9ja2Jsb2NrYm1nYnBiYnB0Y2Fub25pY2FsY29tYmluaW5nY2xhc3NDYW5vbmljYWxfQ29tYmluaW5nX0NsYXNzY2FzZWRDYXNlZGNhc2Vmb2xkaW5nQ2FzZV9Gb2xkaW5nY2FzZWlnbm9yYWJsZUNhc2VfSWdub3JhYmxlY2NjY2VDb21wb3NpdGlvbl9FeGNsdXNpb25jaGFuZ2Vzd2hlbmNhc2Vmb2xkZWRDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZGNoYW5nZXN3aGVuY2FzZW1hcHBlZENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkY2hhbmdlc3doZW5sb3dlcmNhc2VkQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWRjaGFuZ2Vzd2hlbm5ma2NjYXNlZm9sZGVkQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZGNoYW5nZXN3aGVudGl0bGVjYXNlZENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkY2hhbmdlc3doZW51cHBlcmNhc2VkQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWRjaWNqa2FjY291bnRpbmdudW1lcmlja0FjY291bnRpbmdOdW1lcmljY2prY29tcGF0aWJpbGl0eXZhcmlhbnRrQ29tcGF0aWJpbGl0eVZhcmlhbnRjamtpaWNvcmVrSUlDb3JlY2praXJnZ3NvdXJjZWtJUkdfR1NvdXJjZWNqa2lyZ2hzb3VyY2VrSVJHX0hTb3VyY2Vjamtpcmdqc291cmNla0lSR19KU291cmNlY2praXJna3Bzb3VyY2VrSVJHX0tQU291cmNlY2praXJna3NvdXJjZWtJUkdfS1NvdXJjZWNqa2lyZ21zb3VyY2VrSVJHX01Tb3VyY2Vjamtpcmdzc291cmNla0lSR19TU291cmNlY2praXJndHNvdXJjZWtJUkdfVFNvdXJjZWNqa2lyZ3Vrc291cmNla0lSR19VS1NvdXJjZWNqa2lyZ3Vzb3VyY2VrSVJHX1VTb3VyY2Vjamtpcmd2c291cmNla0lSR19WU291cmNlY2prb3RoZXJudW1lcmlja090aGVyTnVtZXJpY2Nqa3ByaW1hcnludW1lcmlja1ByaW1hcnlOdW1lcmljY2prcnN1bmljb2Rla1JTVW5pY29kZWNvbXBleEZ1bGxfQ29tcG9zaXRpb25fRXhjbHVzaW9uY29tcG9zaXRpb25leGNsdXNpb25jd2NmY3djbWN3a2NmY3dsY3d0Y3d1ZGFzaERhc2hkZWNvbXBvc2l0aW9ubWFwcGluZ0RlY29tcG9zaXRpb25fTWFwcGluZ2RlY29tcG9zaXRpb250eXBlRGVjb21wb3NpdGlvbl9UeXBlZGVmYXVsdGlnbm9yYWJsZWNvZGVwb2ludERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnRkZXBEZXByZWNhdGVkZGVwcmVjYXRlZGRpZGlhRGlhY3JpdGljZGlhY3JpdGljZG1kdGVhRWFzdF9Bc2lhbl9XaWR0aGVhc3Rhc2lhbndpZHRoZWJhc2VFbW9qaV9Nb2RpZmllcl9CYXNlZWNvbXBFbW9qaV9Db21wb25lbnRlbW9kRW1vamlfTW9kaWZpZXJlbW9qaUVtb2ppZW1vamljb21wb25lbnRlbW9qaW1vZGlmaWVyZW1vamltb2RpZmllcmJhc2VlbW9qaXByZXNlbnRhdGlvbkVtb2ppX1ByZXNlbnRhdGlvbmVwcmVzZXF1aWRlb0VxdWl2YWxlbnRfVW5pZmllZF9JZGVvZ3JhcGhlcXVpdmFsZW50dW5pZmllZGlkZW9ncmFwaGV4cGFuZHNvbm5mY0V4cGFuZHNfT25fTkZDZXhwYW5kc29ubmZkRXhwYW5kc19Pbl9ORkRleHBhbmRzb25uZmtjRXhwYW5kc19Pbl9ORktDZXhwYW5kc29ubmZrZEV4cGFuZHNfT25fTkZLRGV4dEV4dGVuZGVyZXh0ZW5kZWRwaWN0b2dyYXBoaWNFeHRlbmRlZF9QaWN0b2dyYXBoaWNleHRlbmRlcmV4dHBpY3RmY25ma2NGQ19ORktDX0Nsb3N1cmVmY25ma2NjbG9zdXJlZnVsbGNvbXBvc2l0aW9uZXhjbHVzaW9uZ2NnY2JnZW5lcmFsY2F0ZWdvcnlncmFwaGVtZWJhc2VHcmFwaGVtZV9CYXNlZ3JhcGhlbWVjbHVzdGVyYnJlYWtncmFwaGVtZWV4dGVuZEdyYXBoZW1lX0V4dGVuZGdyYXBoZW1lbGlua0dyYXBoZW1lX0xpbmtncmJhc2VncmV4dGdybGlua2hhbmd1bHN5bGxhYmxldHlwZUhhbmd1bF9TeWxsYWJsZV9UeXBlaGV4SGV4X0RpZ2l0aGV4ZGlnaXRoc3RoeXBoZW5IeXBoZW5pZGNJRF9Db250aW51ZWlkY29udGludWVpZGVvSWRlb2dyYXBoaWNpZGVvZ3JhcGhpY2lkc0lEX1N0YXJ0aWRzYklEU19CaW5hcnlfT3BlcmF0b3JpZHNiaW5hcnlvcGVyYXRvcmlkc3RJRFNfVHJpbmFyeV9PcGVyYXRvcmlkc3RhcnRpZHN0cmluYXJ5b3BlcmF0b3JpbmRpY3Bvc2l0aW9uYWxjYXRlZ29yeUluZGljX1Bvc2l0aW9uYWxfQ2F0ZWdvcnlpbmRpY3N5bGxhYmljY2F0ZWdvcnlJbmRpY19TeWxsYWJpY19DYXRlZ29yeWlucGNpbnNjaXNjSVNPX0NvbW1lbnRqYW1vc2hvcnRuYW1lSmFtb19TaG9ydF9OYW1lamdKb2luaW5nX0dyb3Vwam9pbmNKb2luX0NvbnRyb2xqb2luY29udHJvbGpvaW5pbmdncm91cGpvaW5pbmd0eXBlSm9pbmluZ19UeXBlanNuanRrYWNjb3VudGluZ251bWVyaWNrY29tcGF0aWJpbGl0eXZhcmlhbnRraWljb3Jla2lyZ2dzb3VyY2VraXJnaHNvdXJjZWtpcmdqc291cmNla2lyZ2twc291cmNla2lyZ2tzb3VyY2VraXJnbXNvdXJjZWtpcmdzc291cmNla2lyZ3Rzb3VyY2VraXJndWtzb3VyY2VraXJndXNvdXJjZWtpcmd2c291cmNla290aGVybnVtZXJpY2twcmltYXJ5bnVtZXJpY2tyc3VuaWNvZGVsYkxpbmVfQnJlYWtsY0xvd2VyY2FzZV9NYXBwaW5nbGluZWJyZWFrbG9lTG9naWNhbF9PcmRlcl9FeGNlcHRpb25sb2dpY2Fsb3JkZXJleGNlcHRpb25sb3dlckxvd2VyY2FzZWxvd2VyY2FzZWxvd2VyY2FzZW1hcHBpbmdtYXRoTWF0aG5hTmFtZW5hMVVuaWNvZGVfMV9OYW1lbmFtZW5hbWVhbGlhc05hbWVfQWxpYXNuY2hhck5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50bmZjcWNORkNfUXVpY2tfQ2hlY2tuZmNxdWlja2NoZWNrbmZkcWNORkRfUXVpY2tfQ2hlY2tuZmRxdWlja2NoZWNrbmZrY2Nhc2Vmb2xkTkZLQ19DYXNlZm9sZG5ma2NjZm5ma2NxY05GS0NfUXVpY2tfQ2hlY2tuZmtjcXVpY2tjaGVja25ma2RxY05GS0RfUXVpY2tfQ2hlY2tuZmtkcXVpY2tjaGVja25vbmNoYXJhY3RlcmNvZGVwb2ludG50TnVtZXJpY19UeXBlbnVtZXJpY3R5cGVudW1lcmljdmFsdWVOdW1lcmljX1ZhbHVlbnZvYWxwaGFPdGhlcl9BbHBoYWJldGljb2NvbW1lbnRvZGlPdGhlcl9EZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50b2dyZXh0T3RoZXJfR3JhcGhlbWVfRXh0ZW5kb2lkY090aGVyX0lEX0NvbnRpbnVlb2lkc090aGVyX0lEX1N0YXJ0b2xvd2VyT3RoZXJfTG93ZXJjYXNlb21hdGhPdGhlcl9NYXRob3RoZXJhbHBoYWJldGljb3RoZXJkZWZhdWx0aWdub3JhYmxlY29kZXBvaW50b3RoZXJncmFwaGVtZWV4dGVuZG90aGVyaWRjb250aW51ZW90aGVyaWRzdGFydG90aGVybG93ZXJjYXNlb3RoZXJtYXRob3RoZXJ1cHBlcmNhc2VPdGhlcl9VcHBlcmNhc2VvdXBwZXJwYXRzeW5QYXR0ZXJuX1N5bnRheHBhdHRlcm5zeW50YXhwYXR0ZXJud2hpdGVzcGFjZVBhdHRlcm5fV2hpdGVfU3BhY2VwYXR3c3BjbVByZXBlbmRlZF9Db25jYXRlbmF0aW9uX01hcmtwcmVwZW5kZWRjb25jYXRlbmF0aW9ubWFya3FtYXJrUXVvdGF0aW9uX01hcmtxdW90YXRpb25tYXJrcmFkaWNhbFJhZGljYWxyZWdpb25hbGluZGljYXRvclJlZ2lvbmFsX0luZGljYXRvcnJpc2JzY3NjZlNpbXBsZV9DYXNlX0ZvbGRpbmdzY3JpcHRzY3JpcHRleHRlbnNpb25zc2N4c2RTb2Z0X0RvdHRlZHNlbnRlbmNlYnJlYWtzZW50ZW5jZXRlcm1pbmFsU2VudGVuY2VfVGVybWluYWxzZmNzaW1wbGVjYXNlZm9sZGluZ3NpbXBsZWxvd2VyY2FzZW1hcHBpbmdTaW1wbGVfTG93ZXJjYXNlX01hcHBpbmdzaW1wbGV0aXRsZWNhc2VtYXBwaW5nU2ltcGxlX1RpdGxlY2FzZV9NYXBwaW5nc2ltcGxldXBwZXJjYXNlbWFwcGluZ1NpbXBsZV9VcHBlcmNhc2VfTWFwcGluZ3NsY3NvZnRkb3R0ZWRzcGFjZVdoaXRlX1NwYWNlc3Rjc3Rlcm1zdWN0Y1RpdGxlY2FzZV9NYXBwaW5ndGVybVRlcm1pbmFsX1B1bmN0dWF0aW9udGVybWluYWxwdW5jdHVhdGlvbnRpdGxlY2FzZW1hcHBpbmd1Y1VwcGVyY2FzZV9NYXBwaW5ndWlkZW9VbmlmaWVkX0lkZW9ncmFwaHVuaWNvZGUxbmFtZXVuaWNvZGVyYWRpY2Fsc3Ryb2tldW5pZmllZGlkZW9ncmFwaHVwcGVyVXBwZXJjYXNldXBwZXJjYXNldXBwZXJjYXNlbWFwcGluZ3Vyc3ZhcmlhdGlvbnNlbGVjdG9yVmFyaWF0aW9uX1NlbGVjdG9ydmVydGljYWxvcmllbnRhdGlvblZlcnRpY2FsX09yaWVudGF0aW9udm92c3did2hpdGVzcGFj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aW9uRGFzaF9QdW5jdHVhdGlvbmRlY2ltYWxudW1iZXJEZWNpbWFsX051bWJlcmRpZ2l0ZW5jbG9zaW5nbWFya0VuY2xvc2luZ19NYXJrZmluYWxwdW5jdHVhdGlvbkZpbmFsX1B1bmN0dWF0aW9uZm9ybWF0aW5pdGlhbHB1bmN0dWF0aW9uSW5pdGlhbF9QdW5jdHVhdGlvbmxMZXR0ZXJsZXR0ZXJsZXR0ZXJudW1iZXJMZXR0ZXJfTnVtYmVybGluZXNlcGFyYXRvckxpbmVfU2VwYXJhdG9ybGxMb3dlcmNhc2VfTGV0dGVybG1Nb2RpZmllcl9MZXR0ZXJsb090aGVyX0xldHRlcmxvd2VyY2FzZWxldHRlcmx0VGl0bGVjYXNlX0xldHRlcmx1VXBwZXJjYXNlX0xldHRlcm1tYXJrbWF0aHN5bWJvbE1hdGhfU3ltYm9sbWNTcGFjaW5nX01hcmttZW1uTm9uc3BhY2luZ19NYXJrbW9kaWZpZXJsZXR0ZXJtb2RpZmllcnN5bWJvbE1vZGlmaWVyX1N5bWJvbG5OdW1iZXJuZG5sbm9PdGhlcl9OdW1iZXJub25zcGFjaW5nbWFya251bWJlcm9wZW5wdW5jdHVhdGlvbk9wZW5fUHVuY3R1YXRpb25vdGhlcm90aGVybGV0dGVyb3RoZXJudW1iZXJvdGhlcnB1bmN0dWF0aW9uT3RoZXJfUHVuY3R1YXRpb25vdGhlcnN5bWJvbE90aGVyX1N5bWJvbHBQdW5jdHVhdGlvbnBhcmFncmFwaHNlcGFyYXRvclBhcmFncmFwaF9TZXBhcmF0b3JwY3BkcGVwZnBpcG9wcml2YXRldXNlcHNwdW5jdHB1bmN0dWF0aW9uc1N5bWJvbHNlcGFyYXRvclNlcGFyYXRvcnNrc21zb3NwYWNlc2VwYXJhdG9yU3BhY2VfU2VwYXJhdG9yc3BhY2luZ21hcmtzdXJyb2dhdGVzeW1ib2x0aXRsZWNhc2VsZXR0ZXJ1cHBlcmNhc2VsZXR0ZXJ6emx6cHpzAACMERQAAQAAAI0RFAAFAAAAkhEUAAsAAACdERQADAAAAKkRFAACAAAAqxEUAAcAAAD+0hMAAgAAALIRFAAGAAAAuBEUABAAAADIERQAEQAAANkRFAACAAAAKw4UAAoAAADbERQABQAAAKsR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bl9BbGJhbmlhbmFob21BaG9tYW5hdG9saWFuaGllcm9nbHlwaHNBbmF0b2xpYW5fSGllcm9nbHlwaHNhcmFiQXJhYmljYXJhYmljYXJtZW5pYW5Bcm1lbmlhbmFybWlJbXBlcmlhbF9BcmFtYWljYXJtbmF2ZXN0YW5BdmVzdGFuYXZzdGJhbGlCYWxpbmVzZWJhbGluZXNlYmFtdUJhbXVtYmFtdW1iYXNzQmFzc2FfVmFoYmFzc2F2YWhiYXRha0JhdGFrYmF0a2JlbmdCZW5nYWxpYmVuZ2FsaWJoYWlrc3VraUJoYWlrc3VraWJoa3Nib3BvQm9wb21vZm9ib3BvbW9mb2JyYWhCcmFobWlicmFobWlicmFpQnJhaWxsZWJyYWlsbGVidWdpQnVnaW5lc2VidWdpbmVzZWJ1aGRCdWhpZGJ1aGlkY2FrbUNoYWttYWNhbmFkaWFuYWJvcmlnaW5hbENhbmFkaWFuX0Fib3JpZ2luYWxjYW5zY2FyaUNhcmlhbmNhcmlhbmNhdWNhc2lhbmFsYmFuaWFuY2hha21hY2hhbUNoYW1jaGVyQ2hlcm9rZWVjaGVyb2tlZWNob3Jhc21pYW5DaG9yYXNtaWFuY2hyc2NvbW1vbkNvbW1vbmNvcHRDb3B0aWNjb3B0aWNjcHJ0Q3lwcmlvdGN1bmVpZm9ybUN1bmVpZm9ybWN5cHJpb3RjeXJpbGxpY0N5cmlsbGljY3lybGRlc2VyZXREZXNlcmV0ZGV2YURldmFuYWdhcmlkZXZhbmFnYXJpZGlha0RpdmVzX0FrdXJ1ZGl2ZXNha3VydWRvZ3JEb2dyYWRvZ3JhZHNydGR1cGxEdXBsb3lhbmR1cGxveWFuZWd5cEVneXB0aWFuX0hpZXJvZ2x5cGhzZWd5cHRpYW5oaWVyb2dseXBoc2VsYmFFbGJhc2FuZWxiYXNhbmVseW1FbHltYWljZWx5bWFpY2V0aGlFdGhpb3BpY2V0aGlvcGljZ2Vvckdlb3JnaWFuZ2VvcmdpYW5nbGFnR2xhZ29saXRpY2dsYWdvbGl0aWNnb25nR3VuamFsYV9Hb25kaWdvbm1NYXNhcmFtX0dvbmRpZ290aEdvdGhpY2dvdGhpY2dyYW5HcmFudGhhZ3JhbnRoYWdyZWVrR3JlZWtncmVrZ3VqYXJhdGlHdWphcmF0aWd1anJndW5qYWxhZ29uZGlndXJtdWtoaUd1cm11a2hpZ3VydWhhbkhhbmhhbmdIYW5ndWxoYW5ndWxoYW5paGFuaWZpcm9oaW5neWFIYW5pZmlfUm9oaW5neWFoYW5vSGFudW5vb2hhbnVub29oYXRySGF0cmFuaGF0cmFuaGVickhlYnJld2hlYnJld2hpcmFIaXJhZ2FuYWhpcmFnYW5haGx1d2htbmdQYWhhd2hfSG1vbmdobW5wTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZ2hya3RLYXRha2FuYV9Pcl9IaXJhZ2FuYWh1bmdPbGRfSHVuZ2FyaWFuaW1wZXJpYWxhcmFtYWljaW5oZXJpdGVkSW5oZXJpdGVkaW5zY3JpcHRpb25hbHBhaGxhdmlJbnNjcmlwdGlvbmFsX1BhaGxhdmlpbnNjcmlwdGlvbmFscGFydGhpYW5JbnNjcmlwdGlvbmFsX1BhcnRoaWFuaXRhbE9sZF9JdGFsaWNqYXZhSmF2YW5lc2VqYXZhbmVzZWthaXRoaUthaXRoaWthbGlLYXlhaF9MaWthbmFLYXRha2FuYWthbm5hZGFLYW5uYWRha2F0YWthbmFrYXRha2FuYW9yaGlyYWdhbmFrYXlhaGxpa2hhcktoYXJvc2h0aGlraGFyb3NodGhpa2hpdGFuc21hbGxzY3JpcHRLaGl0YW5fU21hbGxfU2NyaXB0a2htZXJLaG1lcmtobXJraG9qS2hvamtpa2hvamtpa2h1ZGF3YWRpS2h1ZGF3YWRpa2l0c2tuZGFrdGhpbGFuYVRhaV9UaGFtbGFvTGFvbGFvb2xhdGluTGF0aW5sYXRubGVwY0xlcGNoYWxlcGNoYWxpbWJMaW1idWxpbWJ1bGluYUxpbmVhcl9BbGluYkxpbmVhcl9CbGluZWFyYWxpbmVhcmJsaXN1TGlzdWx5Y2lMeWNpYW5seWNpYW5seWRpTHlkaWFubHlkaWFubWFoYWphbmlNYWhhamFuaW1haGptYWthTWFrYXNhcm1ha2FzYXJtYWxheWFsYW1NYWxheWFsYW1tYW5kTWFuZGFpY21hbmRhaWNtYW5pTWFuaWNoYWVhbm1hbmljaGFlYW5tYXJjTWFyY2hlbm1hcmNoZW5tYXNhcmFtZ29uZGltZWRlZmFpZHJpbk1lZGVmYWlkcmlubWVkZm1lZXRlaW1heWVrTWVldGVpX01heWVrbWVuZE1lbmRlX0tpa2FrdWltZW5kZWtpa2FrdWltZXJjTWVyb2l0aWNfQ3Vyc2l2ZW1lcm9NZXJvaXRpY19IaWVyb2dseXBoc21lcm9pdGljY3Vyc2l2ZW1lcm9pdGljaGllcm9nbHlwaHNtaWFvTWlhb21seW1tb2RpTW9kaW1vbmdNb25nb2xpYW5tb25nb2xpYW5tcm9Ncm9tcm9vbXRlaW11bHRNdWx0YW5pbXVsdGFuaW15YW5tYXJNeWFubWFybXltcm5hYmF0YWVhbk5hYmF0YWVhbm5hbmROYW5kaW5hZ2FyaW5hbmRpbmFnYXJpbmFyYk9sZF9Ob3J0aF9BcmFiaWFubmJhdG5ld2FOZXdhbmV3dGFpbHVlTmV3X1RhaV9MdWVua29Oa29ua29vbnNodU51c2h1bnVzaHVueWlha2VuZ3B1YWNodWVobW9uZ29nYW1PZ2hhbW9naGFtb2xjaGlraU9sX0NoaWtpb2xja29sZGh1bmdhcmlhbm9sZGl0YWxpY29sZG5vcnRoYXJhYmlhbm9sZHBlcm1pY09sZF9QZXJtaWNvbGRwZXJzaWFuT2xkX1BlcnNpYW5vbGRzb2dkaWFuT2xkX1NvZ2RpYW5vbGRzb3V0aGFyYWJpYW5PbGRfU291dGhfQXJhYmlhbm9sZHR1cmtpY09sZF9UdXJraWNvcml5YU9yaXlhb3JraG9yeWFvc2FnZU9zYWdlb3NnZW9zbWFPc21hbnlhb3NtYW55YXBhaGF3aGhtb25ncGFsbVBhbG15cmVuZXBhbG15cmVuZXBhdWNQYXVfQ2luX0hhdXBhdWNpbmhhdXBlcm1waGFnUGhhZ3NfUGFwaGFnc3BhcGhsaXBobHBQc2FsdGVyX1BhaGxhdmlwaG54UGhvZW5pY2lhbnBob2VuaWNpYW5wbHJkcHJ0aXBzYWx0ZXJwYWhsYXZpcWFhY3FhYWlyZWphbmdSZWphbmdyam5ncm9oZ3J1bmljUnVuaWNydW5yc2FtYXJpdGFuU2FtYXJpdGFuc2FtcnNhcmJzYXVyU2F1cmFzaHRyYXNhdXJhc2h0cmFzZ253U2lnbldyaXRpbmdzaGFyYWRhU2hhcmFkYXNoYXZpYW5TaGF2aWFuc2hhd3NocmRzaWRkU2lkZGhhbXNpZGRoYW1zaWdud3JpdGluZ3NpbmRzaW5oU2luaGFsYXNpbmhhbGFzb2dkU29nZGlhbnNvZ2RpYW5zb2dvc29yYVNvcmFfU29tcGVuZ3NvcmFzb21wZW5nc295b1NveW9tYm9zb3lvbWJvc3VuZFN1bmRhbmVzZXN1bmRhbmVzZXN5bG9TeWxvdGlfTmFncmlzeWxvdGluYWdyaXN5cmNTeXJpYWNzeXJpYWN0YWdhbG9nVGFnYWxvZ3RhZ2JUYWdiYW53YXRhZ2JhbndhdGFpbGVUYWlfTGV0YWl0aGFtdGFpdmlldFRhaV9WaWV0dGFrclRha3JpdGFrcml0YWxldGFsdXRhbWlsVGFtaWx0YW1sdGFuZ1Rhbmd1dHRhbmd1dHRhdnR0ZWx1VGVsdWd1dGVsdWd1dGZuZ1RpZmluYWdodGdsZ3RoYWFUaGFhbmF0aGFhbmF0aGFpVGhhaXRpYmV0YW5UaWJldGFudGlidHRpZmluYWdodGlyaFRpcmh1dGF0aXJodXRhdWdhclVnYXJpdGljdWdhcml0aWN1bmtub3duVW5rbm93bnZhaVZhaXZhaWl3YW5jaG9XYW5jaG93YXJhV2FyYW5nX0NpdGl3YXJhbmdjaXRpd2Nob3hwZW94c3V4eWV6aVllemlkaXllemlkaXlpWWl5aWlpemFuYWJhemFyc3F1YXJlWmFuYWJhemFyX1NxdWFyZXphbmJ6aW5oenl5eXp6enrUHBQABQAAANkcFAAFAAAA3hwUAAQAAADZHBQABQAAAOIcFAAEAAAA5hwUABIAAAD4HBQABAAAAPwcFAAEAAAAAB0UABQAAAAUHRQAFQAAACkdFAAEAAAALR0UAAYAAAAzHRQABgAAAC0dFAAGAAAAOR0UAAgAAABBHRQACAAAAEkdFAAEAAAATR0UABAAAABdHRQABAAAAEEdFAAIAAAAYR0UAAcAAABoHRQABwAAAG8dFAAEAAAAaB0UAAcAAABzHRQABAAAAHcdFAAIAAAAfx0UAAgAAAB3HRQACAAAAIcdFAAEAAAAix0UAAUAAACQHRQABQAAAIsdFAAFAAAAlR0UAAQAAACZHRQACQAAAKIdFAAIAAAAmR0UAAkAAACqHRQABQAAAK8dFAAFAAAAtB0UAAQAAACvHRQABQAAALgdFAAEAAAAvB0UAAcAAADDHRQABwAAALwd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AADdHgAA3R4AAN8eAADfHgAA4R4AAOEeAADjHgAA4x4AAOUeAADlHgAA5x4AAOceAADpHgAA6R4AAOseAADrHgAA7R4AAO0eAADvHgAA7x4AAPEeAADxHgAA8x4AAPMeAAD1HgAA9R4AAPceAAD3HgAA+R4AAPkeAAD7HgAA+x4AAP0eAAD9HgAA/x4AAAcfAAAQHwAAFR8AACAfAAAnHwAAMB8AADcfAABAHwAARR8AAFAfAABXHwAAYB8AAGcfAABwHwAAfR8AAIAfAACHHwAAkB8AAJcfAACgHwAApx8AALAfAAC0HwAAth8AALcfAAC+HwAAvh8AAMIfAADEHwAAxh8AAMcfAADQHwAA0x8AANYfAADXHwAA4B8AAOcfAADyHwAA9B8AAPYfAAD3HwAACiEAAAohAAAOIQAADyEAABMhAAATIQAALyEAAC8hAAA0IQAANCEAADkhAAA5IQAAPCEAAD0hAABGIQAASSEAAE4hAABOIQAAhCEAAIQhAAAwLAAAXiwAAGEsAABhLAAAZSwAAGYsAABoLAAAaCwAAGosAABqLAAAbCwAAGwsAABxLAAAcSwAAHMsAAB0LAAAdiwAAHssAACBLAAAgSwAAIMsAACDLAAAhSwAAIUsAACHLAAAhywAAIksAACJLAAAiywAAIssAACNLAAAjSwAAI8sAACPLAAAkSwAAJEsAACTLAAAkywAAJUsAACVLAAAlywAAJcsAACZLAAAmSwAAJssAACbLAAAnSwAAJ0sAACfLAAAnywAAKEsAAChLAAAoywAAKMsAAClLAAApSwAAKcsAACnLAAAqSwAAKksAACrLAAAqywAAK0sAACtLAAArywAAK8sAACxLAAAsSwAALMsAACzLAAAtSwAALUsAAC3LAAAtywAALksAAC5LAAAuywAALssAAC9LAAAvSwAAL8sAAC/LAAAwSwAAMEsAADDLAAAwywAAMUsAADFLAAAxywAAMcsAADJLAAAySwAAMssAADLLAAAzSwAAM0sAADPLAAAzywAANEsAADRLAAA0ywAANMsAADVLAAA1SwAANcsAADXLAAA2SwAANksAADbLAAA2ywAAN0sAADdLAAA3ywAAN8sAADhLAAA4SwAAOMsAADkLAAA7CwAAOwsAADuLAAA7iwAAPMsAADzLAAAAC0AACUtAAAnLQAAJy0AAC0tAAAtLQAAQaYAAEGmAABDpgAAQ6YAAEWmAABFpgAAR6YAAEemAABJpgAASaYAAEumAABLpgAATaYAAE2mAABPpgAAT6YAAFGmAABRpgAAU6YAAFOmAABVpgAAVaYAAFemAABXpgAAWaYAAFmmAABbpgAAW6YAAF2mAABdpgAAX6YAAF+mAABhpgAAYaYAAGOmAABjpgAAZaYAAGWmAABnpgAAZ6YAAGmmAABppgAAa6YAAGumAABtpgAAbaYAAIGmAACBpgAAg6YAAIOmAACFpgAAhaYAAIemAACHpgAAiaYAAImmAACLpgAAi6YAAI2mAACNpgAAj6YAAI+mAACRpgAAkaYAAJOmAACTpgAAlaYAAJWmAACXpgAAl6YAAJmmAACZpgAAm6YAAJumAAAjpwAAI6cAACWnAAAlpwAAJ6cAACenAAAppwAAKacAACunAAArpwAALacAAC2nAAAvpwAAMacAADOnAAAzpwAANacAADWnAAA3pwAAN6cAADmnAAA5pwAAO6cAADunAAA9pwAAPacAAD+nAAA/pwAAQacAAEGnAABDpwAAQ6cAAEWnAABFpwAAR6cAAEenAABJpwAASacAAEunAABLpwAATacAAE2nAABPpwAAT6cAAFGnAABRpwAAU6cAAFOnAABVpwAAVacAAFenAABXpwAAWacAAFmnAABbpwAAW6cAAF2nAABdpwAAX6cAAF+nAABhpwAAYacAAGOnAABjpwAAZacAAGWnAABnpwAAZ6cAAGmnAABppwAAa6cAAGunAABtpwAAbacAAG+nAABvpwAAcacAAHinAAB6pwAAeqcAAHynAAB8pwAAf6cAAH+nAACBpwAAgacAAIOnAACDpwAAhacAAIWnAACHpwAAh6cAAIynAACMpwAAjqcAAI6nAACRpwAAkacAAJOnAACVpwAAl6cAAJenAACZpwAAmacAAJunAACbpwAAnacAAJ2nAACfpwAAn6cAAKGnAAChpwAAo6cAAKOnAAClpwAApacAAKenAACnpwAAqacAAKmnAACvpwAAr6cAALWnAAC1pwAAt6cAALenAAC5pwAAuacAALunAAC7pwAAvacAAL2nAAC/pwAAv6cAAMOnAADDpwAAyKcAAMinAADKpwAAyqcAAPanAAD2pwAA+qcAAPqnAAAwqwAAWqsAAGCrAABoqwAAcKsAAL+r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AACuHgAArh4AALAeAACwHgAAsh4AALIeAAC0HgAAtB4AALYeAAC2HgAAuB4AALgeAAC6HgAAuh4AALweAAC8HgAAvh4AAL4eAADAHgAAwB4AAMIeAADCHgAAxB4AAMQeAADGHgAAxh4AAMgeAADIHgAAyh4AAMoeAADMHgAAzB4AAM4eAADOHgAA0B4AANAeAADSHgAA0h4AANQeAADUHgAA1h4AANYeAADYHgAA2B4AANoeAADaHgAA3B4AANweAADeHgAA3h4AAOAeAADgHgAA4h4AAOIeAADkHgAA5B4AAOYeAADmHgAA6B4AAOgeAADqHgAA6h4AAOweAADsHgAA7h4AAO4eAADwHgAA8B4AAPIeAADyHgAA9B4AAPQeAAD2HgAA9h4AAPgeAAD4HgAA+h4AAPoeAAD8HgAA/B4AAP4eAAD+HgAACB8AAA8fAAAYHwAAHR8AACgfAAAvHwAAOB8AAD8fAABIHwAATR8AAFkfAABZHwAAWx8AAFsfAABdHwAAXR8AAF8fAABfHwAAaB8AAG8fAAC4HwAAux8AAMgfAADLHwAA2B8AANsfAADoHwAA7B8AAPgfAAD7HwAAAiEAAAIhAAAHIQAAByEAAAshAAANIQAAECEAABIhAAAVIQAAFSEAABkhAAAdIQAAJCEAACQhAAAmIQAAJiEAACghAAAoIQAAKiEAAC0hAAAwIQAAMyEAAD4hAAA/IQAARSEAAEUhAACDIQAAgyEAAAAsAAAuLAAAYCwAAGAsAABiLAAAZCwAAGcsAABnLAAAaSwAAGksAABrLAAAaywAAG0sAABwLAAAciwAAHIsAAB1LAAAdSwAAH4sAACALAAAgiwAAIIsAACELAAAhCwAAIYsAACGLAAAiCwAAIgsAACKLAAAiiwAAIwsAACMLAAAjiwAAI4sAACQLAAAkCwAAJIsAACSLAAAlCwAAJQsAACWLAAAliwAAJgsAACYLAAAmiwAAJosAACcLAAAnCwAAJ4sAACeLAAAoCwAAKAsAACiLAAAoiwAAKQsAACkLAAApiwAAKYsAACoLAAAqCwAAKosAACqLAAArCwAAKwsAACuLAAAriwAALAsAACwLAAAsiwAALIsAAC0LAAAtCwAALYsAAC2LAAAuCwAALgsAAC6LAAAuiwAALwsAAC8LAAAviwAAL4sAADALAAAwCwAAMIsAADCLAAAxCwAAMQsAADGLAAAxiwAAMgsAADILAAAyiwAAMosAADMLAAAzCwAAM4sAADOLAAA0CwAANAsAADSLAAA0iwAANQsAADULAAA1iwAANYsAADYLAAA2CwAANosAADaLAAA3CwAANwsAADeLAAA3iwAAOAsAADgLAAA4iwAAOIsAADrLAAA6ywAAO0sAADtLAAA8iwAAPIsAABApgAAQKYAAEKmAABCpgAARKYAAESmAABGpgAARqYAAEimAABIpgAASqYAAEqmAABMpgAATKYAAE6mAABOpgAAUKYAAFCmAABSpgAAUqYAAFSmAABUpgAAVqYAAFamAABYpgAAWKYAAFqmAABapgAAXKYAAFymAABepgAAXqYAAGCmAABgpgAAYqYAAGKmAABkpgAAZKYAAGamAABmpgAAaKYAAGimAABqpgAAaqYAAGymAABspgAAgKYAAICmAACCpgAAgqYAAISmAACEpgAAhqYAAIamAACIpgAAiKYAAIqmAACKpgAAjKYAAIymAACOpgAAjqYAAJCmAACQpgAAkqYAAJKmAACUpgAAlKYAAJamAACWpgAAmKYAAJimAACapgAAmqYAACKnAAAipwAAJKcAACSnAAAmpwAAJqcAACinAAAopwAAKqcAACqnAAAspwAALKcAAC6nAAAupwAAMqcAADKnAAA0pwAANKcAADanAAA2pwAAOKcAADinAAA6pwAAOqcAADynAAA8pwAAPqcAAD6nAABApwAAQKcAAEKnAABCpwAARKcAAESnAABGpwAARqcAAEinAABIpwAASqcAAEqnAABMpwAATKcAAE6nAABOpwAAUKcAAFCnAABSpwAAUqcAAFSnAABUpwAAVqcAAFanAABYpwAAWKcAAFqnAABapwAAXKcAAFynAABepwAAXqcAAGCnAABgpwAAYqcAAGKnAABkpwAAZKcAAGanAABmpwAAaKcAAGinAABqpwAAaqcAAGynAABspwAAbqcAAG6nAAB5pwAAeacAAHunAAB7pwAAfacAAH6nAACApwAAgKcAAIKnAACCpwAAhKcAAISnAACGpwAAhqcAAIunAACLpwAAjacAAI2nAACQpwAAkKcAAJKnAACSpwAAlqcAAJanAACYpwAAmKcAAJqnAACapwAAnKcAAJynAACepwAAnqcAAKCnAACgpwAAoqcAAKKn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AADyHAAA8hwAAPocAAD6HAAAMKgAADWoAACgGQEApxkBAKoZAQDXGQEA2hkBAOQZAQCDBAAAgwQAAFADAQB6AwEAUQkAAFIJAABkCQAAZQkAAAELAAADCwAABQsAAAwLAAAPCwAAEAsAABMLAAAoCwAAKgsAADALAAAyCwAAMwsAADULAAA5CwAAPAsAAEQLAABHCwAASAsAAEsLAABNCwAAVQsAAFcLAABcCwAAXQsAAF8LAABjCwAAZgsAAHcLAADaHAAA2hwAAPIcAADyHAAAAhgAAAMYAAAFGAAABRgAAECoAAB3qAAAQAYAAEAGAACACwEAkQsBAJkLAQCcCwEAqQsBAK8LAQBRCQAAUQkAANccAADXHAAA2RwAANkcAADcHAAA3RwAAOAcAADgHAAAgBEBAN8RAQBkCQAAZQkAAIENAACDDQAAhQ0AAJYNAACaDQAAsQ0AALMNAAC7DQAAvQ0AAL0NAADADQAAxg0AAMoNAADKDQAAzw0AANQNAADWDQAA1g0AANgNAADfDQAA5g0AAO8NAADyDQAA9A0AAOERAQD0EQEAQAYAAEAGAAAwDwEAWQ8BAGQJAABlCQAA5gkAAO8JAAAAqAAALKgAAAwGAAAMBgAAGwYAABwGAAAfBgAAHwYAAEAGAABABgAASwYAAFUGAABwBgAAcAYAAAAHAAANBwAADwcAAEoHAABNBwAATwcAAGAIAABqCAAA+B0AAPgdAAAAFwAADBcAAA4XAAAUFwAANRcAADYXAAA1FwAANhcAAGAXAABsFwAAbhcAAHAXAAByFwAAcxcAAEAQAABJEAAAUBkAAG0ZAABwGQAAdBkAAGQJAABlCQAAMKgAADmoAACAFgEAuBYBAMAWAQDJFgEAUQkAAFIJAABkCQAAZQkAAIILAACDCwAAhQsAAIoLAACOCwAAkAsAAJILAACVCwAAmQsAAJoLAACcCwAAnAsAAJ4LAACfCwAAowsAAKQLAACoCwAAqgsAAK4LAAC5CwAAvgsAAMILAADGCwAAyAsAAMoLAADNCwAA0AsAANALAADXCwAA1wsAAOYLAAD6CwAA2hwAANocAADzqAAA86gAAAETAQABEwEAAxMBAAMTAQA7EwEAPBMBAMAfAQDxHwEA/x8BAP8fAQBRCQAAUgkAAGQJAABlCQAAAAwAAAwMAAAODAAAEAwAABIM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AAAuHgAAMB4AADAeAAAyHgAAMh4AADQeAAA0HgAANh4AADYeAAA4HgAAOB4AADoeAAA6HgAAPB4AADweAAA+HgAAPh4AAEAeAABAHgAAQh4AAEIeAABEHgAARB4AAEYeAABGHgAASB4AAEgeAABKHgAASh4AAEweAABMHgAATh4AAE4eAABQHgAAUB4AAFIeAABSHgAAVB4AAFQeAABWHgAAVh4AAFgeAABYHgAAWh4AAFoeAABcHgAAXB4AAF4eAABeHgAAYB4AAGAeAABiHgAAYh4AAGQeAABkHgAAZh4AAGYeAABoHgAAaB4AAGoeAABqHgAAbB4AAGweAABuHgAAbh4AAHAeAABwHgAAch4AAHIeAAB0HgAAdB4AAHYeAAB2HgAAeB4AAHgeAAB6HgAAeh4AAHweAAB8HgAAfh4AAH4eAACAHgAAgB4AAIIeAACCHgAAhB4AAIQeAACGHgAAhh4AAIgeAACIHgAAih4AAIoeAACMHgAAjB4AAI4eAACOHgAAkB4AAJAeAACSHgAAkh4AAJQeAACUHgAAmh4AAJseAACeHgAAnh4AAKAeAACgHgAAoh4AAKIeAACkHgAApB4AAKYeAACmHgAAqB4AAKgeAACqHgAAqh4AAKweAACsHgAArh4AAK4eAACwHgAAsB4AALIeAACyHgAAtB4AALQeAAC2HgAAth4AALgeAAC4HgAAuh4AALoeAAC8HgAAvB4AAL4eAAC+HgAAwB4AAMAeAADCHgAAwh4AAMQeAADEHgAAxh4AAMYeAADIHgAAyB4AAMoeAADKHgAAzB4AAMweAADOHgAAzh4AANAeAADQHgAA0h4AANIeAADUHgAA1B4AANYeAADWHgAA2B4AANgeAADaHgAA2h4AANweAADcHgAA3h4AAN4eAADgHgAA4B4AAOIeAADiHgAA5B4AAOQeAADmHgAA5h4AAOgeAADoHgAA6h4AAOoeAADsHgAA7B4AAO4eAADuHgAA8B4AAPAeAADyHgAA8h4AAPQeAAD0HgAA9h4AAPYeAAD4HgAA+B4AAPoeAAD6HgAA/B4AAPweAAD+HgAA/h4AAAgfAAAPHwAAGB8AAB0fAAAoHwAALx8AADgfAAA/HwAASB8AAE0fAABZHwAAWR8AAFsfAABbHwAAXR8AAF0fAABfHwAAXx8AAGgfAABvHwAAgB8AAK8fAACyHwAAtB8AALcfAAC8HwAAwh8AAMQfAADHHwAAzB8AANgfAADbHwAA6B8AAOwfAADyHwAA9B8AAPcfAAD8HwAAJiEAACYhAAAqIQAAKyEAADIhAAAyIQAAYCEAAG8hAACDIQAAgyEAALYkAADPJAAAACwAAC4sAABgLAAAYCwAAGIsAABkLAAAZywAAGcsAABpLAAAaSwAAGssAABrLAAAbSwAAHAsAAByLAAAciwAAHUsAAB1LAAAfiwAAIAsAACCLAAAgiwAAIQsAACELAAAhiwAAIYsAACILAAAiCwAAIosAACKLAAAjCwAAIwsAACOLAAAjiwAAJAsAACQLAAAkiwAAJIsAACULAAAlCwAAJYsAACWLAAAmCwAAJgsAACaLAAAmiwAAJwsAACcLAAAniwAAJ4sAACgLAAAoCwAAKIsAACiLAAApCwAAKQsAACmLAAApiwAAKgsAACoLAAAqiwAAKosAACsLAAArCwAAK4sAACuLAAAsCwAALAsAACyLAAAsiwAALQsAAC0LAAAtiwAALYsAAC4LAAAuCwAALosAAC6LAAAvCwAALwsAAC+LAAAviwAAMAsAADALAAAwiwAAMIsAADELAAAxCwAAMYsAADGLAAAyCwAAMgsAADKLAAAyiwAAMwsAADMLAAAziwAAM4sAADQLAAA0CwAANIsAADSLAAA1CwAANQsAADWLAAA1iwAANgsAADYLAAA2iwAANosAADcLAAA3CwAAN4sAADeLAAA4CwAAOAsAADiLAAA4iwAAOssAADrLAAA7SwAAO0sAADyLAAA8iwAAECmAABApgAAQqYAAEKmAABEpgAARKYAAEamAABGpgAASKYAAEimAABKpgAASqYAAEymAABMpgAATqYAAE6mAABQpgAAUKYAAFKmAABSpgAAVKYAAFSmAABWpgAAVqYAAFimAABYpgAAWqYAAFqmAABcpgAAXKYAAF6mAABepgAAYKYAAGCmAABipgAAYqYAAGSmAABkpgAAZqYAAGamAABopgAAaKYAAGqmAABqpgAAbKYAAGymAACApgAAgKYAAIKmAACCpgAAhKYAAISmAACGpgAAhqYAAIimAACIpgAAiqYAAIqmAACMpgAAjKYAAI6mAACOpgAAkKYAAJCmAACSpgAAkqYAAJSmAACUpgAAlqYAAJamAACYpgAAmKYAAJqmAACapgAAIqcAACKnAAAkpwAAJKcAACanAAAmpwAAKKcAACinAAAqpwAAKqcAACynAAAspwAALqcAAC6nAAAypwAAMqcAADSnAAA0pwAANqcAADanAAA4pwAAOKcAADqnAAA6pwAAPKcAADynAAA+pwAAPqcAAECnAABApwAAQqcAAEKnAABEpwAARKcAAEanAABGpwAASKcAAEinAABKpwAASqcAAEynAABMpwAATqcAAE6nAABQpwAAUKcAAFKnAABSpwAAVKcAAFSnAABWpwAAVqcAAFinAABYpwAAWqcAAFqnAABcpwAAXKcAAF6nAABepwAAYKcAAGCnAABipwAAYqcAAGSnAABkpwAAZqcAAGanAABopwAAaKcAAGqnAABqpwAAbKcAAGynAABupwAAbqcAAHmnAAB5pwAAe6cAAHunAAB9pwAAfqcAAICnAACApwAAgqcAAIKnAACEpwAAhKcAAIanAACGpwAAi6cAAIunAACNpwAAjacAAJCnAACQpwAAkqcAAJKnAACWpwAAlqcAAJinAACYpwAAmqcAAJqnAACcpwAAnKcAAJ6nAACepwAAoKcAAKCnAACipwAAoqcAAKSnAACkpwAApqcAAKanAACopwAAqKcAAKqnAACupwAAsKcAALSnAAC2pwAAtqcAALinAAC4pwAAuqcAALqnAAC8pwAAvKcAAL6nAAC+pwAAwqcAAMKnAADEpwAAx6cAAMmnAADJpwAA9acAAPWnAABwqwAAv6sAAAD7AAAG+wAAE/sAABf7AAAh/wAAOv8AAAAEAQAnBAEAsAQBANMEAQCADAEAsgwBAKAYAQC/GAEAQG4BAF9uAQAA6QEAIekBAEEAAABaAAAAYQAAAHoAAAC1AAAAtQAAAMAAAADWAAAA2AAAAPYAAAD4AAAANwEAADkBAACMAQAAjgEAAJoBAACcAQAAqQEAAKwBAAC5AQAAvAEAAL0BAAC/AQAAvwEAAMQBAAAgAgAAIgIAADMCAAA6AgAAVAIAAFYCAABXAgAAWQIAAFkCAABbAgAAXAIAAGACAABhAgAAYwIAAGMCAABlAgAAZgIAAGgCAABsAgAAbwIAAG8CAABxAgAAcgIAAHUCAAB1AgAAfQIAAH0CAACAAgAAgAIAAIICAACDAgAAhwIAAIwCAACSAgAAkgIAAJ0CAACeAgAARQMAAEUD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AACqHgAAqh4AAKweAACsHgAArh4AAK4eAACwHgAAsB4AALIeAACyHgAAtB4AALQeAAC2HgAAth4AALgeAAC4HgAAuh4AALoeAAC8HgAAvB4AAL4eAAC+HgAAwB4AAMAeAADCHgAAwh4AAMQeAADEHgAAxh4AAMYeAADIHgAAyB4AAMoeAADKHgAAzB4AAMweAADOHgAAzh4AANAeAADQHgAA0h4AANIeAADUHgAA1B4AANYeAADWHgAA2B4AANgeAADaHgAA2h4AANweAADcHgAA3h4AAN4eAADgHgAA4B4AAOIeAADiHgAA5B4AAOQeAADmHgAA5h4AAOgeAADoHgAA6h4AAOoeAADsHgAA7B4AAO4eAADuHgAA8B4AAPAeAADyHgAA8h4AAPQeAAD0HgAA9h4AAPYeAAD4HgAA+B4AAPoeAAD6HgAA/B4AAPweAAD+HgAA/h4AAAgfAAAPHwAAGB8AAB0fAAAoHwAALx8AADgfAAA/HwAASB8AAE0fAABZHwAAWR8AAFsfAABbHwAAXR8AAF0fAABfHwAAXx8AAGgfAABvHwAAiB8AAI8fAACYHwAAnx8AAKgfAACvHwAAuB8AALwfAADIHwAAzB8AANgfAADbHwAA6B8AAOwfAAD4HwAA/B8AACYhAAAmIQAAKiEAACshAAAyIQAAMiEAAGAhAABvIQAAgyEAAIMhAAC2JAAAzyQAAAAsAAAuLAAAYCwAAGAsAABiLAAAZCwAAGcsAABnLAAAaSwAAGksAABrLAAAaywAAG0sAABwLAAAciwAAHIsAAB1LAAAdSwAAH4sAACALAAAgiwAAIIsAACELAAAhCwAAIYsAACGLAAAiCwAAIgsAACKLAAAiiwAAIwsAACMLAAAjiwAAI4sAACQLAAAkCwAAJIsAACSLAAAlCwAAJQsAACWLAAAliwAAJgsAACYLAAAmiwAAJosAACcLAAAnCwAAJ4sAACeLAAAoCwAAKAsAACiLAAAoiwAAKQsAACkLAAApiwAAKYsAACoLAAAqCwAAKosAACqLAAArCwAAKwsAACuLAAAriwAALAsAACwLAAAsiwAALIsAAC0LAAAtCwAALYsAAC2LAAAuCwAALgsAAC6LAAAuiwAALwsAAC8LAAAviwAAL4sAADALAAAwCwAAMIsAADCLAAAxCwAAMQsAADGLAAAxiwAAMgsAADILAAAyiwAAMosAADMLAAAzCwAAM4sAADOLAAA0CwAANAsAADSLAAA0iwAANQsAADULAAA1iwAANYsAADYLAAA2CwAANosAADaLAAA3CwAANwsAADeLAAA3iwAAOAsAADgLAAA4iwAAOIsAADrLAAA6ywAAO0sAADtLAAA8iwAAPIsAABApgAAQKYAAEKmAABCpgAARKYAAESmAABGpgAARqYAAEimAABIpgAASqYAAEqmAABMpgAATKYAAE6mAABOpgAAUKYAAFCmAABSpgAAUqYAAFSmAABUpgAAVqYAAFamAABYpgAAWKYAAFqmAABapgAAXKYAAFymAABepgAAXqYAAGCmAABgpgAAYqYAAGKmAABkpgAAZKYAAGamAABmpgAAaKYAAGimAABqpgAAaqYAAGymAABspgAAgKYAAICmAACCpgAAgqYAAISmAACEpgAAhqYAAIamAACIpgAAiKYAAIqmAACKpgAAjKYAAIymAACOpgAAjqYAAJCmAACQpgAAkqYAAJKmAACUpgAAlKYAAJamAACWpgAAmKYAAJimAACapgAAmqYAACKnAAAipwAAJKcAACSnAAAmpwAAJqcAACinAAAopwAAKqcAACqnAAAspwAALKcAAC6nAAAupwAAMqcAADKnAAA0pwAANKcAADanAAA2pwAAOKcAADinAAA6pwAAOqcAADynAAA8pwAAPqcAAD6nAABApwAAQKcAAEKnAABCpwAARKcAAESnAABGpwAARqcAAEinAABIpwAASqcAAEqnAABMpwAATKcAAE6nAABOpwAAUKcAAFCnAABSpwAAUqcAAFSnAABUpwAAVqcAAFanAABYpwAAWKcAAFqnAABapwAAXKcAAFynAABepwAAXqcAAGCnAABgpwAAYqcAAGKnAABkpwAAZKcAAGanAABmpwAAaKcAAGinAABqpwAAaqcAAGynAABspwAAbqcAAG6nAAB5pwAAeacAAHunAAB7pwAAfacAAH6nAACApwAAgKcAAIKnAACCpwAAhKcAAISnAACGpwAAhqcAAIunAACLpwAAjacAAI2nAACQpwAAkKcAAJKnAACSpwAAlqcAAJanAACYpwAAmKcAAJqnAACapwAAnKcAAJynAACepwAAnqcAAKCnAACgpwAAoqcAAKKnAACkpwAApKcAAKanAACmpwAAqKcAAKin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AAA5HgAAOx4AADseAAA9HgAAPR4AAD8eAAA/HgAAQR4AAEEeAABDHgAAQx4AAEUeAABFHgAARx4AAEceAABJHgAASR4AAEseAABLHgAATR4AAE0eAABPHgAATx4AAFEeAABRHgAAUx4AAFMeAABVHgAAVR4AAFceAABXHgAAWR4AAFkeAABbHgAAWx4AAF0eAABdHgAAXx4AAF8eAABhHgAAYR4AAGMeAABjHgAAZR4AAGUeAABnHgAAZx4AAGkeAABpHgAAax4AAGseAABtHgAAbR4AAG8eAABvHgAAcR4AAHEeAABzHgAAcx4AAHUeAAB1HgAAdx4AAHceAAB5HgAAeR4AAHseAAB7HgAAfR4AAH0eAAB/HgAAfx4AAIEeAACBHgAAgx4AAIMeAACFHgAAhR4AAIceAACHHgAAiR4AAIkeAACLHgAAix4AAI0eAACNHgAAjx4AAI8eAACRHgAAkR4AAJMeAACTHgAAlR4AAJseAAChHgAAoR4AAKMeAACjHgAApR4AAKUeAACnHgAApx4AAKkeAACpHgAAqx4AAKseAACtHgAArR4AAK8eAACvHgAAsR4AALEeAACzHgAAsx4AALUeAAC1HgAAtx4AALceAAC5HgAAuR4AALseAAC7HgAAvR4AAL0eAAC/HgAAvx4AAMEeAADBHgAAwx4AAMMeAADFHgAAxR4AAMceAADHHgAAyR4AAMkeAADLHgAAyx4AAM0eAADNHgAAzx4AAM8eAADRHgAA0R4AANMeAADTHgAA1R4AANUeAADXHgAA1x4AANkeAADZHgAA2x4AANseAADdHgAA3R4AAN8eAADfHgAA4R4AAOEeAADjHgAA4x4AAOUeAADlHgAA5x4AAOceAADpHgAA6R4AAOseAADrHgAA7R4AAO0eAADvHgAA7x4AAPEeAADxHgAA8x4AAPMeAAD1HgAA9R4AAPceAAD3HgAA+R4AAPkeAAD7HgAA+x4AAP0eAAD9HgAA/x4AAAcfAAAQHwAAFR8AACAfAAAnHwAAMB8AADcfAABAHwAARR8AAFAfAABXHwAAYB8AAGcfAABwHwAAfR8AAIAfAACHHwAAkB8AAJcfAACgHwAApx8AALAfAAC0HwAAth8AALcfAAC+HwAAvh8AAMIfAADEHwAAxh8AAMcfAADQHwAA0x8AANYfAADXHwAA4B8AAOcfAADyHwAA9B8AAPYfAAD3HwAATiEAAE4hAABwIQAAfyEAAIQhAACEIQAA0CQAAOkkAAAwLAAAXiwAAGEsAABhLAAAZSwAAGYsAABoLAAAaCwAAGosAABqLAAAbCwAAGwsAABzLAAAcywAAHYsAAB2LAAAgSwAAIEsAACDLAAAgywAAIUsAACFLAAAhywAAIcsAACJLAAAiSwAAIssAACLLAAAjSwAAI0sAACPLAAAjywAAJEsAACRLAAAkywAAJMsAACVLAAAlSwAAJcsAACXLAAAmSwAAJksAACbLAAAmywAAJ0sAACdLAAAnywAAJ8sAAChLAAAoSwAAKMsAACjLAAApSwAAKUsAACnLAAApywAAKksAACpLAAAqywAAKssAACtLAAArSwAAK8sAACvLAAAsSwAALEsAACzLAAAsywAALUsAAC1LAAAtywAALcsAAC5LAAAuSwAALssAAC7LAAAvSwAAL0sAAC/LAAAvywAAMEsAADBLAAAwywAAMMsAADFLAAAxSwAAMcsAADHLAAAySwAAMksAADLLAAAyywAAM0sAADNLAAAzywAAM8sAADRLAAA0SwAANMsAADTLAAA1SwAANUsAADXLAAA1ywAANksAADZLAAA2ywAANssAADdLAAA3SwAAN8sAADfLAAA4SwAAOEsAADjLAAA4ywAAOwsAADsLAAA7iwAAO4sAADzLAAA8ywAAAAtAAAlLQAAJy0AACctAAAtLQAALS0AAEGmAABBpgAAQ6YAAEOmAABFpgAARaYAAEemAABHpgAASaYAAEmmAABLpgAAS6YAAE2mAABNpgAAT6YAAE+mAABRpgAAUaYAAFOmAABTpgAAVaYAAFWmAABXpgAAV6YAAFmmAABZpgAAW6YAAFumAABdpgAAXaYAAF+mAABfpgAAYaYAAGGmAABjpgAAY6YAAGWmAABlpgAAZ6YAAGemAABppgAAaaYAAGumAABrpgAAbaYAAG2mAACBpgAAgaYAAIOmAACDpgAAhaYAAIWmAACHpgAAh6YAAImmAACJpgAAi6YAAIumAACNpgAAjaYAAI+mAACPpgAAkaYAAJGmAACTpgAAk6YAAJWmAACVpgAAl6YAAJemAACZpgAAmaYAAJumAACbpgAAI6cAACOnAAAlpwAAJacAACenAAAnpwAAKacAACmnAAArpwAAK6cAAC2n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AACzHgAAtR4AALUeAAC3HgAAtx4AALkeAAC5HgAAux4AALseAAC9HgAAvR4AAL8eAAC/HgAAwR4AAMEeAADDHgAAwx4AAMUeAADFHgAAxx4AAMceAADJHgAAyR4AAMseAADLHgAAzR4AAM0eAADPHgAAzx4AANEeAADRHgAA0x4AANMeAADVHgAA1R4AANceAADXHgAA2R4AANkeAADbHgAA2x4AAN0eAADdHgAA3x4AAN8eAADhHgAA4R4AAOMeAADjHgAA5R4AAOUeAADnHgAA5x4AAOkeAADpHgAA6x4AAOseAADtHgAA7R4AAO8eAADvHgAA8R4AAPEeAADzHgAA8x4AAPUeAAD1HgAA9x4AAPceAAD5HgAA+R4AAPseAAD7HgAA/R4AAP0eAAD/HgAABx8AABAfAAAVHwAAIB8AACcfAAAwHwAANx8AAEAfAABFHwAAUB8AAFcfAABgHwAAZx8AAHAfAAB9HwAAgB8AALQfAAC2HwAAtx8AALwfAAC8HwAAvh8AAL4fAADCHwAAxB8AAMYfAADHHwAAzB8AAMwfAADQHwAA0x8AANYfAADXHwAA4B8AAOcfAADyHwAA9B8AAPYfAAD3HwAA/B8AAPwfAABOIQAATiEAAHAhAAB/IQAAhCEAAIQhAADQJAAA6SQAADAsAABeLAAAYSwAAGEsAABlLAAAZiwAAGgsAABoLAAAaiwAAGosAABsLAAAbCwAAHMsAABzLAAAdiwAAHYsAACBLAAAgSwAAIMsAACDLAAAhSwAAIUsAACHLAAAhywAAIksAACJLAAAiywAAIssAACNLAAAjSwAAI8sAACPLAAAkSwAAJEsAACTLAAAkywAAJUsAACVLAAAlywAAJcsAACZLAAAmSwAAJssAACbLAAAnSwAAJ0sAACfLAAAnywAAKEsAAChLAAAoywAAKMsAAClLAAApSwAAKcsAACnLAAAqSwAAKksAACrLAAAqywAAK0sAACtLAAArywAAK8sAACxLAAAsSwAALMsAACzLAAAtSwAALUsAAC3LAAAtywAALksAAC5LAAAuywAALssAAC9LAAAvSwAAL8sAAC/LAAAwSwAAMEsAADDLAAAwywAAMUsAADFLAAAxywAAMcsAADJLAAAySwAAMssAADLLAAAzSwAAM0sAADPLAAAzywAANEsAADRLAAA0ywAANMsAADVLAAA1SwAANcsAADXLAAA2SwAANksAADbLAAA2ywAAN0sAADdLAAA3ywAAN8sAADhLAAA4SwAAOMsAADjLAAA7CwAAOwsAADuLAAA7iwAAPMsAADzLAAAAC0AACUtAAAnLQAAJy0AAC0tAAAtLQAAQaYAAEGmAABDpgAAQ6YAAEWmAABFpgAAR6YAAEemAABJpgAASaYAAEumAABLpgAATaYAAE2mAABPpgAAT6YAAFGmAABRpgAAU6YAAFOmAABVpgAAVaYAAFemAABXpgAAWaYAAFmmAABbpgAAW6YAAF2mAABdpgAAX6YAAF+mAABhpgAAYaYAAGOmAABjpgAAZaYAAGWmAABnpgAAZ6YAAGmmAABppgAAa6YAAGumAABtpgAAbaYAAIGmAACBpgAAg6YAAIOmAACFpgAAhaYAAIemAACHpgAAiaYAAImmAACLpgAAi6YAAI2mAACNpgAAj6YAAI+mAACRpgAAkaYAAJOmAACTpgAAlaYAAJWmAACXpgAAl6YAAJmmAACZpgAAm6YAAJumAAAjpwAAI6cAACWnAAAlpwAAJ6cAACenAAAppwAAKacAACunAAArpwAALacAAC2nAAAvpwAAL6cAADOnAAAzpwAANacAADWnAAA3pwAAN6cAADmnAAA5pwAAO6cAADunAAA9pwAAPacAAD+nAAA/pwAAQacAAEGnAABDpwAAQ6cAAEWnAABFpwAAR6cAAEenAABJpwAASacAAEunAABLpwAATacAAE2nAABPpwAAT6cAAFGnAABRpwAAU6cAAFOnAABVpwAAVacAAFenAABXpwAAWacAAFmnAABbpwAAW6cAAF2nAABdpwAAX6cAAF+nAABhpwAAYacAAGOnAABjpwAAZacAAGWnAABnpwAAZ6cAAGmnAABppwAAa6cAAGunAABtpwAAbacAAG+nAABvpwAAeqcAAHqnAAB8pwAAfKcAAH+nAAB/pwAAgacAAIGnAACDpwAAg6cAAIWnAACFpwAAh6cAAIenAACMpwAAjKcAAJGnAACRpwAAk6cAAJSnAACXpwAAl6cAAJmnAACZpwAAm6cAAJunAACdpwAAnacAAJ+nAACfpwAAoacAAKGnAACjpwAAo6cAAKWnAAClpwAAp6cAAKenAACppwAAqacAALWnAAC1pwAAt6cAALenAAC5pwAAuacAALun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AABzHgAAdR4AAHUeAAB3HgAAdx4AAHkeAAB5HgAAex4AAHseAAB9HgAAfR4AAH8eAAB/HgAAgR4AAIEeAACDHgAAgx4AAIUeAACFHgAAhx4AAIceAACJHgAAiR4AAIseAACLHgAAjR4AAI0eAACPHgAAjx4AAJEeAACRHgAAkx4AAJMeAACVHgAAnR4AAJ8eAACfHgAAoR4AAKEeAACjHgAAox4AAKUeAAClHgAApx4AAKceAACpHgAAqR4AAKseAACrHgAArR4AAK0eAACvHgAArx4AALEeAACxHgAAsx4AALMeAAC1HgAAtR4AALceAAC3HgAAuR4AALkeAAC7HgAAux4AAL0eAAC9HgAAvx4AAL8eAADBHgAAwR4AAMMeAADDHgAAxR4AAMUeAADHHgAAxx4AAMkeAADJHgAAyx4AAMseAADNHgAAzR4AAM8eAADPHgAA0R4AANEeAADTHgAA0x4AANUeAADVHgAA1x4AANceAADZHgAA2R4AANseAADbHgAA3R4AAN0eAADfHgAA3x4AAOEeAADhHgAA4x4AAOMeAADlHgAA5R4AAOceAADnHgAA6R4AAOkeAADrHgAA6x4AAO0eAADtHgAA7x4AAO8eAADxHgAA8R4AAPMeAADzHgAA9R4AAPUeAAD3HgAA9x4AAPkeAAD5HgAA+x4AAPseAAD9HgAA/R4AAP8eAAAHHwAAEB8AABUfAAAgHwAAJx8AADAfAAA3HwAAQB8AAEUfAABQHwAAVx8AAGAfAABnHwAAcB8AAH0fAACAHwAAhx8AAJAfAACXHwAAoB8AAKcfAACwHwAAtB8AALYfAAC3HwAAvh8AAL4fAADCHwAAxB8AAMYfAADHHwAA0B8AANMfAADWHwAA1x8AAOAfAADnHwAA8h8AAPQfAAD2HwAA9x8AAHEgAABxIAAAfyAAAH8gAACQIAAAnCAAAAohAAAKIQAADiEAAA8hAAATIQAAEyEAAC8hAAAvIQAANCEAADQhAAA5IQAAOSEAADwhAAA9IQAARiEAAEkhAABOIQAATiEAAHAhAAB/IQAAhCEAAIQhAADQJAAA6SQAADAsAABeLAAAYSwAAGEsAABlLAAAZiwAAGgsAABoLAAAaiwAAGosAABsLAAAbCwAAHEsAABxLAAAcywAAHQsAAB2LAAAfSwAAIEsAACBLAAAgywAAIMsAACFLAAAhSwAAIcsAACHLAAAiSwAAIksAACLLAAAiywAAI0sAACNLAAAjywAAI8sAACRLAAAkSwAAJMsAACTLAAAlSwAAJUsAACXLAAAlywAAJksAACZLAAAmywAAJssAACdLAAAnSwAAJ8sAACfLAAAoSwAAKEsAACjLAAAoywAAKUsAAClLAAApywAAKcsAACpLAAAqSwAAKssAACrLAAArSwAAK0sAACvLAAArywAALEsAACxLAAAsywAALMsAAC1LAAAtSwAALcsAAC3LAAAuSwAALksAAC7LAAAuywAAL0sAAC9LAAAvywAAL8sAADBLAAAwSwAAMMsAADDLAAAxSwAAMUsAADHLAAAxywAAMksAADJLAAAyywAAMssAADNLAAAzSwAAM8sAADPLAAA0SwAANEsAADTLAAA0ywAANUsAADVLAAA1ywAANcsAADZLAAA2SwAANssAADbLAAA3SwAAN0sAADfLAAA3ywAAOEsAADhLAAA4ywAAOQsAADsLAAA7CwAAO4sAADuLAAA8ywAAPMsAAAALQAAJS0AACctAAAnLQAALS0AAC0tAABBpgAAQaYAAEOmAABDpgAARaYAAEWmAABHpgAAR6YAAEmmAABJpgAAS6YAAEumAABNpgAATaYAAE+mAABPpgAAUaYAAFGmAABTpgAAU6YAAFWmAABVpgAAV6YAAFemAABZpgAAWaYAAFumAABbpgAAXaYAAF2mAABfpgAAX6YAAGGmAABhpgAAY6YAAGOmAABlpgAAZaYAAGemAABnpgAAaaYAAGmmAABrpgAAa6YAAG2mAABtpgAAgaYAAIGmAACDpgAAg6YAAIWmAACFpgAAh6YAAIemAACJpgAAiaYAAIumAACLpgAAjaYAAI2mAACPpgAAj6YAAJGmAACRpgAAk6YAAJOmAACVpgAAlaYAAJemAACXpgAAmaYAAJmmAACbpgAAnaYAACOnAAAjpwAAJacAACWnAAAnpwAAJ6cAACmnAAAppwAAK6cAACunAAAtpwAALacAAC+nAAAxpwAAM6cAADOnAAA1pwAANacAADenAAA3pwAAOacAADmnAAA7pwAAO6cAAD2nAAA9pwAAP6cAAD+nAABBpwAAQacAAEOnAABDpwAARacAAEWnAABHpwAAR6cAAEmnAABJpwAAS6cAAEunAABNpwAATacAAE+nAABPpwAAUacAAFGnAABTpwAAU6cAAFWnAABVpwAAV6cAAFenAABZpwAAWacAAFunAABbpwAAXacAAF2nAABfpwAAX6cAAGGnAABhpwAAY6cAAGOnAABlpwAAZacAAGenAABnpwAAaacAAGmnAABrpwAAa6cAAG2nAABtpwAAb6cAAHinAAB6pwAAeqcAAHynAAB8pwAAf6cAAH+nAACBpwAAgacAAIOnAACDpwAAhacAAIWnAACHpwAAh6cAAIynAACMpwAAjqcAAI6nAACRpwAAkacAAJOnAACVpwAAl6cAAJenAACZpwAAmacAAJunAACbpwAAnacAAJ2nAACfpwAAn6cAAKGnAAChpwAAo6cAAKOnAAClpwAApacAAKenAACnpwAAqacAAKmnAACvpwAAr6cAALWnAAC1pwAAt6cAALenAAC5pwAAuacAALunAAC7pwAAvacAAL2nAAC/pwAAv6cAAMOnAADDpwAAyKcAAMinAADKpwAAyqcAAPanAAD2pwAA+KcAAPqnAAAwqwAAWqsAAFyrAABoqwAAcKsAAL+rAAAA+wAABvsAABP7AAAX+wAAQf8AAFr/AAAoBAEATwQBANgEAQD7BAEAwAwBAPIMAQDAGAEA3xgBAGBuAQB/bgEAGtQBADPUAQBO1AEAVNQBAFbUAQBn1AEAgtQBAJvUAQC21AEAudQBALvUAQC71AEAvdQBAMPUAQDF1AEAz9QBAOrUAQAD1QEAHtUBADfVAQBS1QEAa9UBAIbVAQCf1QEAutUBANPVAQDu1QEAB9YBACLWAQA71gEAVtYBAG/WAQCK1gEApdYBAMLWAQDa1gEA3NYBAOHWAQD81gEAFNcBABbXAQAb1wEANtcBAE7XAQBQ1wEAVdcBAHDXAQCI1wEAitcBAI/XAQCq1wEAwtcBAMTXAQDJ1wEAy9cBAMvXAQAi6QEAQ+kBACsAAAArAAAAPAAAAD4AAABeAAAAXgAAAHwAAAB8AAAAfgAAAH4AAACsAAAArAAAALEAAACxAAAA1wAAANcAAAD3AAAA9wAAANADAADSAwAA1QMAANUDAADwAwAA8QMAAPQDAAD2AwAABgYAAAgGAAAWIAAAFiAAADIgAAA0IAAAQCAAAEAgAABEIAAARCAAAFIgAABSIAAAYSAAAGQgAAB6IAAAfiAAAIogAACOIAAA0CAAANwg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AADmHgAA6B4AAOgeAADqHgAA6h4AAOweAADsHgAA7h4AAO4eAADwHgAA8B4AAPIeAADyHgAA9B4AAPQeAAD2HgAA9h4AAPgeAAD4HgAA+h4AAPoeAAD8HgAA/B4AAP4eAAD+HgAACB8AAA8fAAAYHwAAHR8AACgfAAAvHwAAOB8AAD8fAABIHwAATR8AAFkfAABZHwAAWx8AAFsfAABdHwAAXR8AAF8fAABfHwAAaB8AAG8fAAC4HwAAux8AAMgfAADLHwAA2B8AANsfAADoHwAA7B8AAPgfAAD7HwAAAiEAAAIhAAAHIQAAByEAAAshAAANIQAAECEAABIhAAAVIQAAFSEAABkhAAAdIQAAJCEAACQhAAAmIQAAJiEAACghAAAoIQAAKiEAAC0hAAAwIQAAMyEAAD4hAAA/IQAARSEAAEUhAABgIQAAbyEAAIMhAACDIQAAtiQAAM8kAAAALAAALiwAAGAsAABgLAAAYiwAAGQsAABnLAAAZywAAGksAABpLAAAaywAAGssAABtLAAAcCwAAHIsAAByLAAAdSwAAHUsAAB+LAAAgCwAAIIsAACCLAAAhCwAAIQsAACGLAAAhiwAAIgsAACILAAAiiwAAIosAACMLAAAjCwAAI4sAACOLAAAkCwAAJAsAACSLAAAkiwAAJQsAACULAAAliwAAJYsAACYLAAAmCwAAJosAACaLAAAnCwAAJwsAACeLAAAniwAAKAsAACgLAAAoiwAAKIsAACkLAAApCwAAKYsAACmLAAAqCwAAKgsAACqLAAAqiwAAKwsAACsLAAAriwAAK4sAACwLAAAsCwAALIsAACyLAAAtCwAALQsAAC2LAAAtiwAALgsAAC4LAAAuiwAALosAAC8LAAAvCwAAL4sAAC+LAAAwCwAAMAsAADCLAAAwiwAAMQsAADELAAAxiwAAMYsAADILAAAyCwAAMosAADKLAAAzCwAAMwsAADOLAAAziwAANAsAADQLAAA0iwAANIsAADULAAA1CwAANYsAADWLAAA2CwAANgsAADaLAAA2iwAANwsAADcLAAA3iwAAN4sAADgLAAA4CwAAOIsAADiLAAA6ywAAOssAADtLAAA7SwAAPIsAADyLAAAQKYAAECmAABCpgAAQqYAAESmAABEpgAARqYAAEamAABIpgAASKYAAEqmAABKpgAATKYAAEymAABOpgAATqYAAFCmAABQpgAAUqYAAFKmAABUpgAAVKYAAFamAABWpgAAWKYAAFimAABapgAAWqYAAFymAABcpgAAXqYAAF6mAABgpgAAYKYAAGKmAABipgAAZKYAAGSmAABmpgAAZqYAAGimAABopgAAaqYAAGqmAABspgAAbKYAAICmAACApgAAgqYAAIKmAACEpgAAhKYAAIamAACGpgAAiKYAAIimAACKpgAAiqYAAIymAACMpgAAjqYAAI6mAACQpgAAkKYAAJKmAACSpgAAlKYAAJSmAACWpgAAlqYAAJimAACYpgAAmqYAAJqmAAAipwAAIqcAACSnAAAkpwAAJqcAACanAAAopwAAKKcAACqnAAAqpwAALKcAACynAAAupwAALqcAADKnAAAypwAANKcAADSnAAA2pwAANqcAADinAAA4pwAAOqcAADqnAAA8pwAAPKcAAD6nAAA+pwAAQKcAAECnAABCpwAAQqcAAESnAABEpwAARqcAAEanAABIpwAASKcAAEqnAABKpwAATKcAAEynAABOpwAATqcAAFCnAABQpwAAUqcAAFKnAABUpwAAVKcAAFanAABWpwAAWKcAAFinAABapwAAWqcAAFynAABcpwAAXqcAAF6nAABgpwAAYKcAAGKnAABipwAAZKcAAGSnAABmpwAAZqcAAGinAABopwAAaqcAAGqnAABspwAAbKcAAG6nAABupwAAeacAAHmnAAB7pwAAe6cAAH2nAAB+pwAAgKcAAICnAACCpwAAgqcAAISnAACEpwAAhqcAAIanAACLpwAAi6cAAI2nAACNpwAAkKcAAJCnAACSpwAAkqcAAJanAACWpwAAmKcAAJinAACapwAAmqcAAJynAACcpwAAnqcAAJ6nAACgpwAAoKcAAKKnAACipwAApKcAAKSnAACmpwAApqcAAKinAACopwAAqqcAAK6nAACwpwAAtKcAALanAAC2pwAAuKcAALinAAC6pwAAuqcAALynAAC8pwAAvqcAAL6nAADCpwAAwqcAAMSnAADHpwAAyacAAMmnAAD1pwAA9acAACH/AAA6/wAAAAQBACcEAQCwBAEA0wQBAIAMAQCyDAEAoBgBAL8YAQBAbgEAX24BAADUAQAZ1AEANNQBAE3UAQBo1AEAgdQBAJzUAQCc1AEAntQBAJ/UAQCi1AEAotQBAKXU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AACOAwAAoQMAAKMDAAD1AwAA9wMAAIEEAACKBAAALwUAADEFAABWBQAAWQUAAFkFAABgBQAAiAUAANAFAADqBQAA7wUAAPIFAAAgBgAASgYAAG4GAABvBgAAcQYAANMGAADVBgAA1QYAAOUGAADmBgAA7gYAAO8GAAD6BgAA/AYAAP8GAAD/BgAAEAcAABAHAAASBwAALwcAAE0HAAClBwAAsQcAALEHAADKBwAA6gcAAPQHAAD1BwAA+gcAAPoHAAAACAAAFQgAABoIAAAaCAAAJAgAACQIAAAoCAAAKAgAAEAIAABYCAAAYAgAAGoIAACgCAAAtAgAALYIAADHCAAABAkAADkJAAA9CQAAPQkAAFAJAABQCQAAWAkAAGEJAABxCQAAgAkAAIUJAACMCQAAjwkAAJAJAACTCQAAqAkAAKoJAACwCQAAsgkAALIJAAC2CQAAuQkAAL0JAAC9CQAAzgkAAM4JAADcCQAA3QkAAN8JAADhCQAA8AkAAPEJAAD8CQAA/AkAAAUKAAAKCgAADwoAABAKAAATCgAAKAoAACoKAAAwCgAAMgoAADMKAAA1CgAANgoAADgKAAA5CgAAWQoAAFwKAABeCgAAXgoAAHIKAAB0CgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvQoAAL0KAADQCgAA0AoAAOAKAADhCgAA+QoAAPkKAAAFCwAADAsAAA8LAAAQCwAAEwsAACgLAAAqCwAAMAsAADILAAAzCwAANQsAADkLAAA9CwAAPQsAAFwLAABdCwAAXwsAAGELAABxCwAAcQsAAIMLAACDCwAAhQsAAIoLAACOCwAAkAsAAJILAACVCwAAmQsAAJoLAACcCwAAnAsAAJ4LAACfCwAAowsAAKQLAACoCwAAqgsAAK4LAAC5CwAA0AsAANALAAAFDAAADAwAAA4MAAAQDAAAEgwAACgMAAAqDAAAOQwAAD0MAAA9DAAAWAwAAFoMAABgDAAAYQwAAIAMAACADAAAhQwAAIwMAACODAAAkAwAAJIMAACoDAAAqgwAALMMAAC1DAAAuQwAAL0MAAC9DAAA3gwAAN4MAADgDAAA4QwAAPEMAADyDAAABA0AAAwNAAAODQAAEA0AABINAAA6DQAAPQ0AAD0NAABODQAATg0AAFQN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AAD0rgAA9K4AABCvAAAQrwAALK8AACyvAABIrwAASK8AAGSvAABkrwAAgK8AAICvAACcrwAAnK8AALivAAC4rwAA1K8AANSvAADwrwAA8K8AAAywAAAMsAAAKLAAACiwAABEsAAARLAAAGCwAABgsAAAfLAAAHywAACYsAAAmLAAALSwAAC0sAAA0LAAANCwAADssAAA7LAAAAixAAAIsQAAJLEAACSxAABAsQAAQLEAAFyxAABcsQAAeLEAAHixAACUsQAAlLEAALCxAACwsQAAzLEAAMyxAADosQAA6LEAAASyAAAEsgAAILIAACCyAAA8sgAAPLIAAFiyAABYsgAAdLIAAHSyAACQsgAAkLIAAKyyAACssgAAyLIAAMiyAADksgAA5LIAAACzAAAAswAAHLMAAByzAAA4swAAOLMAAFSzAABUswAAcLMAAHCzAACMswAAjLMAAKizAACoswAAxLMAAMSzAADgswAA4LMAAPyzAAD8swAAGLQAABi0AAA0tAAANLQAAFC0AABQtAAAbLQAAGy0AACItAAAiLQAAKS0AACktAAAwLQAAMC0AADctAAA3LQAAPi0AAD4tAAAFLUAABS1AAAwtQAAMLUAAEy1AABMtQAAaLUAAGi1AACEtQAAhLUAAKC1AACgtQAAvLUAALy1AADYtQAA2LUAAPS1AAD0tQAAELYAABC2AAAstgAALLYAAEi2AABItgAAZLYAAGS2AACAtgAAgLYAAJy2AACctgAAuLYAALi2AADUtgAA1LYAAPC2AADwtgAADLcAAAy3AAAotwAAKLcAAES3AABEtwAAYLcAAGC3AAB8twAAfLcAAJi3AACYtwAAtLcAALS3AADQtwAA0LcAAOy3AADstwAACLgAAAi4AAAkuAAAJLgAAEC4AABAuAAAXLgAAFy4AAB4uAAAeLgAAJS4AACUuAAAsLgAALC4AADMuAAAzLgAAOi4AADouAAABLkAAAS5AAAguQAAILkAADy5AAA8uQAAWLkAAFi5AAB0uQAAdLkAAJC5AACQuQAArLkAAKy5AADIuQAAyLkAAOS5AADkuQAAALoAAAC6AAAcugAAHLoAADi6AAA4ugAAVLoAAFS6AABwugAAcLoAAIy6AACMugAAqLoAAKi6AADEugAAxLoAAOC6AADgugAA/LoAAPy6AAAYuwAAGLsAADS7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AACJtAAAo7QAAKW0AAC/tAAAwbQAANu0AADdtAAA97QAAPm0AAATtQAAFbUAAC+1AAAxtQAAS7UAAE21AABntQAAabUAAIO1AACFtQAAn7UAAKG1AAC7tQAAvbUAANe1AADZtQAA87UAAPW1AAAPtgAAEbYAACu2AAAttgAAR7YAAEm2AABjtgAAZbYAAH+2AACBtgAAm7YAAJ22AAC3tgAAubYAANO2AADVtgAA77YAAPG2AAALtwAADbcAACe3AAAptwAAQ7cAAEW3AABftwAAYbcAAHu3AAB9twAAl7cAAJm3AACztwAAtbcAAM+3AADRtwAA67cAAO23AAAHuAAACbgAACO4AAAluAAAP7gAAEG4AABbuAAAXbgAAHe4AAB5uAAAk7gAAJW4AACvuAAAsbgAAMu4AADNuAAA57gAAOm4AAADuQAABbkAAB+5AAAhuQAAO7kAAD25AABXuQAAWbkAAHO5AAB1uQAAj7kAAJG5AACruQAArbkAAMe5AADJuQAA47kAAOW5AAD/uQAAAboAABu6AAAdugAAN7oAADm6AABTugAAVboAAG+6AABxugAAi7oAAI26AACnugAAqboAAMO6AADFugAA37oAAOG6AAD7ugAA/boAABe7AAAZuwAAM7sAADW7AABPuwAAUbsAAGu7AABtuwAAh7sAAIm7AACjuwAApbsAAL+7AADBuwAA27sAAN27AAD3uwAA+bsAABO8AAAVvAAAL7wAADG8AABLvAAATbwAAGe8AABpvAAAg7wAAIW8AACfvAAAobwAALu8AAC9vAAA17wAANm8AADzvAAA9bwAAA+9AAARvQAAK70AAC29AABHvQAASb0AAGO9AABlvQAAf70AAIG9AACbvQAAnb0AALe9AAC5vQAA070AANW9AADvvQAA8b0AAAu+AAANvgAAJ74AACm+AABDvgAARb4AAF++AABhvgAAe74AAH2+AACXvgAAmb4AALO+AAC1vgAAz74AANG+AADrvgAA7b4AAAe/AAAJvwAAI78AACW/AAA/vwAAQb8AAFu/AABdvwAAd78AAHm/AACTvwAAlb8AAK+/AACxvwAAy78AAM2/AADnvwAA6b8AAAPAAAAFwAAAH8AAACHAAAA7wAAAPcAAAFfAAABZwAAAc8AAAHXAAACPwAAAkcAAAKvAAACtwAAAx8AAAMnA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AAB/HgAAfx4AAIEeAACBHgAAgx4AAIMeAACFHgAAhR4AAIceAACHHgAAiR4AAIkeAACLHgAAix4AAI0eAACNHgAAjx4AAI8eAACRHgAAkR4AAJMeAACTHgAAlR4AAJ0eAACfHgAAnx4AAKEeAAChHgAAox4AAKMeAAClHgAApR4AAKceAACnHgAAqR4AAKkeAACrHgAAqx4AAK0eAACtHgAArx4AAK8eAACxHgAAsR4AALMeAACzHgAAtR4AALUeAAC3HgAAtx4AALkeAAC5HgAAux4AALseAAC9HgAAvR4AAL8eAAC/HgAAwR4AAMEeAADDHgAAwx4AAMUeAADFHgAAxx4AAMceAADJHgAAyR4AAMseAADLHgAAzR4AAM0eAADPHgAAzx4AANEeAADRHgAA0x4AANMeAADVHgAA1R4AANceAADXHgAA2R4AANkeAADbHgAA2x4AAN0eAADdHgAA3x4AAN8eAADhHgAA4R4AAOMeAADjHgAA5R4AAOUeAADnHgAA5x4AAOkeAADpHgAA6x4AAOseAADtHgAA7R4AAO8eAADvHgAA8R4AAPEeAADzHgAA8x4AAPUeAAD1HgAA9x4AAPceAAD5HgAA+R4AAPseAAD7HgAA/R4AAP0eAAD/HgAABx8AABAfAAAVHwAAIB8AACcfAAAwHwAANx8AAEAfAABFHwAAUB8AAFcfAABgHwAAZx8AAHAfAAB9HwAAgB8AAIcfAACQHwAAlx8AAKAfAACnHwAAsB8AALQfAAC2HwAAtx8AAL4fAAC+HwAAwh8AAMQfAADGHwAAxx8AANAfAADTHwAA1h8AANcfAADgHwAA5x8AAPIfAAD0HwAA9h8AAPcfAABxIAAAcSAAAH8gAAB/IAAAkCAAAJwgAAAKIQAACiEAAA4hAAAPIQAAEyEAABMhAAAvIQAALyEAADQhAAA0IQAAOSEAADkhAAA8IQAAPSEAAEYhAABJIQAATiEAAE4hAABwIQAAfyEAAIQhAACEIQAA0CQAAOkkAAAwLAAAXiwAAGEsAABhLAAAZSwAAGYsAABoLAAAaCwAAGosAABqLAAAbCwAAGwsAABxLAAAcSwAAHMsAAB0LAAAdiwAAH0sAACBLAAAgSwAAIMsAACDLAAAhSwAAIUsAACHLAAAhywAAIksAACJLAAAiywAAIssAACNLAAAjSwAAI8sAACPLAAAkSwAAJEsAACTLAAAkywAAJUsAACVLAAAlywAAJcsAACZLAAAmSwAAJssAACbLAAAnSwAAJ0sAACfLAAAnywAAKEsAAChLAAAoywAAKMsAAClLAAApSwAAKcsAACnLAAAqSwAAKksAACrLAAAqywAAK0sAACtLAAArywAAK8sAACxLAAAsSwAALMsAACzLAAAtSwAALUsAAC3LAAAtywAALksAAC5LAAAuywAALssAAC9LAAAvSwAAL8sAAC/LAAAwSwAAMEsAADDLAAAwywAAMUsAADFLAAAxywAAMcsAADJLAAAySwAAMssAADLLAAAzSwAAM0sAADPLAAAzywAANEsAADRLAAA0ywAANMsAADVLAAA1SwAANcsAADXLAAA2SwAANksAADbLAAA2ywAAN0sAADdLAAA3ywAAN8sAADhLAAA4SwAAOMsAADkLAAA7CwAAOwsAADuLAAA7iwAAPMsAADzLAAAAC0AACUtAAAnLQAAJy0AAC0tAAAtLQAAQaYAAEGmAABDpgAAQ6YAAEWmAABFpgAAR6YAAEemAABJpgAASaYAAEumAABLpgAATaYAAE2mAABPpgAAT6YAAFGmAABRpgAAU6YAAFOmAABVpgAAVaYAAFemAABXpgAAWaYAAFmmAABbpgAAW6YAAF2mAABdpgAAX6YAAF+mAABhpgAAYaYAAGOmAABjpgAAZaYAAGWmAABnpgAAZ6YAAGmmAABppgAAa6YAAGumAABtpgAAbaYAAIGmAACBpgAAg6YAAIOmAACFpgAAhaYAAIemAACHpgAAiaYAAImmAACLpgAAi6YAAI2mAACNpgAAj6YAAI+mAACRpgAAkaYAAJOmAACTpgAAlaYAAJWmAACXpgAAl6YAAJmmAACZpgAAm6YAAJ2mAAAjpwAAI6cAACWnAAAlpwAAJ6cAACenAAAppwAAKacAACunAAArpwAALacAAC2nAAAvpwAAMacAADOnAAAzpwAANacAADWnAAA3pwAAN6cAADmnAAA5pwAAO6cAADunAAA9pwAAPacAAD+nAAA/pwAAQacAAEGnAABDpwAAQ6cAAEWnAABFpwAAR6cAAEenAABJpwAASacAAEunAABLpwAATacAAE2nAABPpwAAT6cAAFGnAABRpwAAU6cAAFOnAABVpwAAVacAAFenAABXpwAAWacAAFmn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AACqHgAAqh4AAKweAACsHgAArh4AAK4eAACwHgAAsB4AALIeAACyHgAAtB4AALQeAAC2HgAAth4AALgeAAC4HgAAuh4AALoeAAC8HgAAvB4AAL4eAAC+HgAAwB4AAMAeAADCHgAAwh4AAMQeAADEHgAAxh4AAMYeAADIHgAAyB4AAMoeAADKHgAAzB4AAMweAADOHgAAzh4AANAeAADQHgAA0h4AANIeAADUHgAA1B4AANYeAADWHgAA2B4AANgeAADaHgAA2h4AANweAADcHgAA3h4AAN4eAADgHgAA4B4AAOIeAADiHgAA5B4AAOQeAADmHgAA5h4AAOgeAADoHgAA6h4AAOoeAADsHgAA7B4AAO4eAADuHgAA8B4AAPAeAADyHgAA8h4AAPQeAAD0HgAA9h4AAPYeAAD4HgAA+B4AAPoeAAD6HgAA/B4AAPweAAD+HgAA/h4AAAgfAAAPHwAAGB8AAB0fAAAoHwAALx8AADgfAAA/HwAASB8AAE0fAABZHwAAWR8AAFsfAABbHwAAXR8AAF0fAABfHwAAXx8AAGgfAABvHwAAiB8AAI8fAACYHwAAnx8AAKgfAACvHwAAuB8AALwfAADIHwAAzB8AANgfAADbHwAA6B8AAOwfAAD4HwAA/B8AAAIhAAACIQAAByEAAAchAAALIQAADSEAABAhAAASIQAAFSEAABUhAAAZIQAAHSEAACQhAAAkIQAAJiEAACYhAAAoIQAAKCEAACohAAAtIQAAMCEAADMhAAA+IQAAPyEAAEUhAABFIQAAYCEAAG8hAACDIQAAgyEAALYkAADPJAAAACwAAC4sAABgLAAAYCwAAGIsAABkLAAAZywAAGcsAABpLAAAaSwAAGssAABrLAAAbSwAAHAsAAByLAAAciwAAHUsAAB1LAAAfiwAAIAsAACCLAAAgiwAAIQsAACELAAAhiwAAIYsAACILAAAiCwAAIosAACKLAAAjCwAAIwsAACOLAAAjiwAAJAsAACQLAAAkiwAAJIsAACULAAAlCwAAJYsAACWLAAAmCwAAJgsAACaLAAAmiwAAJwsAACcLAAAniwAAJ4sAACgLAAAoCwAAKIsAACiLAAApCwAAKQsAACmLAAApiwAAKgsAACoLAAAqiwAAKosAACsLAAArCwAAK4sAACuLAAAsCwAALAsAACyLAAAsiwAALQsAAC0LAAAtiwAALYsAAC4LAAAuCwAALosAAC6LAAAvCwAALwsAAC+LAAAviwAAMAsAADALAAAwiwAAMIsAADELAAAxCwAAMYsAADGLAAAyCwAAMgsAADKLAAAyiwAAMwsAADMLAAAziwAAM4sAADQLAAA0CwAANIsAADSLAAA1CwAANQsAADWLAAA1iwAANgsAADYLAAA2iwAANosAADcLAAA3CwAAN4sAADeLAAA4CwAAOAsAADiLAAA4iwAAOssAADrLAAA7SwAAO0sAADyLAAA8iwAAECmAABApgAAQqYAAEKmAABEpgAARKYAAEamAABGpgAASKYAAEimAABKpgAASqYAAEymAABMpgAATqYAAE6mAABQpgAAUKYAAFKmAABSpgAAVKYAAFSmAABWpgAAVqYAAFimAABYpgAAWqYAAFqmAABcpgAAXKYAAF6mAABepgAAYKYAAGCmAABipgAAYqYAAGSmAABkpgAAZqYAAGamAABopgAAaKYAAGqmAABqpgAAbKYAAGymAACApgAAgKYAAIKmAACCpgAAhKYAAISmAACGpgAAhqYAAIimAACIpgAAiqYAAIqmAACMpgAAjKYAAI6mAACOpgAAkKYAAJCmAACSpgAAkqYAAJSmAACUpgAAlqYAAJamAACYpgAAmKYAAJqmAACapgAAIqcAACKnAAAkpwAAJKcAACanAAAmpwAAKKcAACinAAAqpwAAKqcAACynAAAspwAALqcAAC6nAAAypwAAMqcAADSnAAA0pwAANqcAADanAAA4pwAAOKcAADqnAAA6pwAAPKcAADynAAA+pwAAPqcAAECnAABApwAAQqcAAEKnAABEpwAARKcAAEanAABGpwAASKcAAEinAABKpwAASqcAAEynAABMpwAATqcAAE6nAABQpwAAUKcAAFKnAABSpwAAVKcAAFSnAABWpwAAVqcAAFinAABYpwAAWqcAAFqnAABcpwAAXKcAAF6nAABepwAAYKcAAGCnAABipwAAYqcAAGSnAABkpwAAZqcAAGanAABopwAAaKcAAGqnAABqpwAAbKcAAGynAABupwAAbqcAAHmnAAB5pwAAe6cAAHunAAB9pwAAfqcAAICnAACApwAAgqcAAIKnAACEpwAAhKcAAIanAACGpwAAi6cAAIunAACNpwAAjacAAJCnAACQpwAAkqcAAJKn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AAAhAAAAaAEAAAQAAAAEAAAAaQEAAGoBAABrAQAAL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwBQbBcATwAAALcBAAAmAAAAYXNzZXJ0aW9uIGZhaWxlZDogYWRkX2xvd2VyIHx8IGFkZF91cHBlckM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LXN5bnRheC0wLjYuMjVcc3JjXGhpclxpbnRlcnZhbC5ycwAA2GwXAGYAAACTAQAACQAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xyZWdleC1zeW50YXgtMC42LjI1XHNyY1xoaXJcbW9kLnJzAAAAeG0XAGEAAABwAAAAIAAAAGVtcHR5IGNoYXJhY3RlciBjbGFzc2VzIGFyZSBub3QgYWxsb3dlZFVuaWNvZGUtYXdhcmUgY2FzZSBpbnNlbnNpdGl2aXR5IG1hdGNoaW5nIGlzIG5vdCBhdmFpbGFibGUgKG1ha2Ugc3VyZSB0aGUgdW5pY29kZS1jYXNlIGZlYXR1cmUgaXMgZW5hYmxlZClVbmljb2RlLWF3YXJlIFBlcmwgY2xhc3Mgbm90IGZvdW5kIChtYWtlIHN1cmUgdGhlIHVuaWNvZGUtcGVybCBmZWF0dXJlIGlzIGVuYWJsZWQpVW5pY29kZSBwcm9wZXJ0eSB2YWx1ZSBub3QgZm91bmRVbmljb2RlIHByb3BlcnR5IG5vdCBmb3VuZHBhdHRlcm4gY2FuIG1hdGNoIGludmFsaWQgVVRGLThVbmljb2RlIG5vdCBhbGxvd2VkIGhlcmVhc3NlcnRpb24gZmFpbGVkOiBiID4gMHg3RgAAeG0XAGEAAAAAAQAADQAAAHhtFwBhAAAAjQEAAB4AAAB4bRcAYQAAAOoBAAAeAAAAMHgAAIxvFwACAAAAQ2xhc3NVbmljb2RlUmFuZ2VzdGFydAAAbQEAAAwA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YmNkYmM1NjhiZTdjZmY2ZWVlYWFmODFhODliNGFhNTBiL2xpYnJhcnkvYWxsb2Mvc3JjL3ZlYy9tb2QucnM0ehcATAAAADMHAAAkAAAAL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAJB6FwBKAAAAXAQAABUAAACQehcASgAAAGoEAAAeAAAAkHoXAEoAAABzBAAAGAAAAJB6FwBKAAAAdAQAABkAAACQehcASgAAAHcEAAAaAAAAkHoXAEoAAAB9BAAADQAAAJB6FwBKAAAAfgQAABIAAAAEAAAAAAAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXHJlZ2V4LXN5bnRheC0wLjYuMjVcc3JjXHV0ZjgucnNpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBpbnZhbGlkIGVuY29kZWQgbGVuZ3RoOiCyexcAQgAAAFR7FwBeAAAAhgAAABIAAABUexcAXgAAALUBAAAtAAAAVHsXAF4AAAC2AQAAKwAAAFR7FwBeAAAAuQEAAAkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiAAADx8FwAqAAAAaW52YWxpZCBVVEYtOCBieXRlIHNlcXVlbmNlIHNpemVwfBcAIAAAAFR7FwBeAAAAxAEAAA4AAAAEAAAAAAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAfwAAAP8HAAD//wAABAAAAAAAAAAhIiMkJSYnKCkqKywtMDEyMzQ1Njc4OUBBQkNERUZHSElKS0xNTlBRUlNUVVZYWVpbYGFiY2RlaGlqa2xtcHFyQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLC4vQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkuLzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9DOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xiYXNlNjQtMC4xMy4wXHNyY1xlbmNvZGUucnMAAHB+FwBaAAAAkgAAACcAAAB1c2l6ZSBvdmVyZmxvdyB3aGVuIGNhbGN1bGF0aW5nIGI2NCBsZW5ndGgAAHB+FwBaAAAAmQAAAAoAAABwfhcAWgAAALYAAAAgAAAAcH4XAFoAAAC3AAAAJQAAAHB+FwBaAAAA/AAAABwAAABwfhcAWgAAAP0AAAAhAAAAcH4XAFoAAAATAQAALgAAAHB+FwBaAAAAEwEAAAkAAABwfhcAWgAAABQBAAAJAAAAcH4XAFoAAAALAQAALgAAAHB+FwBaAAAACwEAAAkAAABwfhcAWgAAAA0BAAAPAAAAcH4XAFoAAAAMAQAACQAAAHB+FwBaAAAADwEAAAkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiAAANh/FwAqAAAASW1wb3NzaWJsZSByZW1haW5kZXIMgBcAFAAAAHB+FwBaAAAAKgEAABYAAABwfhcAWgAAADsBAAAJAAAAMH4XAPB9FwCwfRcAcH0XADB9FwDwfBcAL3J1c3RjLzc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGIvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pdGVyLnJzAABggBcATgAAACgGAAAVAAAAYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVyb0M6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGFlcy0wLjcuNVxzcmNcc29mdFxmaXhzbGljZTMyLnJz2YAXAF8AAADmAAAAIwAAANmA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AgD8dalCirsLAO4Xa7TV8gYA5XAxIqm2BwDmt+M/cVMIAMFrf/01lwEALjTFSa+SBABXA1rfXDYCAGC7/6c4IQMA/kZG0fehAgDMRIrxXRsBAGZCyELQkAMAddyPKuPvAQA4Eq7nXpIGADLo0IGSrwQA+B0ZEfn+AABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xjdXJ2ZTI1NTE5LWRhbGVrLTMuMi4wXHNyY1xzY2FsYXIucnMA0PwXAGMAAACDAgAAEAAAALABAAAoAAAABAAAALEBAACwAQAAKAAAAAQAAACyAQAAsQEAAET9FwCzAQAAtAEAALUBAAC2AQAAtwEAAEtleXBhaXJDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xlZDI1NTE5LWRhbGVrLTEuMC4xXHNyY1xwdWJsaWMucnMAh/0XAGAAAACJAAAADgAAAEM6XFVzZXJzXGRvdWdhXC5jYXJnb1xyZWdpc3RyeVxzcmNcZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzXGVkMjU1MTktZGFsZWstMS4wLjFcc3JjXHNlY3JldC5yc/j9FwBgAAAAcgAAAA4AAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xlZDI1NTE5LWRhbGVrLTEuMC4xXHNyY1xzaWduYXR1cmUucnMAaP4XAGMAAABuAAAAHwAAAGj+FwBjAAAAbwAAAB8AAABo/hcAYwAAAMsAAAA5AAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQC4AQAACAAAAAQAAABFAAAAU2lnbmF0dXJlQzpcVXNlcnNcZG91Z2FcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcZWQyNTUxOS1kYWxlay0xLjAuMVxzcmNcc2lnbmF0dXJlLnJzQf8XAGMAAACwAAAADwAAAEH/FwBjAAAAsQAAAA8AAABDOlxVc2Vyc1xkb3VnYVwuY2FyZ29c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eXRlIGFycmF5AAAUIxgACgAAAHN0cmluZyAAKCMYAAcAAABjaGFyYWN0ZXIgYGA4IxgACwAAAEMjGAABAAAAZmxvYXRpbmcgcG9pbnQgYFQjGAAQAAAAQyMYAAEAAABpbnRlZ2VyIGAAAAB0IxgACQAAAEMjGAABAAAAYm9vbGVhbiBgAAAAkCMYAAkAAABDIxgAAQAAAHU4AADGAQAABAAAAAQAAADHAQAAQWNjZXNzRXJyb3IAwCMYAAAAAAB1bmNhdGVnb3JpemVkIGVycm9yb3RoZXIgZXJyb3JvdXQgb2YgbWVtb3J5dW5leHBlY3RlZCBlbmQgb2YgZmlsZXVuc3VwcG9ydGVkb3BlcmF0aW9uIGludGVycnVwdGVkYXJndW1lbnQgbGlzdCB0b28gbG9uZ2ZpbGVuYW1lIHRvbyBsb25ndG9vIG1hbnkgbGlua3Njcm9zcy1kZXZpY2UgbGluayBvciByZW5hbWVkZWFkbG9ja2V4ZWN1dGFibGUgZmlsZSBidXN5cmVzb3VyY2UgYnVzeWZpbGUgdG9vIGxhcmdlZmlsZXN5c3RlbSBxdW90YSBleGNlZWRlZHNlZWsgb24gdW5zZWVrYWJsZSBmaWxlbm8gc3RvcmFnZSBzcGFjZXdyaXRlIHplcm90aW1lZCBvdXRpbnZhbGlkIGRhdGFpbnZhbGlkIGlucHV0IHBhcmFtZXRlcnN0YWxlIG5ldHdvcmsgZmlsZSBoYW5kbGVmaWxlc3lzdGVtIGxvb3Agb3IgaW5kaXJlY3Rpb24gbGltaXQgKGUuZy4gc3ltbGluayBsb29wKXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZGlyZWN0b3J5IG5vdCBlbXB0eWlzIGEgZGlyZWN0b3J5bm90IGEgZGlyZWN0b3J5b3BlcmF0aW9uIHdvdWxkIGJsb2NrZW50aXR5IGFscmVhZHkgZXhpc3RzYnJva2VuIHBpcGVuZXR3b3JrIGRvd25hZGRyZXNzIG5vdCBhdmFpbGFibGVhZGRyZXNzIGluIHVzZW5vdCBjb25uZWN0ZWRjb25uZWN0aW9uIGFib3J0ZWRuZXR3b3JrIHVucmVhY2hhYmxlaG9zdCB1bnJlYWNoYWJsZWNvbm5lY3Rpb24gcmVzZXRjb25uZWN0aW9u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"
);
var wasm = async () => {
  await init(wasm_code);
  return exports$1;
};
const getWallet = async () => wasm();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a = function() {
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var base64$2 = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(base64$2, "__esModule", { value: true });
var INVALID_BYTE = 256;
var Coder$1 = function() {
  function Coder2(_paddingCharacter) {
    if (_paddingCharacter === void 0) {
      _paddingCharacter = "=";
    }
    this._paddingCharacter = _paddingCharacter;
  }
  Coder2.prototype.encodedLength = function(length2) {
    if (!this._paddingCharacter) {
      return (length2 * 8 + 5) / 6 | 0;
    }
    return (length2 + 2) / 3 * 4 | 0;
  };
  Coder2.prototype.encode = function(data2) {
    var out = "";
    var i = 0;
    for (; i < data2.length - 2; i += 3) {
      var c = data2[i] << 16 | data2[i + 1] << 8 | data2[i + 2];
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      out += this._encodeByte(c >>> 1 * 6 & 63);
      out += this._encodeByte(c >>> 0 * 6 & 63);
    }
    var left = data2.length - i;
    if (left > 0) {
      var c = data2[i] << 16 | (left === 2 ? data2[i + 1] << 8 : 0);
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      if (left === 2) {
        out += this._encodeByte(c >>> 1 * 6 & 63);
      } else {
        out += this._paddingCharacter || "";
      }
      out += this._paddingCharacter || "";
    }
    return out;
  };
  Coder2.prototype.maxDecodedLength = function(length2) {
    if (!this._paddingCharacter) {
      return (length2 * 6 + 7) / 8 | 0;
    }
    return length2 / 4 * 3 | 0;
  };
  Coder2.prototype.decodedLength = function(s2) {
    return this.maxDecodedLength(s2.length - this._getPaddingLength(s2));
  };
  Coder2.prototype.decode = function(s2) {
    if (s2.length === 0) {
      return new Uint8Array(0);
    }
    var paddingLength = this._getPaddingLength(s2);
    var length2 = s2.length - paddingLength;
    var out = new Uint8Array(this.maxDecodedLength(length2));
    var op = 0;
    var i = 0;
    var haveBad = 0;
    var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
    for (; i < length2 - 4; i += 4) {
      v0 = this._decodeChar(s2.charCodeAt(i + 0));
      v1 = this._decodeChar(s2.charCodeAt(i + 1));
      v2 = this._decodeChar(s2.charCodeAt(i + 2));
      v3 = this._decodeChar(s2.charCodeAt(i + 3));
      out[op++] = v0 << 2 | v1 >>> 4;
      out[op++] = v1 << 4 | v2 >>> 2;
      out[op++] = v2 << 6 | v3;
      haveBad |= v0 & INVALID_BYTE;
      haveBad |= v1 & INVALID_BYTE;
      haveBad |= v2 & INVALID_BYTE;
      haveBad |= v3 & INVALID_BYTE;
    }
    if (i < length2 - 1) {
      v0 = this._decodeChar(s2.charCodeAt(i));
      v1 = this._decodeChar(s2.charCodeAt(i + 1));
      out[op++] = v0 << 2 | v1 >>> 4;
      haveBad |= v0 & INVALID_BYTE;
      haveBad |= v1 & INVALID_BYTE;
    }
    if (i < length2 - 2) {
      v2 = this._decodeChar(s2.charCodeAt(i + 2));
      out[op++] = v1 << 4 | v2 >>> 2;
      haveBad |= v2 & INVALID_BYTE;
    }
    if (i < length2 - 3) {
      v3 = this._decodeChar(s2.charCodeAt(i + 3));
      out[op++] = v2 << 6 | v3;
      haveBad |= v3 & INVALID_BYTE;
    }
    if (haveBad !== 0) {
      throw new Error("Base64Coder: incorrect characters for decoding");
    }
    return out;
  };
  Coder2.prototype._encodeByte = function(b) {
    var result = b;
    result += 65;
    result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
    result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
    result += 61 - b >>> 8 & 52 - 48 - 62 + 43;
    result += 62 - b >>> 8 & 62 - 43 - 63 + 47;
    return String.fromCharCode(result);
  };
  Coder2.prototype._decodeChar = function(c) {
    var result = INVALID_BYTE;
    result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
    result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
    result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
    result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
    result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
    return result;
  };
  Coder2.prototype._getPaddingLength = function(s2) {
    var paddingLength = 0;
    if (this._paddingCharacter) {
      for (var i = s2.length - 1; i >= 0; i--) {
        if (s2[i] !== this._paddingCharacter) {
          break;
        }
        paddingLength++;
      }
      if (s2.length < 4 || paddingLength > 2) {
        throw new Error("Base64Coder: incorrect padding");
      }
    }
    return paddingLength;
  };
  return Coder2;
}();
base64$2.Coder = Coder$1;
var stdCoder = new Coder$1();
function encode$a(data2) {
  return stdCoder.encode(data2);
}
var encode_1$1 = base64$2.encode = encode$a;
function decode$7(s2) {
  return stdCoder.decode(s2);
}
var decode_1 = base64$2.decode = decode$7;
var URLSafeCoder = function(_super) {
  __extends(URLSafeCoder2, _super);
  function URLSafeCoder2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  URLSafeCoder2.prototype._encodeByte = function(b) {
    var result = b;
    result += 65;
    result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
    result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
    result += 61 - b >>> 8 & 52 - 48 - 62 + 45;
    result += 62 - b >>> 8 & 62 - 45 - 63 + 95;
    return String.fromCharCode(result);
  };
  URLSafeCoder2.prototype._decodeChar = function(c) {
    var result = INVALID_BYTE;
    result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
    result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
    result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
    result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
    result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
    return result;
  };
  return URLSafeCoder2;
}(Coder$1);
base64$2.URLSafeCoder = URLSafeCoder;
var urlSafeCoder = new URLSafeCoder();
function encodeURLSafe(data2) {
  return urlSafeCoder.encode(data2);
}
base64$2.encodeURLSafe = encodeURLSafe;
function decodeURLSafe(s2) {
  return urlSafeCoder.decode(s2);
}
base64$2.decodeURLSafe = decodeURLSafe;
base64$2.encodedLength = function(length2) {
  return stdCoder.encodedLength(length2);
};
base64$2.maxDecodedLength = function(length2) {
  return stdCoder.maxDecodedLength(length2);
};
base64$2.decodedLength = function(s2) {
  return stdCoder.decodedLength(s2);
};
async function deepHash$4(data2) {
  if (Array.isArray(data2)) {
    const tag2 = concatBuffers$3([
      stringToBuffer$3("list"),
      stringToBuffer$3(data2.length.toString())
    ]);
    return await deepHashChunks$2(data2, await crypto.subtle.digest("SHA-384", tag2));
  }
  const tag = concatBuffers$3([
    stringToBuffer$3("blob"),
    stringToBuffer$3(data2.byteLength.toString())
  ]);
  const taggedHash = concatBuffers$3([
    await crypto.subtle.digest("SHA-384", tag),
    await crypto.subtle.digest("SHA-384", data2)
  ]);
  return await crypto.subtle.digest("SHA-384", taggedHash);
}
async function deepHashChunks$2(chunks2, acc) {
  if (chunks2.length < 1) {
    return acc;
  }
  const hashPair = concatBuffers$3([acc, await deepHash$4(chunks2[0])]);
  const newAcc = await crypto.subtle.digest("SHA-384", hashPair);
  return await deepHashChunks$2(chunks2.slice(1), newAcc);
}
var bignumber = { exports: {} };
(function(module) {
  (function(globalObject) {
    var BigNumber2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone2(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE2 = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "\xA0",
        suffix: ""
      }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber3(v, b) {
        var alphabet2, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber3))
          return new BigNumber3(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET2.length, "Base");
          if (b == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber3(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet2 = ALPHABET2.slice(0, b);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet2.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER2 || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber3.clone = clone2;
      BigNumber3.ROUND_UP = 0;
      BigNumber3.ROUND_DOWN = 1;
      BigNumber3.ROUND_CEIL = 2;
      BigNumber3.ROUND_FLOOR = 3;
      BigNumber3.ROUND_HALF_UP = 4;
      BigNumber3.ROUND_HALF_DOWN = 5;
      BigNumber3.ROUND_HALF_EVEN = 6;
      BigNumber3.ROUND_HALF_CEIL = 7;
      BigNumber3.ROUND_HALF_FLOOR = 8;
      BigNumber3.EUCLID = 9;
      BigNumber3.config = BigNumber3.set = function(obj2) {
        var p, v;
        if (obj2 != null) {
          if (typeof obj2 == "object") {
            if (obj2.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj2[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj2.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj2[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj2.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj2[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj2.hasOwnProperty(p = "RANGE")) {
              v = obj2[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj2.hasOwnProperty(p = "CRYPTO")) {
              v = obj2[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj2.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj2[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj2.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj2[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj2.hasOwnProperty(p = "FORMAT")) {
              v = obj2[p];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj2.hasOwnProperty(p = "ALPHABET")) {
              v = obj2[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET2 = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj2);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET: ALPHABET2
        };
      };
      BigNumber3.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber3.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s2 = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber3.maximum = BigNumber3.max = function() {
        return maxOrMin(arguments, P.lt);
      };
      BigNumber3.minimum = BigNumber3.min = function() {
        return maxOrMin(arguments, P.gt);
      };
      BigNumber3.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand2 = new BigNumber3(ONE2);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (; i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9e15) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 1e14);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (; i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 1e14);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k; ) {
              v = random53bitInt();
              if (v < 9e15)
                c[i++] = v % 1e14;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (; c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand2.e = e;
          rand2.c = c;
          return rand2;
        };
      }();
      BigNumber3.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber3(args[0]);
        for (; i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet2) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet2.indexOf(str.charAt(i++));
            for (j = 0; j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign7, callerIsToString) {
          var alphabet2, d, e, k, r2, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber3(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(
              toFixedPoint(coeffToString(x.c), x.e, "0"),
              10,
              baseOut,
              decimal
            );
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET2, decimal) : (alphabet2 = decimal, ALPHABET2));
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet2.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign7;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r2 = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r2 = r2 || d < 0 || xc[d + 1] != null;
          r2 = rm < 4 ? (i != null || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r2 || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
          } else {
            xc.length = d;
            if (r2) {
              for (--baseOut; ++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length; !xc[--k]; )
              ;
            for (i = 0, str = ""; i <= k; str += alphabet2.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet2.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x, k, base3) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice(); i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base3 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base3;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare3(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b, aL, base3) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base3 + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y, dp, rm, base3) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber3(
              !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
            );
          }
          q = new BigNumber3(s2);
          qc = q.c = [];
          e = x.e - y.e;
          s2 = dp + e + 1;
          if (!base3) {
            base3 = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
            s2 = s2 / LOG_BASE | 0;
          }
          for (i = 0; yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s2 < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s2 += 2;
            n = mathfloor(base3 / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base3);
              xc = multiply(xc, n, base3);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base3 / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare3(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base3 + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base3)
                    n = base3 - 1;
                  prod = multiply(yc, n, base3);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare3(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base3);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare3(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc, remL, base3);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s2--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base3 == BASE) {
            for (i = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i++)
              ;
            round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm, id2) {
        var c0, e, ne, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id2 == 1 || id2 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber3(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id2 == 1 || id2 == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += "."; i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (; i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, method) {
        var n, i = 1, m = new BigNumber3(args[0]);
        for (; i < args.length; i++) {
          n = new BigNumber3(args[i]);
          if (!n.s) {
            m = n;
            break;
          } else if (method.call(m, n)) {
            m = n;
          }
        }
        return m;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (; !c[--j]; c.pop())
          ;
        for (j = c[0]; j >= 10; j /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base3, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s2)) {
            x.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s2 = s2.replace(basePrefix, function(m, p1, p2) {
                base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base3 ? p1 : m;
              });
              if (b) {
                base3 = b;
                s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s2)
                return new BigNumber3(s2, base3);
            }
            if (BigNumber3.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd, rm, r2) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
              ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = n / pows10[d - j - 1] % 10 | 0;
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r2) {
                  for (; xc.length <= ni; xc.push(0))
                    ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1; k >= 10; k /= 10, d++)
                  ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
              }
            }
            r2 = r2 || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r2) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r2) {
              for (; ; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                    ;
                  j = xc[0] += k;
                  for (k = 1; j >= 10; j /= 10, k++)
                    ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length; xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber3(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P.comparedTo = function(y, b) {
        return compare2(this, new BigNumber3(y, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber3(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (; v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber3(y, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber3(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m != null)
          m = new BigNumber3(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y = new BigNumber3(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
          return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s)
            return new BigNumber3(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp)
            x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k = 1 / k;
          return new BigNumber3(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber3(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y = new BigNumber3(ONE2);
        for (; ; ) {
          if (nIsOdd) {
            y = y.times(x);
            if (!y.c)
              break;
            if (k) {
              if (y.c.length > k)
                y.c.length = k;
            } else if (isModExp) {
              y = y.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k)
              x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp)
          return y;
        if (nIsNeg)
          y = ONE2.div(y);
        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber3(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y, b) {
        return compare2(this, new BigNumber3(y, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y, b) {
        return compare2(this, new BigNumber3(y, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare2(this, new BigNumber3(y, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y, b) {
        return compare2(this, new BigNumber3(y, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare2(this, new BigNumber3(y, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber3(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber3(NaN);
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; t.push(0))
            ;
          t.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy)
          t = xc, xc = yc, yc = t, y.s = -y.s;
        b = (j = yc.length) - (i = xc.length);
        if (b > 0)
          for (; b--; xc[i++] = 0)
            ;
        b = BASE - 1;
        for (; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; xc[i] = b)
              ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y.s = ROUNDING_MODE == 3 ? -1 : 1;
          y.c = [y.e = 0];
          return y;
        }
        return normalise(y, xc, ye);
      };
      P.modulo = P.mod = function(y, b) {
        var q, s2, x = this;
        y = new BigNumber3(y, b);
        if (!x.c || !y.s || y.c && !y.c[0]) {
          return new BigNumber3(NaN);
        } else if (!y.c || x.c && !x.c[0]) {
          return new BigNumber3(x);
        }
        if (MODULO_MODE == 9) {
          s2 = y.s;
          y.s = 1;
          q = div(x, y, 0, 3);
          y.s = s2;
          q.s *= s2;
        } else {
          q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        if (!y.c[0] && MODULO_MODE == 1)
          y.s = x.s;
        return y;
      };
      P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber3(y, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y.c = y.e = y.s = null;
          } else {
            y.s *= x.s;
            if (!xc || !yc) {
              y.c = y.e = null;
            } else {
              y.c = [0];
              y.e = 0;
            }
          }
          return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL)
          zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
        for (i = xcL + ycL, zc = []; i--; zc.push(0))
          ;
        base3 = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k; j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base3 | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base3;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber3(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber3(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber3(NaN);
        if (a != b) {
          y.s = -b;
          return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber3(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (; a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0)
          t = yc, yc = xc, xc = t, b = a;
        for (a = 0; b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber3(x), sd, rm);
        }
        if (!(c = x.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (; v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0]; v >= 10; v /= 10, n++)
            ;
        }
        if (sd && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r2, rep, t, x = this, c = x.c, s2 = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
        if (s2 !== 1 || !c || !c[0]) {
          return new BigNumber3(!s2 || s2 < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s2 = Math.sqrt(+valueOf(x));
        if (s2 == 0 || s2 == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s2 = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s2 == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s2.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r2 = new BigNumber3(n);
        } else {
          r2 = new BigNumber3(s2 + "");
        }
        if (r2.c[0]) {
          e = r2.e;
          s2 = e + dp;
          if (s2 < 3)
            s2 = 0;
          for (; ; ) {
            t = r2;
            r2 = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s2) === (n = coeffToString(r2.c)).slice(0, s2)) {
              if (r2.e < e)
                --s2;
              n = n.slice(s2 - 3, s2 + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r2 = t;
                    break;
                  }
                }
                dp += 4;
                s2 += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                  m = !r2.times(r2).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format2) {
        var str, x = this;
        if (format2 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2)
            i = g1, g1 = g2, g2 = i, len -= i;
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
            new RegExp("\\d{" + g2 + "}\\B", "g"),
            "$&" + (format2.fractionGroupSeparator || "")
          ) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r2, s2, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber3(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE2)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber3(x);
        d = new BigNumber3(ONE2);
        n1 = d0 = new BigNumber3(ONE2);
        d1 = n0 = new BigNumber3(ONE2);
        s2 = coeffToString(xc);
        e = d.e = s2.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber3(s2);
        n0.c[0] = 0;
        for (; ; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r2 = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
        ) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r2;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s2 = n.s, e = n.e;
        if (e === null) {
          if (s2) {
            str = "Infinity";
            if (s2 < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET2.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s2, true);
          }
          if (s2 < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null)
        BigNumber3.set(configObject);
      return BigNumber3;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s2, z, i = 1, j = a.length, r2 = a[0] + "";
      for (; i < j; ) {
        s2 = a[i++] + "";
        z = LOG_BASE - s2.length;
        for (; z--; s2 = "0" + s2)
          ;
        r2 += s2;
      }
      for (j = r2.length; r2.charCodeAt(--j) === 48; )
        ;
      return r2.slice(0, j + 1 || 1);
    }
    function compare2(x, y) {
      var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!i || !j)
        return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b)
        return a ? b ? 0 : -j : i;
      if (i != j)
        return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc)
        return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b)
        return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0; i < j; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name2) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name2 || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + "."; ++e; zs += z)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len; --e; zs += z)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber2 = clone2();
    BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
    if (module.exports) {
      module.exports = BigNumber2;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber2;
    }
  })(commonjsGlobal);
})(bignumber);
const BigNumber$1 = bignumber.exports;
function concatBuffers$3(buffers) {
  let total_length = 0;
  for (let i = 0; i < buffers.length; i++) {
    total_length += buffers[i].byteLength;
  }
  let temp = new Uint8Array(total_length);
  let offset = 0;
  temp.set(new Uint8Array(buffers[0]), offset);
  offset += buffers[0].byteLength;
  for (let i = 1; i < buffers.length; i++) {
    temp.set(new Uint8Array(buffers[i]), offset);
    offset += buffers[i].byteLength;
  }
  return temp;
}
function b64UrlToString$3(b64UrlString) {
  let buffer2 = b64UrlToBuffer$3(b64UrlString);
  if (typeof TextDecoder == "undefined") {
    const TextDecoder2 = require("util").TextDecoder;
    return new TextDecoder2("utf-8", { fatal: true }).decode(buffer2);
  }
  return new TextDecoder("utf-8", { fatal: true }).decode(buffer2);
}
function bufferToString$3(buffer2) {
  if (typeof TextDecoder == "undefined") {
    const TextDecoder2 = require("util").TextDecoder;
    return new TextDecoder2("utf-8", { fatal: true }).decode(buffer2);
  }
  return new TextDecoder("utf-8", { fatal: true }).decode(buffer2);
}
function stringToBuffer$3(string2) {
  if (typeof TextEncoder == "undefined") {
    const TextEncoder2 = require("util").TextEncoder;
    return new TextEncoder2().encode(string2);
  }
  return new TextEncoder().encode(string2);
}
function stringToB64Url$3(string2) {
  return bufferTob64Url$3(stringToBuffer$3(string2));
}
function b64UrlToBuffer$3(b64UrlString) {
  return new Uint8Array(decode_1(b64UrlDecode$3(b64UrlString)));
}
function bufferTob64$3(buffer2) {
  return encode_1$1(new Uint8Array(buffer2));
}
function bufferTob64Url$3(buffer2) {
  return b64UrlEncode$3(bufferTob64$3(buffer2));
}
function b64UrlEncode$3(b64UrlString) {
  return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode$3(b64UrlString) {
  b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
  let padding2;
  b64UrlString.length % 4 == 0 ? padding2 = 0 : padding2 = 4 - b64UrlString.length % 4;
  return b64UrlString.concat("=".repeat(padding2));
}
class BaseObject$1 {
  get(field, options) {
    if (!Object.getOwnPropertyNames(this).includes(field)) {
      throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
    }
    if (this[field] instanceof Uint8Array) {
      if (options && options.decode && options.string) {
        return bufferToString$3(this[field]);
      }
      if (options && options.decode && !options.string) {
        return this[field];
      }
      return bufferTob64Url$3(this[field]);
    }
    if (options && options.decode == true) {
      if (options && options.string) {
        return b64UrlToString$3(this[field]);
      }
      return b64UrlToBuffer$3(this[field]);
    }
    return this[field];
  }
}
class Tag$1 extends BaseObject$1 {
  constructor(name2, value, decode5 = false) {
    super();
    this.name = name2;
    this.value = value;
  }
}
class Transaction$1 extends BaseObject$1 {
  constructor(attributes = {}) {
    super();
    this.format = 2;
    this.id = "";
    this.last_tx = "";
    this.owner = "";
    this.tags = [];
    this.target = "";
    this.quantity = "0";
    this.data_size = "0";
    this.data = new Uint8Array();
    this.data_root = "";
    this.reward = "0";
    this.signature = "";
    Object.assign(this, attributes);
    if (typeof this.data === "string") {
      this.data = b64UrlToBuffer$3(this.data);
    }
    if (attributes.tags) {
      this.tags = attributes.tags.map((tag) => {
        return new Tag$1(tag.name, tag.value);
      });
    }
  }
  addTag(name2, value) {
    this.tags.push(new Tag$1(stringToB64Url$3(name2), stringToB64Url$3(value)));
  }
  toJSON() {
    return {
      format: this.format,
      id: this.id,
      last_tx: this.last_tx,
      owner: this.owner,
      tags: this.tags,
      target: this.target,
      quantity: this.quantity,
      data: bufferTob64Url$3(this.data),
      data_size: this.data_size,
      data_root: this.data_root,
      data_tree: this.data_tree,
      reward: this.reward,
      signature: this.signature
    };
  }
  setOwner(owner) {
    this.owner = owner;
  }
  setSignature({
    id: id2,
    owner,
    reward,
    tags: tags2,
    signature: signature2
  }) {
    this.id = id2;
    this.owner = owner;
    if (reward)
      this.reward = reward;
    if (tags2)
      this.tags = tags2;
    this.signature = signature2;
  }
  async prepareChunks(data2) {
    if (!this.chunks && data2.byteLength > 0) {
      this.chunks = await generateTransactionChunks(data2);
      this.data_root = bufferTob64Url$3(this.chunks.data_root);
    }
    if (!this.chunks && data2.byteLength === 0) {
      this.chunks = {
        chunks: [],
        data_root: new Uint8Array(),
        proofs: []
      };
      this.data_root = "";
    }
  }
  getChunk(idx, data2) {
    if (!this.chunks) {
      throw new Error(`Chunks have not been prepared`);
    }
    const proof = this.chunks.proofs[idx];
    const chunk = this.chunks.chunks[idx];
    return {
      data_root: this.data_root,
      data_size: this.data_size,
      data_path: bufferTob64Url$3(proof.proof),
      offset: proof.offset.toString(),
      chunk: bufferTob64Url$3(data2.slice(chunk.minByteRange, chunk.maxByteRange))
    };
  }
  async getSignatureData() {
    switch (this.format) {
      case 1:
        let tags2 = this.tags.reduce((accumulator, tag) => {
          return concatBuffers$3([
            accumulator,
            tag.get("name", { decode: true, string: false }),
            tag.get("value", { decode: true, string: false })
          ]);
        }, new Uint8Array());
        return concatBuffers$3([
          this.get("owner", { decode: true, string: false }),
          this.get("target", { decode: true, string: false }),
          this.get("data", { decode: true, string: false }),
          stringToBuffer$3(this.quantity),
          stringToBuffer$3(this.reward),
          this.get("last_tx", { decode: true, string: false }),
          tags2
        ]);
      case 2:
        if (!this.data_root) {
          await this.prepareChunks(this.data);
        }
        const tagList = this.tags.map((tag) => [
          tag.get("name", { decode: true, string: false }),
          tag.get("value", { decode: true, string: false })
        ]);
        return await deepHash$4([
          stringToBuffer$3(this.format.toString()),
          this.get("owner", { decode: true, string: false }),
          this.get("target", { decode: true, string: false }),
          stringToBuffer$3(this.quantity),
          stringToBuffer$3(this.reward),
          this.get("last_tx", { decode: true, string: false }),
          tagList,
          stringToBuffer$3(this.data_size),
          this.get("data_root", { decode: true, string: false })
        ]);
      default:
        throw new Error(`Unexpected transaction format: ${this.format}`);
    }
  }
}
var web = {};
var common$6 = {};
var ar = {};
Object.defineProperty(ar, "__esModule", { value: true });
const bignumber_js_1 = bignumber.exports;
class Ar {
  constructor() {
    this.BigNum = (value, decimals) => {
      let instance2 = bignumber_js_1.BigNumber.clone({ DECIMAL_PLACES: decimals });
      return new instance2(value);
    };
  }
  winstonToAr(winstonString, { formatted = false, decimals = 12, trim: trim2 = true } = {}) {
    let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
    return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
  }
  arToWinston(arString, { formatted = false } = {}) {
    let number = this.stringToBigNum(arString).shiftedBy(12);
    return formatted ? number.toFormat() : number.toFixed(0);
  }
  compare(winstonStringA, winstonStringB) {
    let a = this.stringToBigNum(winstonStringA);
    let b = this.stringToBigNum(winstonStringB);
    return a.comparedTo(b);
  }
  isEqual(winstonStringA, winstonStringB) {
    return this.compare(winstonStringA, winstonStringB) === 0;
  }
  isLessThan(winstonStringA, winstonStringB) {
    let a = this.stringToBigNum(winstonStringA);
    let b = this.stringToBigNum(winstonStringB);
    return a.isLessThan(b);
  }
  isGreaterThan(winstonStringA, winstonStringB) {
    let a = this.stringToBigNum(winstonStringA);
    let b = this.stringToBigNum(winstonStringB);
    return a.isGreaterThan(b);
  }
  add(winstonStringA, winstonStringB) {
    let a = this.stringToBigNum(winstonStringA);
    this.stringToBigNum(winstonStringB);
    return a.plus(winstonStringB).toFixed(0);
  }
  sub(winstonStringA, winstonStringB) {
    let a = this.stringToBigNum(winstonStringA);
    this.stringToBigNum(winstonStringB);
    return a.minus(winstonStringB).toFixed(0);
  }
  stringToBigNum(stringValue, decimalPlaces = 12) {
    return this.BigNum(stringValue, decimalPlaces);
  }
}
ar.default = Ar;
var api$2 = {};
var axios$6 = { exports: {} };
var axios$5 = { exports: {} };
var bind$5 = function bind(fn, thisArg) {
  return function wrap2() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$4 = bind$5;
var toString$4 = Object.prototype.toString;
var kindOf = function(cache) {
  return function(thing) {
    var str = toString$4.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}
function isArray$1(val) {
  return Array.isArray(val);
}
function isUndefined$1(val) {
  return typeof val === "undefined";
}
function isBuffer$1(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
var isArrayBuffer$1 = kindOfTest("ArrayBuffer");
function isArrayBufferView$1(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer$1(val.buffer);
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject$1(val) {
  if (kindOf(val) !== "object") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
var isDate$1 = kindOfTest("Date");
var isFile$1 = kindOfTest("File");
var isBlob$1 = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
function isFunction$1(val) {
  return toString$4.call(val) === "[object Function]";
}
function isStream$2(val) {
  return isObject$1(val) && isFunction$1(val.pipe);
}
function isFormData$1(thing) {
  var pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString$4.call(thing) === pattern || isFunction$1(thing.toString) && thing.toString() === pattern);
}
var isURLSearchParams$1 = kindOfTest("URLSearchParams");
function trim$1(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv$1() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach$1(obj2, fn) {
  if (obj2 === null || typeof obj2 === "undefined") {
    return;
  }
  if (typeof obj2 !== "object") {
    obj2 = [obj2];
  }
  if (isArray$1(obj2)) {
    for (var i = 0, l = obj2.length; i < l; i++) {
      fn.call(null, obj2[i], i, obj2);
    }
  } else {
    for (var key3 in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, key3)) {
        fn.call(null, obj2[key3], key3, obj2);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue(val, key3) {
    if (isPlainObject$1(result[key3]) && isPlainObject$1(val)) {
      result[key3] = merge$1(result[key3], val);
    } else if (isPlainObject$1(val)) {
      result[key3] = merge$1({}, val);
    } else if (isArray$1(val)) {
      result[key3] = val.slice();
    } else {
      result[key3] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach$1(arguments[i], assignValue);
  }
  return result;
}
function extend$1(a, b, thisArg) {
  forEach$1(b, function assignValue(val, key3) {
    if (thisArg && typeof val === "function") {
      a[key3] = bind$4(val, thisArg);
    } else {
      a[key3] = val;
    }
  });
  return a;
}
function stripBOM$1(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
function inherits$w(constructor, superConstructor, props, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}
function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};
  destObj = destObj || {};
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}
function endsWith$1(str, searchString, position) {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}
function toArray$2(thing) {
  if (!thing)
    return null;
  var i = thing.length;
  if (isUndefined$1(i))
    return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}
var isTypedArray$1 = function(TypedArray) {
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
var utils$S = {
  isArray: isArray$1,
  isArrayBuffer: isArrayBuffer$1,
  isBuffer: isBuffer$1,
  isFormData: isFormData$1,
  isArrayBufferView: isArrayBufferView$1,
  isString: isString$1,
  isNumber: isNumber$1,
  isObject: isObject$1,
  isPlainObject: isPlainObject$1,
  isUndefined: isUndefined$1,
  isDate: isDate$1,
  isFile: isFile$1,
  isBlob: isBlob$1,
  isFunction: isFunction$1,
  isStream: isStream$2,
  isURLSearchParams: isURLSearchParams$1,
  isStandardBrowserEnv: isStandardBrowserEnv$1,
  forEach: forEach$1,
  merge: merge$1,
  extend: extend$1,
  trim: trim$1,
  stripBOM: stripBOM$1,
  inherits: inherits$w,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith: endsWith$1,
  toArray: toArray$2,
  isTypedArray: isTypedArray$1,
  isFileList
};
var utils$R = utils$S;
function encode$9(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$3 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$R.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$R.forEach(params, function serialize2(val, key3) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$R.isArray(val)) {
        key3 = key3 + "[]";
      } else {
        val = [val];
      }
      utils$R.forEach(val, function parseValue(v) {
        if (utils$R.isDate(v)) {
          v = v.toISOString();
        } else if (utils$R.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode$9(key3) + "=" + encode$9(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$Q = utils$S;
function InterceptorManager$3() {
  this.handlers = [];
}
InterceptorManager$3.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$3.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$3.prototype.forEach = function forEach(fn) {
  utils$Q.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};
var InterceptorManager_1$1 = InterceptorManager$3;
var utils$P = utils$S;
var normalizeHeaderName$3 = function normalizeHeaderName(headers, normalizedName) {
  utils$P.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var utils$O = utils$S;
function AxiosError$2(message, code2, config2, request3, response) {
  Error.call(this);
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request3 && (this.request = request3);
  response && (this.response = response);
}
utils$O.inherits(AxiosError$2, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError$2.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED"
].forEach(function(code2) {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$2, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError$2.from = function(error3, code2, config2, request3, response, customProps) {
  var axiosError = Object.create(prototype);
  utils$O.toFlatObject(error3, axiosError, function filter(obj2) {
    return obj2 !== Error.prototype;
  });
  AxiosError$2.call(axiosError, error3.message, code2, config2, request3, response);
  axiosError.name = error3.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_1 = AxiosError$2;
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var utils$N = utils$S;
function toFormData$1(obj2, formData) {
  formData = formData || new FormData();
  var stack = [];
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$N.isDate(value)) {
      return value.toISOString();
    }
    if (utils$N.isArrayBuffer(value) || utils$N.isTypedArray(value)) {
      return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function build(data2, parentKey) {
    if (utils$N.isPlainObject(data2) || utils$N.isArray(data2)) {
      if (stack.indexOf(data2) !== -1) {
        throw Error("Circular reference detected in " + parentKey);
      }
      stack.push(data2);
      utils$N.forEach(data2, function each(value, key3) {
        if (utils$N.isUndefined(value))
          return;
        var fullKey = parentKey ? parentKey + "." + key3 : key3;
        var arr;
        if (value && !parentKey && typeof value === "object") {
          if (utils$N.endsWith(key3, "{}")) {
            value = JSON.stringify(value);
          } else if (utils$N.endsWith(key3, "[]") && (arr = utils$N.toArray(value))) {
            arr.forEach(function(el) {
              !utils$N.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }
        build(value, fullKey);
      });
      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data2));
    }
  }
  build(obj2);
  return formData;
}
var toFormData_1 = toFormData$1;
var settle$1;
var hasRequiredSettle$1;
function requireSettle$1() {
  if (hasRequiredSettle$1)
    return settle$1;
  hasRequiredSettle$1 = 1;
  var AxiosError2 = AxiosError_1;
  settle$1 = function settle2(resolve, reject, response) {
    var validateStatus3 = response.config.validateStatus;
    if (!response.status || !validateStatus3 || validateStatus3(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError2(
        "Request failed with status code " + response.status,
        [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle$1;
}
var cookies$1;
var hasRequiredCookies$1;
function requireCookies$1() {
  if (hasRequiredCookies$1)
    return cookies$1;
  hasRequiredCookies$1 = 1;
  var utils2 = utils$S;
  cookies$1 = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path3, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path3)) {
          cookie.push("path=" + path3);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  return cookies$1;
}
var isAbsoluteURL$2 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};
var combineURLs$2 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL$1 = isAbsoluteURL$2;
var combineURLs$1 = combineURLs$2;
var buildFullPath$2 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL$1(requestedURL)) {
    return combineURLs$1(baseURL, requestedURL);
  }
  return requestedURL;
};
var parseHeaders$1;
var hasRequiredParseHeaders$1;
function requireParseHeaders$1() {
  if (hasRequiredParseHeaders$1)
    return parseHeaders$1;
  hasRequiredParseHeaders$1 = 1;
  var utils2 = utils$S;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders$1 = function parseHeaders2(headers) {
    var parsed = {};
    var key3;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser2(line) {
      i = line.indexOf(":");
      key3 = utils2.trim(line.substr(0, i)).toLowerCase();
      val = utils2.trim(line.substr(i + 1));
      if (key3) {
        if (parsed[key3] && ignoreDuplicateOf.indexOf(key3) >= 0) {
          return;
        }
        if (key3 === "set-cookie") {
          parsed[key3] = (parsed[key3] ? parsed[key3] : []).concat([val]);
        } else {
          parsed[key3] = parsed[key3] ? parsed[key3] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders$1;
}
var isURLSameOrigin$1;
var hasRequiredIsURLSameOrigin$1;
function requireIsURLSameOrigin$1() {
  if (hasRequiredIsURLSameOrigin$1)
    return isURLSameOrigin$1;
  hasRequiredIsURLSameOrigin$1 = 1;
  var utils2 = utils$S;
  isURLSameOrigin$1 = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin$1;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError2 = AxiosError_1;
  var utils2 = utils$S;
  function CanceledError2(message) {
    AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError2, AxiosError2, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError2;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol)
    return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  };
  return parseProtocol;
}
var xhr$1;
var hasRequiredXhr$1;
function requireXhr$1() {
  if (hasRequiredXhr$1)
    return xhr$1;
  hasRequiredXhr$1 = 1;
  var utils2 = utils$S;
  var settle2 = requireSettle$1();
  var cookies2 = requireCookies$1();
  var buildURL4 = buildURL$3;
  var buildFullPath3 = buildFullPath$2;
  var parseHeaders2 = requireParseHeaders$1();
  var isURLSameOrigin2 = requireIsURLSameOrigin$1();
  var transitionalDefaults2 = transitional;
  var AxiosError2 = AxiosError_1;
  var CanceledError2 = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  xhr$1 = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      var responseType = config2.responseType;
      var onCanceled;
      function done2() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request3 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath3(config2.baseURL, config2.url);
      request3.open(config2.method.toUpperCase(), buildURL4(fullPath, config2.params, config2.paramsSerializer), true);
      request3.timeout = config2.timeout;
      function onloadend() {
        if (!request3) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders2(request3.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
        var response = {
          data: responseData,
          status: request3.status,
          statusText: request3.statusText,
          headers: responseHeaders,
          config: config2,
          request: request3
        };
        settle2(function _resolve(value) {
          resolve(value);
          done2();
        }, function _reject(err) {
          reject(err);
          done2();
        }, response);
        request3 = null;
      }
      if ("onloadend" in request3) {
        request3.onloadend = onloadend;
      } else {
        request3.onreadystatechange = function handleLoad() {
          if (!request3 || request3.readyState !== 4) {
            return;
          }
          if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request3.onabort = function handleAbort() {
        if (!request3) {
          return;
        }
        reject(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config2, request3));
        request3 = null;
      };
      request3.onerror = function handleError2() {
        reject(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config2, request3, request3));
        request3 = null;
      };
      request3.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        var transitional4 = config2.transitional || transitionalDefaults2;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError2(
          timeoutErrorMessage,
          transitional4.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
          config2,
          request3
        ));
        request3 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request3) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key3) {
          if (typeof requestData === "undefined" && key3.toLowerCase() === "content-type") {
            delete requestHeaders[key3];
          } else {
            request3.setRequestHeader(key3, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request3.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request3.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request3.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request3.upload) {
        request3.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = function(cancel) {
          if (!request3) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError2() : cancel);
          request3.abort();
          request3 = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config2));
        return;
      }
      request3.send(requestData);
    });
  };
  return xhr$1;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null)
    return _null;
  hasRequired_null = 1;
  _null = null;
  return _null;
}
var utils$M = utils$S;
var normalizeHeaderName$2 = normalizeHeaderName$3;
var AxiosError$1 = AxiosError_1;
var transitionalDefaults = transitional;
var toFormData = toFormData_1;
var DEFAULT_CONTENT_TYPE$1 = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset$1(headers, value) {
  if (!utils$M.isUndefined(headers) && utils$M.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter$1() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr$1();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr$1();
  }
  return adapter;
}
function stringifySafely$1(rawValue, parser2, encoder) {
  if (utils$M.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$M.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$7 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter$1(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName$2(headers, "Accept");
    normalizeHeaderName$2(headers, "Content-Type");
    if (utils$M.isFormData(data2) || utils$M.isArrayBuffer(data2) || utils$M.isBuffer(data2) || utils$M.isStream(data2) || utils$M.isFile(data2) || utils$M.isBlob(data2)) {
      return data2;
    }
    if (utils$M.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$M.isURLSearchParams(data2)) {
      setContentTypeIfUnset$1(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    var isObjectPayload = utils$M.isObject(data2);
    var contentType = headers && headers["Content-Type"];
    var isFileList2;
    if ((isFileList2 = utils$M.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === "application/json") {
      setContentTypeIfUnset$1(headers, "application/json");
      return stringifySafely$1(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional4 = this.transitional || defaults$7.transitional;
    var silentJSONParsing = transitional4 && transitional4.silentJSONParsing;
    var forcedJSONParsing = transitional4 && transitional4.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$M.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: require_null()
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$M.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$7.headers[method] = {};
});
utils$M.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$7.headers[method] = utils$M.merge(DEFAULT_CONTENT_TYPE$1);
});
var defaults_1$1 = defaults$7;
var utils$L = utils$S;
var defaults$6 = defaults_1$1;
var transformData$3 = function transformData(data2, headers, fns) {
  var context = this || defaults$6;
  utils$L.forEach(fns, function transform(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel$3;
var hasRequiredIsCancel$1;
function requireIsCancel$1() {
  if (hasRequiredIsCancel$1)
    return isCancel$3;
  hasRequiredIsCancel$1 = 1;
  isCancel$3 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$3;
}
var utils$K = utils$S;
var transformData$2 = transformData$3;
var isCancel$2 = requireIsCancel$1();
var defaults$5 = defaults_1$1;
var CanceledError = requireCanceledError();
function throwIfCancellationRequested$1(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError();
  }
}
var dispatchRequest$3 = function dispatchRequest(config2) {
  throwIfCancellationRequested$1(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData$2.call(
    config2,
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$K.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$K.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$5.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested$1(config2);
    response.data = transformData$2.call(
      config2,
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$2(reason)) {
      throwIfCancellationRequested$1(config2);
      if (reason && reason.response) {
        reason.response.data = transformData$2.call(
          config2,
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$J = utils$S;
var mergeConfig$5 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  function getMergedValue(target, source) {
    if (utils$J.isPlainObject(target) && utils$J.isPlainObject(source)) {
      return utils$J.merge(target, source);
    } else if (utils$J.isPlainObject(source)) {
      return utils$J.merge({}, source);
    } else if (utils$J.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$J.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$J.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$J.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$J.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$J.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$J.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$J.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
};
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.27.2"
  };
  return data;
}
var VERSION = requireData().version;
var AxiosError = AxiosError_1;
var validators$3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
  validators$3[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings$1 = {};
validators$3.transitional = function transitional2(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings$1[opt]) {
      deprecatedWarnings$1[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions$1(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys2 = Object.keys(options);
  var i = keys2.length;
  while (i-- > 0) {
    var opt = keys2[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator$3 = {
  assertOptions: assertOptions$1,
  validators: validators$3
};
var utils$I = utils$S;
var buildURL$2 = buildURL$3;
var InterceptorManager$2 = InterceptorManager_1$1;
var dispatchRequest$2 = dispatchRequest$3;
var mergeConfig$4 = mergeConfig$5;
var buildFullPath$1 = buildFullPath$2;
var validator$2 = validator$3;
var validators$2 = validator$2.validators;
function Axios$3(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager$2(),
    response: new InterceptorManager$2()
  };
}
Axios$3.prototype.request = function request(configOrUrl, config2) {
  if (typeof configOrUrl === "string") {
    config2 = config2 || {};
    config2.url = configOrUrl;
  } else {
    config2 = configOrUrl || {};
  }
  config2 = mergeConfig$4(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional4 = config2.transitional;
  if (transitional4 !== void 0) {
    validator$2.assertOptions(transitional4, {
      silentJSONParsing: validators$2.transitional(validators$2.boolean),
      forcedJSONParsing: validators$2.transitional(validators$2.boolean),
      clarifyTimeoutError: validators$2.transitional(validators$2.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest$2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error3) {
      onRejected(error3);
      break;
    }
  }
  try {
    promise = dispatchRequest$2(newConfig);
  } catch (error3) {
    return Promise.reject(error3);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$3.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$4(this.defaults, config2);
  var fullPath = buildFullPath$1(config2.baseURL, config2.url);
  return buildURL$2(fullPath, config2.params, config2.paramsSerializer);
};
utils$I.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$3.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$4(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$I.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config2) {
      return this.request(mergeConfig$4(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios$3.prototype[method] = generateHTTPMethod();
  Axios$3.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_1$1 = Axios$3;
var CancelToken_1$1;
var hasRequiredCancelToken$1;
function requireCancelToken$1() {
  if (hasRequiredCancelToken$1)
    return CancelToken_1$1;
  hasRequiredCancelToken$1 = 1;
  var CanceledError2 = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise2;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise2 = resolve;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i;
      var l = token._listeners.length;
      for (i = 0; i < l; i++) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError2(message);
      resolvePromise2(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  CancelToken_1$1 = CancelToken;
  return CancelToken_1$1;
}
var spread$1;
var hasRequiredSpread$1;
function requireSpread$1() {
  if (hasRequiredSpread$1)
    return spread$1;
  hasRequiredSpread$1 = 1;
  spread$1 = function spread2(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread$1;
}
var isAxiosError$1;
var hasRequiredIsAxiosError$1;
function requireIsAxiosError$1() {
  if (hasRequiredIsAxiosError$1)
    return isAxiosError$1;
  hasRequiredIsAxiosError$1 = 1;
  var utils2 = utils$S;
  isAxiosError$1 = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError$1;
}
var utils$H = utils$S;
var bind$3 = bind$5;
var Axios$2 = Axios_1$1;
var mergeConfig$3 = mergeConfig$5;
var defaults$4 = defaults_1$1;
function createInstance$1(defaultConfig) {
  var context = new Axios$2(defaultConfig);
  var instance2 = bind$3(Axios$2.prototype.request, context);
  utils$H.extend(instance2, Axios$2.prototype, context);
  utils$H.extend(instance2, context);
  instance2.create = function create5(instanceConfig) {
    return createInstance$1(mergeConfig$3(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios$4 = createInstance$1(defaults$4);
axios$4.Axios = Axios$2;
axios$4.CanceledError = requireCanceledError();
axios$4.CancelToken = requireCancelToken$1();
axios$4.isCancel = requireIsCancel$1();
axios$4.VERSION = requireData().version;
axios$4.toFormData = toFormData_1;
axios$4.AxiosError = AxiosError_1;
axios$4.Cancel = axios$4.CanceledError;
axios$4.all = function all(promises) {
  return Promise.all(promises);
};
axios$4.spread = requireSpread$1();
axios$4.isAxiosError = requireIsAxiosError$1();
axios$5.exports = axios$4;
axios$5.exports.default = axios$4;
(function(module) {
  module.exports = axios$5.exports;
})(axios$6);
const axios$3 = /* @__PURE__ */ getDefaultExportFromCjs(axios$6.exports);
Object.defineProperty(api$2, "__esModule", { value: true });
const axios_1 = axios$6.exports;
class Api {
  constructor(config2) {
    this.METHOD_GET = "GET";
    this.METHOD_POST = "POST";
    this.applyConfig(config2);
  }
  applyConfig(config2) {
    this.config = this.mergeDefaults(config2);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(config2) {
    const protocol = config2.protocol || "http";
    const port = config2.port || (protocol === "https" ? 443 : 80);
    return {
      host: config2.host || "127.0.0.1",
      protocol,
      port,
      timeout: config2.timeout || 2e4,
      logging: config2.logging || false,
      logger: config2.logger || console.log,
      network: config2.network
    };
  }
  async get(endpoint, config2) {
    try {
      return await this.request().get(endpoint, config2);
    } catch (error3) {
      if (error3.response && error3.response.status) {
        return error3.response;
      }
      throw error3;
    }
  }
  async post(endpoint, body, config2) {
    try {
      return await this.request().post(endpoint, body, config2);
    } catch (error3) {
      if (error3.response && error3.response.status) {
        return error3.response;
      }
      throw error3;
    }
  }
  request() {
    const headers = {};
    if (this.config.network) {
      headers["x-network"] = this.config.network;
    }
    let instance2 = axios_1.default.create({
      baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`,
      timeout: this.config.timeout,
      maxContentLength: 1024 * 1024 * 512,
      headers
    });
    if (this.config.logging) {
      instance2.interceptors.request.use((request3) => {
        this.config.logger(`Requesting: ${request3.baseURL}/${request3.url}`);
        return request3;
      });
      instance2.interceptors.response.use((response) => {
        this.config.logger(`Response:   ${response.config.url} - ${response.status}`);
        return response;
      });
    }
    return instance2;
  }
}
api$2.default = Api;
var webcryptoDriver = {};
var utils$G = {};
var util$5 = {};
var types$4 = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1)
    return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj2 = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj2[sym] = symVal;
    for (sym in obj2) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj2).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj2).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj2);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj2, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj2, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var implementation$3;
var hasRequiredImplementation$3;
function requireImplementation$3() {
  if (hasRequiredImplementation$3)
    return implementation$3;
  hasRequiredImplementation$3 = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  implementation$3 = function bind4(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          args.concat(slice.call(arguments))
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(
          that,
          args.concat(slice.call(arguments))
        );
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation$3;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation$3();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var src$3;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src$3;
  hasRequiredSrc = 1;
  var bind4 = requireFunctionBind();
  src$3 = bind4.call(Function.call, Object.prototype.hasOwnProperty);
  return src$3;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto = Object.getPrototypeOf || function(x) {
    return x.__proto__;
  };
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  var doEval = function doEval2(name2) {
    var value;
    if (name2 === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name2 === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name2 === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name2 === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name2 === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name2] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind4 = requireFunctionBind();
  var hasOwn = requireSrc();
  var $concat = bind4.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind4.call(Function.apply, Array.prototype.splice);
  var $replace = bind4.call(Function.call, String.prototype.replace);
  var $strSlice = bind4.call(Function.call, String.prototype.slice);
  var $exec = bind4.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first = $strSlice(string2, 0, 1);
    var last = $strSlice(string2, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
    var intrinsicName = name2;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name2, allowMissing) {
    if (typeof name2 !== "string" || name2.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/g, name2) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name2);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind)
    return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var bind4 = requireFunctionBind();
    var GetIntrinsic = requireGetIntrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind4.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind2(originalFunction) {
      var func = $reflectApply(bind4, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind4, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name2, allowMissing) {
    var intrinsic = GetIntrinsic(name2, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments$1;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1)
    return isArguments$1;
  hasRequiredIsArguments$1 = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments$1;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var toStr = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag = requireShams()();
  var getProto = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var GeneratorFunction;
  isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex.test(fnToStr.call(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr.call(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_) {
      if (_ !== isCallableMarker) {
        reflectApply = null;
      }
    }
  } else {
    reflectApply = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
  isCallable = reflectApply ? function isCallable2(value) {
    if (value === documentDotAll) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (typeof value === "function" && !value.prototype) {
      return true;
    }
    try {
      reflectApply(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value);
  } : function isCallable2(value) {
    if (value === documentDotAll) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (typeof value === "function" && !value.prototype) {
      return true;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    return strClass === fnClass || strClass === genClass;
  };
  return isCallable;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (hasOwnProperty.call(array, i)) {
        if (receiver == null) {
          iterator(array[i], i, array);
        } else {
          iterator.call(receiver, array[i], i, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string2, iterator, receiver) {
    for (var i = 0, len = string2.length; i < len; i++) {
      if (receiver == null) {
        iterator(string2.charAt(i), i, string2);
      } else {
        iterator.call(receiver, string2.charAt(i), i, string2);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object) {
      if (hasOwnProperty.call(object, k)) {
        if (receiver == null) {
          iterator(object[k], k, object);
        } else {
          iterator.call(receiver, object[k], k, object);
        }
      }
    }
  };
  var forEach4 = function forEach5(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (toStr.call(list) === "[object Array]") {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  forEach_1 = forEach4;
  return forEach_1;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ];
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i = 0; i < possibleNames.length; i++) {
      if (typeof g[possibleNames[i]] === "function") {
        out[out.length] = possibleNames[i];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var getOwnPropertyDescriptor;
var hasRequiredGetOwnPropertyDescriptor;
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor)
    return getOwnPropertyDescriptor;
  hasRequiredGetOwnPropertyDescriptor = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  getOwnPropertyDescriptor = $gOPD;
  return getOwnPropertyDescriptor;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var forEach4 = requireForEach();
  var availableTypedArrays2 = requireAvailableTypedArrays();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var $slice = callBound2("String.prototype.slice");
  var toStrTags = {};
  var gOPD = requireGetOwnPropertyDescriptor();
  var getPrototypeOf = Object.getPrototypeOf;
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach4(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto2 = getPrototypeOf(arr);
        var descriptor = gOPD(proto2, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto2);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    forEach4(toStrTags, function(getter, typedArray) {
      if (!anyTrue) {
        try {
          anyTrue = getter.call(value) === typedArray;
        } catch (e) {
        }
      }
    });
    return anyTrue;
  };
  isTypedArray = function isTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
      var tag = $slice($toString(value), 8, -1);
      return $indexOf(typedArrays, tag) > -1;
    }
    if (!gOPD) {
      return false;
    }
    return tryTypedArrays(value);
  };
  return isTypedArray;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach4 = requireForEach();
  var availableTypedArrays2 = requireAvailableTypedArrays();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var toStrTags = {};
  var gOPD = requireGetOwnPropertyDescriptor();
  var getPrototypeOf = Object.getPrototypeOf;
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach4(typedArrays, function(typedArray) {
      if (typeof g[typedArray] === "function") {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto2 = getPrototypeOf(arr);
          var descriptor = gOPD(proto2, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto2);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach4(toStrTags, function(getter, typedArray) {
      if (!foundName) {
        try {
          var name2 = getter.call(value);
          if (name2 === typedArray) {
            foundName = name2;
          }
        } catch (e) {
        }
      }
    });
    return foundName;
  };
  var isTypedArray2 = requireIsTypedArray();
  whichTypedArray = function whichTypedArray2(value) {
    if (!isTypedArray2(value)) {
      return false;
    }
    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
      return $slice($toString(value), 8, -1);
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types$4;
  hasRequiredTypes = 1;
  (function(exports2) {
    var isArgumentsObject = requireIsArguments$1();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = requireWhichTypedArray();
    var isTypedArray2 = requireIsTypedArray();
    function uncurryThis(f2) {
      return f2.call.bind(f2);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction2;
    exports2.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView2(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView2;
    function isUint8Array2(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array2;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer2(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer2;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer2(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types$4);
  return types$4;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser)
    return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer2(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var inherits_browser$1 = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser)
    return inherits_browser$1.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser$1.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser$1.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser$1.exports;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$5;
  hasRequiredUtil = 1;
  (function(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj2) {
      var keys2 = Object.keys(obj2);
      var descriptors2 = {};
      for (var i = 0; i < keys2.length; i++) {
        descriptors2[keys2[i]] = Object.getOwnPropertyDescriptor(obj2, keys2[i]);
      }
      return descriptors2;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f2) {
      if (!isString2(f2)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect9(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f2).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject2(x)) {
          str += " " + x;
        } else {
          str += " " + inspect9(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if ({}.NODE_DEBUG) {
      var debugEnv = {}.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect9(obj2, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined2(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined2(ctx.depth))
        ctx.depth = 2;
      if (isUndefined2(ctx.colors))
        ctx.colors = false;
      if (isUndefined2(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj2, ctx.depth);
    }
    exports2.inspect = inspect9;
    inspect9.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect9.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect9.styles[styleType];
      if (style) {
        return "\x1B[" + inspect9.colors[style][0] + "m" + str + "\x1B[" + inspect9.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash3 = {};
      array.forEach(function(val, idx) {
        hash3[val] = true;
      });
      return hash3;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError3(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction2(value)) {
          var name2 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate2(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError3(value)) {
          return formatError(value);
        }
      }
      var base3 = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n = value.name ? ": " + value.name : "";
        base3 = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base3 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate2(value)) {
        base3 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError3(value)) {
        base3 = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base3 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
      } else {
        output = keys2.map(function(key3) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key3, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base3, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined2(value))
        return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber2(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys2.forEach(function(key3) {
        if (!key3.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key3,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key3, array) {
      var name2, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key3) || { value: value[key3] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key3)) {
        name2 = "[" + key3 + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined2(name2)) {
        if (array && key3.match(/^\d+$/)) {
          return str;
        }
        name2 = JSON.stringify("" + key3);
        if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name2 = name2.substr(1, name2.length - 2);
          name2 = ctx.stylize(name2, "name");
        } else {
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name2 = ctx.stylize(name2, "string");
        }
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString(output, base3, braces) {
      var length2 = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0)
          ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length2 > 60) {
        return braces[0] + (base3 === "" ? "" : base3 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base3 + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = requireTypes();
    function isArray2(ar2) {
      return Array.isArray(ar2);
    }
    exports2.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber2;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined2;
    function isRegExp(re) {
      return isObject2(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate2(d) {
      return isObject2(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate2;
    exports2.types.isDate = isDate2;
    function isError3(e) {
      return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError3;
    exports2.types.isNativeError = isError3;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = requireIsBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad3(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = new Date();
      var time = [
        pad3(d.getHours()),
        pad3(d.getMinutes()),
        pad3(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = requireInherits_browser();
    exports2._extend = function(origin, add7) {
      if (!add7 || !isObject2(add7))
        return origin;
      var keys2 = Object.keys(add7);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add7[keys2[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj2, prop) {
      return Object.prototype.hasOwnProperty.call(obj2, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  })(util$5);
  return util$5;
}
Object.defineProperty(utils$G, "__esModule", { value: true });
utils$G.b64UrlDecode = utils$G.b64UrlEncode = utils$G.bufferTob64Url = utils$G.bufferTob64 = utils$G.b64UrlToBuffer = utils$G.stringToB64Url = utils$G.stringToBuffer = utils$G.bufferToString = utils$G.b64UrlToString = utils$G.concatBuffers = void 0;
const B64js$1 = base64Js;
function concatBuffers$2(buffers) {
  let total_length = 0;
  for (let i = 0; i < buffers.length; i++) {
    total_length += buffers[i].byteLength;
  }
  let temp = new Uint8Array(total_length);
  let offset = 0;
  temp.set(new Uint8Array(buffers[0]), offset);
  offset += buffers[0].byteLength;
  for (let i = 1; i < buffers.length; i++) {
    temp.set(new Uint8Array(buffers[i]), offset);
    offset += buffers[i].byteLength;
  }
  return temp;
}
utils$G.concatBuffers = concatBuffers$2;
function b64UrlToString$2(b64UrlString) {
  let buffer2 = b64UrlToBuffer$2(b64UrlString);
  return bufferToString$2(buffer2);
}
utils$G.b64UrlToString = b64UrlToString$2;
function bufferToString$2(buffer2) {
  if (typeof TextDecoder == "undefined") {
    const TextDecoder2 = requireUtil().TextDecoder;
    return new TextDecoder2("utf-8", { fatal: true }).decode(buffer2);
  }
  return new TextDecoder("utf-8", { fatal: true }).decode(buffer2);
}
utils$G.bufferToString = bufferToString$2;
function stringToBuffer$2(string2) {
  if (typeof TextEncoder == "undefined") {
    const TextEncoder2 = requireUtil().TextEncoder;
    return new TextEncoder2().encode(string2);
  }
  return new TextEncoder().encode(string2);
}
utils$G.stringToBuffer = stringToBuffer$2;
function stringToB64Url$2(string2) {
  return bufferTob64Url$2(stringToBuffer$2(string2));
}
utils$G.stringToB64Url = stringToB64Url$2;
function b64UrlToBuffer$2(b64UrlString) {
  return new Uint8Array(B64js$1.toByteArray(b64UrlDecode$2(b64UrlString)));
}
utils$G.b64UrlToBuffer = b64UrlToBuffer$2;
function bufferTob64$2(buffer2) {
  return B64js$1.fromByteArray(new Uint8Array(buffer2));
}
utils$G.bufferTob64 = bufferTob64$2;
function bufferTob64Url$2(buffer2) {
  return b64UrlEncode$2(bufferTob64$2(buffer2));
}
utils$G.bufferTob64Url = bufferTob64Url$2;
function b64UrlEncode$2(b64UrlString) {
  return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
utils$G.b64UrlEncode = b64UrlEncode$2;
function b64UrlDecode$2(b64UrlString) {
  b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
  let padding2;
  b64UrlString.length % 4 == 0 ? padding2 = 0 : padding2 = 4 - b64UrlString.length % 4;
  return b64UrlString.concat("=".repeat(padding2));
}
utils$G.b64UrlDecode = b64UrlDecode$2;
Object.defineProperty(webcryptoDriver, "__esModule", { value: true });
const ArweaveUtils$3 = utils$G;
class WebCryptoDriver {
  constructor() {
    this.keyLength = 4096;
    this.publicExponent = 65537;
    this.hashAlgorithm = "sha256";
    if (!this.detectWebCrypto()) {
      throw new Error("SubtleCrypto not available!");
    }
    this.driver = crypto.subtle;
  }
  async generateJWK() {
    let cryptoKey = await this.driver.generateKey({
      name: "RSA-PSS",
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: {
        name: "SHA-256"
      }
    }, true, ["sign"]);
    let jwk = await this.driver.exportKey("jwk", cryptoKey.privateKey);
    return {
      kty: jwk.kty,
      e: jwk.e,
      n: jwk.n,
      d: jwk.d,
      p: jwk.p,
      q: jwk.q,
      dp: jwk.dp,
      dq: jwk.dq,
      qi: jwk.qi
    };
  }
  async sign(jwk, data2, { saltLength } = {}) {
    let signature2 = await this.driver.sign({
      name: "RSA-PSS",
      saltLength: 32
    }, await this.jwkToCryptoKey(jwk), data2);
    return new Uint8Array(signature2);
  }
  async hash(data2, algorithm = "SHA-256") {
    let digest10 = await this.driver.digest(algorithm, data2);
    return new Uint8Array(digest10);
  }
  async verify(publicModulus, data2, signature2) {
    const publicKey = {
      kty: "RSA",
      e: "AQAB",
      n: publicModulus
    };
    const key3 = await this.jwkToPublicCryptoKey(publicKey);
    const verifyWith32 = this.driver.verify({
      name: "RSA-PSS",
      saltLength: 32
    }, key3, signature2, data2);
    const verifyWith0 = this.driver.verify({
      name: "RSA-PSS",
      saltLength: 0
    }, key3, signature2, data2);
    return verifyWith32 || verifyWith0;
  }
  async jwkToCryptoKey(jwk) {
    return this.driver.importKey("jwk", jwk, {
      name: "RSA-PSS",
      hash: {
        name: "SHA-256"
      }
    }, false, ["sign"]);
  }
  async jwkToPublicCryptoKey(publicJwk) {
    return this.driver.importKey("jwk", publicJwk, {
      name: "RSA-PSS",
      hash: {
        name: "SHA-256"
      }
    }, false, ["verify"]);
  }
  detectWebCrypto() {
    if (typeof crypto === "undefined") {
      return false;
    }
    const subtle2 = crypto === null || crypto === void 0 ? void 0 : crypto.subtle;
    if (subtle2 === void 0) {
      return false;
    }
    const names2 = [
      "generateKey",
      "importKey",
      "exportKey",
      "digest",
      "sign"
    ];
    return names2.every((name2) => typeof subtle2[name2] === "function");
  }
  async encrypt(data2, key3, salt) {
    const initialKey = await this.driver.importKey("raw", typeof key3 == "string" ? ArweaveUtils$3.stringToBuffer(key3) : key3, {
      name: "PBKDF2",
      length: 32
    }, false, ["deriveKey"]);
    const derivedkey = await this.driver.deriveKey({
      name: "PBKDF2",
      salt: salt ? ArweaveUtils$3.stringToBuffer(salt) : ArweaveUtils$3.stringToBuffer("salt"),
      iterations: 1e5,
      hash: "SHA-256"
    }, initialKey, {
      name: "AES-CBC",
      length: 256
    }, false, ["encrypt", "decrypt"]);
    const iv = new Uint8Array(16);
    crypto.getRandomValues(iv);
    const encryptedData = await this.driver.encrypt({
      name: "AES-CBC",
      iv
    }, derivedkey, data2);
    return ArweaveUtils$3.concatBuffers([iv, encryptedData]);
  }
  async decrypt(encrypted, key3, salt) {
    const initialKey = await this.driver.importKey("raw", typeof key3 == "string" ? ArweaveUtils$3.stringToBuffer(key3) : key3, {
      name: "PBKDF2",
      length: 32
    }, false, ["deriveKey"]);
    const derivedkey = await this.driver.deriveKey({
      name: "PBKDF2",
      salt: salt ? ArweaveUtils$3.stringToBuffer(salt) : ArweaveUtils$3.stringToBuffer("salt"),
      iterations: 1e5,
      hash: "SHA-256"
    }, initialKey, {
      name: "AES-CBC",
      length: 256
    }, false, ["encrypt", "decrypt"]);
    const iv = encrypted.slice(0, 16);
    const data2 = await this.driver.decrypt({
      name: "AES-CBC",
      iv
    }, derivedkey, encrypted.slice(16));
    return ArweaveUtils$3.concatBuffers([data2]);
  }
}
webcryptoDriver.default = WebCryptoDriver;
var network = {};
Object.defineProperty(network, "__esModule", { value: true });
class Network {
  constructor(api2) {
    this.api = api2;
  }
  getInfo() {
    return this.api.get(`info`).then((response) => {
      return response.data;
    });
  }
  getPeers() {
    return this.api.get(`peers`).then((response) => {
      return response.data;
    });
  }
}
network.default = Network;
var transactions = {};
var error = {};
Object.defineProperty(error, "__esModule", { value: true });
error.getError = void 0;
class ArweaveError extends Error {
  constructor(type, optional2 = {}) {
    if (optional2.message) {
      super(optional2.message);
    } else {
      super();
    }
    this.type = type;
    this.response = optional2.response;
  }
  getType() {
    return this.type;
  }
}
error.default = ArweaveError;
function getError(resp) {
  let data2 = resp.data;
  if (typeof resp.data === "string") {
    try {
      data2 = JSON.parse(resp.data);
    } catch (e) {
    }
  }
  if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {
    try {
      data2 = JSON.parse(data2.toString());
    } catch (e) {
    }
  }
  return data2 ? data2.error || data2 : resp.statusText || "unknown";
}
error.getError = getError;
var transaction = {};
var deepHash$3 = {};
var hasRequiredDeepHash;
function requireDeepHash() {
  if (hasRequiredDeepHash)
    return deepHash$3;
  hasRequiredDeepHash = 1;
  Object.defineProperty(deepHash$3, "__esModule", { value: true });
  const common_1 = requireCommon();
  async function deepHash2(data2) {
    if (Array.isArray(data2)) {
      const tag2 = common_1.default.utils.concatBuffers([
        common_1.default.utils.stringToBuffer("list"),
        common_1.default.utils.stringToBuffer(data2.length.toString())
      ]);
      return await deepHashChunks2(data2, await common_1.default.crypto.hash(tag2, "SHA-384"));
    }
    const tag = common_1.default.utils.concatBuffers([
      common_1.default.utils.stringToBuffer("blob"),
      common_1.default.utils.stringToBuffer(data2.byteLength.toString())
    ]);
    const taggedHash = common_1.default.utils.concatBuffers([
      await common_1.default.crypto.hash(tag, "SHA-384"),
      await common_1.default.crypto.hash(data2, "SHA-384")
    ]);
    return await common_1.default.crypto.hash(taggedHash, "SHA-384");
  }
  deepHash$3.default = deepHash2;
  async function deepHashChunks2(chunks2, acc) {
    if (chunks2.length < 1) {
      return acc;
    }
    const hashPair = common_1.default.utils.concatBuffers([
      acc,
      await deepHash2(chunks2[0])
    ]);
    const newAcc = await common_1.default.crypto.hash(hashPair, "SHA-384");
    return await deepHashChunks2(chunks2.slice(1), newAcc);
  }
  return deepHash$3;
}
var merkle = {};
var hasRequiredMerkle;
function requireMerkle() {
  if (hasRequiredMerkle)
    return merkle;
  hasRequiredMerkle = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debug = exports2.validatePath = exports2.arrayCompare = exports2.bufferToInt = exports2.intToBuffer = exports2.arrayFlatten = exports2.generateProofs = exports2.buildLayers = exports2.generateTransactionChunks = exports2.generateTree = exports2.computeRootHash = exports2.generateLeaves = exports2.chunkData = exports2.MIN_CHUNK_SIZE = exports2.MAX_CHUNK_SIZE = void 0;
    const common_1 = requireCommon();
    const utils_12 = utils$G;
    exports2.MAX_CHUNK_SIZE = 256 * 1024;
    exports2.MIN_CHUNK_SIZE = 32 * 1024;
    const NOTE_SIZE = 32;
    const HASH_SIZE = 32;
    async function chunkData(data2) {
      let chunks2 = [];
      let rest = data2;
      let cursor = 0;
      while (rest.byteLength >= exports2.MAX_CHUNK_SIZE) {
        let chunkSize = exports2.MAX_CHUNK_SIZE;
        let nextChunkSize = rest.byteLength - exports2.MAX_CHUNK_SIZE;
        if (nextChunkSize > 0 && nextChunkSize < exports2.MIN_CHUNK_SIZE) {
          chunkSize = Math.ceil(rest.byteLength / 2);
        }
        const chunk = rest.slice(0, chunkSize);
        const dataHash = await common_1.default.crypto.hash(chunk);
        cursor += chunk.byteLength;
        chunks2.push({
          dataHash,
          minByteRange: cursor - chunk.byteLength,
          maxByteRange: cursor
        });
        rest = rest.slice(chunkSize);
      }
      chunks2.push({
        dataHash: await common_1.default.crypto.hash(rest),
        minByteRange: cursor,
        maxByteRange: cursor + rest.byteLength
      });
      return chunks2;
    }
    exports2.chunkData = chunkData;
    async function generateLeaves(chunks2) {
      return Promise.all(chunks2.map(async ({ dataHash, minByteRange, maxByteRange }) => {
        return {
          type: "leaf",
          id: await hash3(await Promise.all([hash3(dataHash), hash3(intToBuffer2(maxByteRange))])),
          dataHash,
          minByteRange,
          maxByteRange
        };
      }));
    }
    exports2.generateLeaves = generateLeaves;
    async function computeRootHash(data2) {
      const rootNode = await generateTree(data2);
      return rootNode.id;
    }
    exports2.computeRootHash = computeRootHash;
    async function generateTree(data2) {
      const rootNode = await buildLayers(await generateLeaves(await chunkData(data2)));
      return rootNode;
    }
    exports2.generateTree = generateTree;
    async function generateTransactionChunks2(data2) {
      const chunks2 = await chunkData(data2);
      const leaves = await generateLeaves(chunks2);
      const root = await buildLayers(leaves);
      const proofs = await generateProofs(root);
      const lastChunk = chunks2.slice(-1)[0];
      if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {
        chunks2.splice(chunks2.length - 1, 1);
        proofs.splice(proofs.length - 1, 1);
      }
      return {
        data_root: root.id,
        chunks: chunks2,
        proofs
      };
    }
    exports2.generateTransactionChunks = generateTransactionChunks2;
    async function buildLayers(nodes, level = 0) {
      if (nodes.length < 2) {
        const root = nodes[0];
        return root;
      }
      const nextLayer = [];
      for (let i = 0; i < nodes.length; i += 2) {
        nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));
      }
      return buildLayers(nextLayer, level + 1);
    }
    exports2.buildLayers = buildLayers;
    function generateProofs(root) {
      const proofs = resolveBranchProofs(root);
      if (!Array.isArray(proofs)) {
        return [proofs];
      }
      return arrayFlatten(proofs);
    }
    exports2.generateProofs = generateProofs;
    function resolveBranchProofs(node2, proof = new Uint8Array(), depth = 0) {
      if (node2.type == "leaf") {
        return {
          offset: node2.maxByteRange - 1,
          proof: (0, utils_12.concatBuffers)([
            proof,
            node2.dataHash,
            intToBuffer2(node2.maxByteRange)
          ])
        };
      }
      if (node2.type == "branch") {
        const partialProof = (0, utils_12.concatBuffers)([
          proof,
          node2.leftChild.id,
          node2.rightChild.id,
          intToBuffer2(node2.byteRange)
        ]);
        return [
          resolveBranchProofs(node2.leftChild, partialProof, depth + 1),
          resolveBranchProofs(node2.rightChild, partialProof, depth + 1)
        ];
      }
      throw new Error(`Unexpected node type`);
    }
    function arrayFlatten(input) {
      const flat2 = [];
      input.forEach((item) => {
        if (Array.isArray(item)) {
          flat2.push(...arrayFlatten(item));
        } else {
          flat2.push(item);
        }
      });
      return flat2;
    }
    exports2.arrayFlatten = arrayFlatten;
    async function hashBranch(left, right) {
      if (!right) {
        return left;
      }
      let branch = {
        type: "branch",
        id: await hash3([
          await hash3(left.id),
          await hash3(right.id),
          await hash3(intToBuffer2(left.maxByteRange))
        ]),
        byteRange: left.maxByteRange,
        maxByteRange: right.maxByteRange,
        leftChild: left,
        rightChild: right
      };
      return branch;
    }
    async function hash3(data2) {
      if (Array.isArray(data2)) {
        data2 = common_1.default.utils.concatBuffers(data2);
      }
      return new Uint8Array(await common_1.default.crypto.hash(data2));
    }
    function intToBuffer2(note) {
      const buffer2 = new Uint8Array(NOTE_SIZE);
      for (var i = buffer2.length - 1; i >= 0; i--) {
        var byte = note % 256;
        buffer2[i] = byte;
        note = (note - byte) / 256;
      }
      return buffer2;
    }
    exports2.intToBuffer = intToBuffer2;
    function bufferToInt(buffer2) {
      let value = 0;
      for (var i = 0; i < buffer2.length; i++) {
        value *= 256;
        value += buffer2[i];
      }
      return value;
    }
    exports2.bufferToInt = bufferToInt;
    const arrayCompare = (a, b) => a.every((value, index2) => b[index2] === value);
    exports2.arrayCompare = arrayCompare;
    async function validatePath(id2, dest, leftBound, rightBound, path3) {
      if (rightBound <= 0) {
        return false;
      }
      if (dest >= rightBound) {
        return validatePath(id2, 0, rightBound - 1, rightBound, path3);
      }
      if (dest < 0) {
        return validatePath(id2, 0, 0, rightBound, path3);
      }
      if (path3.length == HASH_SIZE + NOTE_SIZE) {
        const pathData = path3.slice(0, HASH_SIZE);
        const endOffsetBuffer = path3.slice(pathData.length, pathData.length + NOTE_SIZE);
        const pathDataHash = await hash3([
          await hash3(pathData),
          await hash3(endOffsetBuffer)
        ]);
        let result = (0, exports2.arrayCompare)(id2, pathDataHash);
        if (result) {
          return {
            offset: rightBound - 1,
            leftBound,
            rightBound,
            chunkSize: rightBound - leftBound
          };
        }
        return false;
      }
      const left = path3.slice(0, HASH_SIZE);
      const right = path3.slice(left.length, left.length + HASH_SIZE);
      const offsetBuffer = path3.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
      const offset = bufferToInt(offsetBuffer);
      const remainder = path3.slice(left.length + right.length + offsetBuffer.length);
      const pathHash = await hash3([
        await hash3(left),
        await hash3(right),
        await hash3(offsetBuffer)
      ]);
      if ((0, exports2.arrayCompare)(id2, pathHash)) {
        if (dest < offset) {
          return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);
        }
        return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);
      }
      return false;
    }
    exports2.validatePath = validatePath;
    async function debug2(proof, output = "") {
      if (proof.byteLength < 1) {
        return output;
      }
      const left = proof.slice(0, HASH_SIZE);
      const right = proof.slice(left.length, left.length + HASH_SIZE);
      const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
      const offset = bufferToInt(offsetBuffer);
      const remainder = proof.slice(left.length + right.length + offsetBuffer.length);
      const pathHash = await hash3([
        await hash3(left),
        await hash3(right),
        await hash3(offsetBuffer)
      ]);
      const updatedOutput = `${output}
${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
      return debug2(remainder, updatedOutput);
    }
    exports2.debug = debug2;
  })(merkle);
  return merkle;
}
var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction)
    return transaction;
  hasRequiredTransaction = 1;
  Object.defineProperty(transaction, "__esModule", { value: true });
  transaction.Tag = void 0;
  const ArweaveUtils2 = utils$G;
  const deepHash_12 = requireDeepHash();
  const merkle_1 = requireMerkle();
  class BaseObject2 {
    get(field, options) {
      if (!Object.getOwnPropertyNames(this).includes(field)) {
        throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
      }
      if (this[field] instanceof Uint8Array) {
        if (options && options.decode && options.string) {
          return ArweaveUtils2.bufferToString(this[field]);
        }
        if (options && options.decode && !options.string) {
          return this[field];
        }
        return ArweaveUtils2.bufferTob64Url(this[field]);
      }
      if (options && options.decode == true) {
        if (options && options.string) {
          return ArweaveUtils2.b64UrlToString(this[field]);
        }
        return ArweaveUtils2.b64UrlToBuffer(this[field]);
      }
      return this[field];
    }
  }
  class Tag2 extends BaseObject2 {
    constructor(name2, value, decode5 = false) {
      super();
      this.name = name2;
      this.value = value;
    }
  }
  transaction.Tag = Tag2;
  class Transaction2 extends BaseObject2 {
    constructor(attributes = {}) {
      super();
      this.format = 2;
      this.id = "";
      this.last_tx = "";
      this.owner = "";
      this.tags = [];
      this.target = "";
      this.quantity = "0";
      this.data_size = "0";
      this.data = new Uint8Array();
      this.data_root = "";
      this.reward = "0";
      this.signature = "";
      Object.assign(this, attributes);
      if (typeof this.data === "string") {
        this.data = ArweaveUtils2.b64UrlToBuffer(this.data);
      }
      if (attributes.tags) {
        this.tags = attributes.tags.map((tag) => {
          return new Tag2(tag.name, tag.value);
        });
      }
    }
    addTag(name2, value) {
      this.tags.push(new Tag2(ArweaveUtils2.stringToB64Url(name2), ArweaveUtils2.stringToB64Url(value)));
    }
    toJSON() {
      return {
        format: this.format,
        id: this.id,
        last_tx: this.last_tx,
        owner: this.owner,
        tags: this.tags,
        target: this.target,
        quantity: this.quantity,
        data: ArweaveUtils2.bufferTob64Url(this.data),
        data_size: this.data_size,
        data_root: this.data_root,
        data_tree: this.data_tree,
        reward: this.reward,
        signature: this.signature
      };
    }
    setOwner(owner) {
      this.owner = owner;
    }
    setSignature({ id: id2, owner, reward, tags: tags2, signature: signature2 }) {
      this.id = id2;
      this.owner = owner;
      if (reward)
        this.reward = reward;
      if (tags2)
        this.tags = tags2;
      this.signature = signature2;
    }
    async prepareChunks(data2) {
      if (!this.chunks && data2.byteLength > 0) {
        this.chunks = await (0, merkle_1.generateTransactionChunks)(data2);
        this.data_root = ArweaveUtils2.bufferTob64Url(this.chunks.data_root);
      }
      if (!this.chunks && data2.byteLength === 0) {
        this.chunks = {
          chunks: [],
          data_root: new Uint8Array(),
          proofs: []
        };
        this.data_root = "";
      }
    }
    getChunk(idx, data2) {
      if (!this.chunks) {
        throw new Error(`Chunks have not been prepared`);
      }
      const proof = this.chunks.proofs[idx];
      const chunk = this.chunks.chunks[idx];
      return {
        data_root: this.data_root,
        data_size: this.data_size,
        data_path: ArweaveUtils2.bufferTob64Url(proof.proof),
        offset: proof.offset.toString(),
        chunk: ArweaveUtils2.bufferTob64Url(data2.slice(chunk.minByteRange, chunk.maxByteRange))
      };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let tags2 = this.tags.reduce((accumulator, tag) => {
            return ArweaveUtils2.concatBuffers([
              accumulator,
              tag.get("name", { decode: true, string: false }),
              tag.get("value", { decode: true, string: false })
            ]);
          }, new Uint8Array());
          return ArweaveUtils2.concatBuffers([
            this.get("owner", { decode: true, string: false }),
            this.get("target", { decode: true, string: false }),
            this.get("data", { decode: true, string: false }),
            ArweaveUtils2.stringToBuffer(this.quantity),
            ArweaveUtils2.stringToBuffer(this.reward),
            this.get("last_tx", { decode: true, string: false }),
            tags2
          ]);
        case 2:
          if (!this.data_root) {
            await this.prepareChunks(this.data);
          }
          const tagList = this.tags.map((tag) => [
            tag.get("name", { decode: true, string: false }),
            tag.get("value", { decode: true, string: false })
          ]);
          return await (0, deepHash_12.default)([
            ArweaveUtils2.stringToBuffer(this.format.toString()),
            this.get("owner", { decode: true, string: false }),
            this.get("target", { decode: true, string: false }),
            ArweaveUtils2.stringToBuffer(this.quantity),
            ArweaveUtils2.stringToBuffer(this.reward),
            this.get("last_tx", { decode: true, string: false }),
            tagList,
            ArweaveUtils2.stringToBuffer(this.data_size),
            this.get("data_root", { decode: true, string: false })
          ]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }
  transaction.default = Transaction2;
  return transaction;
}
var transactionUploader = {};
var hasRequiredTransactionUploader;
function requireTransactionUploader() {
  if (hasRequiredTransactionUploader)
    return transactionUploader;
  hasRequiredTransactionUploader = 1;
  Object.defineProperty(transactionUploader, "__esModule", { value: true });
  transactionUploader.TransactionUploader = void 0;
  const transaction_1 = requireTransaction();
  const ArweaveUtils2 = utils$G;
  const error_12 = error;
  const merkle_1 = requireMerkle();
  const MAX_CHUNKS_IN_BODY = 1;
  const FATAL_CHUNK_UPLOAD_ERRORS = [
    "invalid_json",
    "chunk_too_big",
    "data_path_too_big",
    "offset_too_big",
    "data_size_too_big",
    "chunk_proof_ratio_not_attractive",
    "invalid_proof"
  ];
  const ERROR_DELAY = 1e3 * 40;
  class TransactionUploader {
    constructor(api2, transaction2) {
      this.api = api2;
      this.chunkIndex = 0;
      this.txPosted = false;
      this.lastRequestTimeEnd = 0;
      this.totalErrors = 0;
      this.lastResponseStatus = 0;
      this.lastResponseError = "";
      if (!transaction2.id) {
        throw new Error(`Transaction is not signed`);
      }
      if (!transaction2.chunks) {
        throw new Error(`Transaction chunks not prepared`);
      }
      this.data = transaction2.data;
      this.transaction = new transaction_1.default(Object.assign({}, transaction2, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    async uploadChunk(chunkIndex_) {
      if (this.isComplete) {
        throw new Error(`Upload is already complete`);
      }
      if (this.lastResponseError !== "") {
        this.totalErrors++;
      } else {
        this.totalErrors = 0;
      }
      if (this.totalErrors === 100) {
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      }
      let delay = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
      if (delay > 0) {
        delay = delay - delay * Math.random() * 0.3;
        await new Promise((res) => setTimeout(res, delay));
      }
      this.lastResponseError = "";
      if (!this.txPosted) {
        await this.postTransaction();
        return;
      }
      if (chunkIndex_) {
        this.chunkIndex = chunkIndex_;
      }
      const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);
      const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils2.b64UrlToBuffer(chunk.data_path));
      if (!chunkOk) {
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      }
      const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch((e) => {
        console.error(e.message);
        return { status: -1, data: { error: e.message } };
      });
      this.lastRequestTimeEnd = Date.now();
      this.lastResponseStatus = resp.status;
      if (this.lastResponseStatus == 200) {
        this.chunkIndex++;
      } else {
        this.lastResponseError = (0, error_12.getError)(resp);
        if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {
          throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
        }
      }
    }
    static async fromSerialized(api2, serialized, data2) {
      if (!serialized || typeof serialized.chunkIndex !== "number" || typeof serialized.transaction !== "object") {
        throw new Error(`Serialized object does not match expected format.`);
      }
      var transaction2 = new transaction_1.default(serialized.transaction);
      if (!transaction2.chunks) {
        await transaction2.prepareChunks(data2);
      }
      const upload = new TransactionUploader(api2, transaction2);
      upload.chunkIndex = serialized.chunkIndex;
      upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;
      upload.lastResponseError = serialized.lastResponseError;
      upload.lastResponseStatus = serialized.lastResponseStatus;
      upload.txPosted = serialized.txPosted;
      upload.data = data2;
      if (upload.transaction.data_root !== serialized.transaction.data_root) {
        throw new Error(`Data mismatch: Uploader doesn't match provided data.`);
      }
      return upload;
    }
    static async fromTransactionId(api2, id2) {
      const resp = await api2.get(`tx/${id2}`);
      if (resp.status !== 200) {
        throw new Error(`Tx ${id2} not found: ${resp.status}`);
      }
      const transaction2 = resp.data;
      transaction2.data = new Uint8Array(0);
      const serialized = {
        txPosted: true,
        chunkIndex: 0,
        lastResponseError: "",
        lastRequestTimeEnd: 0,
        lastResponseStatus: 0,
        transaction: transaction2
      };
      return serialized;
    }
    toJSON() {
      return {
        chunkIndex: this.chunkIndex,
        transaction: this.transaction,
        lastRequestTimeEnd: this.lastRequestTimeEnd,
        lastResponseStatus: this.lastResponseStatus,
        lastResponseError: this.lastResponseError,
        txPosted: this.txPosted
      };
    }
    async postTransaction() {
      const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
      if (uploadInBody) {
        this.transaction.data = this.data;
        const resp2 = await this.api.post(`tx`, this.transaction).catch((e) => {
          console.error(e);
          return { status: -1, data: { error: e.message } };
        });
        this.lastRequestTimeEnd = Date.now();
        this.lastResponseStatus = resp2.status;
        this.transaction.data = new Uint8Array(0);
        if (resp2.status >= 200 && resp2.status < 300) {
          this.txPosted = true;
          this.chunkIndex = MAX_CHUNKS_IN_BODY;
          return;
        }
        this.lastResponseError = (0, error_12.getError)(resp2);
        throw new Error(`Unable to upload transaction: ${resp2.status}, ${this.lastResponseError}`);
      }
      const resp = await this.api.post(`tx`, this.transaction);
      this.lastRequestTimeEnd = Date.now();
      this.lastResponseStatus = resp.status;
      if (!(resp.status >= 200 && resp.status < 300)) {
        this.lastResponseError = (0, error_12.getError)(resp);
        throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
      }
      this.txPosted = true;
    }
  }
  transactionUploader.TransactionUploader = TransactionUploader;
  return transactionUploader;
}
var hasRequiredTransactions;
function requireTransactions() {
  if (hasRequiredTransactions)
    return transactions;
  hasRequiredTransactions = 1;
  var __await = commonjsGlobal && commonjsGlobal.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle2(q[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle2(f2, v) {
      if (f2(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(transactions, "__esModule", { value: true });
  const error_12 = error;
  const transaction_1 = requireTransaction();
  const ArweaveUtils2 = utils$G;
  const transaction_uploader_1 = requireTransactionUploader();
  class Transactions {
    constructor(api2, crypto2, chunks2) {
      this.api = api2;
      this.crypto = crypto2;
      this.chunks = chunks2;
    }
    getTransactionAnchor() {
      return this.api.get(`tx_anchor`, { transformResponse: [] }).then((response) => {
        return response.data;
      });
    }
    getPrice(byteSize, targetAddress) {
      let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
      return this.api.get(endpoint, {
        transformResponse: [
          function(data2) {
            return data2;
          }
        ]
      }).then((response) => {
        return response.data;
      });
    }
    async get(id2) {
      const response = await this.api.get(`tx/${id2}`);
      if (response.status == 200) {
        const data_size = parseInt(response.data.data_size);
        if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {
          const data2 = await this.getData(id2);
          return new transaction_1.default(Object.assign(Object.assign({}, response.data), { data: data2 }));
        }
        return new transaction_1.default(Object.assign(Object.assign({}, response.data), { format: response.data.format || 1 }));
      }
      if (response.status == 404) {
        throw new error_12.default("TX_NOT_FOUND");
      }
      if (response.status == 410) {
        throw new error_12.default("TX_FAILED");
      }
      throw new error_12.default("TX_INVALID");
    }
    fromRaw(attributes) {
      return new transaction_1.default(attributes);
    }
    async search(tagName, tagValue) {
      return this.api.post(`arql`, {
        op: "equals",
        expr1: tagName,
        expr2: tagValue
      }).then((response) => {
        if (!response.data) {
          return [];
        }
        return response.data;
      });
    }
    getStatus(id2) {
      return this.api.get(`tx/${id2}/status`).then((response) => {
        if (response.status == 200) {
          return {
            status: 200,
            confirmed: response.data
          };
        }
        return {
          status: response.status,
          confirmed: null
        };
      });
    }
    async getData(id2, options) {
      let data2 = void 0;
      try {
        data2 = await this.chunks.downloadChunkedData(id2);
      } catch (error3) {
        console.error(`Error while trying to download chunked data for ${id2}`);
        console.error(error3);
      }
      if (!data2) {
        console.warn(`Falling back to gateway cache for ${id2}`);
        try {
          data2 = (await this.api.get(`/${id2}`)).data;
        } catch (error3) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${id2}`);
          console.error(error3);
        }
      }
      if (!data2) {
        throw new Error(`${id2} was not found!`);
      }
      if (options && options.decode && !options.string) {
        return data2;
      }
      if (options && options.decode && options.string) {
        return ArweaveUtils2.bufferToString(data2);
      }
      return ArweaveUtils2.bufferTob64Url(data2);
    }
    async sign(transaction2, jwk, options) {
      if (!jwk && (typeof window === "undefined" || !window.arweaveWallet)) {
        throw new Error(`A new Arweave transaction must provide the jwk parameter.`);
      } else if (!jwk || jwk === "use_wallet") {
        try {
          const existingPermissions = await window.arweaveWallet.getPermissions();
          if (!existingPermissions.includes("SIGN_TRANSACTION"))
            await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch (_a) {
        }
        const signedTransaction = await window.arweaveWallet.sign(transaction2, options);
        transaction2.setSignature({
          id: signedTransaction.id,
          owner: signedTransaction.owner,
          reward: signedTransaction.reward,
          tags: signedTransaction.tags,
          signature: signedTransaction.signature
        });
      } else {
        transaction2.setOwner(jwk.n);
        let dataToSign = await transaction2.getSignatureData();
        let rawSignature = await this.crypto.sign(jwk, dataToSign, options);
        let id2 = await this.crypto.hash(rawSignature);
        transaction2.setSignature({
          id: ArweaveUtils2.bufferTob64Url(id2),
          owner: jwk.n,
          signature: ArweaveUtils2.bufferTob64Url(rawSignature)
        });
      }
    }
    async verify(transaction2) {
      const signaturePayload = await transaction2.getSignatureData();
      const rawSignature = transaction2.get("signature", {
        decode: true,
        string: false
      });
      const expectedId = ArweaveUtils2.bufferTob64Url(await this.crypto.hash(rawSignature));
      if (transaction2.id !== expectedId) {
        throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);
      }
      return this.crypto.verify(transaction2.owner, signaturePayload, rawSignature);
    }
    async post(transaction2) {
      if (typeof transaction2 === "string") {
        transaction2 = new transaction_1.default(JSON.parse(transaction2));
      } else if (typeof transaction2.readInt32BE === "function") {
        transaction2 = new transaction_1.default(JSON.parse(transaction2.toString()));
      } else if (typeof transaction2 === "object" && !(transaction2 instanceof transaction_1.default)) {
        transaction2 = new transaction_1.default(transaction2);
      }
      if (!(transaction2 instanceof transaction_1.default)) {
        throw new Error(`Must be Transaction object`);
      }
      if (!transaction2.chunks) {
        await transaction2.prepareChunks(transaction2.data);
      }
      const uploader = await this.getUploader(transaction2, transaction2.data);
      try {
        while (!uploader.isComplete) {
          await uploader.uploadChunk();
        }
      } catch (e) {
        if (uploader.lastResponseStatus > 0) {
          return {
            status: uploader.lastResponseStatus,
            statusText: uploader.lastResponseError,
            data: {
              error: uploader.lastResponseError
            }
          };
        }
        throw e;
      }
      return {
        status: 200,
        statusText: "OK",
        data: {}
      };
    }
    async getUploader(upload, data2) {
      let uploader;
      if (data2 instanceof ArrayBuffer) {
        data2 = new Uint8Array(data2);
      }
      if (upload instanceof transaction_1.default) {
        if (!data2) {
          data2 = upload.data;
        }
        if (!(data2 instanceof Uint8Array)) {
          throw new Error("Data format is invalid");
        }
        if (!upload.chunks) {
          await upload.prepareChunks(data2);
        }
        uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);
        if (!uploader.data || uploader.data.length === 0) {
          uploader.data = data2;
        }
      } else {
        if (typeof upload === "string") {
          upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);
        }
        if (!data2 || !(data2 instanceof Uint8Array)) {
          throw new Error(`Must provide data when resuming upload`);
        }
        uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data2);
      }
      return uploader;
    }
    upload(upload, data2) {
      return __asyncGenerator(this, arguments, function* upload_1() {
        const uploader = yield __await(this.getUploader(upload, data2));
        while (!uploader.isComplete) {
          yield __await(uploader.uploadChunk());
          yield yield __await(uploader);
        }
        return yield __await(uploader);
      });
    }
  }
  transactions.default = Transactions;
  return transactions;
}
var wallets = {};
Object.defineProperty(wallets, "__esModule", { value: true });
const ArweaveUtils$2 = utils$G;
class Wallets {
  constructor(api2, crypto2) {
    this.api = api2;
    this.crypto = crypto2;
  }
  getBalance(address) {
    return this.api.get(`wallet/${address}/balance`, {
      transformResponse: [
        function(data2) {
          return data2;
        }
      ]
    }).then((response) => {
      return response.data;
    });
  }
  getLastTransactionID(address) {
    return this.api.get(`wallet/${address}/last_tx`).then((response) => {
      return response.data;
    });
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(jwk) {
    if (!jwk || jwk === "use_wallet") {
      return this.getAddress();
    } else {
      return this.getAddress(jwk);
    }
  }
  async getAddress(jwk) {
    if (!jwk || jwk === "use_wallet") {
      try {
        await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
      } catch (_a) {
      }
      return window.arweaveWallet.getActiveAddress();
    } else {
      return this.ownerToAddress(jwk.n);
    }
  }
  async ownerToAddress(owner) {
    return ArweaveUtils$2.bufferTob64Url(await this.crypto.hash(ArweaveUtils$2.b64UrlToBuffer(owner)));
  }
}
wallets.default = Wallets;
var silo = {};
Object.defineProperty(silo, "__esModule", { value: true });
silo.SiloResource = void 0;
const ArweaveUtils$1 = utils$G;
class Silo {
  constructor(api2, crypto2, transactions2) {
    this.api = api2;
    this.crypto = crypto2;
    this.transactions = transactions2;
  }
  async get(siloURI) {
    if (!siloURI) {
      throw new Error(`No Silo URI specified`);
    }
    const resource = await this.parseUri(siloURI);
    const ids = await this.transactions.search("Silo-Name", resource.getAccessKey());
    if (ids.length == 0) {
      throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
    }
    const transaction2 = await this.transactions.get(ids[0]);
    if (!transaction2) {
      throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
    }
    const encrypted = transaction2.get("data", { decode: true, string: false });
    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
  }
  async readTransactionData(transaction2, siloURI) {
    if (!siloURI) {
      throw new Error(`No Silo URI specified`);
    }
    const resource = await this.parseUri(siloURI);
    const encrypted = transaction2.get("data", { decode: true, string: false });
    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
  }
  async parseUri(siloURI) {
    const parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!parsed) {
      throw new Error(`Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'`);
    }
    const siloName = parsed[1];
    const hashIterations = Math.pow(2, parseInt(parsed[2]));
    const digest10 = await this.hash(ArweaveUtils$1.stringToBuffer(siloName), hashIterations);
    const accessKey = ArweaveUtils$1.bufferTob64(digest10.slice(0, 15));
    const encryptionkey = await this.hash(digest10.slice(16, 31), 1);
    return new SiloResource(siloURI, accessKey, encryptionkey);
  }
  async hash(input, iterations) {
    let digest10 = await this.crypto.hash(input);
    for (let count = 0; count < iterations - 1; count++) {
      digest10 = await this.crypto.hash(digest10);
    }
    return digest10;
  }
}
silo.default = Silo;
class SiloResource {
  constructor(uri, accessKey, encryptionKey) {
    this.uri = uri;
    this.accessKey = accessKey;
    this.encryptionKey = encryptionKey;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
silo.SiloResource = SiloResource;
var chunks = {};
Object.defineProperty(chunks, "__esModule", { value: true });
const error_1$1 = error;
const ArweaveUtils = utils$G;
class Chunks {
  constructor(api2) {
    this.api = api2;
  }
  async getTransactionOffset(id2) {
    const resp = await this.api.get(`tx/${id2}/offset`);
    if (resp.status === 200) {
      return resp.data;
    }
    throw new Error(`Unable to get transaction offset: ${(0, error_1$1.getError)(resp)}`);
  }
  async getChunk(offset) {
    const resp = await this.api.get(`chunk/${offset}`);
    if (resp.status === 200) {
      return resp.data;
    }
    throw new Error(`Unable to get chunk: ${(0, error_1$1.getError)(resp)}`);
  }
  async getChunkData(offset) {
    const chunk = await this.getChunk(offset);
    const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
    return buf;
  }
  firstChunkOffset(offsetResponse) {
    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
  }
  async downloadChunkedData(id2) {
    const offsetResponse = await this.getTransactionOffset(id2);
    const size = parseInt(offsetResponse.size);
    const endOffset = parseInt(offsetResponse.offset);
    const startOffset = endOffset - size + 1;
    const data2 = new Uint8Array(size);
    let byte = 0;
    while (byte < size) {
      if (this.api.config.logging) {
        console.log(`[chunk] ${byte}/${size}`);
      }
      let chunkData;
      try {
        chunkData = await this.getChunkData(startOffset + byte);
      } catch (error3) {
        console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);
        console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node`);
      }
      if (chunkData) {
        data2.set(chunkData, byte);
        byte += chunkData.length;
      } else {
        throw new Error(`Couldn't complete data download at ${byte}/${size}`);
      }
    }
    return data2;
  }
}
chunks.default = Chunks;
var blocks = {};
Object.defineProperty(blocks, "__esModule", { value: true });
const error_1 = error;
class Blocks {
  constructor(api2, network2) {
    this.api = api2;
    this.network = network2;
  }
  async get(indepHash) {
    const response = await this.api.get(`${Blocks.ENDPOINT}${indepHash}`);
    if (response.status === 200) {
      return response.data;
    } else {
      if (response.status === 404) {
        throw new error_1.default("BLOCK_NOT_FOUND");
      } else {
        throw new Error(`Error while loading block data: ${response}`);
      }
    }
  }
  async getCurrent() {
    const { current } = await this.network.getInfo();
    return await this.get(current);
  }
}
blocks.default = Blocks;
Blocks.ENDPOINT = "block/hash/";
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common$6;
  hasRequiredCommon = 1;
  Object.defineProperty(common$6, "__esModule", { value: true });
  const ar_1 = ar;
  const api_1 = api$2;
  const node_driver_1 = webcryptoDriver;
  const network_1 = network;
  const transactions_1 = requireTransactions();
  const wallets_1 = wallets;
  const transaction_1 = requireTransaction();
  const ArweaveUtils2 = utils$G;
  const silo_1 = silo;
  const chunks_1 = chunks;
  const blocks_1 = blocks;
  class Arweave2 {
    constructor(apiConfig) {
      this.api = new api_1.default(apiConfig);
      this.wallets = new wallets_1.default(this.api, Arweave2.crypto);
      this.chunks = new chunks_1.default(this.api);
      this.transactions = new transactions_1.default(this.api, Arweave2.crypto, this.chunks);
      this.silo = new silo_1.default(this.api, this.crypto, this.transactions);
      this.network = new network_1.default(this.api);
      this.blocks = new blocks_1.default(this.api, this.network);
      this.ar = new ar_1.default();
    }
    get crypto() {
      return Arweave2.crypto;
    }
    get utils() {
      return Arweave2.utils;
    }
    getConfig() {
      return {
        api: this.api.getConfig(),
        crypto: null
      };
    }
    async createTransaction(attributes, jwk) {
      const transaction2 = {};
      Object.assign(transaction2, attributes);
      if (!attributes.data && !(attributes.target && attributes.quantity)) {
        throw new Error(`A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.`);
      }
      if (attributes.owner == void 0) {
        if (jwk && jwk !== "use_wallet") {
          transaction2.owner = jwk.n;
        }
      }
      if (attributes.last_tx == void 0) {
        transaction2.last_tx = await this.transactions.getTransactionAnchor();
      }
      if (typeof attributes.data === "string") {
        attributes.data = ArweaveUtils2.stringToBuffer(attributes.data);
      }
      if (attributes.data instanceof ArrayBuffer) {
        attributes.data = new Uint8Array(attributes.data);
      }
      if (attributes.data && !(attributes.data instanceof Uint8Array)) {
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      }
      if (attributes.reward == void 0) {
        const length2 = attributes.data ? attributes.data.byteLength : 0;
        transaction2.reward = await this.transactions.getPrice(length2, transaction2.target);
      }
      transaction2.data_root = "";
      transaction2.data_size = attributes.data ? attributes.data.byteLength.toString() : "0";
      transaction2.data = attributes.data || new Uint8Array(0);
      const createdTransaction = new transaction_1.default(transaction2);
      await createdTransaction.getSignatureData();
      return createdTransaction;
    }
    async createSiloTransaction(attributes, jwk, siloUri) {
      const transaction2 = {};
      Object.assign(transaction2, attributes);
      if (!attributes.data) {
        throw new Error(`Silo transactions must have a 'data' value`);
      }
      if (!siloUri) {
        throw new Error(`No Silo URI specified.`);
      }
      if (attributes.target || attributes.quantity) {
        throw new Error(`Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.`);
      }
      if (attributes.owner == void 0) {
        if (!jwk || !jwk.n) {
          throw new Error(`A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.`);
        }
        transaction2.owner = jwk.n;
      }
      if (attributes.last_tx == void 0) {
        transaction2.last_tx = await this.transactions.getTransactionAnchor();
      }
      const siloResource = await this.silo.parseUri(siloUri);
      if (typeof attributes.data == "string") {
        const encrypted = await this.crypto.encrypt(ArweaveUtils2.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
        transaction2.reward = await this.transactions.getPrice(encrypted.byteLength);
        transaction2.data = ArweaveUtils2.bufferTob64Url(encrypted);
      }
      if (attributes.data instanceof Uint8Array) {
        const encrypted = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
        transaction2.reward = await this.transactions.getPrice(encrypted.byteLength);
        transaction2.data = ArweaveUtils2.bufferTob64Url(encrypted);
      }
      const siloTransaction = new transaction_1.default(transaction2);
      siloTransaction.addTag("Silo-Name", siloResource.getAccessKey());
      siloTransaction.addTag("Silo-Version", `0.1.0`);
      return siloTransaction;
    }
    arql(query) {
      return this.api.post("/arql", query).then((response) => response.data || []);
    }
  }
  common$6.default = Arweave2;
  Arweave2.crypto = new node_driver_1.default();
  Arweave2.utils = ArweaveUtils2;
  return common$6;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  const common_1 = requireCommon();
  common_1.default.init = function(apiConfig = {}) {
    function getDefaultConfig() {
      const defaults2 = {
        host: "arweave.net",
        port: 443,
        protocol: "https"
      };
      if (!window || !window.location || !window.location.protocol || !window.location.hostname) {
        return defaults2;
      }
      const currentProtocol = window.location.protocol.replace(":", "");
      const currentHost = window.location.hostname;
      const currentPort = window.location.port ? parseInt(window.location.port) : currentProtocol == "https" ? 443 : 80;
      const isLocal = ["localhost", "127.0.0.1"].includes(currentHost) || currentProtocol == "file";
      if (isLocal) {
        return defaults2;
      }
      return {
        host: currentHost,
        port: currentPort,
        protocol: currentProtocol
      };
    }
    const defaultConfig = getDefaultConfig();
    const protocol = apiConfig.protocol || defaultConfig.protocol;
    const host = apiConfig.host || defaultConfig.host;
    const port = apiConfig.port || defaultConfig.port;
    return new common_1.default(Object.assign(Object.assign({}, apiConfig), {
      host,
      protocol,
      port
    }));
  };
  window.Arweave = common_1.default;
  __exportStar(requireCommon(), exports2);
  exports2.default = common_1.default;
})(web);
const Arweave$1 = /* @__PURE__ */ getDefaultExportFromCjs(web);
var base64url$3 = { exports: {} };
var base64url$2 = {};
var padString$1 = {};
Object.defineProperty(padString$1, "__esModule", { value: true });
function padString(input) {
  var segmentLength = 4;
  var stringLength = input.length;
  var diff = stringLength % segmentLength;
  if (!diff) {
    return input;
  }
  var position = stringLength;
  var padLength = segmentLength - diff;
  var paddedStringLength = stringLength + padLength;
  var buffer2 = Buffer.alloc(paddedStringLength);
  buffer2.write(input);
  while (padLength--) {
    buffer2.write("=", position++);
  }
  return buffer2.toString();
}
padString$1.default = padString;
Object.defineProperty(base64url$2, "__esModule", { value: true });
var pad_string_1 = padString$1;
function encode$8(input, encoding) {
  if (encoding === void 0) {
    encoding = "utf8";
  }
  if (Buffer.isBuffer(input)) {
    return fromBase64(input.toString("base64"));
  }
  return fromBase64(Buffer.from(input, encoding).toString("base64"));
}
function decode$6(base64url2, encoding) {
  if (encoding === void 0) {
    encoding = "utf8";
  }
  return Buffer.from(toBase64(base64url2), "base64").toString(encoding);
}
function toBase64(base64url2) {
  base64url2 = base64url2.toString();
  return pad_string_1.default(base64url2).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(base642) {
  return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer$4(base64url2) {
  return Buffer.from(toBase64(base64url2), "base64");
}
var base64url$1 = encode$8;
base64url$1.encode = encode$8;
base64url$1.decode = decode$6;
base64url$1.toBase64 = toBase64;
base64url$1.fromBase64 = fromBase64;
base64url$1.toBuffer = toBuffer$4;
base64url$2.default = base64url$1;
(function(module) {
  module.exports = base64url$2.default;
  module.exports.default = module.exports;
})(base64url$3);
const SIG_CONFIG = {
  [1]: {
    sigLength: 512,
    pubLength: 512,
    sigName: "arweave"
  },
  [2]: {
    sigLength: 64,
    pubLength: 32,
    sigName: "ed25519"
  },
  [3]: {
    sigLength: 65,
    pubLength: 65,
    sigName: "ethereum"
  },
  [4]: {
    sigLength: 64,
    pubLength: 32,
    sigName: "solana"
  }
};
class Rsa4096Pss$2 {
  constructor(_key, pk) {
    this._key = _key;
    this.pk = pk;
    this.signatureType = 1;
    this.ownerLength = SIG_CONFIG[1].pubLength;
    this.signatureLength = SIG_CONFIG[1].sigLength;
  }
  get publicKey() {
    return this._publicKey;
  }
  sign(message) {
    return [0];
  }
  static async verify(pk, message, signature2) {
    return null;
  }
}
class ArweaveSigner$2 extends Rsa4096Pss$2 {
  constructor(jwk) {
    super(null, jwk.n);
    this.jwk = jwk;
  }
  get publicKey() {
    return b64UrlToBuffer$3(this.pk);
  }
  sign(message) {
    return subtleSign(this.jwk, message);
  }
  static async verify(pk, message, signature2) {
    return await Arweave.crypto.verify(pk, message, signature2);
  }
}
async function uploadDataToBundlr(dataItem) {
  const res = await axios$3.post("https://node2.bundlr.network/tx", dataItem.getRaw(), {
    headers: {
      "Content-Type": "application/octet-stream"
    },
    maxBodyLength: Infinity
  });
  console.log("uploadDataToBundlr", { res });
  if (res.status >= 400)
    throw new Error(`Error uploading DataItem: ${res.status} ${res.statusText}`);
}
var src$2 = {};
var arDataBundle = {};
var arDataBase = {};
var utils$F = {};
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$4(result, mod, k);
  }
  __setModuleDefault$4(result, mod);
  return result;
};
Object.defineProperty(utils$F, "__esModule", { value: true });
utils$F.b64UrlDecode = utils$F.b64UrlEncode = utils$F.bufferTob64Url = utils$F.bufferTob64 = utils$F.b64UrlToBuffer = utils$F.stringToB64Url = utils$F.stringToBuffer = utils$F.bufferToString = utils$F.b64UrlToString = utils$F.concatBuffers = void 0;
const B64js = __importStar$4(base64Js);
function concatBuffers$1(buffers) {
  let total_length = 0;
  for (let i = 0; i < buffers.length; i++) {
    total_length += buffers[i].byteLength;
  }
  let temp = new Uint8Array(total_length);
  let offset = 0;
  temp.set(new Uint8Array(buffers[0]), offset);
  offset += buffers[0].byteLength;
  for (let i = 1; i < buffers.length; i++) {
    temp.set(new Uint8Array(buffers[i]), offset);
    offset += buffers[i].byteLength;
  }
  return temp;
}
utils$F.concatBuffers = concatBuffers$1;
function b64UrlToString$1(b64UrlString) {
  let buffer2 = b64UrlToBuffer$1(b64UrlString);
  return bufferToString$1(buffer2);
}
utils$F.b64UrlToString = b64UrlToString$1;
function bufferToString$1(buffer2) {
  if (typeof TextDecoder == "undefined") {
    const TextDecoder2 = requireUtil().TextDecoder;
    return new TextDecoder2("utf-8", { fatal: true }).decode(buffer2);
  }
  return new TextDecoder("utf-8", { fatal: true }).decode(buffer2);
}
utils$F.bufferToString = bufferToString$1;
function stringToBuffer$1(string2) {
  if (typeof TextEncoder == "undefined") {
    const TextEncoder2 = requireUtil().TextEncoder;
    return new TextEncoder2().encode(string2);
  }
  return new TextEncoder().encode(string2);
}
utils$F.stringToBuffer = stringToBuffer$1;
function stringToB64Url$1(string2) {
  return bufferTob64Url$1(stringToBuffer$1(string2));
}
utils$F.stringToB64Url = stringToB64Url$1;
function b64UrlToBuffer$1(b64UrlString) {
  return new Uint8Array(B64js.toByteArray(b64UrlDecode$1(b64UrlString)));
}
utils$F.b64UrlToBuffer = b64UrlToBuffer$1;
function bufferTob64$1(buffer2) {
  return B64js.fromByteArray(new Uint8Array(buffer2));
}
utils$F.bufferTob64 = bufferTob64$1;
function bufferTob64Url$1(buffer2) {
  return b64UrlEncode$1(bufferTob64$1(buffer2));
}
utils$F.bufferTob64Url = bufferTob64Url$1;
function b64UrlEncode$1(b64UrlString) {
  return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
utils$F.b64UrlEncode = b64UrlEncode$1;
function b64UrlDecode$1(b64UrlString) {
  b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
  let padding2;
  b64UrlString.length % 4 == 0 ? padding2 = 0 : padding2 = 4 - b64UrlString.length % 4;
  return b64UrlString.concat("=".repeat(padding2));
}
utils$F.b64UrlDecode = b64UrlDecode$1;
var utils$E = {};
Object.defineProperty(utils$E, "__esModule", { value: true });
utils$E.isBrowser = utils$E.arraybufferEqual = utils$E.byteArrayToLong = utils$E.longTo32ByteArray = utils$E.longTo16ByteArray = utils$E.shortTo2ByteArray = utils$E.longTo8ByteArray = void 0;
function longTo8ByteArray(long) {
  const byteArray = [0, 0, 0, 0, 0, 0, 0, 0];
  for (let index2 = 0; index2 < byteArray.length; index2++) {
    const byte = long & 255;
    byteArray[index2] = byte;
    long = (long - byte) / 256;
  }
  return Uint8Array.from(byteArray);
}
utils$E.longTo8ByteArray = longTo8ByteArray;
function shortTo2ByteArray(long) {
  if (long > (2 ^ 32 - 1))
    throw new Error("Short too long");
  const byteArray = [0, 0];
  for (let index2 = 0; index2 < byteArray.length; index2++) {
    const byte = long & 255;
    byteArray[index2] = byte;
    long = (long - byte) / 256;
  }
  return Uint8Array.from(byteArray);
}
utils$E.shortTo2ByteArray = shortTo2ByteArray;
function longTo16ByteArray(long) {
  const byteArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let index2 = 0; index2 < byteArray.length; index2++) {
    const byte = long & 255;
    byteArray[index2] = byte;
    long = (long - byte) / 256;
  }
  return byteArray;
}
utils$E.longTo16ByteArray = longTo16ByteArray;
function longTo32ByteArray(long) {
  const byteArray = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  for (let index2 = 0; index2 < byteArray.length; index2++) {
    const byte = long & 255;
    byteArray[index2] = byte;
    long = (long - byte) / 256;
  }
  return Uint8Array.from(byteArray);
}
utils$E.longTo32ByteArray = longTo32ByteArray;
function byteArrayToLong(byteArray) {
  let value = 0;
  for (let i = byteArray.length - 1; i >= 0; i--) {
    value = value * 256 + byteArray[i];
  }
  return value;
}
utils$E.byteArrayToLong = byteArrayToLong;
function arraybufferEqual(buf1, buf2) {
  const _buf1 = buf1.buffer;
  const _buf2 = buf2.buffer;
  if (_buf1 === _buf2) {
    return true;
  }
  if (_buf1.byteLength !== _buf2.byteLength) {
    return false;
  }
  const view1 = new DataView(_buf1);
  const view2 = new DataView(_buf2);
  let i = _buf1.byteLength;
  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }
  return true;
}
utils$E.arraybufferEqual = arraybufferEqual;
utils$E.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var deepHash$2 = {};
var cryptoBrowserify = {};
var browser$e = { exports: {} };
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports2) {
  var buffer2 = buffer$3;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src2, dst) {
    for (var key3 in src2) {
      dst[key3] = src2[key3];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length2) {
    return Buffer2(arg, encodingOrOffset, length2);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length2);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var MAX_BYTES = 65536;
var MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
}
var Buffer$F = safeBuffer$1.exports.Buffer;
var crypto$4 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
if (crypto$4 && crypto$4.getRandomValues) {
  browser$e.exports = randomBytes$3;
} else {
  browser$e.exports = oldBrowser$1;
}
function randomBytes$3(size, cb) {
  if (size > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var bytes = Buffer$F.allocUnsafe(size);
  if (size > 0) {
    if (size > MAX_BYTES) {
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        crypto$4.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
      }
    } else {
      crypto$4.getRandomValues(bytes);
    }
  }
  if (typeof cb === "function") {
    return process.nextTick(function() {
      cb(null, bytes);
    });
  }
  return bytes;
}
var readableBrowser = { exports: {} };
var streamBrowser = events$1.exports.EventEmitter;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key3) {
          _defineProperty(target, key3, source[key3]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key3) {
          Object.defineProperty(target, key3, Object.getOwnPropertyDescriptor(source, key3));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj2, key3, value) {
    if (key3 in obj2) {
      Object.defineProperty(obj2, key3, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key3] = value;
    }
    return obj2;
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer$3, Buffer2 = _require.Buffer;
  var _require2 = require$$0$3, inspect9 = _require2.inspect;
  var custom = inspect9 && inspect9.custom || "inspect";
  function copyBuffer2(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer2(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect9(this, _objectSpread({}, options, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return buffer_list;
}
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb && err2) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err2);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err) {
  self2.emit("error", err);
}
function errorOrDestroy(stream2, err) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream2.destroy(err);
  else
    stream2.emit("error", err);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code2, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code2;
  codes[code2] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes(str, search, start) {
  if (typeof start !== "number") {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
  return 'The value "' + value + '" is invalid for option "' + name2 + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg;
  if (endsWith(name2, " argument")) {
    msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes(name2, ".") ? "property" : "argument";
    msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
  return "The " + name2 + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name2) {
  return "Cannot call " + name2 + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name2 = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name2, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
};
var browser$d = deprecate;
function deprecate(fn, msg) {
  if (config$1("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config$1("throwDeprecation")) {
        throw new Error(msg);
      } else if (config$1("traceDeprecation")) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config$1(name2) {
  try {
    if (!commonjsGlobal.localStorage)
      return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name2];
  if (null == val)
    return false;
  return String(val).toLowerCase() === "true";
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex2;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: browser$d
  };
  var Stream2 = streamBrowser;
  var Buffer2 = buffer$3.Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream2);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy2(stream2, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy2(stream2, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed)
      state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
    else if (writev)
      stream2._writev(chunk, state2.onwrite);
    else
      stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy2(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy2(stream2, er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK2();
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        process.nextTick(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy2(stream2, err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish2(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish2(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished)
        process.nextTick(cb);
      else
        stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys2 = Object.keys || function(obj2) {
    var keys3 = [];
    for (var key3 in obj2) {
      keys3.push(key3);
    }
    return keys3;
  };
  _stream_duplex = Duplex2;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex2, Readable);
  {
    var keys2 = objectKeys2(Writable.prototype);
    for (var v = 0; v < keys2.length; v++) {
      var method = keys2[v];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var Buffer$E = safeBuffer$1.exports.Buffer;
var isEncoding = Buffer$E.isEncoding || function(encoding) {
  encoding = "" + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function _normalizeEncoding(enc) {
  if (!enc)
    return "utf8";
  var retried;
  while (true) {
    switch (enc) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return enc;
      default:
        if (retried)
          return;
        enc = ("" + enc).toLowerCase();
        retried = true;
    }
  }
}
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== "string" && (Buffer$E.isEncoding === isEncoding || !isEncoding(enc)))
    throw new Error("Unknown encoding: " + enc);
  return nenc || enc;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case "base64":
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer$E.allocUnsafe(nb);
}
StringDecoder$1.prototype.write = function(buf) {
  if (buf.length === 0)
    return "";
  var r2;
  var i;
  if (this.lastNeed) {
    r2 = this.fillLast(buf);
    if (r2 === void 0)
      return "";
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length)
    return r2 ? r2 + this.text(buf, i) : this.text(buf, i);
  return r2 || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};
function utf8CheckByte(byte) {
  if (byte <= 127)
    return 0;
  else if (byte >> 5 === 6)
    return 2;
  else if (byte >> 4 === 14)
    return 3;
  else if (byte >> 3 === 30)
    return 4;
  return byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self2, buf, i) {
  var j = buf.length - 1;
  if (j < i)
    return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self2.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes(self2, buf, p) {
  if ((buf[0] & 192) !== 128) {
    self2.lastNeed = 0;
    return "\uFFFD";
  }
  if (self2.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self2.lastNeed = 1;
      return "\uFFFD";
    }
    if (self2.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self2.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
}
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r2 = utf8CheckExtraBytes(this, buf);
  if (r2 !== void 0)
    return r2;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed)
    return buf.toString("utf8", i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString("utf8", i, end);
}
function utf8End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + "\uFFFD";
  return r2;
}
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r2 = buf.toString("utf16le", i);
    if (r2) {
      var c = r2.charCodeAt(r2.length - 1);
      if (c >= 55296 && c <= 56319) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r2.slice(0, -1);
      }
    }
    return r2;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString("utf16le", i, buf.length - 1);
}
function utf16End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r2 + this.lastChar.toString("utf16le", 0, end);
  }
  return r2;
}
function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0)
    return buf.toString("base64", i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  return r2;
}
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$1() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts, callback) {
  if (typeof opts === "function")
    return eos$1(stream2, null, opts);
  if (!opts)
    opts = {};
  callback = once$1(callback || noop$1);
  var readable = opts.readable || opts.readable !== false && stream2.readable;
  var writable = opts.writable || opts.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable)
      onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend = function onend2() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback.call(stream2);
  };
  var onerror = function onerror2(err) {
    callback.call(stream2, err);
  };
  var onclose = function onclose2() {
    var err;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req)
      onrequest();
    else
      stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend);
  stream2.on("finish", onfinish);
  if (opts.error !== false)
    stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req)
      stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj2, key3, value) {
    if (key3 in obj2) {
      Object.defineProperty(obj2, key3, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key3] = value;
    }
    return obj2;
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done2) {
    return {
      value,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error3 = this[kError];
      if (error3 !== null) {
        return Promise.reject(error3);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser)
    return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex2;
  Readable.ReadableState = ReadableState;
  events$1.exports.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = streamBrowser;
  var Buffer2 = buffer$3.Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var debugUtil = require$$0$3;
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug3() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder2;
  var createReadableStreamAsyncIterator;
  var from2;
  requireInherits_browser()(Readable, Stream2);
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2)
        StringDecoder2 = string_decoder.StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy2(stream2, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            errorOrDestroy2(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy2(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream2, state2, chunk, false);
            else
              maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream2, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder2)
      StringDecoder2 = string_decoder.StringDecoder;
    var decoder = new StringDecoder2(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n !== n) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length)
      return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug2("onEofChunk");
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy2(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted)
      process.nextTick(endFn);
    else
      src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy2(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1)
      return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading)
      stream2.read(0);
  }
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.first();
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state2.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from2 === void 0) {
        from2 = requireFromBrowser();
      }
      return from2(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$9;
var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require_stream_duplex();
requireInherits_browser()(Transform$9, Duplex);
function afterTransform(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$9(options) {
  if (!(this instanceof Transform$9))
    return new Transform$9(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done(_this, er, data2);
    });
  } else {
    done(this, null, null);
  }
}
Transform$9.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$9.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$9.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$9.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$9.prototype._destroy = function(err, cb) {
  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
  });
};
function done(stream2, er, data2) {
  if (er)
    return stream2.emit("error", er);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
var _stream_passthrough = PassThrough;
var Transform$8 = _stream_transform;
requireInherits_browser()(PassThrough, Transform$8);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform$8.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  if (err)
    throw err;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err) {
    if (err)
      return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream2))
      return stream2.abort();
    if (typeof stream2.destroy === "function")
      return stream2.destroy();
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from2, to) {
  return from2.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop;
  if (typeof streams[streams.length - 1] !== "function")
    return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error3;
  var destroys = streams.map(function(stream2, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream2, reading, writing, function(err) {
      if (!error3)
        error3 = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error3);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module, exports2) {
  exports2 = module.exports = require_stream_readable();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable();
  exports2.Duplex = require_stream_duplex();
  exports2.Transform = _stream_transform;
  exports2.PassThrough = _stream_passthrough;
  exports2.finished = endOfStream;
  exports2.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var Buffer$D = safeBuffer$1.exports.Buffer;
var Transform$7 = readableBrowser.exports.Transform;
var inherits$v = requireInherits_browser();
function throwIfNotStringOrBuffer(val, prefix) {
  if (!Buffer$D.isBuffer(val) && typeof val !== "string") {
    throw new TypeError(prefix + " must be a string or a buffer");
  }
}
function HashBase$2(blockSize2) {
  Transform$7.call(this);
  this._block = Buffer$D.allocUnsafe(blockSize2);
  this._blockSize = blockSize2;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}
inherits$v(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(chunk, encoding, callback) {
  var error3 = null;
  try {
    this.update(chunk, encoding);
  } catch (err) {
    error3 = err;
  }
  callback(error3);
};
HashBase$2.prototype._flush = function(callback) {
  var error3 = null;
  try {
    this.push(this.digest());
  } catch (err) {
    error3 = err;
  }
  callback(error3);
};
HashBase$2.prototype.update = function(data2, encoding) {
  throwIfNotStringOrBuffer(data2, "Data");
  if (this._finalized)
    throw new Error("Digest already called");
  if (!Buffer$D.isBuffer(data2))
    data2 = Buffer$D.from(data2, encoding);
  var block = this._block;
  var offset = 0;
  while (this._blockOffset + data2.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize; )
      block[i++] = data2[offset++];
    this._update();
    this._blockOffset = 0;
  }
  while (offset < data2.length)
    block[this._blockOffset++] = data2[offset++];
  for (var j = 0, carry = data2.length * 8; carry > 0; ++j) {
    this._length[j] += carry;
    carry = this._length[j] / 4294967296 | 0;
    if (carry > 0)
      this._length[j] -= 4294967296 * carry;
  }
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(encoding) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = true;
  var digest10 = this._digest();
  if (encoding !== void 0)
    digest10 = digest10.toString(encoding);
  this._block.fill(0);
  this._blockOffset = 0;
  for (var i = 0; i < 4; ++i)
    this._length[i] = 0;
  return digest10;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2;
var inherits$u = requireInherits_browser();
var HashBase$1 = hashBase;
var Buffer$C = safeBuffer$1.exports.Buffer;
var ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64);
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
}
inherits$u(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  var M = ARRAY16$1;
  for (var i = 0; i < 16; ++i)
    M[i] = this._block.readInt32LE(i * 4);
  var a = this._a;
  var b = this._b;
  var c = this._c;
  var d = this._d;
  a = fnF(a, b, c, d, M[0], 3614090360, 7);
  d = fnF(d, a, b, c, M[1], 3905402710, 12);
  c = fnF(c, d, a, b, M[2], 606105819, 17);
  b = fnF(b, c, d, a, M[3], 3250441966, 22);
  a = fnF(a, b, c, d, M[4], 4118548399, 7);
  d = fnF(d, a, b, c, M[5], 1200080426, 12);
  c = fnF(c, d, a, b, M[6], 2821735955, 17);
  b = fnF(b, c, d, a, M[7], 4249261313, 22);
  a = fnF(a, b, c, d, M[8], 1770035416, 7);
  d = fnF(d, a, b, c, M[9], 2336552879, 12);
  c = fnF(c, d, a, b, M[10], 4294925233, 17);
  b = fnF(b, c, d, a, M[11], 2304563134, 22);
  a = fnF(a, b, c, d, M[12], 1804603682, 7);
  d = fnF(d, a, b, c, M[13], 4254626195, 12);
  c = fnF(c, d, a, b, M[14], 2792965006, 17);
  b = fnF(b, c, d, a, M[15], 1236535329, 22);
  a = fnG(a, b, c, d, M[1], 4129170786, 5);
  d = fnG(d, a, b, c, M[6], 3225465664, 9);
  c = fnG(c, d, a, b, M[11], 643717713, 14);
  b = fnG(b, c, d, a, M[0], 3921069994, 20);
  a = fnG(a, b, c, d, M[5], 3593408605, 5);
  d = fnG(d, a, b, c, M[10], 38016083, 9);
  c = fnG(c, d, a, b, M[15], 3634488961, 14);
  b = fnG(b, c, d, a, M[4], 3889429448, 20);
  a = fnG(a, b, c, d, M[9], 568446438, 5);
  d = fnG(d, a, b, c, M[14], 3275163606, 9);
  c = fnG(c, d, a, b, M[3], 4107603335, 14);
  b = fnG(b, c, d, a, M[8], 1163531501, 20);
  a = fnG(a, b, c, d, M[13], 2850285829, 5);
  d = fnG(d, a, b, c, M[2], 4243563512, 9);
  c = fnG(c, d, a, b, M[7], 1735328473, 14);
  b = fnG(b, c, d, a, M[12], 2368359562, 20);
  a = fnH(a, b, c, d, M[5], 4294588738, 4);
  d = fnH(d, a, b, c, M[8], 2272392833, 11);
  c = fnH(c, d, a, b, M[11], 1839030562, 16);
  b = fnH(b, c, d, a, M[14], 4259657740, 23);
  a = fnH(a, b, c, d, M[1], 2763975236, 4);
  d = fnH(d, a, b, c, M[4], 1272893353, 11);
  c = fnH(c, d, a, b, M[7], 4139469664, 16);
  b = fnH(b, c, d, a, M[10], 3200236656, 23);
  a = fnH(a, b, c, d, M[13], 681279174, 4);
  d = fnH(d, a, b, c, M[0], 3936430074, 11);
  c = fnH(c, d, a, b, M[3], 3572445317, 16);
  b = fnH(b, c, d, a, M[6], 76029189, 23);
  a = fnH(a, b, c, d, M[9], 3654602809, 4);
  d = fnH(d, a, b, c, M[12], 3873151461, 11);
  c = fnH(c, d, a, b, M[15], 530742520, 16);
  b = fnH(b, c, d, a, M[2], 3299628645, 23);
  a = fnI(a, b, c, d, M[0], 4096336452, 6);
  d = fnI(d, a, b, c, M[7], 1126891415, 10);
  c = fnI(c, d, a, b, M[14], 2878612391, 15);
  b = fnI(b, c, d, a, M[5], 4237533241, 21);
  a = fnI(a, b, c, d, M[12], 1700485571, 6);
  d = fnI(d, a, b, c, M[3], 2399980690, 10);
  c = fnI(c, d, a, b, M[10], 4293915773, 15);
  b = fnI(b, c, d, a, M[1], 2240044497, 21);
  a = fnI(a, b, c, d, M[8], 1873313359, 6);
  d = fnI(d, a, b, c, M[15], 4264355552, 10);
  c = fnI(c, d, a, b, M[6], 2734768916, 15);
  b = fnI(b, c, d, a, M[13], 1309151649, 21);
  a = fnI(a, b, c, d, M[4], 4149444226, 6);
  d = fnI(d, a, b, c, M[11], 3174756917, 10);
  c = fnI(c, d, a, b, M[2], 718787259, 15);
  b = fnI(b, c, d, a, M[9], 3951481745, 21);
  this._a = this._a + a | 0;
  this._b = this._b + b | 0;
  this._c = this._c + c | 0;
  this._d = this._d + d | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();
  var buffer2 = Buffer$C.allocUnsafe(16);
  buffer2.writeInt32LE(this._a, 0);
  buffer2.writeInt32LE(this._b, 4);
  buffer2.writeInt32LE(this._c, 8);
  buffer2.writeInt32LE(this._d, 12);
  return buffer2;
};
function rotl$1(x, n) {
  return x << n | x >>> 32 - n;
}
function fnF(a, b, c, d, m, k, s2) {
  return rotl$1(a + (b & c | ~b & d) + m + k | 0, s2) + b | 0;
}
function fnG(a, b, c, d, m, k, s2) {
  return rotl$1(a + (b & d | c & ~d) + m + k | 0, s2) + b | 0;
}
function fnH(a, b, c, d, m, k, s2) {
  return rotl$1(a + (b ^ c ^ d) + m + k | 0, s2) + b | 0;
}
function fnI(a, b, c, d, m, k, s2) {
  return rotl$1(a + (c ^ (b | ~d)) + m + k | 0, s2) + b | 0;
}
var md5_js = MD5$3;
var Buffer$B = buffer$3.Buffer;
var inherits$t = requireInherits_browser();
var HashBase = hashBase;
var ARRAY16 = new Array(16);
var zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64);
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
}
inherits$t(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  var words2 = ARRAY16;
  for (var j = 0; j < 16; ++j)
    words2[j] = this._block.readInt32LE(j * 4);
  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar2 = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0;
  for (var i = 0; i < 80; i += 1) {
    var tl;
    var tr;
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words2[zl[i]], hl[0], sl[i]);
      tr = fn5(ar2, br, cr, dr, er, words2[zr[i]], hr[0], sr[i]);
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words2[zl[i]], hl[1], sl[i]);
      tr = fn4(ar2, br, cr, dr, er, words2[zr[i]], hr[1], sr[i]);
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words2[zl[i]], hl[2], sl[i]);
      tr = fn3(ar2, br, cr, dr, er, words2[zr[i]], hr[2], sr[i]);
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words2[zl[i]], hl[3], sl[i]);
      tr = fn2(ar2, br, cr, dr, er, words2[zr[i]], hr[3], sr[i]);
    } else {
      tl = fn5(al, bl, cl, dl, el, words2[zl[i]], hl[4], sl[i]);
      tr = fn1(ar2, br, cr, dr, er, words2[zr[i]], hr[4], sr[i]);
    }
    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar2 = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = tr;
  }
  var t = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar2 | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();
  var buffer2 = Buffer$B.alloc ? Buffer$B.alloc(20) : new Buffer$B(20);
  buffer2.writeInt32LE(this._a, 0);
  buffer2.writeInt32LE(this._b, 4);
  buffer2.writeInt32LE(this._c, 8);
  buffer2.writeInt32LE(this._d, 12);
  buffer2.writeInt32LE(this._e, 16);
  return buffer2;
};
function rotl(x, n) {
  return x << n | x >>> 32 - n;
}
function fn1(a, b, c, d, e, m, k, s2) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s2) + e | 0;
}
function fn2(a, b, c, d, e, m, k, s2) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s2) + e | 0;
}
function fn3(a, b, c, d, e, m, k, s2) {
  return rotl(a + ((b | ~c) ^ d) + m + k | 0, s2) + e | 0;
}
function fn4(a, b, c, d, e, m, k, s2) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s2) + e | 0;
}
function fn5(a, b, c, d, e, m, k, s2) {
  return rotl(a + (b ^ (c | ~d)) + m + k | 0, s2) + e | 0;
}
var ripemd160$1 = RIPEMD160$4;
var sha_js = { exports: {} };
var Buffer$A = safeBuffer$1.exports.Buffer;
function Hash$8(blockSize2, finalSize) {
  this._block = Buffer$A.alloc(blockSize2);
  this._finalSize = finalSize;
  this._blockSize = blockSize2;
  this._len = 0;
}
Hash$8.prototype.update = function(data2, enc) {
  if (typeof data2 === "string") {
    enc = enc || "utf8";
    data2 = Buffer$A.from(data2, enc);
  }
  var block = this._block;
  var blockSize2 = this._blockSize;
  var length2 = data2.length;
  var accum = this._len;
  for (var offset = 0; offset < length2; ) {
    var assigned = accum % blockSize2;
    var remainder = Math.min(length2 - offset, blockSize2 - assigned);
    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data2[offset + i];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize2 === 0) {
      this._update(block);
    }
  }
  this._len += length2;
  return this;
};
Hash$8.prototype.digest = function(enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 128;
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;
  if (bits <= 4294967295) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);
  } else {
    var lowBits = (bits & 4294967295) >>> 0;
    var highBits = (bits - lowBits) / 4294967296;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash3 = this._hash();
  return enc ? hash3.toString(enc) : hash3;
};
Hash$8.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$8;
var inherits$s = requireInherits_browser();
var Hash$7 = hash$3;
var Buffer$z = safeBuffer$1.exports.Buffer;
var K$4 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$5 = new Array(80);
function Sha() {
  this.init();
  this._w = W$5;
  Hash$7.call(this, 64, 56);
}
inherits$s(Sha, Hash$7);
Sha.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl5$1(num) {
  return num << 5 | num >>> 27;
}
function rotl30$1(num) {
  return num << 30 | num >>> 2;
}
function ft$1(s2, b, c, d) {
  if (s2 === 0)
    return b & c | ~b & d;
  if (s2 === 2)
    return b & c | b & d | c & d;
  return b ^ c ^ d;
}
Sha.prototype._update = function(M) {
  var W2 = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  for (var i = 0; i < 16; ++i)
    W2[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i)
    W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
  for (var j = 0; j < 80; ++j) {
    var s2 = ~~(j / 20);
    var t = rotl5$1(a) + ft$1(s2, b, c, d) + e + W2[j] + K$4[s2] | 0;
    e = d;
    d = c;
    c = rotl30$1(b);
    b = a;
    a = t;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};
Sha.prototype._hash = function() {
  var H = Buffer$z.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};
var sha$5 = Sha;
var inherits$r = requireInherits_browser();
var Hash$6 = hash$3;
var Buffer$y = safeBuffer$1.exports.Buffer;
var K$3 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$4 = new Array(80);
function Sha1() {
  this.init();
  this._w = W$4;
  Hash$6.call(this, 64, 56);
}
inherits$r(Sha1, Hash$6);
Sha1.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl1(num) {
  return num << 1 | num >>> 31;
}
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s2, b, c, d) {
  if (s2 === 0)
    return b & c | ~b & d;
  if (s2 === 2)
    return b & c | b & d | c & d;
  return b ^ c ^ d;
}
Sha1.prototype._update = function(M) {
  var W2 = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  for (var i = 0; i < 16; ++i)
    W2[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i)
    W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
  for (var j = 0; j < 80; ++j) {
    var s2 = ~~(j / 20);
    var t = rotl5(a) + ft(s2, b, c, d) + e + W2[j] + K$3[s2] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};
Sha1.prototype._hash = function() {
  var H = Buffer$y.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};
var sha1 = Sha1;
var inherits$q = requireInherits_browser();
var Hash$5 = hash$3;
var Buffer$x = safeBuffer$1.exports.Buffer;
var K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
var W$3 = new Array(64);
function Sha256$1() {
  this.init();
  this._w = W$3;
  Hash$5.call(this, 64, 56);
}
inherits$q(Sha256$1, Hash$5);
Sha256$1.prototype.init = function() {
  this._a = 1779033703;
  this._b = 3144134277;
  this._c = 1013904242;
  this._d = 2773480762;
  this._e = 1359893119;
  this._f = 2600822924;
  this._g = 528734635;
  this._h = 1541459225;
  return this;
};
function ch(x, y, z) {
  return z ^ x & (y ^ z);
}
function maj$1(x, y, z) {
  return x & y | z & (x | y);
}
function sigma0$1(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}
function sigma1$1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}
function gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}
function gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
Sha256$1.prototype._update = function(M) {
  var W2 = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  var f2 = this._f | 0;
  var g = this._g | 0;
  var h = this._h | 0;
  for (var i = 0; i < 16; ++i)
    W2[i] = M.readInt32BE(i * 4);
  for (; i < 64; ++i)
    W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
  for (var j = 0; j < 64; ++j) {
    var T1 = h + sigma1$1(e) + ch(e, f2, g) + K$2[j] + W2[j] | 0;
    var T2 = sigma0$1(a) + maj$1(a, b, c) | 0;
    h = g;
    g = f2;
    f2 = e;
    e = d + T1 | 0;
    d = c;
    c = b;
    b = a;
    a = T1 + T2 | 0;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f2 + this._f | 0;
  this._g = g + this._g | 0;
  this._h = h + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var H = Buffer$x.allocUnsafe(32);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  H.writeInt32BE(this._h, 28);
  return H;
};
var sha256$5 = Sha256$1;
var inherits$p = requireInherits_browser();
var Sha256 = sha256$5;
var Hash$4 = hash$3;
var Buffer$w = safeBuffer$1.exports.Buffer;
var W$2 = new Array(64);
function Sha224() {
  this.init();
  this._w = W$2;
  Hash$4.call(this, 64, 56);
}
inherits$p(Sha224, Sha256);
Sha224.prototype.init = function() {
  this._a = 3238371032;
  this._b = 914150663;
  this._c = 812702999;
  this._d = 4144912697;
  this._e = 4290775857;
  this._f = 1750603025;
  this._g = 1694076839;
  this._h = 3204075428;
  return this;
};
Sha224.prototype._hash = function() {
  var H = Buffer$w.allocUnsafe(28);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  return H;
};
var sha224$1 = Sha224;
var inherits$o = requireInherits_browser();
var Hash$3 = hash$3;
var Buffer$v = safeBuffer$1.exports.Buffer;
var K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
var W$1 = new Array(160);
function Sha512() {
  this.init();
  this._w = W$1;
  Hash$3.call(this, 128, 112);
}
inherits$o(Sha512, Hash$3);
Sha512.prototype.init = function() {
  this._ah = 1779033703;
  this._bh = 3144134277;
  this._ch = 1013904242;
  this._dh = 2773480762;
  this._eh = 1359893119;
  this._fh = 2600822924;
  this._gh = 528734635;
  this._hh = 1541459225;
  this._al = 4089235720;
  this._bl = 2227873595;
  this._cl = 4271175723;
  this._dl = 1595750129;
  this._el = 2917565137;
  this._fl = 725511199;
  this._gl = 4215389547;
  this._hl = 327033209;
  return this;
};
function Ch(x, y, z) {
  return z ^ x & (y ^ z);
}
function maj(x, y, z) {
  return x & y | z & (x | y);
}
function sigma0(x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}
function sigma1(x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}
function Gamma0(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}
function Gamma0l(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}
function Gamma1(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}
function Gamma1l(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}
function getCarry(a, b) {
  return a >>> 0 < b >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M) {
  var W2 = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch2 = this._ch | 0;
  var dh2 = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl2 = this._hl | 0;
  for (var i = 0; i < 32; i += 2) {
    W2[i] = M.readInt32BE(i * 4);
    W2[i + 1] = M.readInt32BE(i * 4 + 4);
  }
  for (; i < 160; i += 2) {
    var xh = W2[i - 15 * 2];
    var xl = W2[i - 15 * 2 + 1];
    var gamma02 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W2[i - 2 * 2];
    xl = W2[i - 2 * 2 + 1];
    var gamma12 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh);
    var Wi7h = W2[i - 7 * 2];
    var Wi7l = W2[i - 7 * 2 + 1];
    var Wi16h = W2[i - 16 * 2];
    var Wi16l = W2[i - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma02 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma12 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W2[i] = Wih;
    W2[i + 1] = Wil;
  }
  for (var j = 0; j < 160; j += 2) {
    Wih = W2[j];
    Wil = W2[j + 1];
    var majh = maj(ah, bh, ch2);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh);
    var Kih = K$1[j];
    var Kil = K$1[j + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl2 + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl2) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl2 = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh2 + t1h + getCarry(el, dl) | 0;
    dh2 = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }
  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl2 | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch2 + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh2 + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl2) | 0;
};
Sha512.prototype._hash = function() {
  var H = Buffer$v.allocUnsafe(64);
  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H;
};
var sha512$4 = Sha512;
var inherits$n = requireInherits_browser();
var SHA512$2 = sha512$4;
var Hash$2 = hash$3;
var Buffer$u = safeBuffer$1.exports.Buffer;
var W = new Array(160);
function Sha384() {
  this.init();
  this._w = W;
  Hash$2.call(this, 128, 112);
}
inherits$n(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  this._ah = 3418070365;
  this._bh = 1654270250;
  this._ch = 2438529370;
  this._dh = 355462360;
  this._eh = 1731405415;
  this._fh = 2394180231;
  this._gh = 3675008525;
  this._hh = 1203062813;
  this._al = 3238371032;
  this._bl = 914150663;
  this._cl = 812702999;
  this._dl = 4144912697;
  this._el = 4290775857;
  this._fl = 1750603025;
  this._gl = 1694076839;
  this._hl = 3204075428;
  return this;
};
Sha384.prototype._hash = function() {
  var H = Buffer$u.allocUnsafe(48);
  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H;
};
var sha384$1 = Sha384;
var exports = sha_js.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = exports[algorithm];
  if (!Algorithm)
    throw new Error(algorithm + " is not supported (we accept pull requests)");
  return new Algorithm();
};
exports.sha = sha$5;
exports.sha1 = sha1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$5;
exports.sha384 = sha384$1;
exports.sha512 = sha512$4;
var streamBrowserify = Stream;
var EE = events$1.exports.EventEmitter;
var inherits$m = requireInherits_browser();
inherits$m(Stream, EE);
Stream.Readable = require_stream_readable();
Stream.Writable = require_stream_writable();
Stream.Duplex = require_stream_duplex();
Stream.Transform = _stream_transform;
Stream.PassThrough = _stream_passthrough;
Stream.finished = endOfStream;
Stream.pipeline = pipeline_1;
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var Buffer$t = safeBuffer$1.exports.Buffer;
var Transform$6 = streamBrowserify.Transform;
var StringDecoder = string_decoder.StringDecoder;
var inherits$l = requireInherits_browser();
function CipherBase$1(hashMode) {
  Transform$6.call(this);
  this.hashMode = typeof hashMode === "string";
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
inherits$l(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(data2, inputEnc, outputEnc) {
  if (typeof data2 === "string") {
    data2 = Buffer$t.from(data2, inputEnc);
  }
  var outData = this._update(data2);
  if (this.hashMode)
    return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(data2, _, next) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data2);
    } else {
      this.push(this._update(data2));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};
CipherBase$1.prototype._flush = function(done2) {
  var err;
  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }
  done2(err);
};
CipherBase$1.prototype._finalOrDigest = function(outputEnc) {
  var outData = this.__final() || Buffer$t.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase$1.prototype._toString = function(value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc)
    throw new Error("can't switch encodings");
  var out = this._decoder.write(value);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
var cipherBase = CipherBase$1;
var inherits$k = requireInherits_browser();
var MD5$2 = md5_js;
var RIPEMD160$3 = ripemd160$1;
var sha$4 = sha_js.exports;
var Base$5 = cipherBase;
function Hash$1(hash3) {
  Base$5.call(this, "digest");
  this._hash = hash3;
}
inherits$k(Hash$1, Base$5);
Hash$1.prototype._update = function(data2) {
  this._hash.update(data2);
};
Hash$1.prototype._final = function() {
  return this._hash.digest();
};
var browser$c = function createHash(alg) {
  alg = alg.toLowerCase();
  if (alg === "md5")
    return new MD5$2();
  if (alg === "rmd160" || alg === "ripemd160")
    return new RIPEMD160$3();
  return new Hash$1(sha$4(alg));
};
var inherits$j = requireInherits_browser();
var Buffer$s = safeBuffer$1.exports.Buffer;
var Base$4 = cipherBase;
var ZEROS$2 = Buffer$s.alloc(128);
var blocksize = 64;
function Hmac$3(alg, key3) {
  Base$4.call(this, "digest");
  if (typeof key3 === "string") {
    key3 = Buffer$s.from(key3);
  }
  this._alg = alg;
  this._key = key3;
  if (key3.length > blocksize) {
    key3 = alg(key3);
  } else if (key3.length < blocksize) {
    key3 = Buffer$s.concat([key3, ZEROS$2], blocksize);
  }
  var ipad = this._ipad = Buffer$s.allocUnsafe(blocksize);
  var opad = this._opad = Buffer$s.allocUnsafe(blocksize);
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key3[i] ^ 54;
    opad[i] = key3[i] ^ 92;
  }
  this._hash = [ipad];
}
inherits$j(Hmac$3, Base$4);
Hmac$3.prototype._update = function(data2) {
  this._hash.push(data2);
};
Hmac$3.prototype._final = function() {
  var h = this._alg(Buffer$s.concat(this._hash));
  return this._alg(Buffer$s.concat([this._opad, h]));
};
var legacy = Hmac$3;
var MD5$1 = md5_js;
var md5$2 = function(buffer2) {
  return new MD5$1().update(buffer2).digest();
};
var inherits$i = requireInherits_browser();
var Legacy = legacy;
var Base$3 = cipherBase;
var Buffer$r = safeBuffer$1.exports.Buffer;
var md5$1 = md5$2;
var RIPEMD160$2 = ripemd160$1;
var sha$3 = sha_js.exports;
var ZEROS$1 = Buffer$r.alloc(128);
function Hmac$2(alg, key3) {
  Base$3.call(this, "digest");
  if (typeof key3 === "string") {
    key3 = Buffer$r.from(key3);
  }
  var blocksize2 = alg === "sha512" || alg === "sha384" ? 128 : 64;
  this._alg = alg;
  this._key = key3;
  if (key3.length > blocksize2) {
    var hash3 = alg === "rmd160" ? new RIPEMD160$2() : sha$3(alg);
    key3 = hash3.update(key3).digest();
  } else if (key3.length < blocksize2) {
    key3 = Buffer$r.concat([key3, ZEROS$1], blocksize2);
  }
  var ipad = this._ipad = Buffer$r.allocUnsafe(blocksize2);
  var opad = this._opad = Buffer$r.allocUnsafe(blocksize2);
  for (var i = 0; i < blocksize2; i++) {
    ipad[i] = key3[i] ^ 54;
    opad[i] = key3[i] ^ 92;
  }
  this._hash = alg === "rmd160" ? new RIPEMD160$2() : sha$3(alg);
  this._hash.update(ipad);
}
inherits$i(Hmac$2, Base$3);
Hmac$2.prototype._update = function(data2) {
  this._hash.update(data2);
};
Hmac$2.prototype._final = function() {
  var h = this._hash.digest();
  var hash3 = this._alg === "rmd160" ? new RIPEMD160$2() : sha$3(this._alg);
  return hash3.update(this._opad).update(h).digest();
};
var browser$b = function createHmac(alg, key3) {
  alg = alg.toLowerCase();
  if (alg === "rmd160" || alg === "ripemd160") {
    return new Hmac$2("rmd160", key3);
  }
  if (alg === "md5") {
    return new Legacy(md5$1, key3);
  }
  return new Hmac$2(alg, key3);
};
var algos = { exports: {} };
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
};
const sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
};
const sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
};
const sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
};
const sha256$4 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
};
const sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
};
const sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
};
const sha512$3 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
};
const DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
};
const ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
};
const md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
};
const require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$4,
  sha224,
  sha384,
  sha512: sha512$3,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
(function(module) {
  module.exports = require$$6;
})(algos);
var browser$a = {};
var MAX_ALLOC = Math.pow(2, 30) - 1;
var precondition = function(iterations, keylen) {
  if (typeof iterations !== "number") {
    throw new TypeError("Iterations not a number");
  }
  if (iterations < 0) {
    throw new TypeError("Bad iterations");
  }
  if (typeof keylen !== "number") {
    throw new TypeError("Key length not a number");
  }
  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
    throw new TypeError("Bad key length");
  }
};
var defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser) {
  defaultEncoding$2 = "utf-8";
} else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else {
  defaultEncoding$2 = "utf-8";
}
var defaultEncoding_1 = defaultEncoding$2;
var Buffer$q = safeBuffer$1.exports.Buffer;
var toBuffer$3 = function(thing, encoding, name2) {
  if (Buffer$q.isBuffer(thing)) {
    return thing;
  } else if (typeof thing === "string") {
    return Buffer$q.from(thing, encoding);
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer$q.from(thing.buffer);
  } else {
    throw new TypeError(name2 + " must be a string, a Buffer, a typed array or a DataView");
  }
};
var md5 = md5$2;
var RIPEMD160$1 = ripemd160$1;
var sha$2 = sha_js.exports;
var Buffer$p = safeBuffer$1.exports.Buffer;
var checkParameters$1 = precondition;
var defaultEncoding$1 = defaultEncoding_1;
var toBuffer$2 = toBuffer$3;
var ZEROS = Buffer$p.alloc(128);
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(alg, key3, saltLen) {
  var hash3 = getDigest(alg);
  var blocksize2 = alg === "sha512" || alg === "sha384" ? 128 : 64;
  if (key3.length > blocksize2) {
    key3 = hash3(key3);
  } else if (key3.length < blocksize2) {
    key3 = Buffer$p.concat([key3, ZEROS], blocksize2);
  }
  var ipad = Buffer$p.allocUnsafe(blocksize2 + sizes[alg]);
  var opad = Buffer$p.allocUnsafe(blocksize2 + sizes[alg]);
  for (var i = 0; i < blocksize2; i++) {
    ipad[i] = key3[i] ^ 54;
    opad[i] = key3[i] ^ 92;
  }
  var ipad1 = Buffer$p.allocUnsafe(blocksize2 + saltLen + 4);
  ipad.copy(ipad1, 0, 0, blocksize2);
  this.ipad1 = ipad1;
  this.ipad2 = ipad;
  this.opad = opad;
  this.alg = alg;
  this.blocksize = blocksize2;
  this.hash = hash3;
  this.size = sizes[alg];
}
Hmac$1.prototype.run = function(data2, ipad) {
  data2.copy(ipad, this.blocksize);
  var h = this.hash(ipad);
  h.copy(this.opad, this.blocksize);
  return this.hash(this.opad);
};
function getDigest(alg) {
  function shaFunc(data2) {
    return sha$2(alg).update(data2).digest();
  }
  function rmd160Func(data2) {
    return new RIPEMD160$1().update(data2).digest();
  }
  if (alg === "rmd160" || alg === "ripemd160")
    return rmd160Func;
  if (alg === "md5")
    return md5;
  return shaFunc;
}
function pbkdf2$2(password, salt, iterations, keylen, digest10) {
  checkParameters$1(iterations, keylen);
  password = toBuffer$2(password, defaultEncoding$1, "Password");
  salt = toBuffer$2(salt, defaultEncoding$1, "Salt");
  digest10 = digest10 || "sha1";
  var hmac4 = new Hmac$1(digest10, password, salt.length);
  var DK = Buffer$p.allocUnsafe(keylen);
  var block1 = Buffer$p.allocUnsafe(salt.length + 4);
  salt.copy(block1, 0, 0, salt.length);
  var destPos = 0;
  var hLen = sizes[digest10];
  var l = Math.ceil(keylen / hLen);
  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length);
    var T = hmac4.run(block1, hmac4.ipad1);
    var U = T;
    for (var j = 1; j < iterations; j++) {
      U = hmac4.run(U, hmac4.ipad2);
      for (var k = 0; k < hLen; k++)
        T[k] ^= U[k];
    }
    T.copy(DK, destPos);
    destPos += hLen;
  }
  return DK;
}
var syncBrowser = pbkdf2$2;
var Buffer$o = safeBuffer$1.exports.Buffer;
var checkParameters = precondition;
var defaultEncoding = defaultEncoding_1;
var sync = syncBrowser;
var toBuffer$1 = toBuffer$3;
var ZERO_BUF;
var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
var toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
};
var checks = [];
function checkNative(algo) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
    return Promise.resolve(false);
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false);
  }
  if (checks[algo] !== void 0) {
    return checks[algo];
  }
  ZERO_BUF = ZERO_BUF || Buffer$o.alloc(8);
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
    return true;
  }).catch(function() {
    return false;
  });
  checks[algo] = prom;
  return prom;
}
var nextTick;
function getNextTick() {
  if (nextTick) {
    return nextTick;
  }
  if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
    nextTick = commonjsGlobal.process.nextTick;
  } else if (commonjsGlobal.queueMicrotask) {
    nextTick = commonjsGlobal.queueMicrotask;
  } else if (commonjsGlobal.setImmediate) {
    nextTick = commonjsGlobal.setImmediate;
  } else {
    nextTick = commonjsGlobal.setTimeout;
  }
  return nextTick;
}
function browserPbkdf2(password, salt, iterations, length2, algo) {
  return subtle.importKey(
    "raw",
    password,
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  ).then(function(key3) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt,
      iterations,
      hash: {
        name: algo
      }
    }, key3, length2 << 3);
  }).then(function(res) {
    return Buffer$o.from(res);
  });
}
function resolvePromise(promise, callback) {
  promise.then(function(out) {
    getNextTick()(function() {
      callback(null, out);
    });
  }, function(e) {
    getNextTick()(function() {
      callback(e);
    });
  });
}
var async = function(password, salt, iterations, keylen, digest10, callback) {
  if (typeof digest10 === "function") {
    callback = digest10;
    digest10 = void 0;
  }
  digest10 = digest10 || "sha1";
  var algo = toBrowser[digest10.toLowerCase()];
  if (!algo || typeof commonjsGlobal.Promise !== "function") {
    getNextTick()(function() {
      var out;
      try {
        out = sync(password, salt, iterations, keylen, digest10);
      } catch (e) {
        return callback(e);
      }
      callback(null, out);
    });
    return;
  }
  checkParameters(iterations, keylen);
  password = toBuffer$1(password, defaultEncoding, "Password");
  salt = toBuffer$1(salt, defaultEncoding, "Salt");
  if (typeof callback !== "function")
    throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(algo).then(function(resp) {
    if (resp)
      return browserPbkdf2(password, salt, iterations, keylen, algo);
    return sync(password, salt, iterations, keylen, digest10);
  }), callback);
};
browser$a.pbkdf2 = async;
browser$a.pbkdf2Sync = syncBrowser;
var browser$9 = {};
var des$2 = {};
var utils$D = {};
utils$D.readUInt32BE = function readUInt32BE(bytes, off) {
  var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
  return res >>> 0;
};
utils$D.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = value >>> 16 & 255;
  bytes[2 + off] = value >>> 8 & 255;
  bytes[3 + off] = value & 255;
};
utils$D.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }
  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
utils$D.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
utils$D.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >> j + i & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= inR >> j + i & 1;
  }
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inR >> j + i & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= inL >> j + i & 1;
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
utils$D.r28shl = function r28shl(num, shift) {
  return num << shift & 268435455 | num >>> 28 - shift;
};
var pc2table = [
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$D.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= inL >>> pc2table[i] & 1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= inR >>> pc2table[i] & 1;
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
utils$D.expand = function expand(r2, out, off) {
  var outL = 0;
  var outR = 0;
  outL = (r2 & 1) << 5 | r2 >>> 27;
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= r2 >>> i & 63;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= r2 >>> i & 63;
    outR <<= 6;
  }
  outR |= (r2 & 31) << 1 | r2 >>> 31;
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$D.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = inL >>> 18 - i * 6 & 63;
    var sb = sTable[i * 64 + b];
    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = inR >>> 18 - i * 6 & 63;
    var sb = sTable[4 * 64 + i * 64 + b];
    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$D.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= num >>> permuteTable[i] & 1;
  }
  return out >>> 0;
};
utils$D.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = "0" + str;
  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(" ");
};
var minimalisticAssert$1 = assert$q;
function assert$q(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$q.equal = function assertEqual(l, r2, msg) {
  if (l != r2)
    throw new Error(msg || "Assertion failed: " + l + " != " + r2);
};
var assert$p = minimalisticAssert$1;
function Cipher$3(options) {
  this.options = options;
  this.type = this.options.type;
  this.blockSize = 8;
  this._init();
  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function _init() {
};
Cipher$3.prototype.update = function update(data2) {
  if (data2.length === 0)
    return [];
  if (this.type === "decrypt")
    return this._updateDecrypt(data2);
  else
    return this._updateEncrypt(data2);
};
Cipher$3.prototype._buffer = function _buffer(data2, off) {
  var min = Math.min(this.buffer.length - this.bufferOff, data2.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data2[off + i];
  this.bufferOff += min;
  return min;
};
Cipher$3.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function _updateEncrypt(data2) {
  var inputOff = 0;
  var outputOff = 0;
  var count = (this.bufferOff + data2.length) / this.blockSize | 0;
  var out = new Array(count * this.blockSize);
  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data2, inputOff);
    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }
  var max = data2.length - (data2.length - inputOff) % this.blockSize;
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data2, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }
  for (; inputOff < data2.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data2[inputOff];
  return out;
};
Cipher$3.prototype._updateDecrypt = function _updateDecrypt(data2) {
  var inputOff = 0;
  var outputOff = 0;
  var count = Math.ceil((this.bufferOff + data2.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);
  for (; count > 0; count--) {
    inputOff += this._buffer(data2, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }
  inputOff += this._buffer(data2, inputOff);
  return out;
};
Cipher$3.prototype.final = function final(buffer2) {
  var first;
  if (buffer2)
    first = this.update(buffer2);
  var last;
  if (this.type === "encrypt")
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();
  if (first)
    return first.concat(last);
  else
    return last;
};
Cipher$3.prototype._pad = function _pad(buffer2, off) {
  if (off === 0)
    return false;
  while (off < buffer2.length)
    buffer2[off++] = 0;
  return true;
};
Cipher$3.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};
Cipher$3.prototype._unpad = function _unpad(buffer2) {
  return buffer2;
};
Cipher$3.prototype._finalDecrypt = function _finalDecrypt() {
  assert$p.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);
  return this._unpad(out);
};
var assert$o = minimalisticAssert$1;
var inherits$h = requireInherits_browser();
var utils$C = utils$D;
var Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}
function DES$3(options) {
  Cipher$2.call(this, options);
  var state2 = new DESState();
  this._desState = state2;
  this.deriveKeys(state2, options.key);
}
inherits$h(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function create(options) {
  return new DES$3(options);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function deriveKeys(state2, key3) {
  state2.keys = new Array(16 * 2);
  assert$o.equal(key3.length, this.blockSize, "Invalid key length");
  var kL = utils$C.readUInt32BE(key3, 0);
  var kR = utils$C.readUInt32BE(key3, 4);
  utils$C.pc1(kL, kR, state2.tmp, 0);
  kL = state2.tmp[0];
  kR = state2.tmp[1];
  for (var i = 0; i < state2.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils$C.r28shl(kL, shift);
    kR = utils$C.r28shl(kR, shift);
    utils$C.pc2(kL, kR, state2.keys, i);
  }
};
DES$3.prototype._update = function _update(inp, inOff, out, outOff) {
  var state2 = this._desState;
  var l = utils$C.readUInt32BE(inp, inOff);
  var r2 = utils$C.readUInt32BE(inp, inOff + 4);
  utils$C.ip(l, r2, state2.tmp, 0);
  l = state2.tmp[0];
  r2 = state2.tmp[1];
  if (this.type === "encrypt")
    this._encrypt(state2, l, r2, state2.tmp, 0);
  else
    this._decrypt(state2, l, r2, state2.tmp, 0);
  l = state2.tmp[0];
  r2 = state2.tmp[1];
  utils$C.writeUInt32BE(out, l, outOff);
  utils$C.writeUInt32BE(out, r2, outOff + 4);
};
DES$3.prototype._pad = function _pad2(buffer2, off) {
  var value = buffer2.length - off;
  for (var i = off; i < buffer2.length; i++)
    buffer2[i] = value;
  return true;
};
DES$3.prototype._unpad = function _unpad2(buffer2) {
  var pad3 = buffer2[buffer2.length - 1];
  for (var i = buffer2.length - pad3; i < buffer2.length; i++)
    assert$o.equal(buffer2[i], pad3);
  return buffer2.slice(0, buffer2.length - pad3);
};
DES$3.prototype._encrypt = function _encrypt(state2, lStart, rStart, out, off) {
  var l = lStart;
  var r2 = rStart;
  for (var i = 0; i < state2.keys.length; i += 2) {
    var keyL = state2.keys[i];
    var keyR = state2.keys[i + 1];
    utils$C.expand(r2, state2.tmp, 0);
    keyL ^= state2.tmp[0];
    keyR ^= state2.tmp[1];
    var s2 = utils$C.substitute(keyL, keyR);
    var f2 = utils$C.permute(s2);
    var t = r2;
    r2 = (l ^ f2) >>> 0;
    l = t;
  }
  utils$C.rip(r2, l, out, off);
};
DES$3.prototype._decrypt = function _decrypt(state2, lStart, rStart, out, off) {
  var l = rStart;
  var r2 = lStart;
  for (var i = state2.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state2.keys[i];
    var keyR = state2.keys[i + 1];
    utils$C.expand(l, state2.tmp, 0);
    keyL ^= state2.tmp[0];
    keyR ^= state2.tmp[1];
    var s2 = utils$C.substitute(keyL, keyR);
    var f2 = utils$C.permute(s2);
    var t = l;
    l = (r2 ^ f2) >>> 0;
    r2 = t;
  }
  utils$C.rip(l, r2, out, off);
};
var cbc$1 = {};
var assert$n = minimalisticAssert$1;
var inherits$g = requireInherits_browser();
var proto = {};
function CBCState(iv) {
  assert$n.equal(iv.length, 8, "Invalid IV length");
  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}
function instantiate(Base2) {
  function CBC(options) {
    Base2.call(this, options);
    this._cbcInit();
  }
  inherits$g(CBC, Base2);
  var keys2 = Object.keys(proto);
  for (var i = 0; i < keys2.length; i++) {
    var key3 = keys2[i];
    CBC.prototype[key3] = proto[key3];
  }
  CBC.create = function create5(options) {
    return new CBC(options);
  };
  return CBC;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function _cbcInit() {
  var state2 = new CBCState(this.options.iv);
  this._cbcState = state2;
};
proto._update = function _update2(inp, inOff, out, outOff) {
  var state2 = this._cbcState;
  var superProto = this.constructor.super_.prototype;
  var iv = state2.iv;
  if (this.type === "encrypt") {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];
    superProto._update.call(this, iv, 0, out, outOff);
    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);
    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];
    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};
var assert$m = minimalisticAssert$1;
var inherits$f = requireInherits_browser();
var Cipher$1 = cipher;
var DES$2 = des$1;
function EDEState(type, key3) {
  assert$m.equal(key3.length, 24, "Invalid key length");
  var k1 = key3.slice(0, 8);
  var k2 = key3.slice(8, 16);
  var k3 = key3.slice(16, 24);
  if (type === "encrypt") {
    this.ciphers = [
      DES$2.create({ type: "encrypt", key: k1 }),
      DES$2.create({ type: "decrypt", key: k2 }),
      DES$2.create({ type: "encrypt", key: k3 })
    ];
  } else {
    this.ciphers = [
      DES$2.create({ type: "decrypt", key: k3 }),
      DES$2.create({ type: "encrypt", key: k2 }),
      DES$2.create({ type: "decrypt", key: k1 })
    ];
  }
}
function EDE(options) {
  Cipher$1.call(this, options);
  var state2 = new EDEState(this.type, this.options.key);
  this._edeState = state2;
}
inherits$f(EDE, Cipher$1);
var ede = EDE;
EDE.create = function create2(options) {
  return new EDE(options);
};
EDE.prototype._update = function _update3(inp, inOff, out, outOff) {
  var state2 = this._edeState;
  state2.ciphers[0]._update(inp, inOff, out, outOff);
  state2.ciphers[1]._update(out, outOff, out, outOff);
  state2.ciphers[2]._update(out, outOff, out, outOff);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$D;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase;
var des = des$2;
var inherits$e = requireInherits_browser();
var Buffer$n = safeBuffer$1.exports.Buffer;
var modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$e(DES$1, CipherBase);
function DES$1(opts) {
  CipherBase.call(this);
  var modeName = opts.mode.toLowerCase();
  var mode = modes$3[modeName];
  var type;
  if (opts.decrypt) {
    type = "decrypt";
  } else {
    type = "encrypt";
  }
  var key3 = opts.key;
  if (!Buffer$n.isBuffer(key3)) {
    key3 = Buffer$n.from(key3);
  }
  if (modeName === "des-ede" || modeName === "des-ede-cbc") {
    key3 = Buffer$n.concat([key3, key3.slice(0, 8)]);
  }
  var iv = opts.iv;
  if (!Buffer$n.isBuffer(iv)) {
    iv = Buffer$n.from(iv);
  }
  this._des = mode.create({
    key: key3,
    iv,
    type
  });
}
DES$1.prototype._update = function(data2) {
  return Buffer$n.from(this._des.update(data2));
};
DES$1.prototype._final = function() {
  return Buffer$n.from(this._des.final());
};
var browser$8 = {};
var encrypter = {};
var ecb = {};
ecb.encrypt = function(self2, block) {
  return self2._cipher.encryptBlock(block);
};
ecb.decrypt = function(self2, block) {
  return self2._cipher.decryptBlock(block);
};
var cbc = {};
var bufferXor = function xor(a, b) {
  var length2 = Math.min(a.length, b.length);
  var buffer2 = new Buffer(length2);
  for (var i = 0; i < length2; ++i) {
    buffer2[i] = a[i] ^ b[i];
  }
  return buffer2;
};
var xor$7 = bufferXor;
cbc.encrypt = function(self2, block) {
  var data2 = xor$7(block, self2._prev);
  self2._prev = self2._cipher.encryptBlock(data2);
  return self2._prev;
};
cbc.decrypt = function(self2, block) {
  var pad3 = self2._prev;
  self2._prev = block;
  var out = self2._cipher.decryptBlock(block);
  return xor$7(out, pad3);
};
var cfb = {};
var Buffer$m = safeBuffer$1.exports.Buffer;
var xor$6 = bufferXor;
function encryptStart(self2, data2, decrypt2) {
  var len = data2.length;
  var out = xor$6(data2, self2._cache);
  self2._cache = self2._cache.slice(len);
  self2._prev = Buffer$m.concat([self2._prev, decrypt2 ? data2 : out]);
  return out;
}
cfb.encrypt = function(self2, data2, decrypt2) {
  var out = Buffer$m.allocUnsafe(0);
  var len;
  while (data2.length) {
    if (self2._cache.length === 0) {
      self2._cache = self2._cipher.encryptBlock(self2._prev);
      self2._prev = Buffer$m.allocUnsafe(0);
    }
    if (self2._cache.length <= data2.length) {
      len = self2._cache.length;
      out = Buffer$m.concat([out, encryptStart(self2, data2.slice(0, len), decrypt2)]);
      data2 = data2.slice(len);
    } else {
      out = Buffer$m.concat([out, encryptStart(self2, data2, decrypt2)]);
      break;
    }
  }
  return out;
};
var cfb8 = {};
var Buffer$l = safeBuffer$1.exports.Buffer;
function encryptByte$1(self2, byteParam, decrypt2) {
  var pad3 = self2._cipher.encryptBlock(self2._prev);
  var out = pad3[0] ^ byteParam;
  self2._prev = Buffer$l.concat([
    self2._prev.slice(1),
    Buffer$l.from([decrypt2 ? byteParam : out])
  ]);
  return out;
}
cfb8.encrypt = function(self2, chunk, decrypt2) {
  var len = chunk.length;
  var out = Buffer$l.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    out[i] = encryptByte$1(self2, chunk[i], decrypt2);
  }
  return out;
};
var cfb1 = {};
var Buffer$k = safeBuffer$1.exports.Buffer;
function encryptByte(self2, byteParam, decrypt2) {
  var pad3;
  var i = -1;
  var len = 8;
  var out = 0;
  var bit, value;
  while (++i < len) {
    pad3 = self2._cipher.encryptBlock(self2._prev);
    bit = byteParam & 1 << 7 - i ? 128 : 0;
    value = pad3[0] ^ bit;
    out += (value & 128) >> i % 8;
    self2._prev = shiftIn(self2._prev, decrypt2 ? bit : value);
  }
  return out;
}
function shiftIn(buffer2, value) {
  var len = buffer2.length;
  var i = -1;
  var out = Buffer$k.allocUnsafe(buffer2.length);
  buffer2 = Buffer$k.concat([buffer2, Buffer$k.from([value])]);
  while (++i < len) {
    out[i] = buffer2[i] << 1 | buffer2[i + 1] >> 7;
  }
  return out;
}
cfb1.encrypt = function(self2, chunk, decrypt2) {
  var len = chunk.length;
  var out = Buffer$k.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    out[i] = encryptByte(self2, chunk[i], decrypt2);
  }
  return out;
};
var ofb = {};
var xor$5 = bufferXor;
function getBlock$1(self2) {
  self2._prev = self2._cipher.encryptBlock(self2._prev);
  return self2._prev;
}
ofb.encrypt = function(self2, chunk) {
  while (self2._cache.length < chunk.length) {
    self2._cache = Buffer.concat([self2._cache, getBlock$1(self2)]);
  }
  var pad3 = self2._cache.slice(0, chunk.length);
  self2._cache = self2._cache.slice(chunk.length);
  return xor$5(chunk, pad3);
};
var ctr = {};
function incr32$2(iv) {
  var len = iv.length;
  var item;
  while (len--) {
    item = iv.readUInt8(len);
    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}
var incr32_1 = incr32$2;
var xor$4 = bufferXor;
var Buffer$j = safeBuffer$1.exports.Buffer;
var incr32$1 = incr32_1;
function getBlock(self2) {
  var out = self2._cipher.encryptBlockRaw(self2._prev);
  incr32$1(self2._prev);
  return out;
}
var blockSize = 16;
ctr.encrypt = function(self2, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize);
  var start = self2._cache.length;
  self2._cache = Buffer$j.concat([
    self2._cache,
    Buffer$j.allocUnsafe(chunkNum * blockSize)
  ]);
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self2);
    var offset = start + i * blockSize;
    self2._cache.writeUInt32BE(out[0], offset + 0);
    self2._cache.writeUInt32BE(out[1], offset + 4);
    self2._cache.writeUInt32BE(out[2], offset + 8);
    self2._cache.writeUInt32BE(out[3], offset + 12);
  }
  var pad3 = self2._cache.slice(0, chunk.length);
  self2._cache = self2._cache.slice(chunk.length);
  return xor$4(chunk, pad3);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
};
const aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
};
const aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
};
const require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
};
var modes$2 = require$$2;
for (var key$4 in modes$2) {
  modes$2[key$4].module = modeModules[modes$2[key$4].mode];
}
var modes_1 = modes$2;
var aes$6 = {};
var Buffer$i = safeBuffer$1.exports.Buffer;
function asUInt32Array(buf) {
  if (!Buffer$i.isBuffer(buf))
    buf = Buffer$i.from(buf);
  var len = buf.length / 4 | 0;
  var out = new Array(len);
  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4);
  }
  return out;
}
function scrubVec(v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0;
  }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0];
  var SUB_MIX1 = SUB_MIX[1];
  var SUB_MIX2 = SUB_MIX[2];
  var SUB_MIX3 = SUB_MIX[3];
  var s0 = M[0] ^ keySchedule[0];
  var s1 = M[1] ^ keySchedule[1];
  var s2 = M[2] ^ keySchedule[2];
  var s3 = M[3] ^ keySchedule[3];
  var t0, t1, t2, t3;
  var ksRow = 4;
  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
    s0 = t0;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }
  t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
  t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
  t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
  t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
  t0 = t0 >>> 0;
  t1 = t1 >>> 0;
  t2 = t2 >>> 0;
  t3 = t3 >>> 0;
  return [t0, t1, t2, t3];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
var G = function() {
  var d = new Array(256);
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1;
    } else {
      d[j] = j << 1 ^ 283;
    }
  }
  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX = [[], [], [], []];
  var INV_SUB_MIX = [[], [], [], []];
  var x = 0;
  var xi = 0;
  for (var i = 0; i < 256; ++i) {
    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
    sx = sx >>> 8 ^ sx & 255 ^ 99;
    SBOX[x] = sx;
    INV_SBOX[sx] = x;
    var x2 = d[x];
    var x4 = d[x2];
    var x8 = d[x4];
    var t = d[sx] * 257 ^ sx * 16843008;
    SUB_MIX[0][x] = t << 24 | t >>> 8;
    SUB_MIX[1][x] = t << 16 | t >>> 16;
    SUB_MIX[2][x] = t << 8 | t >>> 24;
    SUB_MIX[3][x] = t;
    t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
    INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
    INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
    INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
    INV_SUB_MIX[3][sx] = t;
    if (x === 0) {
      x = xi = 1;
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]];
      xi ^= d[d[xi]];
    }
  }
  return {
    SBOX,
    INV_SBOX,
    SUB_MIX,
    INV_SUB_MIX
  };
}();
function AES(key3) {
  this._key = asUInt32Array(key3);
  this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  var keyWords = this._key;
  var keySize = keyWords.length;
  var nRounds = keySize + 6;
  var ksRows = (nRounds + 1) * 4;
  var keySchedule = [];
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k];
  }
  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1];
    if (k % keySize === 0) {
      t = t << 8 | t >>> 24;
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
      t ^= RCON[k / keySize | 0] << 24;
    } else if (keySize > 6 && k % keySize === 4) {
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
    }
    keySchedule[k] = keySchedule[k - keySize] ^ t;
  }
  var invKeySchedule = [];
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik;
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt;
    } else {
      invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
    }
  }
  this._nRounds = nRounds;
  this._keySchedule = keySchedule;
  this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
  M = asUInt32Array(M);
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
  var out = this.encryptBlockRaw(M);
  var buf = Buffer$i.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};
AES.prototype.decryptBlock = function(M) {
  M = asUInt32Array(M);
  var m1 = M[1];
  M[1] = M[3];
  M[3] = m1;
  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
  var buf = Buffer$i.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule);
  scrubVec(this._invKeySchedule);
  scrubVec(this._key);
};
aes$6.AES = AES;
var Buffer$h = safeBuffer$1.exports.Buffer;
var ZEROES = Buffer$h.alloc(16, 0);
function toArray$1(buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ];
}
function fromArray(out) {
  var buf = Buffer$h.allocUnsafe(16);
  buf.writeUInt32BE(out[0] >>> 0, 0);
  buf.writeUInt32BE(out[1] >>> 0, 4);
  buf.writeUInt32BE(out[2] >>> 0, 8);
  buf.writeUInt32BE(out[3] >>> 0, 12);
  return buf;
}
function GHASH$1(key3) {
  this.h = key3;
  this.state = Buffer$h.alloc(16, 0);
  this.cache = Buffer$h.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(block) {
  var i = -1;
  while (++i < block.length) {
    this.state[i] ^= block[i];
  }
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  var Vi = toArray$1(this.h);
  var Zi = [0, 0, 0, 0];
  var j, xi, lsbVi;
  var i = -1;
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
    if (xi) {
      Zi[0] ^= Vi[0];
      Zi[1] ^= Vi[1];
      Zi[2] ^= Vi[2];
      Zi[3] ^= Vi[3];
    }
    lsbVi = (Vi[3] & 1) !== 0;
    for (j = 3; j > 0; j--) {
      Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
    }
    Vi[0] = Vi[0] >>> 1;
    if (lsbVi) {
      Vi[0] = Vi[0] ^ 225 << 24;
    }
  }
  this.state = fromArray(Zi);
};
GHASH$1.prototype.update = function(buf) {
  this.cache = Buffer$h.concat([this.cache, buf]);
  var chunk;
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};
GHASH$1.prototype.final = function(abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer$h.concat([this.cache, ZEROES], 16));
  }
  this.ghash(fromArray([0, abl, 0, bl]));
  return this.state;
};
var ghash = GHASH$1;
var aes$5 = aes$6;
var Buffer$g = safeBuffer$1.exports.Buffer;
var Transform$5 = cipherBase;
var inherits$d = requireInherits_browser();
var GHASH = ghash;
var xor$3 = bufferXor;
var incr32 = incr32_1;
function xorTest(a, b) {
  var out = 0;
  if (a.length !== b.length)
    out++;
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; ++i) {
    out += a[i] ^ b[i];
  }
  return out;
}
function calcIv(self2, iv, ck) {
  if (iv.length === 12) {
    self2._finID = Buffer$g.concat([iv, Buffer$g.from([0, 0, 0, 1])]);
    return Buffer$g.concat([iv, Buffer$g.from([0, 0, 0, 2])]);
  }
  var ghash2 = new GHASH(ck);
  var len = iv.length;
  var toPad = len % 16;
  ghash2.update(iv);
  if (toPad) {
    toPad = 16 - toPad;
    ghash2.update(Buffer$g.alloc(toPad, 0));
  }
  ghash2.update(Buffer$g.alloc(8, 0));
  var ivBits = len * 8;
  var tail = Buffer$g.alloc(8);
  tail.writeUIntBE(ivBits, 0, 8);
  ghash2.update(tail);
  self2._finID = ghash2.state;
  var out = Buffer$g.from(self2._finID);
  incr32(out);
  return out;
}
function StreamCipher$3(mode, key3, iv, decrypt2) {
  Transform$5.call(this);
  var h = Buffer$g.alloc(4, 0);
  this._cipher = new aes$5.AES(key3);
  var ck = this._cipher.encryptBlock(h);
  this._ghash = new GHASH(ck);
  iv = calcIv(this, iv, ck);
  this._prev = Buffer$g.from(iv);
  this._cache = Buffer$g.allocUnsafe(0);
  this._secCache = Buffer$g.allocUnsafe(0);
  this._decrypt = decrypt2;
  this._alen = 0;
  this._len = 0;
  this._mode = mode;
  this._authTag = null;
  this._called = false;
}
inherits$d(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - this._alen % 16;
    if (rump < 16) {
      rump = Buffer$g.alloc(rump, 0);
      this._ghash.update(rump);
    }
  }
  this._called = true;
  var out = this._mode.encrypt(this, chunk);
  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }
  this._len += chunk.length;
  return out;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var tag = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(tag, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = tag;
  this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function getAuthTag() {
  if (this._decrypt || !Buffer$g.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function setAuthTag(tag) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = tag;
};
StreamCipher$3.prototype.setAAD = function setAAD(buf) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(buf);
  this._alen += buf.length;
};
var authCipher = StreamCipher$3;
var aes$4 = aes$6;
var Buffer$f = safeBuffer$1.exports.Buffer;
var Transform$4 = cipherBase;
var inherits$c = requireInherits_browser();
function StreamCipher$2(mode, key3, iv, decrypt2) {
  Transform$4.call(this);
  this._cipher = new aes$4.AES(key3);
  this._prev = Buffer$f.from(iv);
  this._cache = Buffer$f.allocUnsafe(0);
  this._secCache = Buffer$f.allocUnsafe(0);
  this._decrypt = decrypt2;
  this._mode = mode;
}
inherits$c(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2;
var Buffer$e = safeBuffer$1.exports.Buffer;
var MD5 = md5_js;
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
  if (!Buffer$e.isBuffer(password))
    password = Buffer$e.from(password, "binary");
  if (salt) {
    if (!Buffer$e.isBuffer(salt))
      salt = Buffer$e.from(salt, "binary");
    if (salt.length !== 8)
      throw new RangeError("salt should be Buffer with 8 byte length");
  }
  var keyLen = keyBits / 8;
  var key3 = Buffer$e.alloc(keyLen);
  var iv = Buffer$e.alloc(ivLen || 0);
  var tmp = Buffer$e.alloc(0);
  while (keyLen > 0 || ivLen > 0) {
    var hash3 = new MD5();
    hash3.update(tmp);
    hash3.update(password);
    if (salt)
      hash3.update(salt);
    tmp = hash3.digest();
    var used = 0;
    if (keyLen > 0) {
      var keyStart = key3.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key3, keyStart, 0, used);
      keyLen -= used;
    }
    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen;
      var length2 = Math.min(ivLen, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length2);
      ivLen -= length2;
    }
  }
  tmp.fill(0);
  return { key: key3, iv };
}
var evp_bytestokey = EVP_BytesToKey;
var MODES$1 = modes_1;
var AuthCipher$1 = authCipher;
var Buffer$d = safeBuffer$1.exports.Buffer;
var StreamCipher$1 = streamCipher;
var Transform$3 = cipherBase;
var aes$3 = aes$6;
var ebtk$2 = evp_bytestokey;
var inherits$b = requireInherits_browser();
function Cipher(mode, key3, iv) {
  Transform$3.call(this);
  this._cache = new Splitter$1();
  this._cipher = new aes$3.AES(key3);
  this._prev = Buffer$d.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
inherits$b(Cipher, Transform$3);
Cipher.prototype._update = function(data2) {
  this._cache.add(data2);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get()) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }
  return Buffer$d.concat(out);
};
var PADDING = Buffer$d.alloc(16, 16);
Cipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);
    this._cipher.scrub();
    return chunk;
  }
  if (!chunk.equals(PADDING)) {
    this._cipher.scrub();
    throw new Error("data not multiple of block length");
  }
};
Cipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter$1() {
  this.cache = Buffer$d.allocUnsafe(0);
}
Splitter$1.prototype.add = function(data2) {
  this.cache = Buffer$d.concat([this.cache, data2]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  var len = 16 - this.cache.length;
  var padBuff = Buffer$d.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }
  return Buffer$d.concat([this.cache, padBuff]);
};
function createCipheriv$1(suite, password, iv) {
  var config2 = MODES$1[suite.toLowerCase()];
  if (!config2)
    throw new TypeError("invalid suite type");
  if (typeof password === "string")
    password = Buffer$d.from(password);
  if (password.length !== config2.key / 8)
    throw new TypeError("invalid key length " + password.length);
  if (typeof iv === "string")
    iv = Buffer$d.from(iv);
  if (config2.mode !== "GCM" && iv.length !== config2.iv)
    throw new TypeError("invalid iv length " + iv.length);
  if (config2.type === "stream") {
    return new StreamCipher$1(config2.module, password, iv);
  } else if (config2.type === "auth") {
    return new AuthCipher$1(config2.module, password, iv);
  }
  return new Cipher(config2.module, password, iv);
}
function createCipher$1(suite, password) {
  var config2 = MODES$1[suite.toLowerCase()];
  if (!config2)
    throw new TypeError("invalid suite type");
  var keys2 = ebtk$2(password, false, config2.key, config2.iv);
  return createCipheriv$1(suite, keys2.key, keys2.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {};
var AuthCipher = authCipher;
var Buffer$c = safeBuffer$1.exports.Buffer;
var MODES = modes_1;
var StreamCipher = streamCipher;
var Transform$2 = cipherBase;
var aes$2 = aes$6;
var ebtk$1 = evp_bytestokey;
var inherits$a = requireInherits_browser();
function Decipher(mode, key3, iv) {
  Transform$2.call(this);
  this._cache = new Splitter();
  this._last = void 0;
  this._cipher = new aes$2.AES(key3);
  this._prev = Buffer$c.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
inherits$a(Decipher, Transform$2);
Decipher.prototype._update = function(data2) {
  this._cache.add(data2);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get(this._autopadding)) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }
  return Buffer$c.concat(out);
};
Decipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error("data not multiple of block length");
  }
};
Decipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter() {
  this.cache = Buffer$c.allocUnsafe(0);
}
Splitter.prototype.add = function(data2) {
  this.cache = Buffer$c.concat([this.cache, data2]);
};
Splitter.prototype.get = function(autoPadding) {
  var out;
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(last) {
  var padded = last[15];
  if (padded < 1 || padded > 16) {
    throw new Error("unable to decrypt data");
  }
  var i = -1;
  while (++i < padded) {
    if (last[i + (16 - padded)] !== padded) {
      throw new Error("unable to decrypt data");
    }
  }
  if (padded === 16)
    return;
  return last.slice(0, 16 - padded);
}
function createDecipheriv$1(suite, password, iv) {
  var config2 = MODES[suite.toLowerCase()];
  if (!config2)
    throw new TypeError("invalid suite type");
  if (typeof iv === "string")
    iv = Buffer$c.from(iv);
  if (config2.mode !== "GCM" && iv.length !== config2.iv)
    throw new TypeError("invalid iv length " + iv.length);
  if (typeof password === "string")
    password = Buffer$c.from(password);
  if (password.length !== config2.key / 8)
    throw new TypeError("invalid key length " + password.length);
  if (config2.type === "stream") {
    return new StreamCipher(config2.module, password, iv, true);
  } else if (config2.type === "auth") {
    return new AuthCipher(config2.module, password, iv, true);
  }
  return new Decipher(config2.module, password, iv);
}
function createDecipher$1(suite, password) {
  var config2 = MODES[suite.toLowerCase()];
  if (!config2)
    throw new TypeError("invalid suite type");
  var keys2 = ebtk$1(password, false, config2.key, config2.iv);
  return createDecipheriv$1(suite, keys2.key, keys2.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter;
var deciphers = decrypter;
var modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$8.createCipher = browser$8.Cipher = ciphers$2.createCipher;
browser$8.createCipheriv = browser$8.Cipheriv = ciphers$2.createCipheriv;
browser$8.createDecipher = browser$8.Decipher = deciphers.createDecipher;
browser$8.createDecipheriv = browser$8.Decipheriv = deciphers.createDecipheriv;
browser$8.listCiphers = browser$8.getCiphers = getCiphers$1;
var modes = {};
(function(exports2) {
  exports2["des-ecb"] = {
    key: 8,
    iv: 0
  };
  exports2["des-cbc"] = exports2.des = {
    key: 8,
    iv: 8
  };
  exports2["des-ede3-cbc"] = exports2.des3 = {
    key: 24,
    iv: 8
  };
  exports2["des-ede3"] = {
    key: 24,
    iv: 0
  };
  exports2["des-ede-cbc"] = {
    key: 16,
    iv: 8
  };
  exports2["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes;
var aes$1 = browser$8;
var aesModes = modes_1;
var desModes = modes;
var ebtk = evp_bytestokey;
function createCipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError("invalid suite type");
  }
  var keys2 = ebtk(password, false, keyLen, ivLen);
  return createCipheriv(suite, keys2.key, keys2.iv);
}
function createDecipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError("invalid suite type");
  }
  var keys2 = ebtk(password, false, keyLen, ivLen);
  return createDecipheriv(suite, keys2.key, keys2.iv);
}
function createCipheriv(suite, key3, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite])
    return aes$1.createCipheriv(suite, key3, iv);
  if (desModes[suite])
    return new DES({ key: key3, iv, mode: suite });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(suite, key3, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite])
    return aes$1.createDecipheriv(suite, key3, iv);
  if (desModes[suite])
    return new DES({ key: key3, iv, mode: suite, decrypt: true });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes$1.getCiphers());
}
browser$9.createCipher = browser$9.Cipher = createCipher;
browser$9.createCipheriv = browser$9.Cipheriv = createCipheriv;
browser$9.createDecipher = browser$9.Decipher = createDecipher;
browser$9.createDecipheriv = browser$9.Decipheriv = createDecipheriv;
browser$9.listCiphers = browser$9.getCiphers = getCiphers;
var browser$7 = {};
var bn$4 = { exports: {} };
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base3, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$3.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init6(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base3, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string2, index2) {
      var c = string2.charCodeAt(index2);
      if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        return c - 48 & 15;
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start, end, mul7) {
      var r2 = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul7;
        if (c >= 49) {
          r2 += c - 49 + 10;
        } else if (c >= 17) {
          r2 += c - 17 + 10;
        } else {
          r2 += c;
        }
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base3);
        for (i = 0; i < mod; i++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect9() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modn(groupBase).toString(base3);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON4() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer2(endian, length2) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length2);
    };
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length2) {
      var byteLength = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType2(reqLength);
      var b, i;
      var q = this.clone();
      if (!littleEndian) {
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i] = b;
        }
        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t = w;
        var r2 = 0;
        if (t >= 4096) {
          r2 += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r2 += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r2 += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r2 += 2;
          t >>>= 2;
        }
        return r2 + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r2 = 0;
      if ((t & 8191) === 0) {
        r2 += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r2 += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r2 += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r2 += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r2 += b;
        if (b !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor4(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add7(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r2 = a * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r2 = a * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N10) {
      var t = new Array(N10);
      var l = BN2.prototype._countBits(N10) - 1;
      for (var i = 0; i < N10; i++) {
        t[i] = this.revBin(i, l, N10);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N10) {
      if (x === 0 || x === N10 - 1)
        return x;
      var rb = 0;
      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute2(rbt, rws, iws, rtws, itws, N10) {
      for (var i = 0; i < N10; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N10);
      for (var s2 = 1; s2 < N10; s2 <<= 1) {
        var l = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0; p < N10; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0; j < s2; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s2];
            var io = itws[p + j + s2];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s2] = re - ro;
            itws[p + j + s2] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N10 = Math.max(m, n) | 1;
      var odd = N10 & 1;
      var i = 0;
      for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
      if (N10 <= 1)
        return;
      for (var i = 0; i < N10 / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N10 - i - 1];
        rws[N10 - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N10 - i - 1];
        iws[N10 - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N10) {
      var carry = 0;
      for (var i = 0; i < N10 / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N10) * 8192 + Math.round(ws[2 * i] / N10) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N10) {
      var carry = 0;
      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len; i < N10; ++i) {
        rws[i] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N10) {
      var ph = new Array(N10);
      for (var i = 0; i < N10; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N10 = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N10);
      var _ = this.stub(N10);
      var rws = new Array(N10);
      var rwst = new Array(N10);
      var iwst = new Array(N10);
      var nrws = new Array(N10);
      var nrwst = new Array(N10);
      var niwst = new Array(N10);
      var rmws = out.words;
      rmws.length = N10;
      this.convert13b(x.words, x.length, rws, N10);
      this.convert13b(y.words, y.length, nrws, N10);
      this.transform(rws, _, rwst, iwst, N10, rbt);
      this.transform(nrws, _, nrwst, niwst, N10, rbt);
      for (var i = 0; i < N10; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N10);
      this.transform(rwst, iwst, rmws, _, N10, rbt);
      this.conjugate(rmws, _, N10);
      this.normalize13b(rmws, N10);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul7(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h -= s2;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2)
        return false;
      var w = this.words[s2];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul7, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul7;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a.strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a.cmp(b);
        if (r2 < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red2(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p) {
      this.name = name2;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg6(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add7(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul7(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r2 = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s2;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN2(1).iushln(m - i - 1));
        r2 = r2.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul7(a, b) {
      if (a.isZero() || b.isZero())
        return new BN2(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$4);
var brorand = { exports: {} };
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var r2;
  brorand.exports = function rand2(len) {
    if (!r2)
      r2 = new Rand(null);
    return r2.generate(len);
  };
  function Rand(rand2) {
    this.rand = rand2;
  }
  brorand.exports.Rand = Rand;
  Rand.prototype.generate = function generate3(len) {
    return this._rand(len);
  };
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for (var i = 0; i < res.length; i++)
      res[i] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      var crypto2 = requireCryptoBrowserify();
      if (typeof crypto2.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n) {
        return crypto2.randomBytes(n);
      };
    } catch (e) {
    }
  }
  return brorand.exports;
}
var mr;
var hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var bn2 = bn$4.exports;
  var brorand2 = requireBrorand();
  function MillerRabin(rand2) {
    this.rand = rand2 || new brorand2.Rand();
  }
  mr = MillerRabin;
  MillerRabin.create = function create5(rand2) {
    return new MillerRabin(rand2);
  };
  MillerRabin.prototype._randbelow = function _randbelow(n) {
    var len = n.bitLength();
    var min_bytes = Math.ceil(len / 8);
    do
      var a = new bn2(this.rand.generate(min_bytes));
    while (a.cmp(n) >= 0);
    return a;
  };
  MillerRabin.prototype._randrange = function _randrange(start, stop) {
    var size = stop.sub(start);
    return start.add(this._randbelow(size));
  };
  MillerRabin.prototype.test = function test(n, k, cb) {
    var len = n.bitLength();
    var red2 = bn2.mont(n);
    var rone = new bn2(1).toRed(red2);
    if (!k)
      k = Math.max(1, len / 48 | 0);
    var n1 = n.subn(1);
    for (var s2 = 0; !n1.testn(s2); s2++) {
    }
    var d = n.shrn(s2);
    var rn1 = n1.toRed(red2);
    var prime = true;
    for (; k > 0; k--) {
      var a = this._randrange(new bn2(2), n1);
      if (cb)
        cb(a);
      var x = a.toRed(red2).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i = 1; i < s2; i++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return false;
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i === s2)
        return false;
    }
    return prime;
  };
  MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
    var len = n.bitLength();
    var red2 = bn2.mont(n);
    var rone = new bn2(1).toRed(red2);
    if (!k)
      k = Math.max(1, len / 48 | 0);
    var n1 = n.subn(1);
    for (var s2 = 0; !n1.testn(s2); s2++) {
    }
    var d = n.shrn(s2);
    var rn1 = n1.toRed(red2);
    for (; k > 0; k--) {
      var a = this._randrange(new bn2(2), n1);
      var g = n.gcd(a);
      if (g.cmpn(1) !== 0)
        return g;
      var x = a.toRed(red2).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i = 1; i < s2; i++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return x.fromRed().subn(1).gcd(n);
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i === s2) {
        x = x.redSqr();
        return x.fromRed().subn(1).gcd(n);
      }
    }
    return false;
  };
  return mr;
}
var generatePrime;
var hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var randomBytes2 = browser$e.exports;
  generatePrime = findPrime;
  findPrime.simpleSieve = simpleSieve;
  findPrime.fermatTest = fermatTest;
  var BN2 = bn$4.exports;
  var TWENTYFOUR = new BN2(24);
  var MillerRabin = requireMr();
  var millerRabin = new MillerRabin();
  var ONE2 = new BN2(1);
  var TWO = new BN2(2);
  var FIVE = new BN2(5);
  new BN2(16);
  new BN2(8);
  var TEN = new BN2(10);
  var THREE = new BN2(3);
  new BN2(7);
  var ELEVEN = new BN2(11);
  var FOUR = new BN2(4);
  new BN2(12);
  var primes = null;
  function _getPrimes() {
    if (primes !== null)
      return primes;
    var limit = 1048576;
    var res = [];
    res[0] = 2;
    for (var i = 1, k = 3; k < limit; k += 2) {
      var sqrt = Math.ceil(Math.sqrt(k));
      for (var j = 0; j < i && res[j] <= sqrt; j++)
        if (k % res[j] === 0)
          break;
      if (i !== j && res[j] <= sqrt)
        continue;
      res[i++] = k;
    }
    primes = res;
    return res;
  }
  function simpleSieve(p) {
    var primes2 = _getPrimes();
    for (var i = 0; i < primes2.length; i++)
      if (p.modn(primes2[i]) === 0) {
        if (p.cmpn(primes2[i]) === 0) {
          return true;
        } else {
          return false;
        }
      }
    return true;
  }
  function fermatTest(p) {
    var red2 = BN2.mont(p);
    return TWO.toRed(red2).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
  }
  function findPrime(bits, gen) {
    if (bits < 16) {
      if (gen === 2 || gen === 5) {
        return new BN2([140, 123]);
      } else {
        return new BN2([140, 39]);
      }
    }
    gen = new BN2(gen);
    var num, n2;
    while (true) {
      num = new BN2(randomBytes2(Math.ceil(bits / 8)));
      while (num.bitLength() > bits) {
        num.ishrn(1);
      }
      if (num.isEven()) {
        num.iadd(ONE2);
      }
      if (!num.testn(1)) {
        num.iadd(TWO);
      }
      if (!gen.cmp(TWO)) {
        while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
          num.iadd(FOUR);
        }
      } else if (!gen.cmp(FIVE)) {
        while (num.mod(TEN).cmp(THREE)) {
          num.iadd(FOUR);
        }
      }
      n2 = num.shrn(1);
      if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
        return num;
      }
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
};
const modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
};
const modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
};
const modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
};
const modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
};
const modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
};
const modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
};
const modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
};
const require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh;
var hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var BN2 = bn$4.exports;
  var MillerRabin = requireMr();
  var millerRabin = new MillerRabin();
  var TWENTYFOUR = new BN2(24);
  var ELEVEN = new BN2(11);
  var TEN = new BN2(10);
  var THREE = new BN2(3);
  var SEVEN = new BN2(7);
  var primes = requireGeneratePrime();
  var randomBytes2 = browser$e.exports;
  dh = DH;
  function setPublicKey(pub2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub2)) {
      pub2 = new Buffer(pub2, enc);
    }
    this._pub = new BN2(pub2);
    return this;
  }
  function setPrivateKey(priv2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv2)) {
      priv2 = new Buffer(priv2, enc);
    }
    this._priv = new BN2(priv2);
    return this;
  }
  var primeCache = {};
  function checkPrime(prime, generator) {
    var gen = generator.toString("hex");
    var hex = [gen, prime.toString(16)].join("_");
    if (hex in primeCache) {
      return primeCache[hex];
    }
    var error3 = 0;
    if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
      error3 += 1;
      if (gen === "02" || gen === "05") {
        error3 += 8;
      } else {
        error3 += 4;
      }
      primeCache[hex] = error3;
      return error3;
    }
    if (!millerRabin.test(prime.shrn(1))) {
      error3 += 2;
    }
    var rem;
    switch (gen) {
      case "02":
        if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
          error3 += 8;
        }
        break;
      case "05":
        rem = prime.mod(TEN);
        if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
          error3 += 8;
        }
        break;
      default:
        error3 += 4;
    }
    primeCache[hex] = error3;
    return error3;
  }
  function DH(prime, generator, malleable) {
    this.setGenerator(generator);
    this.__prime = new BN2(prime);
    this._prime = BN2.mont(this.__prime);
    this._primeLen = prime.length;
    this._pub = void 0;
    this._priv = void 0;
    this._primeCode = void 0;
    if (malleable) {
      this.setPublicKey = setPublicKey;
      this.setPrivateKey = setPrivateKey;
    } else {
      this._primeCode = 8;
    }
  }
  Object.defineProperty(DH.prototype, "verifyError", {
    enumerable: true,
    get: function() {
      if (typeof this._primeCode !== "number") {
        this._primeCode = checkPrime(this.__prime, this.__gen);
      }
      return this._primeCode;
    }
  });
  DH.prototype.generateKeys = function() {
    if (!this._priv) {
      this._priv = new BN2(randomBytes2(this._primeLen));
    }
    this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
    return this.getPublicKey();
  };
  DH.prototype.computeSecret = function(other) {
    other = new BN2(other);
    other = other.toRed(this._prime);
    var secret2 = other.redPow(this._priv).fromRed();
    var out = new Buffer(secret2.toArray());
    var prime = this.getPrime();
    if (out.length < prime.length) {
      var front = new Buffer(prime.length - out.length);
      front.fill(0);
      out = Buffer.concat([front, out]);
    }
    return out;
  };
  DH.prototype.getPublicKey = function getPublicKey(enc) {
    return formatReturnValue(this._pub, enc);
  };
  DH.prototype.getPrivateKey = function getPrivateKey(enc) {
    return formatReturnValue(this._priv, enc);
  };
  DH.prototype.getPrime = function(enc) {
    return formatReturnValue(this.__prime, enc);
  };
  DH.prototype.getGenerator = function(enc) {
    return formatReturnValue(this._gen, enc);
  };
  DH.prototype.setGenerator = function(gen, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(gen)) {
      gen = new Buffer(gen, enc);
    }
    this.__gen = gen;
    this._gen = new BN2(gen);
    return this;
  };
  function formatReturnValue(bn2, enc) {
    var buf = new Buffer(bn2.toArray());
    if (!enc) {
      return buf;
    } else {
      return buf.toString(enc);
    }
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$7;
  hasRequiredBrowser$2 = 1;
  var generatePrime2 = requireGeneratePrime();
  var primes = require$$1$1;
  var DH = requireDh();
  function getDiffieHellman(mod) {
    var prime = new Buffer(primes[mod].prime, "hex");
    var gen = new Buffer(primes[mod].gen, "hex");
    return new DH(prime, gen);
  }
  var ENCODINGS = {
    "binary": true,
    "hex": true,
    "base64": true
  };
  function createDiffieHellman(prime, enc, generator, genc) {
    if (Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
      return createDiffieHellman(prime, "binary", enc, generator);
    }
    enc = enc || "binary";
    genc = genc || "binary";
    generator = generator || new Buffer([2]);
    if (!Buffer.isBuffer(generator)) {
      generator = new Buffer(generator, genc);
    }
    if (typeof prime === "number") {
      return new DH(generatePrime2(prime, generator), generator, true);
    }
    if (!Buffer.isBuffer(prime)) {
      prime = new Buffer(prime, enc);
    }
    return new DH(prime, generator, true);
  }
  browser$7.DiffieHellmanGroup = browser$7.createDiffieHellmanGroup = browser$7.getDiffieHellman = getDiffieHellman;
  browser$7.createDiffieHellman = browser$7.DiffieHellman = createDiffieHellman;
  return browser$7;
}
var sign = { exports: {} };
var bn$3 = { exports: {} };
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base3, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$3.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init6(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base3, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c = string2.charCodeAt(index2);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul7) {
      var r2 = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul7;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert2(c >= 0 && b < mul7, "Invalid character");
        r2 += b;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base3);
        for (i = 0; i < mod; i++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect9;
      } catch (e) {
        BN2.prototype.inspect = inspect9;
      }
    } else {
      BN2.prototype.inspect = inspect9;
    }
    function inspect9() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modrn(groupBase).toString(base3);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON4() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length2) {
        return this.toArrayLike(Buffer2, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType2, size) {
      if (ArrayType2.allocUnsafe) {
        return ArrayType2.allocUnsafe(size);
      }
      return new ArrayType2(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length2) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType2, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t = w;
        var r2 = 0;
        if (t >= 4096) {
          r2 += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r2 += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r2 += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r2 += 2;
          t >>>= 2;
        }
        return r2 + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r2 = 0;
      if ((t & 8191) === 0) {
        r2 += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r2 += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r2 += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r2 += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r2 += b;
        if (b !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor4(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add7(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r2 = a * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r2 = a * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul7(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h -= s2;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2)
        return false;
      var w = this.words[s2];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul7, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul7;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a.cmp(b);
        if (r2 < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red2(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p) {
      this.name = name2;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg6(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add7(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul7(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r2 = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s2;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN2(1).iushln(m - i - 1));
        r2 = r2.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul7(a, b) {
      if (a.isZero() || b.isZero())
        return new BN2(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$3);
var BN$d = bn$3.exports;
var randomBytes$2 = browser$e.exports;
function blind(priv2) {
  var r2 = getr(priv2);
  var blinder = r2.toRed(BN$d.mont(priv2.modulus)).redPow(new BN$d(priv2.publicExponent)).fromRed();
  return { blinder, unblinder: r2.invm(priv2.modulus) };
}
function getr(priv2) {
  var len = priv2.modulus.byteLength();
  var r2;
  do {
    r2 = new BN$d(randomBytes$2(len));
  } while (r2.cmp(priv2.modulus) >= 0 || !r2.umod(priv2.prime1) || !r2.umod(priv2.prime2));
  return r2;
}
function crt$2(msg, priv2) {
  var blinds = blind(priv2);
  var len = priv2.modulus.byteLength();
  var blinded = new BN$d(msg).mul(blinds.blinder).umod(priv2.modulus);
  var c1 = blinded.toRed(BN$d.mont(priv2.prime1));
  var c2 = blinded.toRed(BN$d.mont(priv2.prime2));
  var qinv = priv2.coefficient;
  var p = priv2.prime1;
  var q = priv2.prime2;
  var m1 = c1.redPow(priv2.exponent1).fromRed();
  var m2 = c2.redPow(priv2.exponent2).fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
  return m2.iadd(h).imul(blinds.unblinder).umod(priv2.modulus).toArrayLike(Buffer, "be", len);
}
crt$2.getr = getr;
var browserifyRsa = crt$2;
var elliptic$2 = {};
const name$2 = "elliptic";
const version$r = "6.5.4";
const description$1 = "EC cryptography";
const main$1 = "lib/elliptic.js";
const files$2 = [
  "lib"
];
const scripts$1 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
};
const repository$1 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
};
const keywords$1 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
];
const author$1 = "Fedor Indutny <fedor@indutny.com>";
const license$1 = "MIT";
const bugs$1 = {
  url: "https://github.com/indutny/elliptic/issues"
};
const homepage$1 = "https://github.com/indutny/elliptic";
const devDependencies$1 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
};
const dependencies$1 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
};
const require$$0$2 = {
  name: name$2,
  version: version$r,
  description: description$1,
  main: main$1,
  files: files$2,
  scripts: scripts$1,
  repository: repository$1,
  keywords: keywords$1,
  author: author$1,
  license: license$1,
  bugs: bugs$1,
  homepage: homepage$1,
  devDependencies: devDependencies$1,
  dependencies: dependencies$1
};
var utils$B = {};
var utils$A = {};
(function(exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero22(msg[i].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode8(arr, enc) {
    if (enc === "hex")
      return toHex3(arr);
    else
      return arr;
  };
})(utils$A);
(function(exports2) {
  var utils2 = exports2;
  var BN2 = bn$4.exports;
  var minAssert = minimalisticAssert$1;
  var minUtils = utils$A;
  utils2.assert = minAssert;
  utils2.toArray = minUtils.toArray;
  utils2.zero2 = minUtils.zero2;
  utils2.toHex = minUtils.toHex;
  utils2.encode = minUtils.encode;
  function getNAF2(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj2, name2, computer) {
    var key3 = "_" + name2;
    obj2.prototype[name2] = function cachedProperty3() {
      return this[key3] !== void 0 ? this[key3] : this[key3] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes) {
    return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes) {
    return new BN2(bytes, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
})(utils$B);
var curve = {};
var BN$c = bn$4.exports;
var utils$z = utils$B;
var getNAF$1 = utils$z.getNAF;
var getJSF$1 = utils$z.getJSF;
var assert$l = utils$z.assert;
function BaseCurve$1(type, conf) {
  this.type = type;
  this.p = new BN$c(conf.p, 16);
  this.red = conf.prime ? BN$c.red(conf.prime) : BN$c.mont(this.p);
  this.zero = new BN$c(0).toRed(this.red);
  this.one = new BN$c(1).toRed(this.red);
  this.two = new BN$c(2).toRed(this.red);
  this.n = conf.n && new BN$c(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$4 = BaseCurve$1;
BaseCurve$1.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$l(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF$1(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve$1.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF$1(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$l(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve$1.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF$1(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF$1(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index2 = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF$1(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint$1(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve$1.BasePoint = BasePoint$1;
BasePoint$1.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint$1.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve$1.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils$z.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$l(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$l(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint$1.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint$1.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint$1.prototype.encode = function encode(enc, compact) {
  return utils$z.encode(this._encode(compact), enc);
};
BasePoint$1.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint$1.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint$1.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint$1.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl7 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl7);
  return {
    wnd,
    points: res
  };
};
BasePoint$1.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint$1.prototype.dblp = function dblp(k) {
  var r2 = this;
  for (var i = 0; i < k; i++)
    r2 = r2.dbl();
  return r2;
};
var utils$y = utils$B;
var BN$b = bn$4.exports;
var inherits$9 = requireInherits_browser();
var Base$2 = base$4;
var assert$k = utils$y.assert;
function ShortCurve$1(conf) {
  Base$2.call(this, "short", conf);
  this.a = new BN$b(conf.a, 16).toRed(this.red);
  this.b = new BN$b(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$9(ShortCurve$1, Base$2);
var short = ShortCurve$1;
ShortCurve$1.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$b(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$b(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$k(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$b(vec.a, 16),
        b: new BN$b(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve$1.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red2 = num === this.p ? this.red : BN$b.mont(num);
  var tinv = new BN$b(2).toRed(red2).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$b(3).toRed(red2).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve$1.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$b(1);
  var y1 = new BN$b(0);
  var x2 = new BN$b(0);
  var y2 = new BN$b(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r2;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r2 = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r2;
    v = u;
    u = r2;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve$1.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve$1.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$b(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve$1.prototype.validate = function validate3(point7) {
  if (point7.inf)
    return true;
  var x = point7.x;
  var y = point7.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve$1.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point$3(curve2, x, y, isRed) {
  Base$2.BasePoint.call(this, curve2, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$b(x, 16);
    this.y = new BN$b(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$9(Point$3, Base$2.BasePoint);
ShortCurve$1.prototype.point = function point2(x, y, isRed) {
  return new Point$3(this, x, y, isRed);
};
ShortCurve$1.prototype.pointFromJSON = function pointFromJSON(obj2, red2) {
  return Point$3.fromJSON(this, obj2, red2);
};
Point$3.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre2 = this.precomputed;
  if (pre2 && pre2.beta)
    return pre2.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre2) {
    var curve2 = this.curve;
    var endoMul = function(p) {
      return curve2.point(p.x.redMul(curve2.endo.beta), p.y);
    };
    pre2.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre2.naf && {
        wnd: pre2.naf.wnd,
        points: pre2.naf.points.map(endoMul)
      },
      doubles: pre2.doubles && {
        step: pre2.doubles.step,
        points: pre2.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$3.prototype.toJSON = function toJSON2() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$3.fromJSON = function fromJSON(curve2, obj2, red2) {
  if (typeof obj2 === "string")
    obj2 = JSON.parse(obj2);
  var res = curve2.point(obj2[0], obj2[1], red2);
  if (!obj2[2])
    return res;
  function obj2point(obj3) {
    return curve2.point(obj3[0], obj3[1], red2);
  }
  var pre2 = obj2[2];
  res.precomputed = {
    beta: null,
    doubles: pre2.doubles && {
      step: pre2.doubles.step,
      points: [res].concat(pre2.doubles.points.map(obj2point))
    },
    naf: pre2.naf && {
      wnd: pre2.naf.wnd,
      points: [res].concat(pre2.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$3.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$3.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point$3.prototype.add = function add(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$3.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$3.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point$3.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point$3.prototype.mul = function mul(k) {
  k = new BN$b(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point$3.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$3.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$3.prototype.eq = function eq2(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point$3.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre2 = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre2.naf && {
        wnd: pre2.naf.wnd,
        points: pre2.naf.points.map(negate)
      },
      doubles: pre2.doubles && {
        step: pre2.doubles.step,
        points: pre2.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point$3.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint$1(curve2, x, y, z) {
  Base$2.BasePoint.call(this, curve2, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$b(0);
  } else {
    this.x = new BN$b(x, 16);
    this.y = new BN$b(y, 16);
    this.z = new BN$b(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits$9(JPoint$1, Base$2.BasePoint);
ShortCurve$1.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint$1(this, x, y, z);
};
JPoint$1.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint$1.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint$1.prototype.add = function add2(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.mixedAdd = function mixedAdd(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i = 0; i < pow; i++)
      r2 = r2.dbl();
    return r2;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint$1.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint$1.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f2 = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s2).redISub(s2);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype._dbl = function _dbl() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.mul = function mul2(k, kbase) {
  k = new BN$b(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint$1.prototype.eq = function eq3(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint$1.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint$1.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint$1.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var BN$a = bn$4.exports;
var inherits$8 = requireInherits_browser();
var Base$1 = base$4;
var utils$x = utils$B;
function MontCurve(conf) {
  Base$1.call(this, "mont", conf);
  this.a = new BN$a(conf.a, 16).toRed(this.red);
  this.b = new BN$a(conf.b, 16).toRed(this.red);
  this.i4 = new BN$a(4).toRed(this.red).redInvm();
  this.two = new BN$a(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$8(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function validate4(point7) {
  var x = point7.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();
  return y.redSqr().cmp(rhs) === 0;
};
function Point$2(curve2, x, z) {
  Base$1.BasePoint.call(this, curve2, "projective");
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$a(x, 16);
    this.z = new BN$a(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$8(Point$2, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint2(bytes, enc) {
  return this.point(utils$x.toArray(bytes, enc), 1);
};
MontCurve.prototype.point = function point3(x, z) {
  return new Point$2(this, x, z);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON2(obj2) {
  return Point$2.fromJSON(this, obj2);
};
Point$2.prototype.precompute = function precompute2() {
};
Point$2.prototype._encode = function _encode2() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$2.fromJSON = function fromJSON2(curve2, obj2) {
  return new Point$2(curve2, obj2[0], obj2[1] || curve2.one);
};
Point$2.prototype.inspect = function inspect3() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function isInfinity3() {
  return this.z.cmpn(0) === 0;
};
Point$2.prototype.dbl = function dbl3() {
  var a = this.x.redAdd(this.z);
  var aa = a.redSqr();
  var b = this.x.redSub(this.z);
  var bb = b.redSqr();
  var c = aa.redSub(bb);
  var nx = aa.redMul(bb);
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};
Point$2.prototype.add = function add3() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.diffAdd = function diffAdd(p, diff) {
  var a = this.x.redAdd(this.z);
  var b = this.x.redSub(this.z);
  var c = p.x.redAdd(p.z);
  var d = p.x.redSub(p.z);
  var da = d.redMul(a);
  var cb = c.redMul(b);
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};
Point$2.prototype.mul = function mul3(k) {
  var t = k.clone();
  var a = this;
  var b = this.curve.point(null, null);
  var c = this;
  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));
  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      a = a.diffAdd(b, c);
      b = b.dbl();
    } else {
      b = a.diffAdd(b, c);
      a = a.dbl();
    }
  }
  return b;
};
Point$2.prototype.mulAdd = function mulAdd2() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.jumlAdd = function jumlAdd() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.eq = function eq4(other) {
  return this.getX().cmp(other.getX()) === 0;
};
Point$2.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};
Point$2.prototype.getX = function getX2() {
  this.normalize();
  return this.x.fromRed();
};
var utils$w = utils$B;
var BN$9 = bn$4.exports;
var inherits$7 = requireInherits_browser();
var Base = base$4;
var assert$j = utils$w.assert;
function EdwardsCurve(conf) {
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, "edwards", conf);
  this.a = new BN$9(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$9(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$9(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert$j(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits$7(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};
EdwardsCurve.prototype.jpoint = function jpoint2(x, y, z, t) {
  return this.point(x, y, z, t);
};
EdwardsCurve.prototype.pointFromX = function pointFromX2(x, odd) {
  x = new BN$9(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN$9(y, 16);
  if (!y.red)
    y = y.toRed(this.red);
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());
  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error("invalid point");
    else
      return this.point(this.zero, y);
  }
  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.validate = function validate5(point7) {
  if (point7.isInfinity())
    return true;
  point7.normalize();
  var x2 = point7.x.redSqr();
  var y2 = point7.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};
function Point$1(curve2, x, y, z, t) {
  Base.BasePoint.call(this, curve2, "projective");
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$9(x, 16);
    this.y = new BN$9(y, 16);
    this.z = z ? new BN$9(z, 16) : this.curve.one;
    this.t = t && new BN$9(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits$7(Point$1, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON3(obj2) {
  return Point$1.fromJSON(this, obj2);
};
EdwardsCurve.prototype.point = function point4(x, y, z, t) {
  return new Point$1(this, x, y, z, t);
};
Point$1.fromJSON = function fromJSON3(curve2, obj2) {
  return new Point$1(curve2, obj2[0], obj2[1], obj2[2]);
};
Point$1.prototype.inspect = function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function isInfinity4() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point$1.prototype._extDbl = function _extDbl() {
  var a = this.x.redSqr();
  var b = this.y.redSqr();
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  var d = this.curve._mulA(a);
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  var g = d.redAdd(b);
  var f2 = g.redSub(c);
  var h = d.redSub(b);
  var nx = e.redMul(f2);
  var ny = g.redMul(h);
  var nt = e.redMul(h);
  var nz = f2.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point$1.prototype._projDbl = function _projDbl() {
  var b = this.x.redAdd(this.y).redSqr();
  var c = this.x.redSqr();
  var d = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    e = this.curve._mulA(c);
    var f2 = e.redAdd(d);
    if (this.zOne) {
      nx = b.redSub(c).redSub(d).redMul(f2.redSub(this.curve.two));
      ny = f2.redMul(e.redSub(d));
      nz = f2.redSqr().redSub(f2).redSub(f2);
    } else {
      h = this.z.redSqr();
      j = f2.redSub(h).redISub(h);
      nx = b.redSub(c).redISub(d).redMul(j);
      ny = f2.redMul(e.redSub(d));
      nz = f2.redMul(j);
    }
  } else {
    e = c.redAdd(d);
    h = this.curve._mulC(this.z).redSqr();
    j = e.redSub(h).redSub(h);
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};
Point$1.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};
Point$1.prototype._extAdd = function _extAdd(p) {
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  var d = this.z.redMul(p.z.redAdd(p.z));
  var e = b.redSub(a);
  var f2 = d.redSub(c);
  var g = d.redAdd(c);
  var h = b.redAdd(a);
  var nx = e.redMul(f2);
  var ny = g.redMul(h);
  var nt = e.redMul(h);
  var nz = f2.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point$1.prototype._projAdd = function _projAdd(p) {
  var a = this.z.redMul(p.z);
  var b = a.redSqr();
  var c = this.x.redMul(p.x);
  var d = this.y.redMul(p.y);
  var e = this.curve.d.redMul(c).redMul(d);
  var f2 = b.redSub(e);
  var g = b.redAdd(e);
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f2).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    nz = f2.redMul(g);
  } else {
    ny = a.redMul(g).redMul(d.redSub(c));
    nz = this.curve._mulC(f2).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};
Point$1.prototype.add = function add4(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};
Point$1.prototype.mul = function mul4(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};
Point$1.prototype.mulAdd = function mulAdd3(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
};
Point$1.prototype.jmulAdd = function jmulAdd2(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
};
Point$1.prototype.normalize = function normalize2() {
  if (this.zOne)
    return this;
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};
Point$1.prototype.neg = function neg3() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point$1.prototype.getX = function getX3() {
  this.normalize();
  return this.x.fromRed();
};
Point$1.prototype.getY = function getY2() {
  this.normalize();
  return this.y.fromRed();
};
Point$1.prototype.eq = function eq5(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point$1.prototype.eqXToP = function eqXToP2(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
Point$1.prototype.toP = Point$1.prototype.normalize;
Point$1.prototype.mixedAdd = Point$1.prototype.add;
(function(exports2) {
  var curve2 = exports2;
  curve2.base = base$4;
  curve2.short = short;
  curve2.mont = mont;
  curve2.edwards = edwards;
})(curve);
var curves$1 = {};
var hash$2 = {};
var utils$v = {};
var assert$i = minimalisticAssert$1;
var inherits$6 = requireInherits_browser();
utils$v.inherits = inherits$6;
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 64512) !== 55296) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$v.toArray = toArray;
function toHex$1(msg) {
  var res = "";
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$v.toHex = toHex$1;
function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
  return res >>> 0;
}
utils$v.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === "little")
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils$v.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$v.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$v.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$i(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === "big")
      w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
    else
      w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils$v.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === "big") {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 255;
      res[k + 2] = m >>> 8 & 255;
      res[k + 3] = m & 255;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 255;
      res[k + 1] = m >>> 8 & 255;
      res[k] = m & 255;
    }
  }
  return res;
}
utils$v.split32 = split32;
function rotr32$1(w, b) {
  return w >>> b | w << 32 - b;
}
utils$v.rotr32 = rotr32$1;
function rotl32$2(w, b) {
  return w << b | w >>> 32 - b;
}
utils$v.rotl32 = rotl32$2;
function sum32$3(a, b) {
  return a + b >>> 0;
}
utils$v.sum32 = sum32$3;
function sum32_3$1(a, b, c) {
  return a + b + c >>> 0;
}
utils$v.sum32_3 = sum32_3$1;
function sum32_4$2(a, b, c, d) {
  return a + b + c + d >>> 0;
}
utils$v.sum32_4 = sum32_4$2;
function sum32_5$2(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}
utils$v.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$v.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$v.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$v.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch2, cl, dh2, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch2 + dh2 + carry;
  return hi >>> 0;
}
utils$v.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch2, cl, dh2, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$v.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch2, cl, dh2, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch2 + dh2 + eh + carry;
  return hi >>> 0;
}
utils$v.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch2, cl, dh2, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$v.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
utils$v.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$v.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$v.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$v.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$u = utils$v;
var assert$h = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update2(msg, enc) {
  msg = utils$u.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$u.join32(msg, 0, msg.length - r2, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$h(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 128;
  for (var i = 1; i < k; i++)
    res[i] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len & 255;
  } else {
    res[i++] = len & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 24 & 255;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }
  return res;
};
var sha$1 = {};
var common$4 = {};
var utils$t = utils$v;
var rotr32 = utils$t.rotr32;
function ft_1$1(s2, x, y, z) {
  if (s2 === 0)
    return ch32$1(x, y, z);
  if (s2 === 1 || s2 === 3)
    return p32(x, y, z);
  if (s2 === 2)
    return maj32$1(x, y, z);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x, y, z) {
  return x & y ^ ~x & z;
}
common$4.ch32 = ch32$1;
function maj32$1(x, y, z) {
  return x & y ^ x & z ^ y & z;
}
common$4.maj32 = maj32$1;
function p32(x, y, z) {
  return x ^ y ^ z;
}
common$4.p32 = p32;
function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$s = utils$v;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$s.rotl32;
var sum32$2 = utils$s.sum32;
var sum32_5$1 = utils$s.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$s.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update4(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = rotl32$1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16], 1);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  for (i = 0; i < W2.length; i++) {
    var s2 = ~~(i / 20);
    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s2, b, c, d), e, W2[i], sha1_K[s2]);
    e = d;
    d = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t;
  }
  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d);
  this.h[4] = sum32$2(this.h[4], e);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$s.toHex32(this.h, "big");
  else
    return utils$s.split32(this.h, "big");
};
var utils$r = utils$v;
var common$2 = common$5;
var shaCommon = common$4;
var assert$g = minimalisticAssert$1;
var sum32$1 = utils$r.sum32;
var sum32_4$1 = utils$r.sum32_4;
var sum32_5 = utils$r.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$r.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update5(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = sum32_4$1(g1_256(W2[i - 2]), W2[i - 7], g0_256(W2[i - 15]), W2[i - 16]);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f2 = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert$g(this.k.length === W2.length);
  for (i = 0; i < W2.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f2, g), this.k[i], W2[i]);
    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    h = g;
    g = f2;
    f2 = e;
    e = sum32$1(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$r.toHex32(this.h, "big");
  else
    return utils$r.split32(this.h, "big");
};
var utils$q = utils$v;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$q.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$q.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$q.split32(this.h.slice(0, 7), "big");
};
var utils$p = utils$v;
var common$1 = common$5;
var assert$f = minimalisticAssert$1;
var rotr64_hi = utils$p.rotr64_hi;
var rotr64_lo = utils$p.rotr64_lo;
var shr64_hi = utils$p.shr64_hi;
var shr64_lo = utils$p.shr64_lo;
var sum64 = utils$p.sum64;
var sum64_hi = utils$p.sum64_hi;
var sum64_lo = utils$p.sum64_lo;
var sum64_4_hi = utils$p.sum64_4_hi;
var sum64_4_lo = utils$p.sum64_4_lo;
var sum64_5_hi = utils$p.sum64_5_hi;
var sum64_5_lo = utils$p.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$p.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 32; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i += 2) {
    var c0_hi = g1_512_hi(W2[i - 4], W2[i - 3]);
    var c0_lo = g1_512_lo(W2[i - 4], W2[i - 3]);
    var c1_hi = W2[i - 14];
    var c1_lo = W2[i - 13];
    var c2_hi = g0_512_hi(W2[i - 30], W2[i - 29]);
    var c2_lo = g0_512_lo(W2[i - 30], W2[i - 29]);
    var c3_hi = W2[i - 32];
    var c3_lo = W2[i - 31];
    W2[i] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update6(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch2 = this.h[4];
  var cl = this.h[5];
  var dh2 = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl2 = this.h[15];
  assert$f(this.k.length === W2.length);
  for (var i = 0; i < W2.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W2[i];
    var c4_lo = W2[i + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch2);
    c1_lo = maj64_lo(ah, al, bh, bl, ch2, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl2 = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh2, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh2 = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch2, cl);
  sum64(this.h, 6, dh2, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl2);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$p.toHex32(this.h, "big");
  else
    return utils$p.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ ~xh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh, zl2) {
  var r2 = xl & yl ^ ~xl & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ xh & zh ^ yh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh, zl2) {
  var r2 = xl & yl ^ xl & zl2 ^ yl & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$o = utils$v;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$o.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$o.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$o.split32(this.h.slice(0, 12), "big");
};
sha$1.sha1 = _1;
sha$1.sha224 = _224;
sha$1.sha256 = _256;
sha$1.sha384 = _384;
sha$1.sha512 = _512;
var ripemd = {};
var utils$n = utils$v;
var common = common$5;
var rotl32 = utils$n.rotl32;
var sum32 = utils$n.sum32;
var sum32_3 = utils$n.sum32_3;
var sum32_4 = utils$n.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$n.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update3(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch2 = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f$4(j, B, C, D), msg[r$1[j] + start], K(j)),
        s[j]
      ),
      E
    );
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f$4(79 - j, Bh, Ch2, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]
      ),
      Eh
    );
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch2, 10);
    Ch2 = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch2);
  this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$n.toHex32(this.h, "little");
  else
    return utils$n.split32(this.h, "little");
};
function f$4(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return x & y | ~x & z;
  else if (j <= 47)
    return (x | ~y) ^ z;
  else if (j <= 63)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
function K(j) {
  if (j <= 15)
    return 0;
  else if (j <= 31)
    return 1518500249;
  else if (j <= 47)
    return 1859775393;
  else if (j <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j) {
  if (j <= 15)
    return 1352829926;
  else if (j <= 31)
    return 1548603684;
  else if (j <= 47)
    return 1836072691;
  else if (j <= 63)
    return 2053994217;
  else
    return 0;
}
var r$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$m = utils$v;
var assert$e = minimalisticAssert$1;
function Hmac(hash3, key3, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash3, key3, enc);
  this.Hash = hash3;
  this.blockSize = hash3.blockSize / 8;
  this.outSize = hash3.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$m.toArray(key3, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init2(key3) {
  if (key3.length > this.blockSize)
    key3 = new this.Hash().update(key3).digest();
  assert$e(key3.length <= this.blockSize);
  for (var i = key3.length; i < this.blockSize; i++)
    key3.push(0);
  for (i = 0; i < key3.length; i++)
    key3[i] ^= 54;
  this.inner = new this.Hash().update(key3);
  for (i = 0; i < key3.length; i++)
    key3[i] ^= 106;
  this.outer = new this.Hash().update(key3);
};
Hmac.prototype.update = function update4(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports2) {
  var hash3 = exports2;
  hash3.utils = utils$v;
  hash3.common = common$5;
  hash3.sha = sha$1;
  hash3.ripemd = ripemd;
  hash3.hmac = hmac;
  hash3.sha1 = hash3.sha.sha1;
  hash3.sha256 = hash3.sha.sha256;
  hash3.sha224 = hash3.sha.sha224;
  hash3.sha384 = hash3.sha.sha384;
  hash3.sha512 = hash3.sha.sha512;
  hash3.ripemd160 = hash3.ripemd.ripemd160;
})(hash$2);
var secp256k1$1;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1)
    return secp256k1$1;
  hasRequiredSecp256k1 = 1;
  secp256k1$1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1$1;
}
(function(exports2) {
  var curves2 = exports2;
  var hash3 = hash$2;
  var curve$1 = curve;
  var utils2 = utils$B;
  var assert2 = utils2.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve$1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve$1.edwards(options);
    else
      this.curve = new curve$1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre2;
  try {
    pre2 = requireSecp256k1();
  } catch (e) {
    pre2 = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash3.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre2
    ]
  });
})(curves$1);
var hash$1 = hash$2;
var utils$l = utils$A;
var assert$d = minimalisticAssert$1;
function HmacDRBG$1(options) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils$l.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils$l.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils$l.toArray(options.pers, options.persEnc || "hex");
  assert$d(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg$1 = HmacDRBG$1;
HmacDRBG$1.prototype._init = function init3(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function hmac2() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function update5(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add7, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add7;
    add7 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils$l.toArray(entropy, entropyEnc);
  add7 = utils$l.toArray(add7, addEnc);
  assert$d(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add7 || []));
  this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function generate(len, enc, add7, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add7;
    add7 = enc;
    enc = null;
  }
  if (add7) {
    add7 = utils$l.toArray(add7, addEnc || "hex");
    this._update(add7);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add7);
  this._reseed++;
  return utils$l.encode(res, enc);
};
var BN$8 = bn$4.exports;
var utils$k = utils$B;
var assert$c = utils$k.assert;
function KeyPair$3(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$3 = KeyPair$3;
KeyPair$3.fromPublic = function fromPublic(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$3)
    return pub2;
  return new KeyPair$3(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$3.fromPrivate = function fromPrivate(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$3)
    return priv2;
  return new KeyPair$3(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$3.prototype.validate = function validate6() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$3.prototype._importPrivate = function _importPrivate(key3, enc) {
  this.priv = new BN$8(key3, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function _importPublic(key3, enc) {
  if (key3.x || key3.y) {
    if (this.ec.curve.type === "mont") {
      assert$c(key3.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$c(key3.x && key3.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key3.x, key3.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key3, enc);
};
KeyPair$3.prototype.derive = function derive(pub2) {
  if (!pub2.validate()) {
    assert$c(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function sign2(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair$3.prototype.verify = function verify2(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair$3.prototype.inspect = function inspect5() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$7 = bn$4.exports;
var utils$j = utils$B;
var assert$b = utils$j.assert;
function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$b(options.r && options.s, "Signature without r or s");
  this.r = new BN$7(options.r, 16);
  this.s = new BN$7(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$2 = Signature$3;
function Position$1() {
  this.place = 0;
}
function getLength$1(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding$1(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature$3.prototype._importDER = function _importDER(data2, enc) {
  data2 = utils$j.toArray(data2, enc);
  var p = new Position$1();
  if (data2[p.place++] !== 48) {
    return false;
  }
  var len = getLength$1(data2, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data2.length) {
    return false;
  }
  if (data2[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength$1(data2, p);
  if (rlen === false) {
    return false;
  }
  var r2 = data2.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data2[p.place++] !== 2) {
    return false;
  }
  var slen = getLength$1(data2, p);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p.place) {
    return false;
  }
  var s2 = data2.slice(p.place, slen + p.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$7(r2);
  this.s = new BN$7(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength$1(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature$3.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding$1(r2);
  s2 = rmPadding$1(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength$1(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength$1(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength$1(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$j.encode(res, enc);
};
var ec$2;
var hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec$2;
  hasRequiredEc = 1;
  var BN2 = bn$4.exports;
  var HmacDRBG2 = hmacDrbg$1;
  var utils2 = utils$B;
  var curves2 = curves$1;
  var rand2 = requireBrorand();
  var assert2 = utils2.assert;
  var KeyPair2 = key$3;
  var Signature2 = signature$2;
  function EC2(options) {
    if (!(this instanceof EC2))
      return new EC2(options);
    if (typeof options === "string") {
      assert2(
        Object.prototype.hasOwnProperty.call(curves2, options),
        "Unknown curve " + options
      );
      options = curves2[options];
    }
    if (options instanceof curves2.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  ec$2 = EC2;
  EC2.prototype.keyPair = function keyPair2(options) {
    return new KeyPair2(this, options);
  };
  EC2.prototype.keyFromPrivate = function keyFromPrivate2(priv2, enc) {
    return KeyPair2.fromPrivate(this, priv2, enc);
  };
  EC2.prototype.keyFromPublic = function keyFromPublic3(pub2, enc) {
    return KeyPair2.fromPublic(this, pub2, enc);
  };
  EC2.prototype.genKeyPair = function genKeyPair2(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG2({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand2(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN2(2));
    for (; ; ) {
      var priv2 = new BN2(drbg.generate(bytes));
      if (priv2.cmp(ns2) > 0)
        continue;
      priv2.iaddn(1);
      return this.keyFromPrivate(priv2);
    }
  };
  EC2.prototype._truncateToN = function _truncateToN2(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC2.prototype.sign = function sign7(msg, key3, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key3 = this.keyFromPrivate(key3, enc);
    msg = this._truncateToN(new BN2(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key3.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    var drbg = new HmacDRBG2({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN2(1));
    for (var iter = 0; ; iter++) {
      var k = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r2 = kpX.umod(this.n);
      if (r2.cmpn(0) === 0)
        continue;
      var s2 = k.invm(this.n).mul(r2.mul(key3.getPrivate()).iadd(msg));
      s2 = s2.umod(this.n);
      if (s2.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
      if (options.canonical && s2.cmp(this.nh) > 0) {
        s2 = this.n.sub(s2);
        recoveryParam ^= 1;
      }
      return new Signature2({ r: r2, s: s2, recoveryParam });
    }
  };
  EC2.prototype.verify = function verify7(msg, signature2, key3, enc) {
    msg = this._truncateToN(new BN2(msg, 16));
    key3 = this.keyFromPublic(key3, enc);
    signature2 = new Signature2(signature2, "hex");
    var r2 = signature2.r;
    var s2 = signature2.s;
    if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
      return false;
    if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
      return false;
    var sinv = s2.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r2).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
      p = this.g.mulAdd(u1, key3.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.getX().umod(this.n).cmp(r2) === 0;
    }
    p = this.g.jmulAdd(u1, key3.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.eqXToP(r2);
  };
  EC2.prototype.recoverPubKey = function(msg, signature2, j, enc) {
    assert2((3 & j) === j, "The recovery param is more than two bits");
    signature2 = new Signature2(signature2, enc);
    var n = this.n;
    var e = new BN2(msg);
    var r2 = signature2.r;
    var s2 = signature2.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
    else
      r2 = this.curve.pointFromX(r2, isYOdd);
    var rInv = signature2.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s22 = s2.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r2, s22);
  };
  EC2.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
    signature2 = new Signature2(signature2, enc);
    if (signature2.recoveryParam !== null)
      return signature2.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature2, i);
      } catch (e2) {
        continue;
      }
      if (Qprime.eq(Q))
        return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  return ec$2;
}
var utils$i = utils$B;
var assert$a = utils$i.assert;
var parseBytes$2 = utils$i.parseBytes;
var cachedProperty$1 = utils$i.cachedProperty;
function KeyPair$2(eddsa2, params) {
  this.eddsa = eddsa2;
  this._secret = parseBytes$2(params.secret);
  if (eddsa2.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}
KeyPair$2.fromPublic = function fromPublic2(eddsa2, pub2) {
  if (pub2 instanceof KeyPair$2)
    return pub2;
  return new KeyPair$2(eddsa2, { pub: pub2 });
};
KeyPair$2.fromSecret = function fromSecret(eddsa2, secret2) {
  if (secret2 instanceof KeyPair$2)
    return secret2;
  return new KeyPair$2(eddsa2, { secret: secret2 });
};
KeyPair$2.prototype.secret = function secret() {
  return this._secret;
};
cachedProperty$1(KeyPair$2, "pubBytes", function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$2, "pub", function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$2, "privBytes", function privBytes() {
  var eddsa2 = this.eddsa;
  var hash3 = this.hash();
  var lastIx = eddsa2.encodingLength - 1;
  var a = hash3.slice(0, eddsa2.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;
  return a;
});
cachedProperty$1(KeyPair$2, "priv", function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$2, "hash", function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$2, "messagePrefix", function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$2.prototype.sign = function sign3(message) {
  assert$a(this._secret, "KeyPair can only verify");
  return this.eddsa.sign(message, this);
};
KeyPair$2.prototype.verify = function verify3(message, sig) {
  return this.eddsa.verify(message, sig, this);
};
KeyPair$2.prototype.getSecret = function getSecret(enc) {
  assert$a(this._secret, "KeyPair is public only");
  return utils$i.encode(this.secret(), enc);
};
KeyPair$2.prototype.getPublic = function getPublic2(enc) {
  return utils$i.encode(this.pubBytes(), enc);
};
var key$2 = KeyPair$2;
var BN$6 = bn$4.exports;
var utils$h = utils$B;
var assert$9 = utils$h.assert;
var cachedProperty = utils$h.cachedProperty;
var parseBytes$1 = utils$h.parseBytes;
function Signature$2(eddsa2, sig) {
  this.eddsa = eddsa2;
  if (typeof sig !== "object")
    sig = parseBytes$1(sig);
  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa2.encodingLength),
      S: sig.slice(eddsa2.encodingLength)
    };
  }
  assert$9(sig.R && sig.S, "Signature without R or S");
  if (eddsa2.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN$6)
    this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature$2, "S", function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$2, "R", function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$2, "Rencoded", function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$2, "Sencoded", function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});
Signature$2.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$2.prototype.toHex = function toHex() {
  return utils$h.encode(this.toBytes(), "hex").toUpperCase();
};
var signature$1 = Signature$2;
var hash2 = hash$2;
var curves = curves$1;
var utils$g = utils$B;
var assert$8 = utils$g.assert;
var parseBytes = utils$g.parseBytes;
var KeyPair$1 = key$2;
var Signature$1 = signature$1;
function EDDSA(curve2) {
  assert$8(curve2 === "ed25519", "only tested with ed25519 so far");
  if (!(this instanceof EDDSA))
    return new EDDSA(curve2);
  curve2 = curves[curve2].curve;
  this.curve = curve2;
  this.g = curve2.g;
  this.g.precompute(curve2.n.bitLength() + 1);
  this.pointClass = curve2.point().constructor;
  this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
  this.hash = hash2.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function sign4(message, secret2) {
  message = parseBytes(message);
  var key3 = this.keyFromSecret(secret2);
  var r2 = this.hashInt(key3.messagePrefix(), message);
  var R2 = this.g.mul(r2);
  var Rencoded2 = this.encodePoint(R2);
  var s_ = this.hashInt(Rencoded2, key3.pubBytes(), message).mul(key3.priv());
  var S2 = r2.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R2, S: S2, Rencoded: Rencoded2 });
};
EDDSA.prototype.verify = function verify4(message, sig, pub2) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key3 = this.keyFromPublic(pub2);
  var h = this.hashInt(sig.Rencoded(), key3.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key3.pub().mul(h));
  return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
  var hash3 = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash3.update(arguments[i]);
  return utils$g.intFromLE(hash3.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic(pub2) {
  return KeyPair$1.fromPublic(this, pub2);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret2) {
  return KeyPair$1.fromSecret(this, secret2);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature$1)
    return sig;
  return new Signature$1(this, sig);
};
EDDSA.prototype.encodePoint = function encodePoint(point7) {
  var enc = point7.getY().toArray("le", this.encodingLength);
  enc[this.encodingLength - 1] |= point7.getX().isOdd() ? 128 : 0;
  return enc;
};
EDDSA.prototype.decodePoint = function decodePoint3(bytes) {
  bytes = utils$g.parseBytes(bytes);
  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
  var xIsOdd = (bytes[lastIx] & 128) !== 0;
  var y = utils$g.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils$g.intFromLE(bytes);
};
EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  if (hasRequiredElliptic)
    return elliptic$2;
  hasRequiredElliptic = 1;
  (function(exports2) {
    var elliptic2 = exports2;
    elliptic2.version = require$$0$2.version;
    elliptic2.utils = utils$B;
    elliptic2.rand = requireBrorand();
    elliptic2.curve = curve;
    elliptic2.curves = curves$1;
    elliptic2.ec = requireEc();
    elliptic2.eddsa = eddsa;
  })(elliptic$2);
  return elliptic$2;
}
var bn$2 = { exports: {} };
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base3, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$3.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init6(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base3, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c = string2.charCodeAt(index2);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul7) {
      var r2 = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul7;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert2(c >= 0 && b < mul7, "Invalid character");
        r2 += b;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base3);
        for (i = 0; i < mod; i++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect9;
      } catch (e) {
        BN2.prototype.inspect = inspect9;
      }
    } else {
      BN2.prototype.inspect = inspect9;
    }
    function inspect9() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modrn(groupBase).toString(base3);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON4() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length2) {
        return this.toArrayLike(Buffer2, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType2, size) {
      if (ArrayType2.allocUnsafe) {
        return ArrayType2.allocUnsafe(size);
      }
      return new ArrayType2(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length2) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType2, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t = w;
        var r2 = 0;
        if (t >= 4096) {
          r2 += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r2 += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r2 += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r2 += 2;
          t >>>= 2;
        }
        return r2 + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r2 = 0;
      if ((t & 8191) === 0) {
        r2 += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r2 += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r2 += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r2 += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r2 += b;
        if (b !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor4(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add7(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r2 = a * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r2 = a * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul7(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h -= s2;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2)
        return false;
      var w = this.words[s2];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul7, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul7;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a.cmp(b);
        if (r2 < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red2(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p) {
      this.name = name2;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg6(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add7(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul7(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r2 = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s2;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN2(1).iushln(m - i - 1));
        r2 = r2.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul7(a, b) {
      if (a.isZero() || b.isZero())
        return new BN2(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$2);
var asn1$3 = {};
var asn1$2 = {};
var api$1 = {};
var encoders = {};
var buffer$2 = buffer$3;
var Buffer$b = buffer$2.Buffer;
var safer = {};
var key$1;
for (key$1 in buffer$2) {
  if (!buffer$2.hasOwnProperty(key$1))
    continue;
  if (key$1 === "SlowBuffer" || key$1 === "Buffer")
    continue;
  safer[key$1] = buffer$2[key$1];
}
var Safer = safer.Buffer = {};
for (key$1 in Buffer$b) {
  if (!Buffer$b.hasOwnProperty(key$1))
    continue;
  if (key$1 === "allocUnsafe" || key$1 === "allocUnsafeSlow")
    continue;
  Safer[key$1] = Buffer$b[key$1];
}
safer.Buffer.prototype = Buffer$b.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function(value, encodingOrOffset, length2) {
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }
    if (value && typeof value.length === "undefined") {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    return Buffer$b(value, encodingOrOffset, length2);
  };
}
if (!Safer.alloc) {
  Safer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
    var buf = Buffer$b(size);
    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === "string") {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
    return buf;
  };
}
if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch (e) {
  }
}
if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}
var safer_1 = safer;
var reporter = {};
const inherits$5 = requireInherits_browser();
function Reporter$2(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
reporter.Reporter = Reporter$2;
Reporter$2.prototype.isError = function isError(obj2) {
  return obj2 instanceof ReporterError;
};
Reporter$2.prototype.save = function save() {
  const state2 = this._reporterState;
  return { obj: state2.obj, pathLen: state2.path.length };
};
Reporter$2.prototype.restore = function restore(data2) {
  const state2 = this._reporterState;
  state2.obj = data2.obj;
  state2.path = state2.path.slice(0, data2.pathLen);
};
Reporter$2.prototype.enterKey = function enterKey(key3) {
  return this._reporterState.path.push(key3);
};
Reporter$2.prototype.exitKey = function exitKey(index2) {
  const state2 = this._reporterState;
  state2.path = state2.path.slice(0, index2 - 1);
};
Reporter$2.prototype.leaveKey = function leaveKey(index2, key3, value) {
  const state2 = this._reporterState;
  this.exitKey(index2);
  if (state2.obj !== null)
    state2.obj[key3] = value;
};
Reporter$2.prototype.path = function path() {
  return this._reporterState.path.join("/");
};
Reporter$2.prototype.enterObject = function enterObject() {
  const state2 = this._reporterState;
  const prev = state2.obj;
  state2.obj = {};
  return prev;
};
Reporter$2.prototype.leaveObject = function leaveObject(prev) {
  const state2 = this._reporterState;
  const now2 = state2.obj;
  state2.obj = prev;
  return now2;
};
Reporter$2.prototype.error = function error2(msg) {
  let err;
  const state2 = this._reporterState;
  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state2.path.map(function(elem) {
      return "[" + JSON.stringify(elem) + "]";
    }).join(""), msg.message || msg, msg.stack);
  }
  if (!state2.options.partial)
    throw err;
  if (!inherited)
    state2.errors.push(err);
  return err;
};
Reporter$2.prototype.wrapResult = function wrapResult(result) {
  const state2 = this._reporterState;
  if (!state2.options.partial)
    return result;
  return {
    result: this.isError(result) ? null : result,
    errors: state2.errors
  };
};
function ReporterError(path3, msg) {
  this.path = path3;
  this.rethrow(msg);
}
inherits$5(ReporterError, Error);
ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + " at: " + (this.path || "(shallow)");
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);
  if (!this.stack) {
    try {
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};
var buffer$1 = {};
const inherits$4 = requireInherits_browser();
const Reporter$1 = reporter.Reporter;
const Buffer$a = safer_1.Buffer;
function DecoderBuffer$2(base3, options) {
  Reporter$1.call(this, options);
  if (!Buffer$a.isBuffer(base3)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = base3;
  this.offset = 0;
  this.length = base3.length;
}
inherits$4(DecoderBuffer$2, Reporter$1);
buffer$1.DecoderBuffer = DecoderBuffer$2;
DecoderBuffer$2.isDecoderBuffer = function isDecoderBuffer(data2) {
  if (data2 instanceof DecoderBuffer$2) {
    return true;
  }
  const isCompatible = typeof data2 === "object" && Buffer$a.isBuffer(data2.base) && data2.constructor.name === "DecoderBuffer" && typeof data2.offset === "number" && typeof data2.length === "number" && typeof data2.save === "function" && typeof data2.restore === "function" && typeof data2.isEmpty === "function" && typeof data2.readUInt8 === "function" && typeof data2.skip === "function" && typeof data2.raw === "function";
  return isCompatible;
};
DecoderBuffer$2.prototype.save = function save2() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
};
DecoderBuffer$2.prototype.restore = function restore2(save3) {
  const res = new DecoderBuffer$2(this.base);
  res.offset = save3.offset;
  res.length = this.offset;
  this.offset = save3.offset;
  Reporter$1.prototype.restore.call(this, save3.reporter);
  return res;
};
DecoderBuffer$2.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};
DecoderBuffer$2.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || "DecoderBuffer overrun");
};
DecoderBuffer$2.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || "DecoderBuffer overrun");
  const res = new DecoderBuffer$2(this.base);
  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};
DecoderBuffer$2.prototype.raw = function raw(save3) {
  return this.base.slice(save3 ? save3.offset : this.offset, this.length);
};
function EncoderBuffer$1(value, reporter2) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer$1.isEncoderBuffer(item))
        item = new EncoderBuffer$1(item, reporter2);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === "number") {
    if (!(0 <= value && value <= 255))
      return reporter2.error("non-byte EncoderBuffer value");
    this.value = value;
    this.length = 1;
  } else if (typeof value === "string") {
    this.value = value;
    this.length = Buffer$a.byteLength(value);
  } else if (Buffer$a.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter2.error("Unsupported type: " + typeof value);
  }
}
buffer$1.EncoderBuffer = EncoderBuffer$1;
EncoderBuffer$1.isEncoderBuffer = function isEncoderBuffer(data2) {
  if (data2 instanceof EncoderBuffer$1) {
    return true;
  }
  const isCompatible = typeof data2 === "object" && data2.constructor.name === "EncoderBuffer" && typeof data2.length === "number" && typeof data2.join === "function";
  return isCompatible;
};
EncoderBuffer$1.prototype.join = function join(out, offset) {
  if (!out)
    out = Buffer$a.alloc(this.length);
  if (!offset)
    offset = 0;
  if (this.length === 0)
    return out;
  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === "number")
      out[offset] = this.value;
    else if (typeof this.value === "string")
      out.write(this.value, offset);
    else if (Buffer$a.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }
  return out;
};
const Reporter = reporter.Reporter;
const EncoderBuffer = buffer$1.EncoderBuffer;
const DecoderBuffer$1 = buffer$1.DecoderBuffer;
const assert$7 = minimalisticAssert$1;
const tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
];
const methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags);
const overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node$2(enc, parent, name2) {
  const state2 = {};
  this._baseState = state2;
  state2.name = name2;
  state2.enc = enc;
  state2.parent = parent || null;
  state2.children = null;
  state2.tag = null;
  state2.args = null;
  state2.reverseArgs = null;
  state2.choice = null;
  state2.optional = false;
  state2.any = false;
  state2.obj = false;
  state2.use = null;
  state2.useDecoder = null;
  state2.key = null;
  state2["default"] = null;
  state2.explicit = null;
  state2.implicit = null;
  state2.contains = null;
  if (!state2.parent) {
    state2.children = [];
    this._wrap();
  }
}
var node$1 = Node$2;
const stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node$2.prototype.clone = function clone() {
  const state2 = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state2[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};
Node$2.prototype._wrap = function wrap() {
  const state2 = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone2 = new this.constructor(this);
      state2.children.push(clone2);
      return clone2[method].apply(clone2, arguments);
    };
  }, this);
};
Node$2.prototype._init = function init4(body) {
  const state2 = this._baseState;
  assert$7(state2.parent === null);
  body.call(this);
  state2.children = state2.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert$7.equal(state2.children.length, 1, "Root node can have only one child");
};
Node$2.prototype._useArgs = function useArgs(args) {
  const state2 = this._baseState;
  const children2 = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);
  if (children2.length !== 0) {
    assert$7(state2.children === null);
    state2.children = children2;
    children2.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert$7(state2.args === null);
    state2.args = args;
    state2.reverseArgs = args.map(function(arg) {
      if (typeof arg !== "object" || arg.constructor !== Object)
        return arg;
      const res = {};
      Object.keys(arg).forEach(function(key3) {
        if (key3 == (key3 | 0))
          key3 |= 0;
        const value = arg[key3];
        res[value] = key3;
      });
      return res;
    });
  }
};
overrided.forEach(function(method) {
  Node$2.prototype[method] = function _overrided() {
    const state2 = this._baseState;
    throw new Error(method + " not implemented for encoding: " + state2.enc);
  };
});
tags.forEach(function(tag) {
  Node$2.prototype[tag] = function _tagMethod() {
    const state2 = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    assert$7(state2.tag === null);
    state2.tag = tag;
    this._useArgs(args);
    return this;
  };
});
Node$2.prototype.use = function use2(item) {
  assert$7(item);
  const state2 = this._baseState;
  assert$7(state2.use === null);
  state2.use = item;
  return this;
};
Node$2.prototype.optional = function optional() {
  const state2 = this._baseState;
  state2.optional = true;
  return this;
};
Node$2.prototype.def = function def(val) {
  const state2 = this._baseState;
  assert$7(state2["default"] === null);
  state2["default"] = val;
  state2.optional = true;
  return this;
};
Node$2.prototype.explicit = function explicit(num) {
  const state2 = this._baseState;
  assert$7(state2.explicit === null && state2.implicit === null);
  state2.explicit = num;
  return this;
};
Node$2.prototype.implicit = function implicit(num) {
  const state2 = this._baseState;
  assert$7(state2.explicit === null && state2.implicit === null);
  state2.implicit = num;
  return this;
};
Node$2.prototype.obj = function obj() {
  const state2 = this._baseState;
  const args = Array.prototype.slice.call(arguments);
  state2.obj = true;
  if (args.length !== 0)
    this._useArgs(args);
  return this;
};
Node$2.prototype.key = function key(newKey) {
  const state2 = this._baseState;
  assert$7(state2.key === null);
  state2.key = newKey;
  return this;
};
Node$2.prototype.any = function any() {
  const state2 = this._baseState;
  state2.any = true;
  return this;
};
Node$2.prototype.choice = function choice(obj2) {
  const state2 = this._baseState;
  assert$7(state2.choice === null);
  state2.choice = obj2;
  this._useArgs(Object.keys(obj2).map(function(key3) {
    return obj2[key3];
  }));
  return this;
};
Node$2.prototype.contains = function contains(item) {
  const state2 = this._baseState;
  assert$7(state2.use === null);
  state2.contains = item;
  return this;
};
Node$2.prototype._decode = function decode(input, options) {
  const state2 = this._baseState;
  if (state2.parent === null)
    return input.wrapResult(state2.children[0]._decode(input, options));
  let result = state2["default"];
  let present = true;
  let prevKey = null;
  if (state2.key !== null)
    prevKey = input.enterKey(state2.key);
  if (state2.optional) {
    let tag = null;
    if (state2.explicit !== null)
      tag = state2.explicit;
    else if (state2.implicit !== null)
      tag = state2.implicit;
    else if (state2.tag !== null)
      tag = state2.tag;
    if (tag === null && !state2.any) {
      const save3 = input.save();
      try {
        if (state2.choice === null)
          this._decodeGeneric(state2.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save3);
    } else {
      present = this._peekTag(input, tag, state2.any);
      if (input.isError(present))
        return present;
    }
  }
  let prevObj;
  if (state2.obj && present)
    prevObj = input.enterObject();
  if (present) {
    if (state2.explicit !== null) {
      const explicit2 = this._decodeTag(input, state2.explicit);
      if (input.isError(explicit2))
        return explicit2;
      input = explicit2;
    }
    const start = input.offset;
    if (state2.use === null && state2.choice === null) {
      let save3;
      if (state2.any)
        save3 = input.save();
      const body = this._decodeTag(
        input,
        state2.implicit !== null ? state2.implicit : state2.tag,
        state2.any
      );
      if (input.isError(body))
        return body;
      if (state2.any)
        result = input.raw(save3);
      else
        input = body;
    }
    if (options && options.track && state2.tag !== null)
      options.track(input.path(), start, input.length, "tagged");
    if (options && options.track && state2.tag !== null)
      options.track(input.path(), input.offset, input.length, "content");
    if (state2.any)
      ;
    else if (state2.choice === null) {
      result = this._decodeGeneric(state2.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }
    if (input.isError(result))
      return result;
    if (!state2.any && state2.choice === null && state2.children !== null) {
      state2.children.forEach(function decodeChildren(child) {
        child._decode(input, options);
      });
    }
    if (state2.contains && (state2.tag === "octstr" || state2.tag === "bitstr")) {
      const data2 = new DecoderBuffer$1(result);
      result = this._getUse(state2.contains, input._reporterState.obj)._decode(data2, options);
    }
  }
  if (state2.obj && present)
    result = input.leaveObject(prevObj);
  if (state2.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state2.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);
  return result;
};
Node$2.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state2 = this._baseState;
  if (tag === "seq" || tag === "set")
    return null;
  if (tag === "seqof" || tag === "setof")
    return this._decodeList(input, tag, state2.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === "objid" && state2.args)
    return this._decodeObjid(input, state2.args[0], state2.args[1], options);
  else if (tag === "objid")
    return this._decodeObjid(input, null, null, options);
  else if (tag === "gentime" || tag === "utctime")
    return this._decodeTime(input, tag, options);
  else if (tag === "null_")
    return this._decodeNull(input, options);
  else if (tag === "bool")
    return this._decodeBool(input, options);
  else if (tag === "objDesc")
    return this._decodeStr(input, tag, options);
  else if (tag === "int" || tag === "enum")
    return this._decodeInt(input, state2.args && state2.args[0], options);
  if (state2.use !== null) {
    return this._getUse(state2.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error("unknown tag: " + tag);
  }
};
Node$2.prototype._getUse = function _getUse(entity, obj2) {
  const state2 = this._baseState;
  state2.useDecoder = this._use(entity, obj2);
  assert$7(state2.useDecoder._baseState.parent === null);
  state2.useDecoder = state2.useDecoder._baseState.children[0];
  if (state2.implicit !== state2.useDecoder._baseState.implicit) {
    state2.useDecoder = state2.useDecoder.clone();
    state2.useDecoder._baseState.implicit = state2.implicit;
  }
  return state2.useDecoder;
};
Node$2.prototype._decodeChoice = function decodeChoice(input, options) {
  const state2 = this._baseState;
  let result = null;
  let match = false;
  Object.keys(state2.choice).some(function(key3) {
    const save3 = input.save();
    const node2 = state2.choice[key3];
    try {
      const value = node2._decode(input, options);
      if (input.isError(value))
        return false;
      result = { type: key3, value };
      match = true;
    } catch (e) {
      input.restore(save3);
      return false;
    }
    return true;
  }, this);
  if (!match)
    return input.error("Choice not matched");
  return result;
};
Node$2.prototype._createEncoderBuffer = function createEncoderBuffer(data2) {
  return new EncoderBuffer(data2, this.reporter);
};
Node$2.prototype._encode = function encode2(data2, reporter2, parent) {
  const state2 = this._baseState;
  if (state2["default"] !== null && state2["default"] === data2)
    return;
  const result = this._encodeValue(data2, reporter2, parent);
  if (result === void 0)
    return;
  if (this._skipDefault(result, reporter2, parent))
    return;
  return result;
};
Node$2.prototype._encodeValue = function encode3(data2, reporter2, parent) {
  const state2 = this._baseState;
  if (state2.parent === null)
    return state2.children[0]._encode(data2, reporter2 || new Reporter());
  let result = null;
  this.reporter = reporter2;
  if (state2.optional && data2 === void 0) {
    if (state2["default"] !== null)
      data2 = state2["default"];
    else
      return;
  }
  let content = null;
  let primitive = false;
  if (state2.any) {
    result = this._createEncoderBuffer(data2);
  } else if (state2.choice) {
    result = this._encodeChoice(data2, reporter2);
  } else if (state2.contains) {
    content = this._getUse(state2.contains, parent)._encode(data2, reporter2);
    primitive = true;
  } else if (state2.children) {
    content = state2.children.map(function(child) {
      if (child._baseState.tag === "null_")
        return child._encode(null, reporter2, data2);
      if (child._baseState.key === null)
        return reporter2.error("Child should have a key");
      const prevKey = reporter2.enterKey(child._baseState.key);
      if (typeof data2 !== "object")
        return reporter2.error("Child expected, but input is not object");
      const res = child._encode(data2[child._baseState.key], reporter2, data2);
      reporter2.leaveKey(prevKey);
      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state2.tag === "seqof" || state2.tag === "setof") {
      if (!(state2.args && state2.args.length === 1))
        return reporter2.error("Too many args for : " + state2.tag);
      if (!Array.isArray(data2))
        return reporter2.error("seqof/setof, but data is not Array");
      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data2.map(function(item) {
        const state3 = this._baseState;
        return this._getUse(state3.args[0], data2)._encode(item, reporter2);
      }, child));
    } else if (state2.use !== null) {
      result = this._getUse(state2.use, parent)._encode(data2, reporter2);
    } else {
      content = this._encodePrimitive(state2.tag, data2);
      primitive = true;
    }
  }
  if (!state2.any && state2.choice === null) {
    const tag = state2.implicit !== null ? state2.implicit : state2.tag;
    const cls = state2.implicit === null ? "universal" : "context";
    if (tag === null) {
      if (state2.use === null)
        reporter2.error("Tag could be omitted only for .use()");
    } else {
      if (state2.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }
  if (state2.explicit !== null)
    result = this._encodeComposite(state2.explicit, false, "context", result);
  return result;
};
Node$2.prototype._encodeChoice = function encodeChoice(data2, reporter2) {
  const state2 = this._baseState;
  const node2 = state2.choice[data2.type];
  if (!node2) {
    assert$7(
      false,
      data2.type + " not found in " + JSON.stringify(Object.keys(state2.choice))
    );
  }
  return node2._encode(data2.value, reporter2);
};
Node$2.prototype._encodePrimitive = function encodePrimitive(tag, data2) {
  const state2 = this._baseState;
  if (/str$/.test(tag))
    return this._encodeStr(data2, tag);
  else if (tag === "objid" && state2.args)
    return this._encodeObjid(data2, state2.reverseArgs[0], state2.args[1]);
  else if (tag === "objid")
    return this._encodeObjid(data2, null, null);
  else if (tag === "gentime" || tag === "utctime")
    return this._encodeTime(data2, tag);
  else if (tag === "null_")
    return this._encodeNull();
  else if (tag === "int" || tag === "enum")
    return this._encodeInt(data2, state2.args && state2.reverseArgs[0]);
  else if (tag === "bool")
    return this._encodeBool(data2);
  else if (tag === "objDesc")
    return this._encodeStr(data2, tag);
  else
    throw new Error("Unsupported tag: " + tag);
};
Node$2.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};
Node$2.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
var der$2 = {};
(function(exports2) {
  function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key3) {
      if ((key3 | 0) == key3)
        key3 = key3 | 0;
      const value = map[key3];
      res[value] = key3;
    });
    return res;
  }
  exports2.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  };
  exports2.tagClassByName = reverse(exports2.tagClass);
  exports2.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  };
  exports2.tagByName = reverse(exports2.tag);
})(der$2);
const inherits$3 = requireInherits_browser();
const Buffer$9 = safer_1.Buffer;
const Node$1 = node$1;
const der$1 = der$2;
function DEREncoder$1(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode$1();
  this.tree._init(entity.body);
}
var der_1$1 = DEREncoder$1;
DEREncoder$1.prototype.encode = function encode4(data2, reporter2) {
  return this.tree._encode(data2, reporter2).join();
};
function DERNode$1(parent) {
  Node$1.call(this, "der", parent);
}
inherits$3(DERNode$1, Node$1);
DERNode$1.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
  if (content.length < 128) {
    const header2 = Buffer$9.alloc(2);
    header2[0] = encodedTag;
    header2[1] = content.length;
    return this._createEncoderBuffer([header2, content]);
  }
  let lenOctets = 1;
  for (let i = content.length; i >= 256; i >>= 8)
    lenOctets++;
  const header = Buffer$9.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 128 | lenOctets;
  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 255;
  return this._createEncoderBuffer([header, content]);
};
DERNode$1.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === "bitstr") {
    return this._createEncoderBuffer([str.unused | 0, str.data]);
  } else if (tag === "bmpstr") {
    const buf = Buffer$9.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === "numstr") {
    if (!this._isNumstr(str)) {
      return this.reporter.error("Encoding of string type: numstr supports only digits and space");
    }
    return this._createEncoderBuffer(str);
  } else if (tag === "printstr") {
    if (!this._isPrintstr(str)) {
      return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === "objDesc") {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error("Encoding of string type: " + tag + " unsupported");
  }
};
DERNode$1.prototype._encodeObjid = function encodeObjid(id2, values, relative) {
  if (typeof id2 === "string") {
    if (!values)
      return this.reporter.error("string objid given, but no values map found");
    if (!values.hasOwnProperty(id2))
      return this.reporter.error("objid not found in values map");
    id2 = values[id2].split(/[\s.]+/g);
    for (let i = 0; i < id2.length; i++)
      id2[i] |= 0;
  } else if (Array.isArray(id2)) {
    id2 = id2.slice();
    for (let i = 0; i < id2.length; i++)
      id2[i] |= 0;
  }
  if (!Array.isArray(id2)) {
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id2));
  }
  if (!relative) {
    if (id2[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    id2.splice(0, 2, id2[0] * 40 + id2[1]);
  }
  let size = 0;
  for (let i = 0; i < id2.length; i++) {
    let ident = id2[i];
    for (size++; ident >= 128; ident >>= 7)
      size++;
  }
  const objid = Buffer$9.alloc(size);
  let offset = objid.length - 1;
  for (let i = id2.length - 1; i >= 0; i--) {
    let ident = id2[i];
    objid[offset--] = ident & 127;
    while ((ident >>= 7) > 0)
      objid[offset--] = 128 | ident & 127;
  }
  return this._createEncoderBuffer(objid);
};
function two(num) {
  if (num < 10)
    return "0" + num;
  else
    return num;
}
DERNode$1.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);
  if (tag === "gentime") {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else if (tag === "utctime") {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else {
    this.reporter.error("Encoding " + tag + " time is not supported yet");
  }
  return this._encodeStr(str, "octstr");
};
DERNode$1.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer("");
};
DERNode$1.prototype._encodeInt = function encodeInt2(num, values) {
  if (typeof num === "string") {
    if (!values)
      return this.reporter.error("String int or enum given, but no values map");
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
    }
    num = values[num];
  }
  if (typeof num !== "number" && !Buffer$9.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 128) {
      numArray.unshift(0);
    }
    num = Buffer$9.from(numArray);
  }
  if (Buffer$9.isBuffer(num)) {
    let size2 = num.length;
    if (num.length === 0)
      size2++;
    const out2 = Buffer$9.alloc(size2);
    num.copy(out2);
    if (num.length === 0)
      out2[0] = 0;
    return this._createEncoderBuffer(out2);
  }
  if (num < 128)
    return this._createEncoderBuffer(num);
  if (num < 256)
    return this._createEncoderBuffer([0, num]);
  let size = 1;
  for (let i = num; i >= 256; i >>= 8)
    size++;
  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 255;
    num >>= 8;
  }
  if (out[0] & 128) {
    out.unshift(0);
  }
  return this._createEncoderBuffer(Buffer$9.from(out));
};
DERNode$1.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 255 : 0);
};
DERNode$1.prototype._use = function use3(entity, obj2) {
  if (typeof entity === "function")
    entity = entity(obj2);
  return entity._getEncoder("der").tree;
};
DERNode$1.prototype._skipDefault = function skipDefault(dataBuffer, reporter2, parent) {
  const state2 = this._baseState;
  let i;
  if (state2["default"] === null)
    return false;
  const data2 = dataBuffer.join();
  if (state2.defaultBuffer === void 0)
    state2.defaultBuffer = this._encodeValue(state2["default"], reporter2, parent).join();
  if (data2.length !== state2.defaultBuffer.length)
    return false;
  for (i = 0; i < data2.length; i++)
    if (data2[i] !== state2.defaultBuffer[i])
      return false;
  return true;
};
function encodeTag(tag, primitive, cls, reporter2) {
  let res;
  if (tag === "seqof")
    tag = "seq";
  else if (tag === "setof")
    tag = "set";
  if (der$1.tagByName.hasOwnProperty(tag))
    res = der$1.tagByName[tag];
  else if (typeof tag === "number" && (tag | 0) === tag)
    res = tag;
  else
    return reporter2.error("Unknown tag: " + tag);
  if (res >= 31)
    return reporter2.error("Multi-octet tag encoding unsupported");
  if (!primitive)
    res |= 32;
  res |= der$1.tagClassByName[cls || "universal"] << 6;
  return res;
}
const inherits$2 = requireInherits_browser();
const DEREncoder = der_1$1;
function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = "pem";
}
inherits$2(PEMEncoder, DEREncoder);
var pem$2 = PEMEncoder;
PEMEncoder.prototype.encode = function encode5(data2, options) {
  const buf = DEREncoder.prototype.encode.call(this, data2);
  const p = buf.toString("base64");
  const out = ["-----BEGIN " + options.label + "-----"];
  for (let i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push("-----END " + options.label + "-----");
  return out.join("\n");
};
(function(exports2) {
  const encoders2 = exports2;
  encoders2.der = der_1$1;
  encoders2.pem = pem$2;
})(encoders);
var decoders = {};
const inherits$1 = requireInherits_browser();
const bignum = bn$4.exports;
const DecoderBuffer = buffer$1.DecoderBuffer;
const Node = node$1;
const der = der$2;
function DERDecoder$1(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
var der_1 = DERDecoder$1;
DERDecoder$1.prototype.decode = function decode2(data2, options) {
  if (!DecoderBuffer.isDecoderBuffer(data2)) {
    data2 = new DecoderBuffer(data2, options);
  }
  return this.tree._decode(data2, options);
};
function DERNode(parent) {
  Node.call(this, "der", parent);
}
inherits$1(DERNode, Node);
DERNode.prototype._peekTag = function peekTag(buffer2, tag, any2) {
  if (buffer2.isEmpty())
    return false;
  const state2 = buffer2.save();
  const decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
  if (buffer2.isError(decodedTag))
    return decodedTag;
  buffer2.restore(state2);
  return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any2;
};
DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any2) {
  const decodedTag = derDecodeTag(
    buffer2,
    'Failed to decode tag of "' + tag + '"'
  );
  if (buffer2.isError(decodedTag))
    return decodedTag;
  let len = derDecodeLen(
    buffer2,
    decodedTag.primitive,
    'Failed to get length of "' + tag + '"'
  );
  if (buffer2.isError(len))
    return len;
  if (!any2 && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
    return buffer2.error('Failed to match tag: "' + tag + '"');
  }
  if (decodedTag.primitive || len !== null)
    return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
  const state2 = buffer2.save();
  const res = this._skipUntilEnd(
    buffer2,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  if (buffer2.isError(res))
    return res;
  len = buffer2.offset - state2.offset;
  buffer2.restore(state2);
  return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
};
DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail) {
  for (; ; ) {
    const tag = derDecodeTag(buffer2, fail);
    if (buffer2.isError(tag))
      return tag;
    const len = derDecodeLen(buffer2, tag.primitive, fail);
    if (buffer2.isError(len))
      return len;
    let res;
    if (tag.primitive || len !== null)
      res = buffer2.skip(len);
    else
      res = this._skipUntilEnd(buffer2, fail);
    if (buffer2.isError(res))
      return res;
    if (tag.tagStr === "end")
      break;
  }
};
DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options) {
  const result = [];
  while (!buffer2.isEmpty()) {
    const possibleEnd = this._peekTag(buffer2, "end");
    if (buffer2.isError(possibleEnd))
      return possibleEnd;
    const res = decoder.decode(buffer2, "der", options);
    if (buffer2.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};
DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
  if (tag === "bitstr") {
    const unused = buffer2.readUInt8();
    if (buffer2.isError(unused))
      return unused;
    return { unused, data: buffer2.raw() };
  } else if (tag === "bmpstr") {
    const raw2 = buffer2.raw();
    if (raw2.length % 2 === 1)
      return buffer2.error("Decoding of string type: bmpstr length mismatch");
    let str = "";
    for (let i = 0; i < raw2.length / 2; i++) {
      str += String.fromCharCode(raw2.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === "numstr") {
    const numstr = buffer2.raw().toString("ascii");
    if (!this._isNumstr(numstr)) {
      return buffer2.error("Decoding of string type: numstr unsupported characters");
    }
    return numstr;
  } else if (tag === "octstr") {
    return buffer2.raw();
  } else if (tag === "objDesc") {
    return buffer2.raw();
  } else if (tag === "printstr") {
    const printstr = buffer2.raw().toString("ascii");
    if (!this._isPrintstr(printstr)) {
      return buffer2.error("Decoding of string type: printstr unsupported characters");
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer2.raw().toString();
  } else {
    return buffer2.error("Decoding of string type: " + tag + " unsupported");
  }
};
DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer2.isEmpty()) {
    subident = buffer2.readUInt8();
    ident <<= 7;
    ident |= subident & 127;
    if ((subident & 128) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 128)
    identifiers.push(ident);
  const first = identifiers[0] / 40 | 0;
  const second = identifiers[0] % 40;
  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));
  if (values) {
    let tmp = values[result.join(" ")];
    if (tmp === void 0)
      tmp = values[result.join(".")];
    if (tmp !== void 0)
      result = tmp;
  }
  return result;
};
DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
  const str = buffer2.raw().toString();
  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;
  if (tag === "gentime") {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === "utctime") {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2e3 + year;
    else
      year = 1900 + year;
  } else {
    return buffer2.error("Decoding " + tag + " time is not supported yet");
  }
  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};
DERNode.prototype._decodeBool = function decodeBool(buffer2) {
  const res = buffer2.readUInt8();
  if (buffer2.isError(res))
    return res;
  else
    return res !== 0;
};
DERNode.prototype._decodeInt = function decodeInt2(buffer2, values) {
  const raw2 = buffer2.raw();
  let res = new bignum(raw2);
  if (values)
    res = values[res.toString(10)] || res;
  return res;
};
DERNode.prototype._use = function use4(entity, obj2) {
  if (typeof entity === "function")
    entity = entity(obj2);
  return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;
  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 32) === 0;
  if ((tag & 31) === 31) {
    let oct = tag;
    tag = 0;
    while ((oct & 128) === 128) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;
      tag <<= 7;
      tag |= oct & 127;
    }
  } else {
    tag &= 31;
  }
  const tagStr = der.tag[tag];
  return {
    cls,
    primitive,
    tag,
    tagStr
  };
}
function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;
  if (!primitive && len === 128)
    return null;
  if ((len & 128) === 0) {
    return len;
  }
  const num = len & 127;
  if (num > 4)
    return buf.error("length octect is too long");
  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }
  return len;
}
const inherits = requireInherits_browser();
const Buffer$8 = safer_1.Buffer;
const DERDecoder = der_1;
function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = "pem";
}
inherits(PEMDecoder, DERDecoder);
var pem$1 = PEMDecoder;
PEMDecoder.prototype.decode = function decode3(data2, options) {
  const lines = data2.toString().split(/[\r\n]+/g);
  const label = options.label.toUpperCase();
  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null)
      continue;
    if (match[2] !== label)
      continue;
    if (start === -1) {
      if (match[1] !== "BEGIN")
        break;
      start = i;
    } else {
      if (match[1] !== "END")
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error("PEM section not found for: " + label);
  const base642 = lines.slice(start + 1, end).join("");
  base642.replace(/[^a-z0-9+/=]+/gi, "");
  const input = Buffer$8.from(base642, "base64");
  return DERDecoder.prototype.decode.call(this, input, options);
};
(function(exports2) {
  const decoders2 = exports2;
  decoders2.der = der_1;
  decoders2.pem = pem$1;
})(decoders);
(function(exports2) {
  const encoders$1 = encoders;
  const decoders$1 = decoders;
  const inherits2 = requireInherits_browser();
  const api2 = exports2;
  api2.define = function define(name2, body) {
    return new Entity(name2, body);
  };
  function Entity(name2, body) {
    this.name = name2;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
  }
  Entity.prototype._createNamed = function createNamed(Base2) {
    const name2 = this.name;
    function Generated(entity) {
      this._initNamed(entity, name2);
    }
    inherits2(Generated, Base2);
    Generated.prototype._initNamed = function _initNamed(entity, name3) {
      Base2.call(this, entity, name3);
    };
    return new Generated(this);
  };
  Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc))
      this.decoders[enc] = this._createNamed(decoders$1[enc]);
    return this.decoders[enc];
  };
  Entity.prototype.decode = function decode5(data2, enc, options) {
    return this._getDecoder(enc).decode(data2, options);
  };
  Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc))
      this.encoders[enc] = this._createNamed(encoders$1[enc]);
    return this.encoders[enc];
  };
  Entity.prototype.encode = function encode8(data2, enc, reporter2) {
    return this._getEncoder(enc).encode(data2, reporter2);
  };
})(api$1);
var base$3 = {};
(function(exports2) {
  const base3 = exports2;
  base3.Reporter = reporter.Reporter;
  base3.DecoderBuffer = buffer$1.DecoderBuffer;
  base3.EncoderBuffer = buffer$1.EncoderBuffer;
  base3.Node = node$1;
})(base$3);
var constants$2 = {};
(function(exports2) {
  const constants2 = exports2;
  constants2._reverse = function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key3) {
      if ((key3 | 0) == key3)
        key3 = key3 | 0;
      const value = map[key3];
      res[value] = key3;
    });
    return res;
  };
  constants2.der = der$2;
})(constants$2);
(function(exports2) {
  const asn12 = exports2;
  asn12.bignum = bn$4.exports;
  asn12.define = api$1.define;
  asn12.base = base$3;
  asn12.constants = constants$2;
  asn12.decoders = decoders;
  asn12.encoders = encoders;
})(asn1$2);
var asn$1 = asn1$2;
var Time = asn$1.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
});
var AttributeTypeValue = asn$1.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
});
var AlgorithmIdentifier$2 = asn$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
});
var SubjectPublicKeyInfo = asn$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$2),
    this.key("subjectPublicKey").bitstr()
  );
});
var RelativeDistinguishedName = asn$1.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
});
var RDNSequence = asn$1.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
});
var Name = asn$1.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
});
var Validity = asn$1.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
});
var Extension = asn$1.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(false),
    this.key("extnValue").octstr()
  );
});
var TBSCertificate = asn$1.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$2),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
});
var X509Certificate = asn$1.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$2),
    this.key("signatureValue").bitstr()
  );
});
var certificate = X509Certificate;
var asn1$1 = asn1$2;
asn1$3.certificate = certificate;
var RSAPrivateKey$1 = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey$1;
var RSAPublicKey$1 = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey$1;
var PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var AlgorithmIdentifier$1 = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
});
var PrivateKeyInfo$1 = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo$1;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
var evp = evp_bytestokey;
var ciphers$1 = browser$8;
var Buffer$7 = safeBuffer$1.exports.Buffer;
var fixProc$1 = function(okey, password) {
  var key3 = okey.toString();
  var match = key3.match(findProc);
  var decrypted;
  if (!match) {
    var match2 = key3.match(fullRegex);
    decrypted = Buffer$7.from(match2[2].replace(/[\r\n]/g, ""), "base64");
  } else {
    var suite = "aes" + match[1];
    var iv = Buffer$7.from(match[2], "hex");
    var cipherText = Buffer$7.from(match[3].replace(/[\r\n]/g, ""), "base64");
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
    var out = [];
    var cipher2 = ciphers$1.createDecipheriv(suite, cipherKey, iv);
    out.push(cipher2.update(cipherText));
    out.push(cipher2.final());
    decrypted = Buffer$7.concat(out);
  }
  var tag = key3.match(startRegex)[1];
  return {
    tag,
    data: decrypted
  };
};
var asn1 = asn1$3;
var aesid = require$$1;
var fixProc = fixProc$1;
var ciphers = browser$8;
var compat = browser$a;
var Buffer$6 = safeBuffer$1.exports.Buffer;
var parseAsn1 = parseKeys$2;
function parseKeys$2(buffer2) {
  var password;
  if (typeof buffer2 === "object" && !Buffer$6.isBuffer(buffer2)) {
    password = buffer2.passphrase;
    buffer2 = buffer2.key;
  }
  if (typeof buffer2 === "string") {
    buffer2 = Buffer$6.from(buffer2);
  }
  var stripped = fixProc(buffer2, password);
  var type = stripped.tag;
  var data2 = stripped.data;
  var subtype, ndata;
  switch (type) {
    case "CERTIFICATE":
      ndata = asn1.certificate.decode(data2, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data2, "der");
      }
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: "ec",
            data: ndata
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
          return {
            type: "dsa",
            data: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "ENCRYPTED PRIVATE KEY":
      data2 = asn1.EncryptedPrivateKey.decode(data2, "der");
      data2 = decrypt$2(data2, password);
    case "PRIVATE KEY":
      ndata = asn1.PrivateKey.decode(data2, "der");
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
          return {
            type: "dsa",
            params: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(data2, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(data2, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(data2, "der")
      };
    case "EC PRIVATE KEY":
      data2 = asn1.ECPrivateKey.decode(data2, "der");
      return {
        curve: data2.parameters.value,
        privateKey: data2.privateKey
      };
    default:
      throw new Error("unknown key type " + type);
  }
}
parseKeys$2.signature = asn1.signature;
function decrypt$2(data2, password) {
  var salt = data2.algorithm.decrypt.kde.kdeparams.salt;
  var iters = parseInt(data2.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  var algo = aesid[data2.algorithm.decrypt.cipher.algo.join(".")];
  var iv = data2.algorithm.decrypt.cipher.iv;
  var cipherText = data2.subjectPrivateKey;
  var keylen = parseInt(algo.split("-")[1], 10) / 8;
  var key3 = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
  var cipher2 = ciphers.createDecipheriv(algo, key3, iv);
  var out = [];
  out.push(cipher2.update(cipherText));
  out.push(cipher2.final());
  return Buffer$6.concat(out);
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign.exports;
  hasRequiredSign = 1;
  var Buffer2 = safeBuffer$1.exports.Buffer;
  var createHmac2 = browser$b;
  var crt2 = browserifyRsa;
  var EC2 = requireElliptic().ec;
  var BN2 = bn$2.exports;
  var parseKeys2 = parseAsn1;
  var curves2 = require$$4;
  function sign$12(hash3, key3, hashType, signType, tag) {
    var priv2 = parseKeys2(key3);
    if (priv2.curve) {
      if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ecSign(hash3, priv2);
    } else if (priv2.type === "dsa") {
      if (signType !== "dsa")
        throw new Error("wrong private key type");
      return dsaSign(hash3, priv2, hashType);
    } else {
      if (signType !== "rsa" && signType !== "ecdsa/rsa")
        throw new Error("wrong private key type");
    }
    hash3 = Buffer2.concat([tag, hash3]);
    var len = priv2.modulus.byteLength();
    var pad3 = [0, 1];
    while (hash3.length + pad3.length + 1 < len)
      pad3.push(255);
    pad3.push(0);
    var i = -1;
    while (++i < hash3.length)
      pad3.push(hash3[i]);
    var out = crt2(pad3, priv2);
    return out;
  }
  function ecSign(hash3, priv2) {
    var curveId = curves2[priv2.curve.join(".")];
    if (!curveId)
      throw new Error("unknown curve " + priv2.curve.join("."));
    var curve2 = new EC2(curveId);
    var key3 = curve2.keyFromPrivate(priv2.privateKey);
    var out = key3.sign(hash3);
    return Buffer2.from(out.toDER());
  }
  function dsaSign(hash3, priv2, algo) {
    var x = priv2.params.priv_key;
    var p = priv2.params.p;
    var q = priv2.params.q;
    var g = priv2.params.g;
    var r2 = new BN2(0);
    var k;
    var H = bits2int(hash3, q).mod(q);
    var s2 = false;
    var kv = getKey(x, q, hash3, algo);
    while (s2 === false) {
      k = makeKey(q, kv, algo);
      r2 = makeR(g, k, p, q);
      s2 = k.invm(q).imul(H.add(x.mul(r2))).mod(q);
      if (s2.cmpn(0) === 0) {
        s2 = false;
        r2 = new BN2(0);
      }
    }
    return toDER3(r2, s2);
  }
  function toDER3(r2, s2) {
    r2 = r2.toArray();
    s2 = s2.toArray();
    if (r2[0] & 128)
      r2 = [0].concat(r2);
    if (s2[0] & 128)
      s2 = [0].concat(s2);
    var total = r2.length + s2.length + 4;
    var res = [48, total, 2, r2.length];
    res = res.concat(r2, [2, s2.length], s2);
    return Buffer2.from(res);
  }
  function getKey(x, q, hash3, algo) {
    x = Buffer2.from(x.toArray());
    if (x.length < q.byteLength()) {
      var zeros2 = Buffer2.alloc(q.byteLength() - x.length);
      x = Buffer2.concat([zeros2, x]);
    }
    var hlen = hash3.length;
    var hbits = bits2octets(hash3, q);
    var v = Buffer2.alloc(hlen);
    v.fill(1);
    var k = Buffer2.alloc(hlen);
    k = createHmac2(algo, k).update(v).update(Buffer2.from([0])).update(x).update(hbits).digest();
    v = createHmac2(algo, k).update(v).digest();
    k = createHmac2(algo, k).update(v).update(Buffer2.from([1])).update(x).update(hbits).digest();
    v = createHmac2(algo, k).update(v).digest();
    return { k, v };
  }
  function bits2int(obits, q) {
    var bits = new BN2(obits);
    var shift = (obits.length << 3) - q.bitLength();
    if (shift > 0)
      bits.ishrn(shift);
    return bits;
  }
  function bits2octets(bits, q) {
    bits = bits2int(bits, q);
    bits = bits.mod(q);
    var out = Buffer2.from(bits.toArray());
    if (out.length < q.byteLength()) {
      var zeros2 = Buffer2.alloc(q.byteLength() - out.length);
      out = Buffer2.concat([zeros2, out]);
    }
    return out;
  }
  function makeKey(q, kv, algo) {
    var t;
    var k;
    do {
      t = Buffer2.alloc(0);
      while (t.length * 8 < q.bitLength()) {
        kv.v = createHmac2(algo, kv.k).update(kv.v).digest();
        t = Buffer2.concat([t, kv.v]);
      }
      k = bits2int(t, q);
      kv.k = createHmac2(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest();
      kv.v = createHmac2(algo, kv.k).update(kv.v).digest();
    } while (k.cmp(q) !== -1);
    return k;
  }
  function makeR(g, k, p, q) {
    return g.toRed(BN2.mont(p)).redPow(k).fromRed().mod(q);
  }
  sign.exports = sign$12;
  sign.exports.getKey = getKey;
  sign.exports.makeKey = makeKey;
  return sign.exports;
}
var verify_1;
var hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var Buffer2 = safeBuffer$1.exports.Buffer;
  var BN2 = bn$2.exports;
  var EC2 = requireElliptic().ec;
  var parseKeys2 = parseAsn1;
  var curves2 = require$$4;
  function verify7(sig, hash3, key3, signType, tag) {
    var pub2 = parseKeys2(key3);
    if (pub2.type === "ec") {
      if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return ecVerify(sig, hash3, pub2);
    } else if (pub2.type === "dsa") {
      if (signType !== "dsa")
        throw new Error("wrong public key type");
      return dsaVerify(sig, hash3, pub2);
    } else {
      if (signType !== "rsa" && signType !== "ecdsa/rsa")
        throw new Error("wrong public key type");
    }
    hash3 = Buffer2.concat([tag, hash3]);
    var len = pub2.modulus.byteLength();
    var pad3 = [1];
    var padNum = 0;
    while (hash3.length + pad3.length + 2 < len) {
      pad3.push(255);
      padNum++;
    }
    pad3.push(0);
    var i = -1;
    while (++i < hash3.length) {
      pad3.push(hash3[i]);
    }
    pad3 = Buffer2.from(pad3);
    var red2 = BN2.mont(pub2.modulus);
    sig = new BN2(sig).toRed(red2);
    sig = sig.redPow(new BN2(pub2.publicExponent));
    sig = Buffer2.from(sig.fromRed().toArray());
    var out = padNum < 8 ? 1 : 0;
    len = Math.min(sig.length, pad3.length);
    if (sig.length !== pad3.length)
      out = 1;
    i = -1;
    while (++i < len)
      out |= sig[i] ^ pad3[i];
    return out === 0;
  }
  function ecVerify(sig, hash3, pub2) {
    var curveId = curves2[pub2.data.algorithm.curve.join(".")];
    if (!curveId)
      throw new Error("unknown curve " + pub2.data.algorithm.curve.join("."));
    var curve2 = new EC2(curveId);
    var pubkey = pub2.data.subjectPrivateKey.data;
    return curve2.verify(hash3, sig, pubkey);
  }
  function dsaVerify(sig, hash3, pub2) {
    var p = pub2.data.p;
    var q = pub2.data.q;
    var g = pub2.data.g;
    var y = pub2.data.pub_key;
    var unpacked = parseKeys2.signature.decode(sig, "der");
    var s2 = unpacked.s;
    var r2 = unpacked.r;
    checkValue(s2, q);
    checkValue(r2, q);
    var montp = BN2.mont(p);
    var w = s2.invm(q);
    var v = g.toRed(montp).redPow(new BN2(hash3).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r2.mul(w).mod(q)).fromRed()).mod(p).mod(q);
    return v.cmp(r2) === 0;
  }
  function checkValue(b, q) {
    if (b.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (b.cmp(q) >= q)
      throw new Error("invalid sig");
  }
  verify_1 = verify7;
  return verify_1;
}
var browser$6;
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$6;
  hasRequiredBrowser$1 = 1;
  var Buffer2 = safeBuffer$1.exports.Buffer;
  var createHash3 = browser$c;
  var stream2 = readableBrowser.exports;
  var inherits2 = requireInherits_browser();
  var sign7 = requireSign();
  var verify7 = requireVerify();
  var algorithms = require$$6;
  Object.keys(algorithms).forEach(function(key3) {
    algorithms[key3].id = Buffer2.from(algorithms[key3].id, "hex");
    algorithms[key3.toLowerCase()] = algorithms[key3];
  });
  function Sign2(algorithm) {
    stream2.Writable.call(this);
    var data2 = algorithms[algorithm];
    if (!data2)
      throw new Error("Unknown message digest");
    this._hashType = data2.hash;
    this._hash = createHash3(data2.hash);
    this._tag = data2.id;
    this._signType = data2.sign;
  }
  inherits2(Sign2, stream2.Writable);
  Sign2.prototype._write = function _write(data2, _, done2) {
    this._hash.update(data2);
    done2();
  };
  Sign2.prototype.update = function update7(data2, enc) {
    if (typeof data2 === "string")
      data2 = Buffer2.from(data2, enc);
    this._hash.update(data2);
    return this;
  };
  Sign2.prototype.sign = function signMethod(key3, enc) {
    this.end();
    var hash3 = this._hash.digest();
    var sig = sign7(hash3, key3, this._hashType, this._signType, this._tag);
    return enc ? sig.toString(enc) : sig;
  };
  function Verify(algorithm) {
    stream2.Writable.call(this);
    var data2 = algorithms[algorithm];
    if (!data2)
      throw new Error("Unknown message digest");
    this._hash = createHash3(data2.hash);
    this._tag = data2.id;
    this._signType = data2.sign;
  }
  inherits2(Verify, stream2.Writable);
  Verify.prototype._write = function _write(data2, _, done2) {
    this._hash.update(data2);
    done2();
  };
  Verify.prototype.update = function update7(data2, enc) {
    if (typeof data2 === "string")
      data2 = Buffer2.from(data2, enc);
    this._hash.update(data2);
    return this;
  };
  Verify.prototype.verify = function verifyMethod(key3, sig, enc) {
    if (typeof sig === "string")
      sig = Buffer2.from(sig, enc);
    this.end();
    var hash3 = this._hash.digest();
    return verify7(sig, hash3, key3, this._signType, this._tag);
  };
  function createSign(algorithm) {
    return new Sign2(algorithm);
  }
  function createVerify(algorithm) {
    return new Verify(algorithm);
  }
  browser$6 = {
    Sign: createSign,
    Verify: createVerify,
    createSign,
    createVerify
  };
  return browser$6;
}
var browser$5;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$5;
  hasRequiredBrowser = 1;
  var elliptic2 = requireElliptic();
  var BN2 = bn$4.exports;
  browser$5 = function createECDH(curve2) {
    return new ECDH(curve2);
  };
  var aliases = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  aliases.p224 = aliases.secp224r1;
  aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
  aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
  aliases.p384 = aliases.secp384r1;
  aliases.p521 = aliases.secp521r1;
  function ECDH(curve2) {
    this.curveType = aliases[curve2];
    if (!this.curveType) {
      this.curveType = {
        name: curve2
      };
    }
    this.curve = new elliptic2.ec(this.curveType.name);
    this.keys = void 0;
  }
  ECDH.prototype.generateKeys = function(enc, format) {
    this.keys = this.curve.genKeyPair();
    return this.getPublicKey(enc, format);
  };
  ECDH.prototype.computeSecret = function(other, inenc, enc) {
    inenc = inenc || "utf8";
    if (!Buffer.isBuffer(other)) {
      other = new Buffer(other, inenc);
    }
    var otherPub = this.curve.keyFromPublic(other).getPublic();
    var out = otherPub.mul(this.keys.getPrivate()).getX();
    return formatReturnValue(out, enc, this.curveType.byteLength);
  };
  ECDH.prototype.getPublicKey = function(enc, format) {
    var key3 = this.keys.getPublic(format === "compressed", true);
    if (format === "hybrid") {
      if (key3[key3.length - 1] % 2) {
        key3[0] = 7;
      } else {
        key3[0] = 6;
      }
    }
    return formatReturnValue(key3, enc);
  };
  ECDH.prototype.getPrivateKey = function(enc) {
    return formatReturnValue(this.keys.getPrivate(), enc);
  };
  ECDH.prototype.setPublicKey = function(pub2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub2)) {
      pub2 = new Buffer(pub2, enc);
    }
    this.keys._importPublic(pub2);
    return this;
  };
  ECDH.prototype.setPrivateKey = function(priv2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv2)) {
      priv2 = new Buffer(priv2, enc);
    }
    var _priv = new BN2(priv2);
    _priv = _priv.toString(16);
    this.keys = this.curve.genKeyPair();
    this.keys._importPrivate(_priv);
    return this;
  };
  function formatReturnValue(bn2, enc, len) {
    if (!Array.isArray(bn2)) {
      bn2 = bn2.toArray();
    }
    var buf = new Buffer(bn2);
    if (len && buf.length < len) {
      var zeros2 = new Buffer(len - buf.length);
      zeros2.fill(0);
      buf = Buffer.concat([zeros2, buf]);
    }
    if (!enc) {
      return buf;
    } else {
      return buf.toString(enc);
    }
  }
  return browser$5;
}
var browser$4 = {};
var createHash$2 = browser$c;
var Buffer$5 = safeBuffer$1.exports.Buffer;
var mgf$2 = function(seed, len) {
  var t = Buffer$5.alloc(0);
  var i = 0;
  var c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer$5.concat([t, createHash$2("sha1").update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};
function i2ops(c) {
  var out = Buffer$5.allocUnsafe(4);
  out.writeUInt32BE(c, 0);
  return out;
}
var xor$2 = function xor2(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a;
};
var BN$5 = bn$4.exports;
var Buffer$4 = safeBuffer$1.exports.Buffer;
function withPublic$2(paddedMsg, key3) {
  return Buffer$4.from(paddedMsg.toRed(BN$5.mont(key3.modulus)).redPow(new BN$5(key3.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2;
var parseKeys$1 = parseAsn1;
var randomBytes$1 = browser$e.exports;
var createHash$1 = browser$c;
var mgf$1 = mgf$2;
var xor$1 = xor$2;
var BN$4 = bn$4.exports;
var withPublic$1 = withPublic_1;
var crt$1 = browserifyRsa;
var Buffer$3 = safeBuffer$1.exports.Buffer;
var publicEncrypt = function publicEncrypt2(publicKey, msg, reverse) {
  var padding2;
  if (publicKey.padding) {
    padding2 = publicKey.padding;
  } else if (reverse) {
    padding2 = 1;
  } else {
    padding2 = 4;
  }
  var key3 = parseKeys$1(publicKey);
  var paddedMsg;
  if (padding2 === 4) {
    paddedMsg = oaep$1(key3, msg);
  } else if (padding2 === 1) {
    paddedMsg = pkcs1$1(key3, msg, reverse);
  } else if (padding2 === 3) {
    paddedMsg = new BN$4(msg);
    if (paddedMsg.cmp(key3.modulus) >= 0) {
      throw new Error("data too long for modulus");
    }
  } else {
    throw new Error("unknown padding");
  }
  if (reverse) {
    return crt$1(paddedMsg, key3);
  } else {
    return withPublic$1(paddedMsg, key3);
  }
};
function oaep$1(key3, msg) {
  var k = key3.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash$1("sha1").update(Buffer$3.alloc(0)).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error("message too long");
  }
  var ps = Buffer$3.alloc(k - mLen - hLen2 - 2);
  var dblen = k - hLen - 1;
  var seed = randomBytes$1(hLen);
  var maskedDb = xor$1(Buffer$3.concat([iHash, ps, Buffer$3.alloc(1, 1), msg], dblen), mgf$1(seed, dblen));
  var maskedSeed = xor$1(seed, mgf$1(maskedDb, hLen));
  return new BN$4(Buffer$3.concat([Buffer$3.alloc(1), maskedSeed, maskedDb], k));
}
function pkcs1$1(key3, msg, reverse) {
  var mLen = msg.length;
  var k = key3.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error("message too long");
  }
  var ps;
  if (reverse) {
    ps = Buffer$3.alloc(k - mLen - 3, 255);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new BN$4(Buffer$3.concat([Buffer$3.from([0, reverse ? 1 : 2]), ps, Buffer$3.alloc(1), msg], k));
}
function nonZero(len) {
  var out = Buffer$3.allocUnsafe(len);
  var i = 0;
  var cache = randomBytes$1(len * 2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes$1(len * 2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
var parseKeys = parseAsn1;
var mgf = mgf$2;
var xor3 = xor$2;
var BN$3 = bn$4.exports;
var crt = browserifyRsa;
var createHash2 = browser$c;
var withPublic = withPublic_1;
var Buffer$2 = safeBuffer$1.exports.Buffer;
var privateDecrypt = function privateDecrypt2(privateKey, enc, reverse) {
  var padding2;
  if (privateKey.padding) {
    padding2 = privateKey.padding;
  } else if (reverse) {
    padding2 = 1;
  } else {
    padding2 = 4;
  }
  var key3 = parseKeys(privateKey);
  var k = key3.modulus.byteLength();
  if (enc.length > k || new BN$3(enc).cmp(key3.modulus) >= 0) {
    throw new Error("decryption error");
  }
  var msg;
  if (reverse) {
    msg = withPublic(new BN$3(enc), key3);
  } else {
    msg = crt(enc, key3);
  }
  var zBuffer = Buffer$2.alloc(k - msg.length);
  msg = Buffer$2.concat([zBuffer, msg], k);
  if (padding2 === 4) {
    return oaep(key3, msg);
  } else if (padding2 === 1) {
    return pkcs1(key3, msg, reverse);
  } else if (padding2 === 3) {
    return msg;
  } else {
    throw new Error("unknown padding");
  }
};
function oaep(key3, msg) {
  var k = key3.modulus.byteLength();
  var iHash = createHash2("sha1").update(Buffer$2.alloc(0)).digest();
  var hLen = iHash.length;
  if (msg[0] !== 0) {
    throw new Error("decryption error");
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb = msg.slice(hLen + 1);
  var seed = xor3(maskedSeed, mgf(maskedDb, hLen));
  var db = xor3(maskedDb, mgf(seed, k - hLen - 1));
  if (compare$2(iHash, db.slice(0, hLen))) {
    throw new Error("decryption error");
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error("decryption error");
  }
  return db.slice(i);
}
function pkcs1(key3, msg, reverse) {
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error("decryption error");
  }
  return msg.slice(i);
}
function compare$2(a, b) {
  a = Buffer$2.from(a);
  b = Buffer$2.from(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += a[i] ^ b[i];
  }
  return dif;
}
(function(exports2) {
  exports2.publicEncrypt = publicEncrypt;
  exports2.privateDecrypt = privateDecrypt;
  exports2.privateEncrypt = function privateEncrypt(key3, buf) {
    return exports2.publicEncrypt(key3, buf, true);
  };
  exports2.publicDecrypt = function publicDecrypt(key3, buf) {
    return exports2.privateDecrypt(key3, buf, true);
  };
})(browser$4);
var browser$3 = {};
function oldBrowser() {
  throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
}
var safeBuffer = safeBuffer$1.exports;
var randombytes = browser$e.exports;
var Buffer$1 = safeBuffer.Buffer;
var kBufferMaxLength = safeBuffer.kMaxLength;
var crypto$3 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
var kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(offset, length2) {
  if (typeof offset !== "number" || offset !== offset) {
    throw new TypeError("offset must be a number");
  }
  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError("offset must be a uint32");
  }
  if (offset > kBufferMaxLength || offset > length2) {
    throw new RangeError("offset out of range");
  }
}
function assertSize(size, offset, length2) {
  if (typeof size !== "number" || size !== size) {
    throw new TypeError("size must be a number");
  }
  if (size > kMaxUint32 || size < 0) {
    throw new TypeError("size must be a uint32");
  }
  if (size + offset > length2 || size > kBufferMaxLength) {
    throw new RangeError("buffer too small");
  }
}
if (crypto$3 && crypto$3.getRandomValues || !process.browser) {
  browser$3.randomFill = randomFill;
  browser$3.randomFillSync = randomFillSync;
} else {
  browser$3.randomFill = oldBrowser;
  browser$3.randomFillSync = oldBrowser;
}
function randomFill(buf, offset, size, cb) {
  if (!Buffer$1.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }
  if (typeof offset === "function") {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === "function") {
    cb = size;
    size = buf.length - offset;
  } else if (typeof cb !== "function") {
    throw new TypeError('"cb" argument must be a function');
  }
  assertOffset(offset, buf.length);
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size, cb);
}
function actualFill(buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer;
    var uint = new Uint8Array(ourBuf, offset, size);
    crypto$3.getRandomValues(uint);
    if (cb) {
      process.nextTick(function() {
        cb(null, buf);
      });
      return;
    }
    return buf;
  }
  if (cb) {
    randombytes(size, function(err, bytes3) {
      if (err) {
        return cb(err);
      }
      bytes3.copy(buf, offset);
      cb(null, buf);
    });
    return;
  }
  var bytes = randombytes(size);
  bytes.copy(buf, offset);
  return buf;
}
function randomFillSync(buf, offset, size) {
  if (typeof offset === "undefined") {
    offset = 0;
  }
  if (!Buffer$1.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }
  assertOffset(offset, buf.length);
  if (size === void 0)
    size = buf.length - offset;
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1;
  cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browser$e.exports;
  cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$c;
  cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$b;
  var algos$1 = algos.exports;
  var algoKeys = Object.keys(algos$1);
  var hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
  cryptoBrowserify.getHashes = function() {
    return hashes;
  };
  var p = browser$a;
  cryptoBrowserify.pbkdf2 = p.pbkdf2;
  cryptoBrowserify.pbkdf2Sync = p.pbkdf2Sync;
  var aes2 = browser$9;
  cryptoBrowserify.Cipher = aes2.Cipher;
  cryptoBrowserify.createCipher = aes2.createCipher;
  cryptoBrowserify.Cipheriv = aes2.Cipheriv;
  cryptoBrowserify.createCipheriv = aes2.createCipheriv;
  cryptoBrowserify.Decipher = aes2.Decipher;
  cryptoBrowserify.createDecipher = aes2.createDecipher;
  cryptoBrowserify.Decipheriv = aes2.Decipheriv;
  cryptoBrowserify.createDecipheriv = aes2.createDecipheriv;
  cryptoBrowserify.getCiphers = aes2.getCiphers;
  cryptoBrowserify.listCiphers = aes2.listCiphers;
  var dh2 = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = dh2.DiffieHellmanGroup;
  cryptoBrowserify.createDiffieHellmanGroup = dh2.createDiffieHellmanGroup;
  cryptoBrowserify.getDiffieHellman = dh2.getDiffieHellman;
  cryptoBrowserify.createDiffieHellman = dh2.createDiffieHellman;
  cryptoBrowserify.DiffieHellman = dh2.DiffieHellman;
  var sign7 = requireBrowser$1();
  cryptoBrowserify.createSign = sign7.createSign;
  cryptoBrowserify.Sign = sign7.Sign;
  cryptoBrowserify.createVerify = sign7.createVerify;
  cryptoBrowserify.Verify = sign7.Verify;
  cryptoBrowserify.createECDH = requireBrowser();
  var publicEncrypt3 = browser$4;
  cryptoBrowserify.publicEncrypt = publicEncrypt3.publicEncrypt;
  cryptoBrowserify.privateEncrypt = publicEncrypt3.privateEncrypt;
  cryptoBrowserify.publicDecrypt = publicEncrypt3.publicDecrypt;
  cryptoBrowserify.privateDecrypt = publicEncrypt3.privateDecrypt;
  var rf = browser$3;
  cryptoBrowserify.randomFill = rf.randomFill;
  cryptoBrowserify.randomFillSync = rf.randomFillSync;
  cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join("\n"));
  };
  cryptoBrowserify.constants = {
    "DH_CHECK_P_NOT_SAFE_PRIME": 2,
    "DH_CHECK_P_NOT_PRIME": 1,
    "DH_UNABLE_TO_CHECK_GENERATOR": 4,
    "DH_NOT_SUITABLE_GENERATOR": 8,
    "NPN_ENABLED": 1,
    "ALPN_ENABLED": 1,
    "RSA_PKCS1_PADDING": 1,
    "RSA_SSLV23_PADDING": 2,
    "RSA_NO_PADDING": 3,
    "RSA_PKCS1_OAEP_PADDING": 4,
    "RSA_X931_PADDING": 5,
    "RSA_PKCS1_PSS_PADDING": 6,
    "POINT_CONVERSION_COMPRESSED": 2,
    "POINT_CONVERSION_UNCOMPRESSED": 4,
    "POINT_CONVERSION_HYBRID": 6
  };
  return cryptoBrowserify;
}
var __importDefault$f = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(deepHash$2, "__esModule", { value: true });
deepHash$2.hashStream = deepHash$2.deepHashChunks = deepHash$2.deepHash = void 0;
const arweave_1$2 = __importDefault$f(web);
const crypto_1$1 = requireCryptoBrowserify();
async function deepHash$1(data2) {
  if (typeof data2[Symbol.asyncIterator] === "function") {
    const _data2 = data2;
    const context = crypto_1$1.createHash("sha384");
    let length2 = 0;
    for await (const chunk of _data2) {
      length2 += chunk.byteLength;
      context.update(chunk);
    }
    const tag2 = arweave_1$2.default.utils.concatBuffers([
      arweave_1$2.default.utils.stringToBuffer("blob"),
      arweave_1$2.default.utils.stringToBuffer(length2.toString())
    ]);
    const taggedHash2 = arweave_1$2.default.utils.concatBuffers([
      await arweave_1$2.default.crypto.hash(tag2, "SHA-384"),
      context.digest()
    ]);
    return await arweave_1$2.default.crypto.hash(taggedHash2, "SHA-384");
  } else if (Array.isArray(data2)) {
    const tag2 = arweave_1$2.default.utils.concatBuffers([
      arweave_1$2.default.utils.stringToBuffer("list"),
      arweave_1$2.default.utils.stringToBuffer(data2.length.toString())
    ]);
    return await deepHashChunks$1(data2, await arweave_1$2.default.crypto.hash(tag2, "SHA-384"));
  }
  const _data = data2;
  const tag = arweave_1$2.default.utils.concatBuffers([
    arweave_1$2.default.utils.stringToBuffer("blob"),
    arweave_1$2.default.utils.stringToBuffer(_data.byteLength.toString())
  ]);
  const taggedHash = arweave_1$2.default.utils.concatBuffers([
    await arweave_1$2.default.crypto.hash(tag, "SHA-384"),
    await arweave_1$2.default.crypto.hash(_data, "SHA-384")
  ]);
  return await arweave_1$2.default.crypto.hash(taggedHash, "SHA-384");
}
deepHash$2.deepHash = deepHash$1;
async function deepHashChunks$1(chunks2, acc) {
  if (chunks2.length < 1) {
    return acc;
  }
  const hashPair = arweave_1$2.default.utils.concatBuffers([
    acc,
    await deepHash$1(chunks2[0])
  ]);
  const newAcc = await arweave_1$2.default.crypto.hash(hashPair, "SHA-384");
  return await deepHashChunks$1(chunks2.slice(1), newAcc);
}
deepHash$2.deepHashChunks = deepHashChunks$1;
async function hashStream(stream2) {
  const context = crypto_1$1.createHash("sha384");
  for await (const chunk of stream2) {
    context.update(chunk);
  }
  return context.digest();
}
deepHash$2.hashStream = hashStream;
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$3(result, mod, k);
  }
  __setModuleDefault$3(result, mod);
  return result;
};
Object.defineProperty(arDataBase, "__esModule", { value: true });
arDataBase.getSignatureData = void 0;
const utils_1$2 = utils$F;
const utils_2 = utils$E;
const deepHash_1 = deepHash$2;
async function getSignatureData(item) {
  if (utils_2.isBrowser) {
    const web2 = await Promise.resolve().then(() => __importStar$3(requireDeepHash()));
    return web2.default([
      utils_1$2.stringToBuffer("dataitem"),
      utils_1$2.stringToBuffer("1"),
      utils_1$2.stringToBuffer(item.signatureType.toString()),
      item.rawOwner,
      item.rawTarget,
      item.rawAnchor,
      item.rawTags,
      item.rawData
    ]);
  } else {
    return deepHash_1.deepHash([
      utils_1$2.stringToBuffer("dataitem"),
      utils_1$2.stringToBuffer("1"),
      utils_1$2.stringToBuffer(item.signatureType.toString()),
      item.rawOwner,
      item.rawTarget,
      item.rawAnchor,
      item.rawTags,
      item.rawData
    ]);
  }
}
arDataBase.getSignatureData = getSignatureData;
var Bundle = {};
var DataItem = {};
var parser = {};
var avsc = { exports: {} };
var avscServices = { exports: {} };
var crypto$2 = requireCryptoBrowserify();
var util$4 = requireUtil();
var POOL = new BufferPool(4096);
function newBuffer(size) {
  if (typeof Buffer.alloc == "function") {
    return Buffer.alloc(size);
  } else {
    return new Buffer(size);
  }
}
function bufferFrom(data2, enc) {
  if (typeof Buffer.from == "function") {
    return Buffer.from(data2, enc);
  } else {
    return new Buffer(data2, enc);
  }
}
function capitalize(s2) {
  return s2.charAt(0).toUpperCase() + s2.slice(1);
}
function compare$1(n1, n2) {
  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;
}
function getOption(opts, key3, def2) {
  var value = opts[key3];
  return value === void 0 ? def2 : value;
}
function getHash(str, algorithm) {
  algorithm = algorithm || "md5";
  var hash3 = crypto$2.createHash(algorithm);
  hash3.end(str);
  return hash3.read();
}
function singleIndexOf(arr, v) {
  var pos = -1;
  var i, l;
  if (!arr) {
    return -1;
  }
  for (i = 0, l = arr.length; i < l; i++) {
    if (arr[i] === v) {
      if (pos >= 0) {
        return -2;
      }
      pos = i;
    }
  }
  return pos;
}
function toMap(arr, fn) {
  var obj2 = {};
  var i, elem;
  for (i = 0; i < arr.length; i++) {
    elem = arr[i];
    obj2[fn(elem)] = elem;
  }
  return obj2;
}
function objectValues(obj2) {
  return Object.keys(obj2).map(function(key3) {
    return obj2[key3];
  });
}
function hasDuplicates(arr, fn) {
  var obj2 = {};
  var i, l, elem;
  for (i = 0, l = arr.length; i < l; i++) {
    elem = arr[i];
    if (fn) {
      elem = fn(elem);
    }
    if (obj2[elem]) {
      return true;
    }
    obj2[elem] = true;
  }
  return false;
}
function copyOwnProperties(src2, dst, overwrite) {
  var names2 = Object.getOwnPropertyNames(src2);
  var i, l, name2;
  for (i = 0, l = names2.length; i < l; i++) {
    name2 = names2[i];
    if (!dst.hasOwnProperty(name2) || overwrite) {
      var descriptor = Object.getOwnPropertyDescriptor(src2, name2);
      Object.defineProperty(dst, name2, descriptor);
    }
  }
  return dst;
}
function jsonEnd(str, pos) {
  pos = pos | 0;
  var c = str.charAt(pos++);
  if (/[\d-]/.test(c)) {
    while (/[eE\d.+-]/.test(str.charAt(pos))) {
      pos++;
    }
    return pos;
  } else if (/true|null/.test(str.slice(pos - 1, pos + 3))) {
    return pos + 3;
  } else if (/false/.test(str.slice(pos - 1, pos + 4))) {
    return pos + 4;
  }
  var depth = 0;
  var literal = false;
  do {
    switch (c) {
      case "{":
      case "[":
        if (!literal) {
          depth++;
        }
        break;
      case "}":
      case "]":
        if (!literal && !--depth) {
          return pos;
        }
        break;
      case '"':
        literal = !literal;
        if (!depth && !literal) {
          return pos;
        }
        break;
      case "\\":
        pos++;
    }
  } while (c = str.charAt(pos++));
  return -1;
}
function abstractFunction() {
  throw new Error("abstract");
}
function addDeprecatedGetters(obj2, props) {
  var proto2 = obj2.prototype;
  var i, l, prop, getter;
  for (i = 0, l = props.length; i < l; i++) {
    prop = props[i];
    getter = "get" + capitalize(prop);
    proto2[getter] = util$4.deprecate(
      createGetter(prop),
      "use `." + prop + "` instead of `." + getter + "()`"
    );
  }
  function createGetter(prop2) {
    return function() {
      var delegate = this[prop2];
      return typeof delegate == "function" ? delegate.apply(this, arguments) : delegate;
    };
  }
}
function BufferPool(len) {
  this._len = len | 0;
  this._pos = 0;
  this._slab = newBuffer(this._len);
}
BufferPool.prototype.alloc = function(len) {
  var maxLen = this._len;
  if (len > maxLen) {
    return newBuffer(len);
  }
  if (this._pos + len > maxLen) {
    this._slab = newBuffer(maxLen);
    this._pos = 0;
  }
  return this._slab.slice(this._pos, this._pos += len);
};
function Lcg(seed) {
  var a = 1103515245;
  var c = 12345;
  var m = Math.pow(2, 31);
  var state2 = Math.floor(seed || Math.random() * (m - 1));
  this._max = m;
  this._nextInt = function() {
    return state2 = (a * state2 + c) % m;
  };
}
Lcg.prototype.nextBoolean = function() {
  return !!(this._nextInt() % 2);
};
Lcg.prototype.nextInt = function(start, end) {
  if (end === void 0) {
    end = start;
    start = 0;
  }
  end = end === void 0 ? this._max : end;
  return start + Math.floor(this.nextFloat() * (end - start));
};
Lcg.prototype.nextFloat = function(start, end) {
  if (end === void 0) {
    end = start;
    start = 0;
  }
  end = end === void 0 ? 1 : end;
  return start + (end - start) * this._nextInt() / this._max;
};
Lcg.prototype.nextString = function(len, flags) {
  len |= 0;
  flags = flags || "aA";
  var mask = "";
  if (flags.indexOf("a") > -1) {
    mask += "abcdefghijklmnopqrstuvwxyz";
  }
  if (flags.indexOf("A") > -1) {
    mask += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  }
  if (flags.indexOf("#") > -1) {
    mask += "0123456789";
  }
  if (flags.indexOf("!") > -1) {
    mask += "~`!@#$%^&*()_+-={}[]:\";'<>?,./|\\";
  }
  var result = [];
  for (var i = 0; i < len; i++) {
    result.push(this.choice(mask));
  }
  return result.join("");
};
Lcg.prototype.nextBuffer = function(len) {
  var arr = [];
  var i;
  for (i = 0; i < len; i++) {
    arr.push(this.nextInt(256));
  }
  return bufferFrom(arr);
};
Lcg.prototype.choice = function(arr) {
  var len = arr.length;
  if (!len) {
    throw new Error("choosing from empty array");
  }
  return arr[this.nextInt(len)];
};
function OrderedQueue() {
  this._index = 0;
  this._items = [];
}
OrderedQueue.prototype.push = function(item) {
  var items = this._items;
  var i = items.length | 0;
  var j;
  items.push(item);
  while (i > 0 && items[i].index < items[j = i - 1 >> 1].index) {
    item = items[i];
    items[i] = items[j];
    items[j] = item;
    i = j;
  }
};
OrderedQueue.prototype.pop = function() {
  var items = this._items;
  var len = items.length - 1 | 0;
  var first = items[0];
  if (!first || first.index > this._index) {
    return null;
  }
  this._index++;
  if (!len) {
    items.pop();
    return first;
  }
  items[0] = items.pop();
  var mid = len >> 1;
  var i = 0;
  var i1, i2, j, item, c, c1, c2;
  while (i < mid) {
    item = items[i];
    i1 = (i << 1) + 1;
    i2 = i + 1 << 1;
    c1 = items[i1];
    c2 = items[i2];
    if (!c2 || c1.index <= c2.index) {
      c = c1;
      j = i1;
    } else {
      c = c2;
      j = i2;
    }
    if (c.index >= item.index) {
      break;
    }
    items[j] = item;
    items[i] = c;
    i = j;
  }
  return first;
};
function Tap$3(buf, pos) {
  this.buf = buf;
  this.pos = pos | 0;
  if (this.pos < 0) {
    throw new Error("negative offset");
  }
}
Tap$3.prototype.isValid = function() {
  return this.pos <= this.buf.length;
};
Tap$3.prototype.readBoolean = function() {
  return !!this.buf[this.pos++];
};
Tap$3.prototype.skipBoolean = function() {
  this.pos++;
};
Tap$3.prototype.writeBoolean = function(b) {
  this.buf[this.pos++] = !!b;
};
Tap$3.prototype.readInt = Tap$3.prototype.readLong = function() {
  var n = 0;
  var k = 0;
  var buf = this.buf;
  var b, h, f2, fk;
  do {
    b = buf[this.pos++];
    h = b & 128;
    n |= (b & 127) << k;
    k += 7;
  } while (h && k < 28);
  if (h) {
    f2 = n;
    fk = 268435456;
    do {
      b = buf[this.pos++];
      f2 += (b & 127) * fk;
      fk *= 128;
    } while (b & 128);
    return (f2 % 2 ? -(f2 + 1) : f2) / 2;
  }
  return n >> 1 ^ -(n & 1);
};
Tap$3.prototype.skipInt = Tap$3.prototype.skipLong = function() {
  var buf = this.buf;
  while (buf[this.pos++] & 128) {
  }
};
Tap$3.prototype.writeInt = Tap$3.prototype.writeLong = function(n) {
  var buf = this.buf;
  var f2, m;
  if (n >= -1073741824 && n < 1073741824) {
    m = n >= 0 ? n << 1 : ~n << 1 | 1;
    do {
      buf[this.pos] = m & 127;
      m >>= 7;
    } while (m && (buf[this.pos++] |= 128));
  } else {
    f2 = n >= 0 ? n * 2 : -n * 2 - 1;
    do {
      buf[this.pos] = f2 & 127;
      f2 /= 128;
    } while (f2 >= 1 && (buf[this.pos++] |= 128));
  }
  this.pos++;
};
Tap$3.prototype.readFloat = function() {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 4;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.readFloatLE(pos);
};
Tap$3.prototype.skipFloat = function() {
  this.pos += 4;
};
Tap$3.prototype.writeFloat = function(f2) {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 4;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.writeFloatLE(f2, pos);
};
Tap$3.prototype.readDouble = function() {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 8;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.readDoubleLE(pos);
};
Tap$3.prototype.skipDouble = function() {
  this.pos += 8;
};
Tap$3.prototype.writeDouble = function(d) {
  var buf = this.buf;
  var pos = this.pos;
  this.pos += 8;
  if (this.pos > buf.length) {
    return;
  }
  return this.buf.writeDoubleLE(d, pos);
};
Tap$3.prototype.readFixed = function(len) {
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  var fixed = POOL.alloc(len);
  this.buf.copy(fixed, 0, pos, pos + len);
  return fixed;
};
Tap$3.prototype.skipFixed = function(len) {
  this.pos += len;
};
Tap$3.prototype.writeFixed = function(buf, len) {
  len = len || buf.length;
  var pos = this.pos;
  this.pos += len;
  if (this.pos > this.buf.length) {
    return;
  }
  buf.copy(this.buf, pos, 0, len);
};
Tap$3.prototype.readBytes = function() {
  return this.readFixed(this.readLong());
};
Tap$3.prototype.skipBytes = function() {
  var len = this.readLong();
  this.pos += len;
};
Tap$3.prototype.writeBytes = function(buf) {
  var len = buf.length;
  this.writeLong(len);
  this.writeFixed(buf, len);
};
if (typeof Buffer.prototype.utf8Slice == "function") {
  Tap$3.prototype.readString = function() {
    var len = this.readLong();
    var pos = this.pos;
    var buf = this.buf;
    this.pos += len;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.utf8Slice(pos, pos + len);
  };
} else {
  Tap$3.prototype.readString = function() {
    var len = this.readLong();
    var pos = this.pos;
    var buf = this.buf;
    this.pos += len;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.slice(pos, pos + len).toString();
  };
}
Tap$3.prototype.skipString = function() {
  var len = this.readLong();
  this.pos += len;
};
Tap$3.prototype.writeString = function(s2) {
  var len = Buffer.byteLength(s2);
  var buf = this.buf;
  this.writeLong(len);
  var pos = this.pos;
  this.pos += len;
  if (this.pos > buf.length) {
    return;
  }
  if (len > 64) {
    this._writeUtf8(s2, len);
  } else {
    var i, l, c1, c2;
    for (i = 0, l = len; i < l; i++) {
      c1 = s2.charCodeAt(i);
      if (c1 < 128) {
        buf[pos++] = c1;
      } else if (c1 < 2048) {
        buf[pos++] = c1 >> 6 | 192;
        buf[pos++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = s2.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        i++;
        buf[pos++] = c1 >> 18 | 240;
        buf[pos++] = c1 >> 12 & 63 | 128;
        buf[pos++] = c1 >> 6 & 63 | 128;
        buf[pos++] = c1 & 63 | 128;
      } else {
        buf[pos++] = c1 >> 12 | 224;
        buf[pos++] = c1 >> 6 & 63 | 128;
        buf[pos++] = c1 & 63 | 128;
      }
    }
  }
};
if (typeof Buffer.prototype.utf8Write == "function") {
  Tap$3.prototype._writeUtf8 = function(str, len) {
    this.buf.utf8Write(str, this.pos - len, len);
  };
} else {
  Tap$3.prototype._writeUtf8 = function(str, len) {
    this.buf.write(str, this.pos - len, len, "utf8");
  };
}
if (typeof Buffer.prototype.latin1Write == "function") {
  Tap$3.prototype.writeBinary = function(str, len) {
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    this.buf.latin1Write(str, pos, len);
  };
} else if (typeof Buffer.prototype.binaryWrite == "function") {
  Tap$3.prototype.writeBinary = function(str, len) {
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    this.buf.binaryWrite(str, pos, len);
  };
} else {
  Tap$3.prototype.writeBinary = function(s2, len) {
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    this.buf.write(s2, pos, len, "binary");
  };
}
Tap$3.prototype.matchBoolean = function(tap) {
  return this.buf[this.pos++] - tap.buf[tap.pos++];
};
Tap$3.prototype.matchInt = Tap$3.prototype.matchLong = function(tap) {
  var n1 = this.readLong();
  var n2 = tap.readLong();
  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;
};
Tap$3.prototype.matchFloat = function(tap) {
  var n1 = this.readFloat();
  var n2 = tap.readFloat();
  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;
};
Tap$3.prototype.matchDouble = function(tap) {
  var n1 = this.readDouble();
  var n2 = tap.readDouble();
  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;
};
Tap$3.prototype.matchFixed = function(tap, len) {
  return this.readFixed(len).compare(tap.readFixed(len));
};
Tap$3.prototype.matchBytes = Tap$3.prototype.matchString = function(tap) {
  var l1 = this.readLong();
  var p1 = this.pos;
  this.pos += l1;
  var l2 = tap.readLong();
  var p2 = tap.pos;
  tap.pos += l2;
  var b1 = this.buf.slice(p1, this.pos);
  var b2 = tap.buf.slice(p2, tap.pos);
  return b1.compare(b2);
};
Tap$3.prototype.unpackLongBytes = function() {
  var res = newBuffer(8);
  var n = 0;
  var i = 0;
  var j = 6;
  var buf = this.buf;
  var b, neg6;
  b = buf[this.pos++];
  neg6 = b & 1;
  res.fill(0);
  n |= (b & 127) >> 1;
  while (b & 128) {
    b = buf[this.pos++];
    n |= (b & 127) << j;
    j += 7;
    if (j >= 8) {
      j -= 8;
      res[i++] = n;
      n >>= 8;
    }
  }
  res[i] = n;
  if (neg6) {
    invert(res, 8);
  }
  return res;
};
Tap$3.prototype.packLongBytes = function(buf) {
  var neg6 = (buf[7] & 128) >> 7;
  var res = this.buf;
  var j = 1;
  var k = 0;
  var m = 3;
  var n;
  if (neg6) {
    invert(buf, 8);
    n = 1;
  } else {
    n = 0;
  }
  var parts = [
    buf.readUIntLE(0, 3),
    buf.readUIntLE(3, 3),
    buf.readUIntLE(6, 2)
  ];
  while (m && !parts[--m]) {
  }
  while (k < m) {
    n |= parts[k++] << j;
    j += 24;
    while (j > 7) {
      res[this.pos++] = n & 127 | 128;
      n >>= 7;
      j -= 7;
    }
  }
  n |= parts[m] << j;
  do {
    res[this.pos] = n & 127;
    n >>= 7;
  } while (n && (res[this.pos++] |= 128));
  this.pos++;
  if (neg6) {
    invert(buf, 8);
  }
};
function invert(buf, len) {
  while (len--) {
    buf[len] = ~buf[len];
  }
}
var utils$f = {
  abstractFunction,
  addDeprecatedGetters,
  bufferFrom,
  capitalize,
  copyOwnProperties,
  getHash,
  compare: compare$1,
  getOption,
  jsonEnd,
  newBuffer,
  objectValues,
  toMap,
  singleIndexOf,
  hasDuplicates,
  Lcg,
  OrderedQueue,
  Tap: Tap$3
};
var utils$e = utils$f, buffer = buffer$3, util$3 = requireUtil();
var Tap$2 = utils$e.Tap;
var debug$1 = util$3.debuglog("avsc:types");
var f$3 = util$3.format;
var TYPES = {
  "array": ArrayType,
  "boolean": BooleanType,
  "bytes": BytesType,
  "double": DoubleType,
  "enum": EnumType,
  "error": RecordType,
  "fixed": FixedType,
  "float": FloatType,
  "int": IntType,
  "long": LongType,
  "map": MapType,
  "null": NullType,
  "record": RecordType,
  "string": StringType
};
var NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;
var RANDOM = new utils$e.Lcg();
var TAP = new Tap$2(new buffer.SlowBuffer(1024));
var LOGICAL_TYPE = null;
var UNDERLYING_TYPES = [];
function Type$1(schema, opts) {
  var type;
  if (LOGICAL_TYPE) {
    type = LOGICAL_TYPE;
    UNDERLYING_TYPES.push([LOGICAL_TYPE, this]);
    LOGICAL_TYPE = null;
  } else {
    type = this;
  }
  this._hash = new Hash();
  this.name = void 0;
  this.aliases = void 0;
  this.doc = schema && schema.doc ? "" + schema.doc : void 0;
  if (schema) {
    var name2 = schema.name;
    var namespace = schema.namespace === void 0 ? opts && opts.namespace : schema.namespace;
    if (name2 !== void 0) {
      name2 = qualify(name2, namespace);
      if (isPrimitive(name2)) {
        throw new Error(f$3("cannot rename primitive type: %j", name2));
      }
      var registry = opts && opts.registry;
      if (registry) {
        if (registry[name2] !== void 0) {
          throw new Error(f$3("duplicate type name: %s", name2));
        }
        registry[name2] = type;
      }
    } else if (opts && opts.noAnonymousTypes) {
      throw new Error(f$3("missing name property in schema: %j", schema));
    }
    this.name = name2;
    this.aliases = schema.aliases ? schema.aliases.map(function(s2) {
      return qualify(s2, namespace);
    }) : [];
  }
}
Type$1.forSchema = function(schema, opts) {
  opts = opts || {};
  opts.registry = opts.registry || {};
  var UnionType2 = function(wrapUnions) {
    if (wrapUnions === true) {
      wrapUnions = "always";
    } else if (wrapUnions === false) {
      wrapUnions = "never";
    } else if (wrapUnions === void 0) {
      wrapUnions = "auto";
    } else if (typeof wrapUnions == "string") {
      wrapUnions = wrapUnions.toLowerCase();
    }
    switch (wrapUnions) {
      case "always":
        return WrappedUnionType;
      case "never":
        return UnwrappedUnionType;
      case "auto":
        return void 0;
      default:
        throw new Error(f$3("invalid wrap unions option: %j", wrapUnions));
    }
  }(opts.wrapUnions);
  if (schema === null) {
    throw new Error('invalid type: null (did you mean "null"?)');
  }
  if (Type$1.isType(schema)) {
    return schema;
  }
  var type;
  if (opts.typeHook && (type = opts.typeHook(schema, opts))) {
    if (!Type$1.isType(type)) {
      throw new Error(f$3("invalid typehook return value: %j", type));
    }
    return type;
  }
  if (typeof schema == "string") {
    schema = qualify(schema, opts.namespace);
    type = opts.registry[schema];
    if (type) {
      return type;
    }
    if (isPrimitive(schema)) {
      return opts.registry[schema] = Type$1.forSchema({ type: schema }, opts);
    }
    throw new Error(f$3("undefined type name: %s", schema));
  }
  if (schema.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {
    var DerivedType = opts.logicalTypes[schema.logicalType];
    if (DerivedType) {
      var namespace = opts.namespace;
      var registry = {};
      Object.keys(opts.registry).forEach(function(key3) {
        registry[key3] = opts.registry[key3];
      });
      try {
        debug$1("instantiating logical type for %s", schema.logicalType);
        return new DerivedType(schema, opts);
      } catch (err) {
        debug$1("failed to instantiate logical type for %s", schema.logicalType);
        if (opts.assertLogicalTypes) {
          throw err;
        }
        LOGICAL_TYPE = null;
        opts.namespace = namespace;
        opts.registry = registry;
      }
    }
  }
  if (Array.isArray(schema)) {
    var types2 = schema.map(function(obj2) {
      return Type$1.forSchema(obj2, opts);
    });
    if (!UnionType2) {
      UnionType2 = isAmbiguous(types2) ? WrappedUnionType : UnwrappedUnionType;
    }
    type = new UnionType2(types2, opts);
  } else {
    type = function(typeName) {
      var Type2 = TYPES[typeName];
      if (Type2 === void 0) {
        throw new Error(f$3("unknown type: %j", typeName));
      }
      return new Type2(schema, opts);
    }(schema.type);
  }
  return type;
};
Type$1.forValue = function(val, opts) {
  opts = opts || {};
  opts.emptyArrayType = opts.emptyArrayType || Type$1.forSchema({
    type: "array",
    items: "null"
  });
  if (opts.valueHook) {
    var type = opts.valueHook(val, opts);
    if (type !== void 0) {
      if (!Type$1.isType(type)) {
        throw new Error(f$3("invalid value hook return value: %j", type));
      }
      return type;
    }
  }
  switch (typeof val) {
    case "string":
      return Type$1.forSchema("string", opts);
    case "boolean":
      return Type$1.forSchema("boolean", opts);
    case "number":
      if ((val | 0) === val) {
        return Type$1.forSchema("int", opts);
      } else if (Math.abs(val) < 9007199254740991) {
        return Type$1.forSchema("float", opts);
      }
      return Type$1.forSchema("double", opts);
    case "object":
      if (val === null) {
        return Type$1.forSchema("null", opts);
      } else if (Array.isArray(val)) {
        if (!val.length) {
          return opts.emptyArrayType;
        }
        return Type$1.forSchema({
          type: "array",
          items: Type$1.forTypes(
            val.map(function(v) {
              return Type$1.forValue(v, opts);
            })
          )
        }, opts);
      } else if (Buffer.isBuffer(val)) {
        return Type$1.forSchema("bytes", opts);
      }
      var fieldNames = Object.keys(val);
      if (fieldNames.some(function(s2) {
        return !isValidName$1(s2);
      })) {
        return Type$1.forSchema({
          type: "map",
          values: Type$1.forTypes(fieldNames.map(function(s2) {
            return Type$1.forValue(val[s2], opts);
          }), opts)
        }, opts);
      }
      return Type$1.forSchema({
        type: "record",
        fields: fieldNames.map(function(s2) {
          return { name: s2, type: Type$1.forValue(val[s2], opts) };
        })
      }, opts);
    default:
      throw new Error(f$3("cannot infer type from: %j", val));
  }
};
Type$1.forTypes = function(types2, opts) {
  if (!types2.length) {
    throw new Error("no types to combine");
  }
  if (types2.length === 1) {
    return types2[0];
  }
  opts = opts || {};
  var expanded = [];
  var numWrappedUnions = 0;
  var isValidWrappedUnion = true;
  types2.forEach(function(type) {
    switch (type.typeName) {
      case "union:unwrapped":
        isValidWrappedUnion = false;
        expanded = expanded.concat(type.types);
        break;
      case "union:wrapped":
        numWrappedUnions++;
        expanded = expanded.concat(type.types);
        break;
      case "null":
        expanded.push(type);
        break;
      default:
        isValidWrappedUnion = false;
        expanded.push(type);
    }
  });
  if (numWrappedUnions) {
    if (!isValidWrappedUnion) {
      throw new Error("cannot combine wrapped union");
    }
    var branchTypes = {};
    expanded.forEach(function(type) {
      var name2 = type.branchName;
      var branchType = branchTypes[name2];
      if (!branchType) {
        branchTypes[name2] = type;
      } else if (!type.equals(branchType)) {
        throw new Error("inconsistent branch type");
      }
    });
    var wrapUnions = opts.wrapUnions;
    var unionType;
    opts.wrapUnions = true;
    try {
      unionType = Type$1.forSchema(Object.keys(branchTypes).map(function(name2) {
        return branchTypes[name2];
      }), opts);
    } catch (err) {
      opts.wrapUnions = wrapUnions;
      throw err;
    }
    opts.wrapUnions = wrapUnions;
    return unionType;
  }
  var bucketized = {};
  expanded.forEach(function(type) {
    var bucket = getTypeBucket(type);
    var bucketTypes = bucketized[bucket];
    if (!bucketTypes) {
      bucketized[bucket] = bucketTypes = [];
    }
    bucketTypes.push(type);
  });
  var buckets = Object.keys(bucketized);
  var augmented = buckets.map(function(bucket) {
    var bucketTypes = bucketized[bucket];
    if (bucketTypes.length === 1) {
      return bucketTypes[0];
    } else {
      switch (bucket) {
        case "null":
        case "boolean":
          return bucketTypes[0];
        case "number":
          return combineNumbers(bucketTypes);
        case "string":
          return combineStrings(bucketTypes, opts);
        case "buffer":
          return combineBuffers(bucketTypes, opts);
        case "array":
          bucketTypes = bucketTypes.filter(function(t) {
            return t !== opts.emptyArrayType;
          });
          if (!bucketTypes.length) {
            return opts.emptyArrayType;
          }
          return Type$1.forSchema({
            type: "array",
            items: Type$1.forTypes(bucketTypes.map(function(t) {
              return t.itemsType;
            }))
          }, opts);
        default:
          return combineObjects(bucketTypes, opts);
      }
    }
  });
  if (augmented.length === 1) {
    return augmented[0];
  } else {
    return Type$1.forSchema(augmented, opts);
  }
};
Type$1.isType = function() {
  var l = arguments.length;
  if (!l) {
    return false;
  }
  var any2 = arguments[0];
  if (!any2 || typeof any2._update != "function" || typeof any2.fingerprint != "function") {
    return false;
  }
  if (l === 1) {
    return true;
  }
  var typeName = any2.typeName;
  var i;
  for (i = 1; i < l; i++) {
    if (typeName.indexOf(arguments[i]) === 0) {
      return true;
    }
  }
  return false;
};
Type$1.__reset = function(size) {
  debug$1("resetting type buffer to %d", size);
  TAP.buf = new buffer.SlowBuffer(size);
};
Object.defineProperty(Type$1.prototype, "branchName", {
  enumerable: true,
  get: function() {
    if (this.name) {
      return this.name;
    }
    var type = Type$1.isType(this, "logical") ? this.underlyingType : this;
    if (Type$1.isType(type, "abstract")) {
      return type._concreteTypeName;
    }
    return Type$1.isType(type, "union") ? void 0 : type.typeName;
  }
});
Type$1.prototype.clone = function(val, opts) {
  if (opts) {
    opts = {
      coerce: !!opts.coerceBuffers | 0,
      fieldHook: opts.fieldHook,
      qualifyNames: !!opts.qualifyNames,
      skip: !!opts.skipMissingFields,
      wrap: !!opts.wrapUnions | 0
    };
    return this._copy(val, opts);
  } else {
    return this.fromBuffer(this.toBuffer(val));
  }
};
Type$1.prototype.compare = utils$e.abstractFunction;
Type$1.prototype.compareBuffers = function(buf1, buf2) {
  return this._match(new Tap$2(buf1), new Tap$2(buf2));
};
Type$1.prototype.createResolver = function(type, opts) {
  if (!Type$1.isType(type)) {
    throw new Error(f$3("not a type: %j", type));
  }
  if (!Type$1.isType(this, "union", "logical") && Type$1.isType(type, "logical")) {
    return this.createResolver(type.underlyingType, opts);
  }
  opts = opts || {};
  opts.registry = opts.registry || {};
  var resolver, key3;
  if (Type$1.isType(this, "record", "error") && Type$1.isType(type, "record", "error")) {
    key3 = this.name + ":" + type.name;
    resolver = opts.registry[key3];
    if (resolver) {
      return resolver;
    }
  }
  resolver = new Resolver$1(this);
  if (key3) {
    opts.registry[key3] = resolver;
  }
  if (Type$1.isType(type, "union")) {
    var resolvers = type.types.map(function(t) {
      return this.createResolver(t, opts);
    }, this);
    resolver._read = function(tap) {
      var index2 = tap.readLong();
      var resolver2 = resolvers[index2];
      if (resolver2 === void 0) {
        throw new Error(f$3("invalid union index: %s", index2));
      }
      return resolvers[index2]._read(tap);
    };
  } else {
    this._update(resolver, type, opts);
  }
  if (!resolver._read) {
    throw new Error(f$3("cannot read %s as %s", type, this));
  }
  return Object.freeze(resolver);
};
Type$1.prototype.decode = function(buf, pos, resolver) {
  var tap = new Tap$2(buf, pos);
  var val = readValue(this, tap, resolver);
  if (!tap.isValid()) {
    return { value: void 0, offset: -1 };
  }
  return { value: val, offset: tap.pos };
};
Type$1.prototype.encode = function(val, buf, pos) {
  var tap = new Tap$2(buf, pos);
  this._write(tap, val);
  if (!tap.isValid()) {
    return buf.length - tap.pos;
  }
  return tap.pos;
};
Type$1.prototype.equals = function(type) {
  return Type$1.isType(type) && this.fingerprint().equals(type.fingerprint());
};
Type$1.prototype.fingerprint = function(algorithm) {
  if (!algorithm) {
    if (!this._hash.str) {
      var schemaStr = JSON.stringify(this.schema());
      this._hash.str = utils$e.getHash(schemaStr).toString("binary");
    }
    return utils$e.bufferFrom(this._hash.str, "binary");
  } else {
    return utils$e.getHash(JSON.stringify(this.schema()), algorithm);
  }
};
Type$1.prototype.fromBuffer = function(buf, resolver, noCheck) {
  var tap = new Tap$2(buf);
  var val = readValue(this, tap, resolver, noCheck);
  if (!tap.isValid()) {
    throw new Error("truncated buffer");
  }
  if (!noCheck && tap.pos < buf.length) {
    throw new Error("trailing data");
  }
  return val;
};
Type$1.prototype.fromString = function(str) {
  return this._copy(JSON.parse(str), { coerce: 2 });
};
Type$1.prototype.inspect = function() {
  var typeName = this.typeName;
  var className = getClassName(typeName);
  if (isPrimitive(typeName)) {
    return f$3("<%s>", className);
  } else {
    var obj2 = this.schema({ exportAttrs: true, noDeref: true });
    if (typeof obj2 == "object" && !Type$1.isType(this, "logical")) {
      obj2.type = void 0;
    }
    return f$3("<%s %j>", className, obj2);
  }
};
Type$1.prototype.isValid = function(val, opts) {
  var flags = (opts && opts.noUndeclaredFields) | 0;
  var errorHook = opts && opts.errorHook;
  var hook, path3;
  if (errorHook) {
    path3 = [];
    hook = function(any2, type) {
      errorHook.call(this, path3.slice(), any2, type, val);
    };
  }
  return this._check(val, flags, hook, path3);
};
Type$1.prototype.random = utils$e.abstractFunction;
Type$1.prototype.schema = function(opts) {
  return this._attrs({
    exportAttrs: !!(opts && opts.exportAttrs),
    noDeref: !!(opts && opts.noDeref)
  });
};
Type$1.prototype.toBuffer = function(val) {
  TAP.pos = 0;
  this._write(TAP, val);
  var buf = utils$e.newBuffer(TAP.pos);
  if (TAP.isValid()) {
    TAP.buf.copy(buf, 0, 0, TAP.pos);
  } else {
    this._write(new Tap$2(buf), val);
  }
  return buf;
};
Type$1.prototype.toJSON = function() {
  return this.schema({ exportAttrs: true });
};
Type$1.prototype.toString = function(val) {
  if (val === void 0) {
    return JSON.stringify(this.schema({ noDeref: true }));
  }
  return JSON.stringify(this._copy(val, { coerce: 3 }));
};
Type$1.prototype.wrap = function(val) {
  var Branch = this._branchConstructor;
  return Branch === null ? null : new Branch(val);
};
Type$1.prototype._attrs = function(opts) {
  opts.derefed = opts.derefed || {};
  var name2 = this.name;
  if (name2 !== void 0) {
    if (opts.noDeref || opts.derefed[name2]) {
      return name2;
    }
    opts.derefed[name2] = true;
  }
  var schema = {};
  if (this.name !== void 0) {
    schema.name = name2;
  }
  schema.type = this.typeName;
  var derefedSchema = this._deref(schema, opts);
  if (derefedSchema !== void 0) {
    schema = derefedSchema;
  }
  if (opts.exportAttrs) {
    if (this.aliases && this.aliases.length) {
      schema.aliases = this.aliases;
    }
    if (this.doc !== void 0) {
      schema.doc = this.doc;
    }
  }
  return schema;
};
Type$1.prototype._createBranchConstructor = function() {
  var name2 = this.branchName;
  if (name2 === "null") {
    return null;
  }
  function ConstructorFunction() {
    return function Branch$(val) {
      if (~name2.indexOf(".")) {
        this[`${name2}`] = val;
      } else {
        this[name2] = val;
      }
    };
  }
  var Branch = ConstructorFunction();
  Branch.type = this;
  Branch.prototype.unwrap = function() {
    return this[`${name2}`];
  };
  Branch.prototype.unwrapped = Branch.prototype.unwrap;
  return Branch;
};
Type$1.prototype._peek = function(tap) {
  var pos = tap.pos;
  var val = this._read(tap);
  tap.pos = pos;
  return val;
};
Type$1.prototype._check = utils$e.abstractFunction;
Type$1.prototype._copy = utils$e.abstractFunction;
Type$1.prototype._deref = utils$e.abstractFunction;
Type$1.prototype._match = utils$e.abstractFunction;
Type$1.prototype._read = utils$e.abstractFunction;
Type$1.prototype._skip = utils$e.abstractFunction;
Type$1.prototype._update = utils$e.abstractFunction;
Type$1.prototype._write = utils$e.abstractFunction;
Type$1.prototype.getAliases = function() {
  return this.aliases;
};
Type$1.prototype.getFingerprint = Type$1.prototype.fingerprint;
Type$1.prototype.getName = function(asBranch) {
  return this.name || !asBranch ? this.name : this.branchName;
};
Type$1.prototype.getSchema = Type$1.prototype.schema;
Type$1.prototype.getTypeName = function() {
  return this.typeName;
};
function PrimitiveType(noFreeze) {
  Type$1.call(this);
  this._branchConstructor = this._createBranchConstructor();
  if (!noFreeze) {
    Object.freeze(this);
  }
}
util$3.inherits(PrimitiveType, Type$1);
PrimitiveType.prototype._update = function(resolver, type) {
  if (type.typeName === this.typeName) {
    resolver._read = this._read;
  }
};
PrimitiveType.prototype._copy = function(val) {
  this._check(val, void 0, throwInvalidError);
  return val;
};
PrimitiveType.prototype._deref = function() {
  return this.typeName;
};
PrimitiveType.prototype.compare = utils$e.compare;
function NullType() {
  PrimitiveType.call(this);
}
util$3.inherits(NullType, PrimitiveType);
NullType.prototype._check = function(val, flags, hook) {
  var b = val === null;
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
NullType.prototype._read = function() {
  return null;
};
NullType.prototype._skip = function() {
};
NullType.prototype._write = function(tap, val) {
  if (val !== null) {
    throwInvalidError(val, this);
  }
};
NullType.prototype._match = function() {
  return 0;
};
NullType.prototype.compare = NullType.prototype._match;
NullType.prototype.typeName = "null";
NullType.prototype.random = NullType.prototype._read;
function BooleanType() {
  PrimitiveType.call(this);
}
util$3.inherits(BooleanType, PrimitiveType);
BooleanType.prototype._check = function(val, flags, hook) {
  var b = typeof val == "boolean";
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
BooleanType.prototype._read = function(tap) {
  return tap.readBoolean();
};
BooleanType.prototype._skip = function(tap) {
  tap.skipBoolean();
};
BooleanType.prototype._write = function(tap, val) {
  if (typeof val != "boolean") {
    throwInvalidError(val, this);
  }
  tap.writeBoolean(val);
};
BooleanType.prototype._match = function(tap1, tap2) {
  return tap1.matchBoolean(tap2);
};
BooleanType.prototype.typeName = "boolean";
BooleanType.prototype.random = function() {
  return RANDOM.nextBoolean();
};
function IntType() {
  PrimitiveType.call(this);
}
util$3.inherits(IntType, PrimitiveType);
IntType.prototype._check = function(val, flags, hook) {
  var b = val === (val | 0);
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
IntType.prototype._read = function(tap) {
  return tap.readInt();
};
IntType.prototype._skip = function(tap) {
  tap.skipInt();
};
IntType.prototype._write = function(tap, val) {
  if (val !== (val | 0)) {
    throwInvalidError(val, this);
  }
  tap.writeInt(val);
};
IntType.prototype._match = function(tap1, tap2) {
  return tap1.matchInt(tap2);
};
IntType.prototype.typeName = "int";
IntType.prototype.random = function() {
  return RANDOM.nextInt(1e3) | 0;
};
function LongType() {
  PrimitiveType.call(this);
}
util$3.inherits(LongType, PrimitiveType);
LongType.prototype._check = function(val, flags, hook) {
  var b = typeof val == "number" && val % 1 === 0 && isSafeLong(val);
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
LongType.prototype._read = function(tap) {
  var n = tap.readLong();
  if (!isSafeLong(n)) {
    throw new Error("potential precision loss");
  }
  return n;
};
LongType.prototype._skip = function(tap) {
  tap.skipLong();
};
LongType.prototype._write = function(tap, val) {
  if (typeof val != "number" || val % 1 || !isSafeLong(val)) {
    throwInvalidError(val, this);
  }
  tap.writeLong(val);
};
LongType.prototype._match = function(tap1, tap2) {
  return tap1.matchLong(tap2);
};
LongType.prototype._update = function(resolver, type) {
  switch (type.typeName) {
    case "int":
      resolver._read = type._read;
      break;
    case "abstract:long":
    case "long":
      resolver._read = this._read;
  }
};
LongType.prototype.typeName = "long";
LongType.prototype.random = function() {
  return RANDOM.nextInt();
};
LongType.__with = function(methods2, noUnpack) {
  methods2 = methods2 || {};
  var mapping = {
    toBuffer: "_toBuffer",
    fromBuffer: "_fromBuffer",
    fromJSON: "_fromJSON",
    toJSON: "_toJSON",
    isValid: "_isValid",
    compare: "compare"
  };
  var type = new AbstractLongType(noUnpack);
  Object.keys(mapping).forEach(function(name2) {
    if (methods2[name2] === void 0) {
      throw new Error(f$3("missing method implementation: %s", name2));
    }
    type[mapping[name2]] = methods2[name2];
  });
  return Object.freeze(type);
};
function FloatType() {
  PrimitiveType.call(this);
}
util$3.inherits(FloatType, PrimitiveType);
FloatType.prototype._check = function(val, flags, hook) {
  var b = typeof val == "number";
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
FloatType.prototype._read = function(tap) {
  return tap.readFloat();
};
FloatType.prototype._skip = function(tap) {
  tap.skipFloat();
};
FloatType.prototype._write = function(tap, val) {
  if (typeof val != "number") {
    throwInvalidError(val, this);
  }
  tap.writeFloat(val);
};
FloatType.prototype._match = function(tap1, tap2) {
  return tap1.matchFloat(tap2);
};
FloatType.prototype._update = function(resolver, type) {
  switch (type.typeName) {
    case "float":
    case "int":
      resolver._read = type._read;
      break;
    case "abstract:long":
    case "long":
      resolver._read = function(tap) {
        return tap.readLong();
      };
  }
};
FloatType.prototype.typeName = "float";
FloatType.prototype.random = function() {
  return RANDOM.nextFloat(1e3);
};
function DoubleType() {
  PrimitiveType.call(this);
}
util$3.inherits(DoubleType, PrimitiveType);
DoubleType.prototype._check = function(val, flags, hook) {
  var b = typeof val == "number";
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
DoubleType.prototype._read = function(tap) {
  return tap.readDouble();
};
DoubleType.prototype._skip = function(tap) {
  tap.skipDouble();
};
DoubleType.prototype._write = function(tap, val) {
  if (typeof val != "number") {
    throwInvalidError(val, this);
  }
  tap.writeDouble(val);
};
DoubleType.prototype._match = function(tap1, tap2) {
  return tap1.matchDouble(tap2);
};
DoubleType.prototype._update = function(resolver, type) {
  switch (type.typeName) {
    case "double":
    case "float":
    case "int":
      resolver._read = type._read;
      break;
    case "abstract:long":
    case "long":
      resolver._read = function(tap) {
        return tap.readLong();
      };
  }
};
DoubleType.prototype.typeName = "double";
DoubleType.prototype.random = function() {
  return RANDOM.nextFloat();
};
function StringType() {
  PrimitiveType.call(this);
}
util$3.inherits(StringType, PrimitiveType);
StringType.prototype._check = function(val, flags, hook) {
  var b = typeof val == "string";
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
StringType.prototype._read = function(tap) {
  return tap.readString();
};
StringType.prototype._skip = function(tap) {
  tap.skipString();
};
StringType.prototype._write = function(tap, val) {
  if (typeof val != "string") {
    throwInvalidError(val, this);
  }
  tap.writeString(val);
};
StringType.prototype._match = function(tap1, tap2) {
  return tap1.matchString(tap2);
};
StringType.prototype._update = function(resolver, type) {
  switch (type.typeName) {
    case "bytes":
    case "string":
      resolver._read = this._read;
  }
};
StringType.prototype.typeName = "string";
StringType.prototype.random = function() {
  return RANDOM.nextString(RANDOM.nextInt(32));
};
function BytesType() {
  PrimitiveType.call(this);
}
util$3.inherits(BytesType, PrimitiveType);
BytesType.prototype._check = function(val, flags, hook) {
  var b = Buffer.isBuffer(val);
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
BytesType.prototype._read = function(tap) {
  return tap.readBytes();
};
BytesType.prototype._skip = function(tap) {
  tap.skipBytes();
};
BytesType.prototype._write = function(tap, val) {
  if (!Buffer.isBuffer(val)) {
    throwInvalidError(val, this);
  }
  tap.writeBytes(val);
};
BytesType.prototype._match = function(tap1, tap2) {
  return tap1.matchBytes(tap2);
};
BytesType.prototype._update = StringType.prototype._update;
BytesType.prototype._copy = function(obj2, opts) {
  var buf;
  switch ((opts && opts.coerce) | 0) {
    case 3:
      this._check(obj2, void 0, throwInvalidError);
      return obj2.toString("binary");
    case 2:
      if (typeof obj2 != "string") {
        throw new Error(f$3("cannot coerce to buffer: %j", obj2));
      }
      buf = utils$e.bufferFrom(obj2, "binary");
      this._check(buf, void 0, throwInvalidError);
      return buf;
    case 1:
      if (!isJsonBuffer(obj2)) {
        throw new Error(f$3("cannot coerce to buffer: %j", obj2));
      }
      buf = utils$e.bufferFrom(obj2.data);
      this._check(buf, void 0, throwInvalidError);
      return buf;
    default:
      this._check(obj2, void 0, throwInvalidError);
      return utils$e.bufferFrom(obj2);
  }
};
BytesType.prototype.compare = Buffer.compare;
BytesType.prototype.typeName = "bytes";
BytesType.prototype.random = function() {
  return RANDOM.nextBuffer(RANDOM.nextInt(32));
};
function UnionType(schema, opts) {
  Type$1.call(this);
  if (!Array.isArray(schema)) {
    throw new Error(f$3("non-array union schema: %j", schema));
  }
  if (!schema.length) {
    throw new Error("empty union");
  }
  this.types = Object.freeze(schema.map(function(obj2) {
    return Type$1.forSchema(obj2, opts);
  }));
  this._branchIndices = {};
  this.types.forEach(function(type, i) {
    if (Type$1.isType(type, "union")) {
      throw new Error("unions cannot be directly nested");
    }
    var branch = type.branchName;
    if (this._branchIndices[branch] !== void 0) {
      throw new Error(f$3("duplicate union branch name: %j", branch));
    }
    this._branchIndices[branch] = i;
  }, this);
}
util$3.inherits(UnionType, Type$1);
UnionType.prototype._branchConstructor = function() {
  throw new Error("unions cannot be directly wrapped");
};
UnionType.prototype._skip = function(tap) {
  this.types[tap.readLong()]._skip(tap);
};
UnionType.prototype._match = function(tap1, tap2) {
  var n1 = tap1.readLong();
  var n2 = tap2.readLong();
  if (n1 === n2) {
    return this.types[n1]._match(tap1, tap2);
  } else {
    return n1 < n2 ? -1 : 1;
  }
};
UnionType.prototype._deref = function(schema, opts) {
  return this.types.map(function(t) {
    return t._attrs(opts);
  });
};
UnionType.prototype.getTypes = function() {
  return this.types;
};
function UnwrappedUnionType(schema, opts) {
  UnionType.call(this, schema, opts);
  this._dynamicBranches = null;
  this._bucketIndices = {};
  this.types.forEach(function(type, index2) {
    if (Type$1.isType(type, "abstract", "logical")) {
      if (!this._dynamicBranches) {
        this._dynamicBranches = [];
      }
      this._dynamicBranches.push({ index: index2, type });
    } else {
      var bucket = getTypeBucket(type);
      if (this._bucketIndices[bucket] !== void 0) {
        throw new Error(f$3("ambiguous unwrapped union: %j", this));
      }
      this._bucketIndices[bucket] = index2;
    }
  }, this);
  Object.freeze(this);
}
util$3.inherits(UnwrappedUnionType, UnionType);
UnwrappedUnionType.prototype._getIndex = function(val) {
  var index2 = this._bucketIndices[getValueBucket(val)];
  if (this._dynamicBranches) {
    index2 = this._getBranchIndex(val, index2);
  }
  return index2;
};
UnwrappedUnionType.prototype._getBranchIndex = function(any2, index2) {
  var logicalBranches = this._dynamicBranches;
  var i, l, branch;
  for (i = 0, l = logicalBranches.length; i < l; i++) {
    branch = logicalBranches[i];
    if (branch.type._check(any2)) {
      if (index2 === void 0) {
        index2 = branch.index;
      } else {
        throw new Error("ambiguous conversion");
      }
    }
  }
  return index2;
};
UnwrappedUnionType.prototype._check = function(val, flags, hook, path3) {
  var index2 = this._getIndex(val);
  var b = index2 !== void 0;
  if (b) {
    return this.types[index2]._check(val, flags, hook, path3);
  }
  if (hook) {
    hook(val, this);
  }
  return b;
};
UnwrappedUnionType.prototype._read = function(tap) {
  var index2 = tap.readLong();
  var branchType = this.types[index2];
  if (branchType) {
    return branchType._read(tap);
  } else {
    throw new Error(f$3("invalid union index: %s", index2));
  }
};
UnwrappedUnionType.prototype._write = function(tap, val) {
  var index2 = this._getIndex(val);
  if (index2 === void 0) {
    throwInvalidError(val, this);
  }
  tap.writeLong(index2);
  if (val !== null) {
    this.types[index2]._write(tap, val);
  }
};
UnwrappedUnionType.prototype._update = function(resolver, type, opts) {
  var i, l, typeResolver;
  for (i = 0, l = this.types.length; i < l; i++) {
    try {
      typeResolver = this.types[i].createResolver(type, opts);
    } catch (err) {
      continue;
    }
    resolver._read = function(tap) {
      return typeResolver._read(tap);
    };
    return;
  }
};
UnwrappedUnionType.prototype._copy = function(val, opts) {
  var coerce2 = opts && opts.coerce | 0;
  var wrap2 = opts && opts.wrap | 0;
  var index2;
  if (wrap2 === 2) {
    index2 = 0;
  } else {
    switch (coerce2) {
      case 1:
        if (isJsonBuffer(val) && this._bucketIndices.buffer !== void 0) {
          index2 = this._bucketIndices.buffer;
        } else {
          index2 = this._getIndex(val);
        }
        break;
      case 2:
        if (val === null) {
          index2 = this._bucketIndices["null"];
        } else if (typeof val === "object") {
          var keys2 = Object.keys(val);
          if (keys2.length === 1) {
            index2 = this._branchIndices[keys2[0]];
            val = val[keys2[0]];
          }
        }
        break;
      default:
        index2 = this._getIndex(val);
    }
    if (index2 === void 0) {
      throwInvalidError(val, this);
    }
  }
  var type = this.types[index2];
  if (val === null || wrap2 === 3) {
    return type._copy(val, opts);
  } else {
    switch (coerce2) {
      case 3:
        var obj2 = {};
        obj2[type.branchName] = type._copy(val, opts);
        return obj2;
      default:
        return type._copy(val, opts);
    }
  }
};
UnwrappedUnionType.prototype.compare = function(val1, val2) {
  var index1 = this._getIndex(val1);
  var index2 = this._getIndex(val2);
  if (index1 === void 0) {
    throwInvalidError(val1, this);
  } else if (index2 === void 0) {
    throwInvalidError(val2, this);
  } else if (index1 === index2) {
    return this.types[index1].compare(val1, val2);
  } else {
    return utils$e.compare(index1, index2);
  }
};
UnwrappedUnionType.prototype.typeName = "union:unwrapped";
UnwrappedUnionType.prototype.random = function() {
  var index2 = RANDOM.nextInt(this.types.length);
  return this.types[index2].random();
};
function WrappedUnionType(schema, opts) {
  UnionType.call(this, schema, opts);
  Object.freeze(this);
}
util$3.inherits(WrappedUnionType, UnionType);
WrappedUnionType.prototype._check = function(val, flags, hook, path3) {
  var b = false;
  if (val === null) {
    b = this._branchIndices["null"] !== void 0;
  } else if (typeof val == "object") {
    var keys2 = Object.keys(val);
    if (keys2.length === 1) {
      var name2 = keys2[0];
      var index2 = this._branchIndices[name2];
      if (index2 !== void 0) {
        if (hook) {
          path3.push(name2);
          b = this.types[index2]._check(val[name2], flags, hook, path3);
          path3.pop();
          return b;
        } else {
          return this.types[index2]._check(val[name2], flags);
        }
      }
    }
  }
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
WrappedUnionType.prototype._read = function(tap) {
  var type = this.types[tap.readLong()];
  if (!type) {
    throw new Error(f$3("invalid union index"));
  }
  var Branch = type._branchConstructor;
  if (Branch === null) {
    return null;
  } else {
    return new Branch(type._read(tap));
  }
};
WrappedUnionType.prototype._write = function(tap, val) {
  var index2, keys2, name2;
  if (val === null) {
    index2 = this._branchIndices["null"];
    if (index2 === void 0) {
      throwInvalidError(val, this);
    }
    tap.writeLong(index2);
  } else {
    keys2 = Object.keys(val);
    if (keys2.length === 1) {
      name2 = keys2[0];
      index2 = this._branchIndices[name2];
    }
    if (index2 === void 0) {
      throwInvalidError(val, this);
    }
    tap.writeLong(index2);
    this.types[index2]._write(tap, val[name2]);
  }
};
WrappedUnionType.prototype._update = function(resolver, type, opts) {
  var i, l, typeResolver, Branch;
  for (i = 0, l = this.types.length; i < l; i++) {
    try {
      typeResolver = this.types[i].createResolver(type, opts);
    } catch (err) {
      continue;
    }
    Branch = this.types[i]._branchConstructor;
    if (Branch) {
      resolver._read = function(tap) {
        return new Branch(typeResolver._read(tap));
      };
    } else {
      resolver._read = function() {
        return null;
      };
    }
    return;
  }
};
WrappedUnionType.prototype._copy = function(val, opts) {
  var wrap2 = opts && opts.wrap | 0;
  if (wrap2 === 2) {
    var firstType = this.types[0];
    if (val === null && firstType.typeName === "null") {
      return null;
    }
    return new firstType._branchConstructor(firstType._copy(val, opts));
  }
  if (val === null && this._branchIndices["null"] !== void 0) {
    return null;
  }
  var i, l, obj2;
  if (typeof val == "object") {
    var keys2 = Object.keys(val);
    if (keys2.length === 1) {
      var name2 = keys2[0];
      i = this._branchIndices[name2];
      if (i === void 0 && opts.qualifyNames) {
        var j, type;
        for (j = 0, l = this.types.length; j < l; j++) {
          type = this.types[j];
          if (type.name && name2 === unqualify(type.name)) {
            i = j;
            break;
          }
        }
      }
      if (i !== void 0) {
        obj2 = this.types[i]._copy(val[name2], opts);
      }
    }
  }
  if (wrap2 === 1 && obj2 === void 0) {
    i = 0;
    l = this.types.length;
    while (i < l && obj2 === void 0) {
      try {
        obj2 = this.types[i]._copy(val, opts);
      } catch (err) {
        i++;
      }
    }
  }
  if (obj2 !== void 0) {
    return wrap2 === 3 ? obj2 : new this.types[i]._branchConstructor(obj2);
  }
  throwInvalidError(val, this);
};
WrappedUnionType.prototype.compare = function(val1, val2) {
  var name1 = val1 === null ? "null" : Object.keys(val1)[0];
  var name2 = val2 === null ? "null" : Object.keys(val2)[0];
  var index2 = this._branchIndices[name1];
  if (name1 === name2) {
    return name1 === "null" ? 0 : this.types[index2].compare(val1[name1], val2[name1]);
  } else {
    return utils$e.compare(index2, this._branchIndices[name2]);
  }
};
WrappedUnionType.prototype.typeName = "union:wrapped";
WrappedUnionType.prototype.random = function() {
  var index2 = RANDOM.nextInt(this.types.length);
  var type = this.types[index2];
  var Branch = type._branchConstructor;
  if (!Branch) {
    return null;
  }
  return new Branch(type.random());
};
function EnumType(schema, opts) {
  Type$1.call(this, schema, opts);
  if (!Array.isArray(schema.symbols) || !schema.symbols.length) {
    throw new Error(f$3("invalid enum symbols: %j", schema.symbols));
  }
  this.symbols = Object.freeze(schema.symbols.slice());
  this._indices = {};
  this.symbols.forEach(function(symbol, i) {
    if (!isValidName$1(symbol)) {
      throw new Error(f$3("invalid %s symbol: %j", this, symbol));
    }
    if (this._indices[symbol] !== void 0) {
      throw new Error(f$3("duplicate %s symbol: %j", this, symbol));
    }
    this._indices[symbol] = i;
  }, this);
  this._branchConstructor = this._createBranchConstructor();
  Object.freeze(this);
}
util$3.inherits(EnumType, Type$1);
EnumType.prototype._check = function(val, flags, hook) {
  var b = this._indices[val] !== void 0;
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
EnumType.prototype._read = function(tap) {
  var index2 = tap.readLong();
  var symbol = this.symbols[index2];
  if (symbol === void 0) {
    throw new Error(f$3("invalid %s enum index: %s", this.name, index2));
  }
  return symbol;
};
EnumType.prototype._skip = function(tap) {
  tap.skipLong();
};
EnumType.prototype._write = function(tap, val) {
  var index2 = this._indices[val];
  if (index2 === void 0) {
    throwInvalidError(val, this);
  }
  tap.writeLong(index2);
};
EnumType.prototype._match = function(tap1, tap2) {
  return tap1.matchLong(tap2);
};
EnumType.prototype.compare = function(val1, val2) {
  return utils$e.compare(this._indices[val1], this._indices[val2]);
};
EnumType.prototype._update = function(resolver, type) {
  var symbols = this.symbols;
  if (type.typeName === "enum" && (!type.name || ~getAliases(this).indexOf(type.name)) && type.symbols.every(function(s2) {
    return ~symbols.indexOf(s2);
  })) {
    resolver.symbols = type.symbols;
    resolver._read = type._read;
  }
};
EnumType.prototype._copy = function(val) {
  this._check(val, void 0, throwInvalidError);
  return val;
};
EnumType.prototype._deref = function(schema) {
  schema.symbols = this.symbols;
};
EnumType.prototype.getSymbols = function() {
  return this.symbols;
};
EnumType.prototype.typeName = "enum";
EnumType.prototype.random = function() {
  return RANDOM.choice(this.symbols);
};
function FixedType(schema, opts) {
  Type$1.call(this, schema, opts);
  if (schema.size !== (schema.size | 0) || schema.size < 1) {
    throw new Error(f$3("invalid %s size", this.branchName));
  }
  this.size = schema.size | 0;
  this._branchConstructor = this._createBranchConstructor();
  Object.freeze(this);
}
util$3.inherits(FixedType, Type$1);
FixedType.prototype._check = function(val, flags, hook) {
  var b = Buffer.isBuffer(val) && val.length === this.size;
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
FixedType.prototype._read = function(tap) {
  return tap.readFixed(this.size);
};
FixedType.prototype._skip = function(tap) {
  tap.skipFixed(this.size);
};
FixedType.prototype._write = function(tap, val) {
  if (!Buffer.isBuffer(val) || val.length !== this.size) {
    throwInvalidError(val, this);
  }
  tap.writeFixed(val, this.size);
};
FixedType.prototype._match = function(tap1, tap2) {
  return tap1.matchFixed(tap2, this.size);
};
FixedType.prototype.compare = Buffer.compare;
FixedType.prototype._update = function(resolver, type) {
  if (type.typeName === "fixed" && this.size === type.size && (!type.name || ~getAliases(this).indexOf(type.name))) {
    resolver.size = this.size;
    resolver._read = this._read;
  }
};
FixedType.prototype._copy = BytesType.prototype._copy;
FixedType.prototype._deref = function(schema) {
  schema.size = this.size;
};
FixedType.prototype.getSize = function() {
  return this.size;
};
FixedType.prototype.typeName = "fixed";
FixedType.prototype.random = function() {
  return RANDOM.nextBuffer(this.size);
};
function MapType(schema, opts) {
  Type$1.call(this);
  if (!schema.values) {
    throw new Error(f$3("missing map values: %j", schema));
  }
  this.valuesType = Type$1.forSchema(schema.values, opts);
  this._branchConstructor = this._createBranchConstructor();
  Object.freeze(this);
}
util$3.inherits(MapType, Type$1);
MapType.prototype._check = function(val, flags, hook, path3) {
  if (!val || typeof val != "object" || Array.isArray(val)) {
    if (hook) {
      hook(val, this);
    }
    return false;
  }
  var keys2 = Object.keys(val);
  var b = true;
  var i, l, j, key3;
  if (hook) {
    j = path3.length;
    path3.push("");
    for (i = 0, l = keys2.length; i < l; i++) {
      key3 = path3[j] = keys2[i];
      if (!this.valuesType._check(val[key3], flags, hook, path3)) {
        b = false;
      }
    }
    path3.pop();
  } else {
    for (i = 0, l = keys2.length; i < l; i++) {
      if (!this.valuesType._check(val[keys2[i]], flags)) {
        return false;
      }
    }
  }
  return b;
};
MapType.prototype._read = function(tap) {
  var values = this.valuesType;
  var val = {};
  var n;
  while (n = readArraySize(tap)) {
    while (n--) {
      var key3 = tap.readString();
      val[key3] = values._read(tap);
    }
  }
  return val;
};
MapType.prototype._skip = function(tap) {
  var values = this.valuesType;
  var len, n;
  while (n = tap.readLong()) {
    if (n < 0) {
      len = tap.readLong();
      tap.pos += len;
    } else {
      while (n--) {
        tap.skipString();
        values._skip(tap);
      }
    }
  }
};
MapType.prototype._write = function(tap, val) {
  if (!val || typeof val != "object" || Array.isArray(val)) {
    throwInvalidError(val, this);
  }
  var values = this.valuesType;
  var keys2 = Object.keys(val);
  var n = keys2.length;
  var i, key3;
  if (n) {
    tap.writeLong(n);
    for (i = 0; i < n; i++) {
      key3 = keys2[i];
      tap.writeString(key3);
      values._write(tap, val[key3]);
    }
  }
  tap.writeLong(0);
};
MapType.prototype._match = function() {
  throw new Error("maps cannot be compared");
};
MapType.prototype._update = function(rsv, type, opts) {
  if (type.typeName === "map") {
    rsv.valuesType = this.valuesType.createResolver(type.valuesType, opts);
    rsv._read = this._read;
  }
};
MapType.prototype._copy = function(val, opts) {
  if (val && typeof val == "object" && !Array.isArray(val)) {
    var values = this.valuesType;
    var keys2 = Object.keys(val);
    var i, l, key3;
    var copy = {};
    for (i = 0, l = keys2.length; i < l; i++) {
      key3 = keys2[i];
      copy[key3] = values._copy(val[key3], opts);
    }
    return copy;
  }
  throwInvalidError(val, this);
};
MapType.prototype.compare = MapType.prototype._match;
MapType.prototype.typeName = "map";
MapType.prototype.getValuesType = function() {
  return this.valuesType;
};
MapType.prototype.random = function() {
  var val = {};
  var i, l;
  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
    val[RANDOM.nextString(RANDOM.nextInt(20))] = this.valuesType.random();
  }
  return val;
};
MapType.prototype._deref = function(schema, opts) {
  schema.values = this.valuesType._attrs(opts);
};
function ArrayType(schema, opts) {
  Type$1.call(this);
  if (!schema.items) {
    throw new Error(f$3("missing array items: %j", schema));
  }
  this.itemsType = Type$1.forSchema(schema.items, opts);
  this._branchConstructor = this._createBranchConstructor();
  Object.freeze(this);
}
util$3.inherits(ArrayType, Type$1);
ArrayType.prototype._check = function(val, flags, hook, path3) {
  if (!Array.isArray(val)) {
    if (hook) {
      hook(val, this);
    }
    return false;
  }
  var b = true;
  var i, l, j;
  if (hook) {
    j = path3.length;
    path3.push("");
    for (i = 0, l = val.length; i < l; i++) {
      path3[j] = "" + i;
      if (!this.itemsType._check(val[i], flags, hook, path3)) {
        b = false;
      }
    }
    path3.pop();
  } else {
    for (i = 0, l = val.length; i < l; i++) {
      if (!this.itemsType._check(val[i], flags)) {
        return false;
      }
    }
  }
  return b;
};
ArrayType.prototype._read = function(tap) {
  var items = this.itemsType;
  var val = [];
  var n;
  while (n = tap.readLong()) {
    if (n < 0) {
      n = -n;
      tap.skipLong();
    }
    while (n--) {
      val.push(items._read(tap));
    }
  }
  return val;
};
ArrayType.prototype._skip = function(tap) {
  var len, n;
  while (n = tap.readLong()) {
    if (n < 0) {
      len = tap.readLong();
      tap.pos += len;
    } else {
      while (n--) {
        this.itemsType._skip(tap);
      }
    }
  }
};
ArrayType.prototype._write = function(tap, val) {
  if (!Array.isArray(val)) {
    throwInvalidError(val, this);
  }
  var n = val.length;
  var i;
  if (n) {
    tap.writeLong(n);
    for (i = 0; i < n; i++) {
      this.itemsType._write(tap, val[i]);
    }
  }
  tap.writeLong(0);
};
ArrayType.prototype._match = function(tap1, tap2) {
  var n1 = tap1.readLong();
  var n2 = tap2.readLong();
  var f2;
  while (n1 && n2) {
    f2 = this.itemsType._match(tap1, tap2);
    if (f2) {
      return f2;
    }
    if (!--n1) {
      n1 = readArraySize(tap1);
    }
    if (!--n2) {
      n2 = readArraySize(tap2);
    }
  }
  return utils$e.compare(n1, n2);
};
ArrayType.prototype._update = function(resolver, type, opts) {
  if (type.typeName === "array") {
    resolver.itemsType = this.itemsType.createResolver(type.itemsType, opts);
    resolver._read = this._read;
  }
};
ArrayType.prototype._copy = function(val, opts) {
  if (!Array.isArray(val)) {
    throwInvalidError(val, this);
  }
  var items = new Array(val.length);
  var i, l;
  for (i = 0, l = val.length; i < l; i++) {
    items[i] = this.itemsType._copy(val[i], opts);
  }
  return items;
};
ArrayType.prototype._deref = function(schema, opts) {
  schema.items = this.itemsType._attrs(opts);
};
ArrayType.prototype.compare = function(val1, val2) {
  var n1 = val1.length;
  var n2 = val2.length;
  var i, l, f2;
  for (i = 0, l = Math.min(n1, n2); i < l; i++) {
    if (f2 = this.itemsType.compare(val1[i], val2[i])) {
      return f2;
    }
  }
  return utils$e.compare(n1, n2);
};
ArrayType.prototype.getItemsType = function() {
  return this.itemsType;
};
ArrayType.prototype.typeName = "array";
ArrayType.prototype.random = function() {
  var arr = [];
  var i, l;
  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
    arr.push(this.itemsType.random());
  }
  return arr;
};
function RecordType(schema, opts) {
  opts = opts || {};
  var namespace = opts.namespace;
  if (schema.namespace !== void 0) {
    opts.namespace = schema.namespace;
  } else if (schema.name) {
    var match = /^(.*)\.[^.]+$/.exec(schema.name);
    if (match) {
      opts.namespace = match[1];
    }
  }
  Type$1.call(this, schema, opts);
  if (!Array.isArray(schema.fields)) {
    throw new Error(f$3("non-array record fields: %j", schema.fields));
  }
  if (utils$e.hasDuplicates(schema.fields, function(f2) {
    return f2.name;
  })) {
    throw new Error(f$3("duplicate field name: %j", schema.fields));
  }
  this._fieldsByName = {};
  this.fields = Object.freeze(schema.fields.map(function(f2) {
    var field = new Field(f2, opts);
    this._fieldsByName[field.name] = field;
    return field;
  }, this));
  this._branchConstructor = this._createBranchConstructor();
  this._isError = schema.type === "error";
  this.recordConstructor = this._createConstructor(opts.errorStackTraces);
  this._read = this._createReader();
  this._skip = this._createSkipper();
  this._write = this._createWriter();
  this._check = this._createChecker();
  opts.namespace = namespace;
  Object.freeze(this);
}
util$3.inherits(RecordType, Type$1);
RecordType.prototype._getConstructorName = function() {
  return this.name ? unqualify(this.name) : this._isError ? "Error$" : "Record$";
};
RecordType.prototype._createConstructor = function(errorStackTraces) {
  var ds = {};
  var i, l, field, name2, defaultValue, hasDefault, stackField;
  for (i = 0, l = this.fields.length; i < l; i++) {
    field = this.fields[i];
    defaultValue = field.defaultValue;
    hasDefault = defaultValue() !== void 0;
    name2 = field.name;
    if (errorStackTraces && this._isError && name2 === "stack" && Type$1.isType(field.type, "string") && !hasDefault) {
      stackField = field;
    }
    if (hasDefault) {
      ds[i] = defaultValue;
    }
  }
  var self2 = this;
  function ConstructorFunction(outerArgs) {
    const constructorName = self2._getConstructorName();
    var innerFunction = {
      [constructorName]: function(...innerArgs) {
        for (var i2 = 0, l2 = self2.fields.length; i2 < l2; i2++) {
          let f2 = self2.fields[i2];
          if (f2.defaultValue() === void 0) {
            this[f2.name] = innerArgs[i2];
          } else {
            if (innerArgs[i2] === void 0) {
              this[f2.name] = outerArgs[i2]();
            } else {
              this[f2.name] = innerArgs[i2];
            }
          }
        }
        if (stackField) {
          if (this.stack === void 0) {
            if (typeof Error.captureStackTrace === "function") {
              Error.captureStackTrace(this, this.constructor);
            } else {
              this.stack = Error().stack;
            }
          }
        }
      }
    }[constructorName];
    return innerFunction;
  }
  var Record = ConstructorFunction(ds);
  Record.getType = function() {
    return self2;
  };
  Record.type = self2;
  if (this._isError) {
    util$3.inherits(Record, Error);
    Record.prototype.name = this._getConstructorName();
  }
  Record.prototype.clone = function(o) {
    return self2.clone(this, o);
  };
  Record.prototype.compare = function(v) {
    return self2.compare(this, v);
  };
  Record.prototype.isValid = function(o) {
    return self2.isValid(this, o);
  };
  Record.prototype.toBuffer = function() {
    return self2.toBuffer(this);
  };
  Record.prototype.toString = function() {
    return self2.toString(this);
  };
  Record.prototype.wrap = function() {
    return self2.wrap(this);
  };
  Record.prototype.wrapped = Record.prototype.wrap;
  return Record;
};
RecordType.prototype._createChecker = function() {
  const values = [];
  this.fields.forEach((field) => {
    values.push(field.type);
  });
  var self2 = this;
  function ConstructorFunction(outerArgs) {
    var constructorName = self2._getConstructorName();
    var innerFunction = {
      [constructorName]: function(v, f2, h, p) {
        if (v === null || typeof v !== "object" || f2 && !this._checkFields(v)) {
          if (h) {
            h(v, this);
          }
          return false;
        }
        const vArray = [];
        if (!self2.fields.length) {
          return true;
        } else {
          for (var i = 0, l = self2.fields.length; i < l; i++) {
            let f3 = self2.fields[i];
            if (f3.defaultValue() !== void 0) {
              vArray.push(v[f3.name]);
            }
          }
        }
        if (h) {
          var b = 1;
          var j = p.length;
          p.push("");
          for (var i = 0, l = self2.fields.length; i < l; i++) {
            let f3 = self2.fields[i];
            p[j] = f3.name;
            b &= f3.defaultValue() === void 0 ? outerArgs[i]._check(v[f3.name], f3, h, p) : vArray[i] === void 0 || outerArgs[i]._check(vArray[i], f3, h, p);
          }
          p.pop();
          return !!b;
        } else {
          return self2.fields.reduce((prevVal, currentVal, i2) => {
            return prevVal && (currentVal.defaultValue() === void 0 ? outerArgs[i2]._check(v[currentVal.name]) : vArray[i2] === void 0 || outerArgs[i2]._check(vArray[i2], f2));
          }, true);
        }
      }
    }[constructorName];
    return innerFunction;
  }
  return ConstructorFunction(values);
};
RecordType.prototype._createReader = function() {
  var values = [this.recordConstructor];
  var i, l;
  for (i = 0, l = this.fields.length; i < l; i++) {
    values.push(this.fields[i].type);
  }
  var self2 = this;
  function ConstructorFunction(outerArgs) {
    var constructorName = self2._getConstructorName();
    var innerFunction = {
      [constructorName]: function(t) {
        return new outerArgs[0](...outerArgs.slice(1).map((ftype) => ftype["_read"](t)));
      }
    }[constructorName];
    return innerFunction;
  }
  return ConstructorFunction(values);
};
RecordType.prototype._createSkipper = function() {
  var values = [];
  this.fields.forEach((field) => {
    values.push(field.type);
  });
  var self2 = this;
  function ConstructorFunction(outerArgs) {
    var constructorName = self2._getConstructorName();
    var innerFunction = {
      [constructorName]: function(t) {
        outerArgs.forEach((arg) => arg._skip(t));
      }
    }[constructorName];
    return innerFunction;
  }
  return ConstructorFunction(values);
};
RecordType.prototype._createWriter = function() {
  var values = [];
  var dValues = {};
  this.fields.forEach((field, i) => {
    values.push(field.type);
    if (field.defaultValue() !== void 0) {
      dValues[i] = field.type.toBuffer(field.defaultValue()).toString("binary");
    }
  });
  var self2 = this;
  function ConstructorFunction(vv, dv) {
    var constructorName = self2._getConstructorName();
    var innerFunction = {
      [constructorName]: function(t, v) {
        for (var i = 0, l = self2.fields.length; i < l; i++) {
          let f2 = self2.fields[i];
          if (f2.defaultValue() === void 0) {
            vv[i]._write(t, v[f2.name]);
          } else {
            if (v[f2.name] === void 0) {
              t.writeBinary(dv[i], dv[i].length);
            } else {
              vv[i]._write(t, v[f2.name]);
            }
          }
        }
      }
    }[constructorName];
    return innerFunction;
  }
  return ConstructorFunction(values, dValues);
};
RecordType.prototype._update = function(resolver, type, opts) {
  if (type.name && !~getAliases(this).indexOf(type.name)) {
    throw new Error(f$3("no alias found for %s", type.name));
  }
  var rFields = this.fields;
  var wFields = type.fields;
  var wFieldsMap = utils$e.toMap(wFields, function(f2) {
    return f2.name;
  });
  var resolvers = {};
  var i, j, field, name2, names2, matches, fieldResolver;
  for (i = 0; i < rFields.length; i++) {
    field = rFields[i];
    names2 = getAliases(field);
    matches = [];
    for (j = 0; j < names2.length; j++) {
      name2 = names2[j];
      if (wFieldsMap[name2]) {
        matches.push(name2);
      }
    }
    if (matches.length > 1) {
      throw new Error(
        f$3("ambiguous aliasing for %s.%s (%s)", type.name, field.name, matches)
      );
    }
    if (!matches.length) {
      if (field.defaultValue() === void 0) {
        throw new Error(
          f$3("no matching field for default-less %s.%s", type.name, field.name)
        );
      }
    } else {
      name2 = matches[0];
      fieldResolver = {
        resolver: field.type.createResolver(wFieldsMap[name2].type, opts),
        name: "_" + field.name
      };
      if (!resolvers[name2]) {
        resolvers[name2] = [fieldResolver];
      } else {
        resolvers[name2].push(fieldResolver);
      }
    }
  }
  var self2 = this;
  function ConstructorFunction() {
    var constructorName = self2._getConstructorName();
    var innerFunction = {
      [constructorName]: function(t, b) {
        if (b)
          return;
        var innerArgs = [];
        for (i2 = 0; i2 < rFields.length; i2++) {
          field = rFields[i2];
          names2 = getAliases(field);
          matches = [];
          for (j2 = 0; j2 < names2.length; j2++) {
            name2 = names2[j2];
            if (wFieldsMap[name2]) {
              matches.push(name2);
            }
          }
          if (!matches.length) {
            innerArgs.push(void 0);
          }
        }
        for (var i2 = 0; i2 < wFields.length; i2++) {
          let wf = type.fields[i2];
          name2 = wf.name;
          if (resolvers[name2] === void 0) {
            wf.type._skip(t);
          } else {
            var j2 = resolvers[name2].length;
            while (j2--) {
              innerArgs.unshift(j2 ? resolvers[name2][j2].resolver._peek(t) : resolvers[name2][j2].resolver._read(t));
            }
          }
        }
        return new self2.recordConstructor(...innerArgs);
      }
    }[constructorName];
    return innerFunction;
  }
  resolver._read = ConstructorFunction();
};
RecordType.prototype._match = function(tap1, tap2) {
  var fields = this.fields;
  var i, l, field, order, type;
  for (i = 0, l = fields.length; i < l; i++) {
    field = fields[i];
    order = field._order;
    type = field.type;
    if (order) {
      order *= type._match(tap1, tap2);
      if (order) {
        return order;
      }
    } else {
      type._skip(tap1);
      type._skip(tap2);
    }
  }
  return 0;
};
RecordType.prototype._checkFields = function(obj2) {
  var keys2 = Object.keys(obj2);
  var i, l;
  for (i = 0, l = keys2.length; i < l; i++) {
    if (!this._fieldsByName[keys2[i]]) {
      return false;
    }
  }
  return true;
};
RecordType.prototype._copy = function(val, opts) {
  var hook = opts && opts.fieldHook;
  var values = [void 0];
  var i, l, field, value;
  for (i = 0, l = this.fields.length; i < l; i++) {
    field = this.fields[i];
    value = val[field.name];
    if (value === void 0 && field.hasOwnProperty("defaultValue")) {
      value = field.defaultValue();
    }
    if (opts && !opts.skip || value !== void 0) {
      value = field.type._copy(value, opts);
    }
    if (hook) {
      value = hook(field, value, this);
    }
    values.push(value);
  }
  var Record = this.recordConstructor;
  return new (Record.bind.apply(Record, values))();
};
RecordType.prototype._deref = function(schema, opts) {
  schema.fields = this.fields.map(function(field) {
    var fieldType = field.type;
    var fieldSchema = {
      name: field.name,
      type: fieldType._attrs(opts)
    };
    if (opts.exportAttrs) {
      var val = field.defaultValue();
      if (val !== void 0) {
        fieldSchema["default"] = fieldType._copy(val, { coerce: 3, wrap: 3 });
      }
      var fieldOrder = field.order;
      if (fieldOrder !== "ascending") {
        fieldSchema.order = fieldOrder;
      }
      var fieldAliases = field.aliases;
      if (fieldAliases.length) {
        fieldSchema.aliases = fieldAliases;
      }
      var fieldDoc = field.doc;
      if (fieldDoc !== void 0) {
        fieldSchema.doc = fieldDoc;
      }
    }
    return fieldSchema;
  });
};
RecordType.prototype.compare = function(val1, val2) {
  var fields = this.fields;
  var i, l, field, name2, order, type;
  for (i = 0, l = fields.length; i < l; i++) {
    field = fields[i];
    name2 = field.name;
    order = field._order;
    type = field.type;
    if (order) {
      order *= type.compare(val1[name2], val2[name2]);
      if (order) {
        return order;
      }
    }
  }
  return 0;
};
RecordType.prototype.random = function() {
  var fields = this.fields.map(function(f2) {
    return f2.type.random();
  });
  fields.unshift(void 0);
  var Record = this.recordConstructor;
  return new (Record.bind.apply(Record, fields))();
};
RecordType.prototype.field = function(name2) {
  return this._fieldsByName[name2];
};
RecordType.prototype.getField = RecordType.prototype.field;
RecordType.prototype.getFields = function() {
  return this.fields;
};
RecordType.prototype.getRecordConstructor = function() {
  return this.recordConstructor;
};
Object.defineProperty(RecordType.prototype, "typeName", {
  enumerable: true,
  get: function() {
    return this._isError ? "error" : "record";
  }
});
function LogicalType(schema, opts) {
  this._logicalTypeName = schema.logicalType;
  Type$1.call(this);
  LOGICAL_TYPE = this;
  try {
    this._underlyingType = Type$1.forSchema(schema, opts);
  } finally {
    LOGICAL_TYPE = null;
    var l = UNDERLYING_TYPES.length;
    if (l && UNDERLYING_TYPES[l - 1][0] === this) {
      UNDERLYING_TYPES.pop();
    }
  }
  if (Type$1.isType(this.underlyingType, "union")) {
    this._branchConstructor = this.underlyingType._branchConstructor;
  } else {
    this._branchConstructor = this.underlyingType._createBranchConstructor();
  }
}
util$3.inherits(LogicalType, Type$1);
Object.defineProperty(LogicalType.prototype, "typeName", {
  enumerable: true,
  get: function() {
    return "logical:" + this._logicalTypeName;
  }
});
Object.defineProperty(LogicalType.prototype, "underlyingType", {
  enumerable: true,
  get: function() {
    if (this._underlyingType) {
      return this._underlyingType;
    }
    var i, l, arr;
    for (i = 0, l = UNDERLYING_TYPES.length; i < l; i++) {
      arr = UNDERLYING_TYPES[i];
      if (arr[0] === this) {
        return arr[1];
      }
    }
  }
});
LogicalType.prototype.getUnderlyingType = function() {
  return this.underlyingType;
};
LogicalType.prototype._read = function(tap) {
  return this._fromValue(this.underlyingType._read(tap));
};
LogicalType.prototype._write = function(tap, any2) {
  this.underlyingType._write(tap, this._toValue(any2));
};
LogicalType.prototype._check = function(any2, flags, hook, path3) {
  try {
    var val = this._toValue(any2);
  } catch (err) {
  }
  if (val === void 0) {
    if (hook) {
      hook(any2, this);
    }
    return false;
  }
  return this.underlyingType._check(val, flags, hook, path3);
};
LogicalType.prototype._copy = function(any2, opts) {
  var type = this.underlyingType;
  switch (opts && opts.coerce) {
    case 3:
      return type._copy(this._toValue(any2), opts);
    case 2:
      return this._fromValue(type._copy(any2, opts));
    default:
      return this._fromValue(type._copy(this._toValue(any2), opts));
  }
};
LogicalType.prototype._update = function(resolver, type, opts) {
  var _fromValue = this._resolve(type, opts);
  if (_fromValue) {
    resolver._read = function(tap) {
      return _fromValue(type._read(tap));
    };
  }
};
LogicalType.prototype.compare = function(obj1, obj2) {
  var val1 = this._toValue(obj1);
  var val2 = this._toValue(obj2);
  return this.underlyingType.compare(val1, val2);
};
LogicalType.prototype.random = function() {
  return this._fromValue(this.underlyingType.random());
};
LogicalType.prototype._deref = function(schema, opts) {
  var type = this.underlyingType;
  var isVisited = type.name !== void 0 && opts.derefed[type.name];
  schema = type._attrs(opts);
  if (!isVisited && opts.exportAttrs) {
    if (typeof schema == "string") {
      schema = { type: schema };
    }
    schema.logicalType = this._logicalTypeName;
    this._export(schema);
  }
  return schema;
};
LogicalType.prototype._skip = function(tap) {
  this.underlyingType._skip(tap);
};
LogicalType.prototype._export = function() {
};
LogicalType.prototype._fromValue = utils$e.abstractFunction;
LogicalType.prototype._toValue = utils$e.abstractFunction;
LogicalType.prototype._resolve = utils$e.abstractFunction;
function AbstractLongType(noUnpack) {
  this._concreteTypeName = "long";
  PrimitiveType.call(this, true);
  this._noUnpack = !!noUnpack;
}
util$3.inherits(AbstractLongType, LongType);
AbstractLongType.prototype.typeName = "abstract:long";
AbstractLongType.prototype._check = function(val, flags, hook) {
  var b = this._isValid(val);
  if (!b && hook) {
    hook(val, this);
  }
  return b;
};
AbstractLongType.prototype._read = function(tap) {
  var buf, pos;
  if (this._noUnpack) {
    pos = tap.pos;
    tap.skipLong();
    buf = tap.buf.slice(pos, tap.pos);
  } else {
    buf = tap.unpackLongBytes(tap);
  }
  if (tap.isValid()) {
    return this._fromBuffer(buf);
  }
};
AbstractLongType.prototype._write = function(tap, val) {
  if (!this._isValid(val)) {
    throwInvalidError(val, this);
  }
  var buf = this._toBuffer(val);
  if (this._noUnpack) {
    tap.writeFixed(buf);
  } else {
    tap.packLongBytes(buf);
  }
};
AbstractLongType.prototype._copy = function(val, opts) {
  switch (opts && opts.coerce) {
    case 3:
      return this._toJSON(val);
    case 2:
      return this._fromJSON(val);
    default:
      return this._fromJSON(this._toJSON(val));
  }
};
AbstractLongType.prototype._deref = function() {
  return "long";
};
AbstractLongType.prototype._update = function(resolver, type) {
  var self2 = this;
  switch (type.typeName) {
    case "int":
      resolver._read = function(tap) {
        return self2._fromJSON(type._read(tap));
      };
      break;
    case "long":
      resolver._read = function(tap) {
        return self2._read(tap);
      };
  }
};
AbstractLongType.prototype.random = function() {
  return this._fromJSON(LongType.prototype.random());
};
AbstractLongType.prototype._fromBuffer = utils$e.abstractFunction;
AbstractLongType.prototype._toBuffer = utils$e.abstractFunction;
AbstractLongType.prototype._fromJSON = utils$e.abstractFunction;
AbstractLongType.prototype._toJSON = utils$e.abstractFunction;
AbstractLongType.prototype._isValid = utils$e.abstractFunction;
AbstractLongType.prototype.compare = utils$e.abstractFunction;
function Field(schema, opts) {
  var name2 = schema.name;
  if (typeof name2 != "string" || !isValidName$1(name2)) {
    throw new Error(f$3("invalid field name: %s", name2));
  }
  this.name = name2;
  this.type = Type$1.forSchema(schema.type, opts);
  this.aliases = schema.aliases || [];
  this.doc = schema.doc !== void 0 ? "" + schema.doc : void 0;
  this._order = function(order) {
    switch (order) {
      case "ascending":
        return 1;
      case "descending":
        return -1;
      case "ignore":
        return 0;
      default:
        throw new Error(f$3("invalid order: %j", order));
    }
  }(schema.order === void 0 ? "ascending" : schema.order);
  var value = schema["default"];
  if (value !== void 0) {
    var type = this.type;
    var val = type._copy(value, { coerce: 2, wrap: 2 });
    if (isPrimitive(type.typeName) && type.typeName !== "bytes") {
      this.defaultValue = function() {
        return val;
      };
    } else {
      this.defaultValue = function() {
        return type._copy(val);
      };
    }
  }
  Object.freeze(this);
}
Field.prototype.defaultValue = function() {
};
Object.defineProperty(Field.prototype, "order", {
  enumerable: true,
  get: function() {
    return ["descending", "ignore", "ascending"][this._order + 1];
  }
});
Field.prototype.getAliases = function() {
  return this.aliases;
};
Field.prototype.getDefault = Field.prototype.defaultValue;
Field.prototype.getName = function() {
  return this.name;
};
Field.prototype.getOrder = function() {
  return this.order;
};
Field.prototype.getType = function() {
  return this.type;
};
function Resolver$1(readerType) {
  this._readerType = readerType;
  this._read = null;
  this.itemsType = null;
  this.size = 0;
  this.symbols = null;
  this.valuesType = null;
}
Resolver$1.prototype._peek = Type$1.prototype._peek;
Resolver$1.prototype.inspect = function() {
  return "<Resolver>";
};
function Hash() {
  this.str = void 0;
}
function readValue(type, tap, resolver, lazy) {
  if (resolver) {
    if (resolver._readerType !== type) {
      throw new Error("invalid resolver");
    }
    return resolver._read(tap, lazy);
  } else {
    return type._read(tap);
  }
}
function unqualify(name2) {
  var parts = name2.split(".");
  return parts[parts.length - 1];
}
function qualify(name2, namespace) {
  if (~name2.indexOf(".")) {
    name2 = name2.replace(/^\./, "");
  } else if (namespace) {
    name2 = namespace + "." + name2;
  }
  name2.split(".").forEach(function(part) {
    if (!isValidName$1(part)) {
      throw new Error(f$3("invalid name: %j", name2));
    }
  });
  var tail = unqualify(name2);
  return isPrimitive(tail) ? tail : name2;
}
function getAliases(obj2) {
  var names2 = {};
  if (obj2.name) {
    names2[obj2.name] = true;
  }
  var aliases = obj2.aliases;
  var i, l;
  for (i = 0, l = aliases.length; i < l; i++) {
    names2[aliases[i]] = true;
  }
  return Object.keys(names2);
}
function isPrimitive(typeName) {
  var type = TYPES[typeName];
  return type && type.prototype instanceof PrimitiveType;
}
function getClassName(typeName) {
  if (typeName === "error") {
    typeName = "record";
  } else {
    var match = /^([^:]+):(.*)$/.exec(typeName);
    if (match) {
      if (match[1] === "union") {
        typeName = match[2] + "Union";
      } else {
        typeName = match[1];
      }
    }
  }
  return utils$e.capitalize(typeName) + "Type";
}
function readArraySize(tap) {
  var n = tap.readLong();
  if (n < 0) {
    n = -n;
    tap.skipLong();
  }
  return n;
}
function isSafeLong(n) {
  return n >= -9007199254740990 && n <= 9007199254740990;
}
function isJsonBuffer(obj2) {
  return obj2 && obj2.type === "Buffer" && Array.isArray(obj2.data);
}
function isValidName$1(str) {
  return NAME_PATTERN.test(str);
}
function throwInvalidError(val, type) {
  throw new Error(f$3("invalid %s: %j", type, val));
}
function getTypeBucket(type) {
  var typeName = type.typeName;
  switch (typeName) {
    case "double":
    case "float":
    case "int":
    case "long":
      return "number";
    case "bytes":
    case "fixed":
      return "buffer";
    case "enum":
      return "string";
    case "map":
    case "error":
    case "record":
      return "object";
    default:
      return typeName;
  }
}
function getValueBucket(val) {
  if (val === null) {
    return "null";
  }
  var bucket = typeof val;
  if (bucket === "object") {
    if (Array.isArray(val)) {
      return "array";
    } else if (Buffer.isBuffer(val)) {
      return "buffer";
    }
  }
  return bucket;
}
function isAmbiguous(types2) {
  var buckets = {};
  var i, l, bucket, type;
  for (i = 0, l = types2.length; i < l; i++) {
    type = types2[i];
    if (!Type$1.isType(type, "logical")) {
      bucket = getTypeBucket(type);
      if (buckets[bucket]) {
        return true;
      }
      buckets[bucket] = true;
    }
  }
  return false;
}
function combineNumbers(types2) {
  var typeNames = ["int", "long", "float", "double"];
  var superIndex = -1;
  var superType = null;
  var i, l, type, index2;
  for (i = 0, l = types2.length; i < l; i++) {
    type = types2[i];
    index2 = typeNames.indexOf(type.typeName);
    if (index2 > superIndex) {
      superIndex = index2;
      superType = type;
    }
  }
  return superType;
}
function combineStrings(types2, opts) {
  var symbols = {};
  var i, l, type, typeSymbols;
  for (i = 0, l = types2.length; i < l; i++) {
    type = types2[i];
    if (type.typeName === "string") {
      return type;
    }
    typeSymbols = type.symbols;
    var j, m;
    for (j = 0, m = typeSymbols.length; j < m; j++) {
      symbols[typeSymbols[j]] = true;
    }
  }
  return Type$1.forSchema({ type: "enum", symbols: Object.keys(symbols) }, opts);
}
function combineBuffers(types2, opts) {
  var size = -1;
  var i, l, type;
  for (i = 0, l = types2.length; i < l; i++) {
    type = types2[i];
    if (type.typeName === "bytes") {
      return type;
    }
    if (size === -1) {
      size = type.size;
    } else if (type.size !== size) {
      size = -2;
    }
  }
  return size < 0 ? Type$1.forSchema("bytes", opts) : types2[0];
}
function combineObjects(types2, opts) {
  var allTypes = [];
  var fieldTypes = {};
  var fieldDefaults = {};
  var isValidRecord = true;
  var i, l, type, fields;
  for (i = 0, l = types2.length; i < l; i++) {
    type = types2[i];
    if (type.typeName === "map") {
      isValidRecord = false;
      allTypes.push(type.valuesType);
    } else {
      fields = type.fields;
      var j, m, field, fieldDefault, fieldName, fieldType;
      for (j = 0, m = fields.length; j < m; j++) {
        field = fields[j];
        fieldName = field.name;
        fieldType = field.type;
        allTypes.push(fieldType);
        if (isValidRecord) {
          if (!fieldTypes[fieldName]) {
            fieldTypes[fieldName] = [];
          }
          fieldTypes[fieldName].push(fieldType);
          fieldDefault = field.defaultValue();
          if (fieldDefault !== void 0) {
            fieldDefaults[fieldName] = fieldDefault;
          }
        }
      }
    }
  }
  if (isValidRecord) {
    var fieldNames = Object.keys(fieldTypes);
    for (i = 0, l = fieldNames.length; i < l; i++) {
      fieldName = fieldNames[i];
      if (fieldTypes[fieldName].length < types2.length && fieldDefaults[fieldName] === void 0) {
        if (opts && opts.strictDefaults) {
          isValidRecord = false;
        } else {
          fieldTypes[fieldName].unshift(Type$1.forSchema("null", opts));
          fieldDefaults[fieldName] = null;
        }
      }
    }
  }
  var schema;
  if (isValidRecord) {
    schema = {
      type: "record",
      fields: fieldNames.map(function(s2) {
        var fieldType2 = Type$1.forTypes(fieldTypes[s2], opts);
        var fieldDefault2 = fieldDefaults[s2];
        if (fieldDefault2 !== void 0 && ~fieldType2.typeName.indexOf("union")) {
          var unionTypes = fieldType2.types.slice();
          var i2, l2;
          for (i2 = 0, l2 = unionTypes.length; i2 < l2; i2++) {
            if (unionTypes[i2].isValid(fieldDefault2)) {
              break;
            }
          }
          if (i2 > 0) {
            var unionType = unionTypes[0];
            unionTypes[0] = unionTypes[i2];
            unionTypes[i2] = unionType;
            fieldType2 = Type$1.forSchema(unionTypes, opts);
          }
        }
        return {
          name: s2,
          type: fieldType2,
          "default": fieldDefaults[s2]
        };
      })
    };
  } else {
    schema = {
      type: "map",
      values: Type$1.forTypes(allTypes, opts)
    };
  }
  return Type$1.forSchema(schema, opts);
}
var types$3 = {
  Type: Type$1,
  getTypeBucket,
  getValueBucket,
  isPrimitive,
  isValidName: isValidName$1,
  qualify,
  builtins: function() {
    var types2 = {
      LogicalType,
      UnwrappedUnionType,
      WrappedUnionType
    };
    var typeNames = Object.keys(TYPES);
    var i, l, typeName;
    for (i = 0, l = typeNames.length; i < l; i++) {
      typeName = typeNames[i];
      types2[getClassName(typeName)] = TYPES[typeName];
    }
    return types2;
  }()
};
var types$2 = types$3;
function parse$2(any2, opts) {
  var schema;
  if (typeof any2 == "string") {
    try {
      schema = JSON.parse(any2);
    } catch (err) {
      schema = any2;
    }
  } else {
    schema = any2;
  }
  return types$2.Type.forSchema(schema, opts);
}
var avscTypes = {
  Type: types$2.Type,
  parse: parse$2,
  types: types$2.builtins,
  combine: types$2.Type.forTypes,
  infer: types$2.Type.forValue
};
var types$1 = types$3, utils$d = utils$f, events = events$1.exports, stream$3 = streamBrowserify, util$2 = requireUtil();
var Tap$1 = utils$d.Tap;
var Type = types$1.Type;
var debug = util$2.debuglog("avsc:services");
var f$2 = util$2.format;
var OPTS$1 = { namespace: "org.apache.avro.ipc" };
var BOOLEAN_TYPE = Type.forSchema("boolean", OPTS$1);
var MAP_BYTES_TYPE$1 = Type.forSchema({ type: "map", values: "bytes" }, OPTS$1);
var STRING_TYPE = Type.forSchema("string", OPTS$1);
var HANDSHAKE_REQUEST_TYPE = Type.forSchema({
  name: "HandshakeRequest",
  type: "record",
  fields: [
    { name: "clientHash", type: { name: "MD5", type: "fixed", size: 16 } },
    { name: "clientProtocol", type: ["null", "string"], "default": null },
    { name: "serverHash", type: "MD5" },
    { name: "meta", type: ["null", MAP_BYTES_TYPE$1], "default": null }
  ]
}, OPTS$1);
var HANDSHAKE_RESPONSE_TYPE = Type.forSchema({
  name: "HandshakeResponse",
  type: "record",
  fields: [
    {
      name: "match",
      type: {
        name: "HandshakeMatch",
        type: "enum",
        symbols: ["BOTH", "CLIENT", "NONE"]
      }
    },
    { name: "serverProtocol", type: ["null", "string"], "default": null },
    { name: "serverHash", type: ["null", "MD5"], "default": null },
    { name: "meta", type: ["null", MAP_BYTES_TYPE$1], "default": null }
  ]
}, OPTS$1);
var PREFIX_LENGTH = 16;
var PING_MESSAGE = new Message(
  "",
  Type.forSchema({ name: "PingRequest", type: "record", fields: [] }, OPTS$1),
  Type.forSchema(["string"], OPTS$1),
  Type.forSchema("null", OPTS$1)
);
function Message(name2, reqType, errType, resType, oneWay, doc) {
  this.name = name2;
  if (!Type.isType(reqType, "record")) {
    throw new Error("invalid request type");
  }
  this.requestType = reqType;
  if (!Type.isType(errType, "union") || !Type.isType(errType.getTypes()[0], "string")) {
    throw new Error("invalid error type");
  }
  this.errorType = errType;
  if (oneWay) {
    if (!Type.isType(resType, "null") || errType.getTypes().length > 1) {
      throw new Error("inapplicable one-way parameter");
    }
  }
  this.responseType = resType;
  this.oneWay = !!oneWay;
  this.doc = doc !== void 0 ? "" + doc : void 0;
  Object.freeze(this);
}
Message.forSchema = function(name2, schema, opts) {
  opts = opts || {};
  if (!types$1.isValidName(name2)) {
    throw new Error(f$2("invalid message name: %s", name2));
  }
  if (!Array.isArray(schema.request)) {
    throw new Error(f$2("invalid message request: %s", name2));
  }
  var recordName = f$2("%s.%sRequest", OPTS$1.namespace, utils$d.capitalize(name2));
  var reqType = Type.forSchema({
    name: recordName,
    type: "record",
    namespace: opts.namespace || "",
    fields: schema.request
  }, opts);
  delete opts.registry[recordName];
  if (!schema.response) {
    throw new Error(f$2("invalid message response: %s", name2));
  }
  var resType = Type.forSchema(schema.response, opts);
  if (schema.errors !== void 0 && !Array.isArray(schema.errors)) {
    throw new Error(f$2("invalid message errors: %s", name2));
  }
  var errType = Type.forSchema(["string"].concat(schema.errors || []), opts);
  var oneWay = !!schema["one-way"];
  return new Message(name2, reqType, errType, resType, oneWay, schema.doc);
};
Message.prototype.schema = Type.prototype.getSchema;
Message.prototype._attrs = function(opts) {
  var reqSchema = this.requestType._attrs(opts);
  var schema = {
    request: reqSchema.fields,
    response: this.responseType._attrs(opts)
  };
  var msgDoc = this.doc;
  if (msgDoc !== void 0) {
    schema.doc = msgDoc;
  }
  var errSchema = this.errorType._attrs(opts);
  if (errSchema.length > 1) {
    schema.errors = errSchema.slice(1);
  }
  if (this.oneWay) {
    schema["one-way"] = true;
  }
  return schema;
};
utils$d.addDeprecatedGetters(
  Message,
  ["name", "errorType", "requestType", "responseType"]
);
Message.prototype.isOneWay = util$2.deprecate(
  function() {
    return this.oneWay;
  },
  "use `.oneWay` directly instead of `.isOneWay()`"
);
function Service(name2, messages, types2, ptcl, server) {
  if (typeof name2 != "string") {
    return Service.forProtocol(name2, messages);
  }
  this.name = name2;
  this._messagesByName = messages || {};
  this.messages = Object.freeze(utils$d.objectValues(this._messagesByName));
  this._typesByName = types2 || {};
  this.types = Object.freeze(utils$d.objectValues(this._typesByName));
  this.protocol = ptcl;
  this._hashStr = utils$d.getHash(JSON.stringify(ptcl)).toString("binary");
  this.doc = ptcl.doc ? "" + ptcl.doc : void 0;
  this._server = server || this.createServer({ silent: true });
  Object.freeze(this);
}
Service.Client = Client;
Service.Server = Server;
Service.compatible = function(clientSvc, serverSvc) {
  try {
    createReaders(clientSvc, serverSvc);
  } catch (err) {
    return false;
  }
  return true;
};
Service.forProtocol = function(ptcl, opts) {
  opts = opts || {};
  var name2 = ptcl.protocol;
  if (!name2) {
    throw new Error("missing protocol name");
  }
  if (ptcl.namespace !== void 0) {
    opts.namespace = ptcl.namespace;
  } else {
    var match = /^(.*)\.[^.]+$/.exec(name2);
    if (match) {
      opts.namespace = match[1];
    }
  }
  name2 = types$1.qualify(name2, opts.namespace);
  if (ptcl.types) {
    ptcl.types.forEach(function(obj2) {
      Type.forSchema(obj2, opts);
    });
  }
  var msgs;
  if (ptcl.messages) {
    msgs = {};
    Object.keys(ptcl.messages).forEach(function(key3) {
      msgs[key3] = Message.forSchema(key3, ptcl.messages[key3], opts);
    });
  }
  return new Service(name2, msgs, opts.registry, ptcl);
};
Service.isService = function(any2) {
  return !!any2 && any2.hasOwnProperty("_hashStr");
};
Service.prototype.createClient = function(opts) {
  var client = new Client(this, opts);
  process.nextTick(function() {
    if (opts && opts.server) {
      var obj2 = { objectMode: true };
      var pts = [new stream$3.PassThrough(obj2), new stream$3.PassThrough(obj2)];
      opts.server.createChannel({ readable: pts[0], writable: pts[1] }, obj2);
      client.createChannel({ readable: pts[1], writable: pts[0] }, obj2);
    } else if (opts && opts.transport) {
      client.createChannel(opts.transport);
    }
  });
  return client;
};
Service.prototype.createServer = function(opts) {
  return new Server(this, opts);
};
Object.defineProperty(Service.prototype, "hash", {
  enumerable: true,
  get: function() {
    return utils$d.bufferFrom(this._hashStr, "binary");
  }
});
Service.prototype.message = function(name2) {
  return this._messagesByName[name2];
};
Service.prototype.type = function(name2) {
  return this._typesByName[name2];
};
Service.prototype.inspect = function() {
  return f$2("<Service %j>", this.name);
};
utils$d.addDeprecatedGetters(
  Service,
  ["message", "messages", "name", "type", "types"]
);
Service.prototype.createEmitter = util$2.deprecate(
  function(transport, opts) {
    opts = opts || {};
    var client = this.createClient({
      cache: opts.cache,
      buffering: false,
      strictTypes: opts.strictErrors,
      timeout: opts.timeout
    });
    var channel = client.createChannel(transport, opts);
    forwardErrors$1(client, channel);
    return channel;
  },
  "use `.createClient()` instead of `.createEmitter()`"
);
Service.prototype.createListener = util$2.deprecate(
  function(transport, opts) {
    if (opts && opts.strictErrors) {
      throw new Error("use `.createServer()` to support strict errors");
    }
    return this._server.createChannel(transport, opts);
  },
  "use `.createServer().createChannel()` instead of `.createListener()`"
);
Service.prototype.emit = util$2.deprecate(
  function(name2, req, channel, cb) {
    if (!channel || !this.equals(channel.client._svc$)) {
      throw new Error("invalid emitter");
    }
    var client = channel.client;
    Client.prototype.emitMessage.call(client, name2, req, cb && cb.bind(this));
    return channel.getPending();
  },
  "create a client via `.createClient()` to emit messages instead of `.emit()`"
);
Service.prototype.equals = util$2.deprecate(
  function(any2) {
    return Service.isService(any2) && this.getFingerprint().equals(any2.getFingerprint());
  },
  "equality testing is deprecated, compare the `.protocol`s instead"
);
Service.prototype.getFingerprint = util$2.deprecate(
  function(algorithm) {
    return utils$d.getHash(JSON.stringify(this.protocol), algorithm);
  },
  "use `.hash` instead of `.getFingerprint()`"
);
Service.prototype.getSchema = util$2.deprecate(
  Type.prototype.getSchema,
  "use `.protocol` instead of `.getSchema()`"
);
Service.prototype.on = util$2.deprecate(
  function(name2, handler) {
    var self2 = this;
    this._server.onMessage(name2, function(req, cb) {
      return handler.call(self2, req, this.channel, cb);
    });
    return this;
  },
  "use `.createServer().onMessage()` instead of `.on()`"
);
Service.prototype.subprotocol = util$2.deprecate(
  function() {
    var parent = this._server;
    var opts = { strictTypes: parent._strict, cache: parent._cache };
    var server = new Server(parent.service, opts);
    server._handlers = Object.create(parent._handlers);
    return new Service(
      this.name,
      this._messagesByName,
      this._typesByName,
      this.protocol,
      server
    );
  },
  "`.subprotocol()` will be removed in 5.1"
);
Service.prototype._attrs = function(opts) {
  var ptcl = { protocol: this.name };
  var types2 = [];
  this.types.forEach(function(t) {
    if (t.getName() === void 0) {
      return;
    }
    var typeSchema = t._attrs(opts);
    if (typeof typeSchema != "string") {
      types2.push(typeSchema);
    }
  });
  if (types2.length) {
    ptcl.types = types2;
  }
  var msgNames = Object.keys(this._messagesByName);
  if (msgNames.length) {
    ptcl.messages = {};
    msgNames.forEach(function(name2) {
      ptcl.messages[name2] = this._messagesByName[name2]._attrs(opts);
    }, this);
  }
  if (opts && opts.exportAttrs && this.doc !== void 0) {
    ptcl.doc = this.doc;
  }
  return ptcl;
};
function discoverProtocol(transport, opts, cb) {
  if (cb === void 0 && typeof opts == "function") {
    cb = opts;
    opts = void 0;
  }
  var svc = new Service({ protocol: "Empty" }, OPTS$1);
  var ptclStr;
  svc.createClient({ timeout: opts && opts.timeout }).createChannel(transport, {
    scope: opts && opts.scope,
    endWritable: typeof transport == "function"
  }).once("handshake", function(hreq, hres) {
    ptclStr = hres.serverProtocol;
    this.destroy(true);
  }).once("eot", function(pending, err) {
    if (err && !/interrupted/.test(err)) {
      cb(err);
    } else {
      cb(null, JSON.parse(ptclStr));
    }
  });
}
function Client(svc, opts) {
  opts = opts || {};
  events.EventEmitter.call(this);
  this._svc$ = svc;
  this._channels$ = [];
  this._fns$ = [];
  this._buffering$ = !!opts.buffering;
  this._cache$ = opts.cache || {};
  this._policy$ = opts.channelPolicy;
  this._strict$ = !!opts.strictTypes;
  this._timeout$ = utils$d.getOption(opts, "timeout", 1e4);
  if (opts.remoteProtocols) {
    insertRemoteProtocols(this._cache$, opts.remoteProtocols, svc, true);
  }
  this._svc$.messages.forEach(function(msg) {
    this[msg.name] = this._createMessageHandler$(msg);
  }, this);
}
util$2.inherits(Client, events.EventEmitter);
Client.prototype.activeChannels = function() {
  return this._channels$.slice();
};
Client.prototype.createChannel = function(transport, opts) {
  var objectMode = opts && opts.objectMode;
  var channel;
  if (typeof transport == "function") {
    var writableFactory;
    if (objectMode) {
      writableFactory = transport;
    } else {
      writableFactory = function(cb) {
        var encoder2 = new FrameEncoder();
        var writable2 = transport(function(err, readable2) {
          if (err) {
            cb(err);
            return;
          }
          var decoder2 = new FrameDecoder().once("error", function(err2) {
            channel.destroy(err2);
          });
          cb(null, readable2.pipe(decoder2));
        });
        if (writable2) {
          encoder2.pipe(writable2);
          return encoder2;
        }
      };
    }
    channel = new StatelessClientChannel(this, writableFactory, opts);
  } else {
    var readable, writable;
    if (isStream$1(transport)) {
      readable = writable = transport;
    } else {
      readable = transport.readable;
      writable = transport.writable;
    }
    if (!objectMode) {
      var decoder = new NettyDecoder();
      readable = readable.pipe(decoder);
      var encoder = new NettyEncoder();
      encoder.pipe(writable);
      writable = encoder;
    }
    channel = new StatefulClientChannel(this, readable, writable, opts);
    if (!objectMode) {
      channel.once("eot", function() {
        readable.unpipe(decoder);
        encoder.unpipe(writable);
      });
      decoder.once("error", function(err) {
        channel.destroy(err);
      });
    }
  }
  var channels = this._channels$;
  channels.push(channel);
  channel.once("_drain", function() {
    channels.splice(channels.indexOf(this), 1);
  });
  this._buffering$ = false;
  this.emit("channel", channel);
  return channel;
};
Client.prototype.destroyChannels = function(opts) {
  this._channels$.forEach(function(channel) {
    channel.destroy(opts && opts.noWait);
  });
};
Client.prototype.emitMessage = function(name2, req, opts, cb) {
  var msg = getExistingMessage(this._svc$, name2);
  var wreq = new WrappedRequest(msg, {}, req);
  this._emitMessage$(wreq, opts, cb);
};
Client.prototype.remoteProtocols = function() {
  return getRemoteProtocols(this._cache$, true);
};
Object.defineProperty(Client.prototype, "service", {
  enumerable: true,
  get: function() {
    return this._svc$;
  }
});
Client.prototype.use = function() {
  var i, l, fn;
  for (i = 0, l = arguments.length; i < l; i++) {
    fn = arguments[i];
    this._fns$.push(fn.length < 3 ? fn(this) : fn);
  }
  return this;
};
Client.prototype._emitMessage$ = function(wreq, opts, cb) {
  if (!cb && typeof opts === "function") {
    cb = opts;
    opts = void 0;
  }
  var self2 = this;
  var channels = this._channels$;
  var numChannels = channels.length;
  if (!numChannels) {
    if (this._buffering$) {
      debug("no active client channels, buffering call");
      this.once("channel", function() {
        this._emitMessage$(wreq, opts, cb);
      });
    } else {
      var err = new Error("no active channels");
      process.nextTick(function() {
        if (cb) {
          cb.call(new CallContext(wreq._msg), err);
        } else {
          self2.emit("error", err);
        }
      });
    }
    return;
  }
  opts = opts || {};
  if (opts.timeout === void 0) {
    opts.timeout = this._timeout$;
  }
  var channel;
  if (numChannels === 1) {
    channel = channels[0];
  } else if (this._policy$) {
    channel = this._policy$(this._channels$.slice());
    if (!channel) {
      debug("policy returned no channel, skipping call");
      return;
    }
  } else {
    channel = channels[Math.floor(Math.random() * numChannels)];
  }
  channel._emit(wreq, opts, function(err2, wres) {
    var ctx = this;
    var errType = ctx.message.errorType;
    if (err2) {
      if (self2._strict$) {
        err2 = errType.clone(err2.message, { wrapUnions: true });
      }
      done2(err2);
      return;
    }
    if (!wres) {
      done2();
      return;
    }
    err2 = wres.error;
    if (!self2._strict$) {
      if (err2 === void 0) {
        err2 = null;
      } else {
        if (Type.isType(errType, "union:unwrapped")) {
          if (typeof err2 == "string") {
            err2 = new Error(err2);
          }
        } else if (err2 && err2.string && typeof err2.string == "string") {
          err2 = new Error(err2.string);
        }
      }
    }
    done2(err2, wres.response);
    function done2(err3, res) {
      if (cb) {
        cb.call(ctx, err3, res);
      } else if (err3) {
        self2.emit("error", err3);
      }
    }
  });
};
Client.prototype._createMessageHandler$ = function(msg) {
  var fields = msg.requestType.getFields();
  var names2 = fields.map(function(f2) {
    return f2.getName();
  });
  var body = "return function " + msg.name + "(";
  if (names2.length) {
    body += names2.join(", ") + ", ";
  }
  body += "opts, cb) {\n";
  body += "  var req = {";
  body += names2.map(function(n) {
    return n + ": " + n;
  }).join(", ");
  body += "};\n";
  body += "  return this.emitMessage('" + msg.name + "', req, opts, cb);\n";
  body += "};";
  return new Function(body)();
};
function Server(svc, opts) {
  opts = opts || {};
  events.EventEmitter.call(this);
  this.service = svc;
  this._handlers = {};
  this._fns = [];
  this._channels = {};
  this._nextChannelId = 1;
  this._cache = opts.cache || {};
  this._defaultHandler = opts.defaultHandler;
  this._sysErrFormatter = opts.systemErrorFormatter;
  this._silent = !!opts.silent;
  this._strict = !!opts.strictTypes;
  if (opts.remoteProtocols) {
    insertRemoteProtocols(this._cache, opts.remoteProtocols, svc, false);
  }
  svc.messages.forEach(function(msg) {
    var name2 = msg.name;
    if (!opts.noCapitalize) {
      name2 = utils$d.capitalize(name2);
    }
    this["on" + name2] = this._createMessageHandler(msg);
  }, this);
}
util$2.inherits(Server, events.EventEmitter);
Server.prototype.activeChannels = function() {
  return utils$d.objectValues(this._channels);
};
Server.prototype.createChannel = function(transport, opts) {
  var objectMode = opts && opts.objectMode;
  var channel;
  if (typeof transport == "function") {
    var readableFactory;
    if (objectMode) {
      readableFactory = transport;
    } else {
      readableFactory = function(cb) {
        var decoder2 = new FrameDecoder().once("error", function(err) {
          channel.destroy(err);
        });
        return transport(function(err, writable2) {
          if (err) {
            cb(err);
            return;
          }
          var encoder2 = new FrameEncoder();
          encoder2.pipe(writable2);
          cb(null, encoder2);
        }).pipe(decoder2);
      };
    }
    channel = new StatelessServerChannel(this, readableFactory, opts);
  } else {
    var readable, writable;
    if (isStream$1(transport)) {
      readable = writable = transport;
    } else {
      readable = transport.readable;
      writable = transport.writable;
    }
    if (!objectMode) {
      var decoder = new NettyDecoder();
      readable = readable.pipe(decoder);
      var encoder = new NettyEncoder();
      encoder.pipe(writable);
      writable = encoder;
    }
    channel = new StatefulServerChannel(this, readable, writable, opts);
    if (!objectMode) {
      channel.once("eot", function() {
        readable.unpipe(decoder);
        encoder.unpipe(writable);
      });
      decoder.once("error", function(err) {
        channel.destroy(err);
      });
    }
  }
  if (!this.listeners("error").length) {
    this.on("error", this._onError);
  }
  var channelId = this._nextChannelId++;
  var channels = this._channels;
  channels[channelId] = channel.once("eot", function() {
    delete channels[channelId];
  });
  this.emit("channel", channel);
  return channel;
};
Server.prototype.onMessage = function(name2, handler) {
  getExistingMessage(this.service, name2);
  this._handlers[name2] = handler;
  return this;
};
Server.prototype.remoteProtocols = function() {
  return getRemoteProtocols(this._cache, false);
};
Server.prototype.use = function() {
  var i, l, fn;
  for (i = 0, l = arguments.length; i < l; i++) {
    fn = arguments[i];
    this._fns.push(fn.length < 3 ? fn(this) : fn);
  }
  return this;
};
Server.prototype._createMessageHandler = function(msg) {
  var name2 = msg.name;
  var fields = msg.requestType.fields;
  var numArgs = fields.length;
  var args = fields.length ? ", " + fields.map(function(f2) {
    return "req." + f2.name;
  }).join(", ") : "";
  var body = "return function (handler) {\n";
  body += "  if (handler.length > " + numArgs + ") {\n";
  body += "    return this.onMessage('" + name2 + "', function (req, cb) {\n";
  body += "      return handler.call(this" + args + ", cb);\n";
  body += "    });\n";
  body += "  } else {\n";
  body += "    return this.onMessage('" + name2 + "', function (req) {\n";
  body += "      return handler.call(this" + args + ");\n";
  body += "    });\n";
  body += "  }\n";
  body += "};\n";
  return new Function(body)();
};
Server.prototype._onError = function(err) {
  if (!this._silent && err.rpcCode !== "UNKNOWN_PROTOCOL") {
    console.error();
    if (err.rpcCode) {
      console.error(err.rpcCode);
      console.error(err.cause);
    } else {
      console.error("INTERNAL_SERVER_ERROR");
      console.error(err);
    }
  }
};
function ClientChannel(client, opts) {
  opts = opts || {};
  events.EventEmitter.call(this);
  this.client = client;
  this.timeout = utils$d.getOption(opts, "timeout", client._timeout$);
  this._endWritable = !!utils$d.getOption(opts, "endWritable", true);
  this._prefix = normalizedPrefix(opts.scope);
  var cache = client._cache$;
  var clientSvc = client._svc$;
  var hash3 = opts.serverHash;
  if (!hash3) {
    hash3 = clientSvc.hash;
  }
  var adapter = cache[hash3];
  if (!adapter) {
    hash3 = clientSvc.hash;
    adapter = cache[hash3] = new Adapter(clientSvc, clientSvc, hash3);
  }
  this._adapter = adapter;
  this._registry = new Registry(this, PREFIX_LENGTH);
  this.pending = 0;
  this.destroyed = false;
  this.draining = false;
  this.once("_eot", function(pending, err) {
    debug("client channel EOT");
    this.destroyed = true;
    this.emit("eot", pending, err);
  });
}
util$2.inherits(ClientChannel, events.EventEmitter);
ClientChannel.prototype.destroy = function(noWait) {
  debug("destroying client channel");
  if (!this.draining) {
    this.draining = true;
    this.emit("_drain");
  }
  var registry = this._registry;
  var pending = this.pending;
  if (noWait) {
    registry.clear();
  }
  if (noWait || !pending) {
    if (isError2(noWait)) {
      debug("fatal client channel error: %s", noWait);
      this.emit("_eot", pending, noWait);
    } else {
      this.emit("_eot", pending);
    }
  } else {
    debug("client channel entering drain mode (%s pending)", pending);
  }
};
ClientChannel.prototype.ping = function(timeout, cb) {
  if (!cb && typeof timeout == "function") {
    cb = timeout;
    timeout = void 0;
  }
  var self2 = this;
  var wreq = new WrappedRequest(PING_MESSAGE);
  this._emit(wreq, { timeout }, function(err) {
    if (cb) {
      cb.call(self2, err);
    } else if (err) {
      self2.destroy(err);
    }
  });
};
ClientChannel.prototype._createHandshakeRequest = function(adapter, noSvc) {
  var svc = this.client._svc$;
  return {
    clientHash: svc.hash,
    clientProtocol: noSvc ? null : JSON.stringify(svc.protocol),
    serverHash: adapter._hash
  };
};
ClientChannel.prototype._emit = function(wreq, opts, cb) {
  var msg = wreq._msg;
  var wres = msg.oneWay ? void 0 : new WrappedResponse(msg, {});
  var ctx = new CallContext(msg, this);
  var self2 = this;
  this.pending++;
  process.nextTick(function() {
    if (!msg.name) {
      onTransition(wreq, wres, onCompletion);
    } else {
      self2.emit("outgoingCall", ctx, opts);
      var fns = self2.client._fns$;
      debug("starting client middleware chain (%s middleware)", fns.length);
      chainMiddleware({
        fns,
        ctx,
        wreq,
        wres,
        onTransition,
        onCompletion,
        onError
      });
    }
  });
  function onTransition(wreq2, wres2, prev) {
    var err, reqBuf;
    if (self2.destroyed) {
      err = new Error("channel destroyed");
    } else {
      try {
        reqBuf = wreq2.toBuffer();
      } catch (cause) {
        err = serializationError(
          f$2("invalid %j request", msg.name),
          wreq2,
          [
            { name: "headers", type: MAP_BYTES_TYPE$1 },
            { name: "request", type: msg.requestType }
          ]
        );
      }
    }
    if (err) {
      prev(err);
      return;
    }
    var timeout = opts && opts.timeout !== void 0 ? opts.timeout : self2.timeout;
    var id2 = self2._registry.add(timeout, function(err2, resBuf, adapter) {
      if (!err2 && !msg.oneWay) {
        try {
          adapter._decodeResponse(resBuf, wres2, msg);
        } catch (cause) {
          err2 = cause;
        }
      }
      prev(err2);
    });
    id2 |= self2._prefix;
    debug("sending message %s", id2);
    self2._send(id2, reqBuf, !!msg && msg.oneWay);
  }
  function onCompletion(err) {
    self2.pending--;
    cb.call(ctx, err, wres);
    if (self2.draining && !self2.destroyed && !self2.pending) {
      self2.destroy();
    }
  }
  function onError(err) {
    self2.client.emit("error", err, self2);
  }
};
ClientChannel.prototype._getAdapter = function(hres) {
  var hash3 = hres.serverHash;
  var cache = this.client._cache$;
  var adapter = cache[hash3];
  if (adapter) {
    return adapter;
  }
  var ptcl = JSON.parse(hres.serverProtocol);
  var serverSvc = Service.forProtocol(ptcl);
  adapter = new Adapter(this.client._svc$, serverSvc, hash3, true);
  return cache[hash3] = adapter;
};
ClientChannel.prototype._matchesPrefix = function(id2) {
  return matchesPrefix(id2, this._prefix);
};
ClientChannel.prototype._send = utils$d.abstractFunction;
utils$d.addDeprecatedGetters(ClientChannel, ["pending", "timeout"]);
ClientChannel.prototype.getCache = util$2.deprecate(
  function() {
    return this.client._cache$;
  },
  "use `.remoteProtocols()` instead of `.getCache()`"
);
ClientChannel.prototype.getProtocol = util$2.deprecate(
  function() {
    return this.client._svc$;
  },
  "use `.service` instead or `.getProtocol()`"
);
ClientChannel.prototype.isDestroyed = util$2.deprecate(
  function() {
    return this.destroyed;
  },
  "use `.destroyed` instead of `.isDestroyed`"
);
function StatelessClientChannel(client, writableFactory, opts) {
  ClientChannel.call(this, client, opts);
  this._writableFactory = writableFactory;
  if (!opts || !opts.noPing) {
    debug("emitting ping request");
    this.ping();
  }
}
util$2.inherits(StatelessClientChannel, ClientChannel);
StatelessClientChannel.prototype._send = function(id2, reqBuf) {
  var cb = this._registry.get(id2);
  var adapter = this._adapter;
  var self2 = this;
  process.nextTick(emit);
  return true;
  function emit(retry) {
    if (self2.destroyed) {
      return;
    }
    var hreq = self2._createHandshakeRequest(adapter, !retry);
    var writable = self2._writableFactory.call(self2, function(err, readable) {
      if (err) {
        cb(err);
        return;
      }
      readable.on("data", function(obj2) {
        debug("received response %s", obj2.id);
        var buf = Buffer.concat(obj2.payload);
        try {
          var parts = readHead(HANDSHAKE_RESPONSE_TYPE, buf);
          var hres = parts.head;
          if (hres.serverHash) {
            adapter = self2._getAdapter(hres);
          }
        } catch (cause) {
          cb(cause);
          return;
        }
        var match = hres.match;
        debug("handshake match: %s", match);
        self2.emit("handshake", hreq, hres);
        if (match === "NONE") {
          process.nextTick(function() {
            emit(true);
          });
        } else {
          self2._adapter = adapter;
          cb(null, parts.tail, adapter);
        }
      });
    });
    if (!writable) {
      cb(new Error("invalid writable stream"));
      return;
    }
    writable.write({
      id: id2,
      payload: [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), reqBuf]
    });
    if (self2._endWritable) {
      writable.end();
    }
  }
};
function StatefulClientChannel(client, readable, writable, opts) {
  ClientChannel.call(this, client, opts);
  this._readable = readable;
  this._writable = writable;
  this._connected = !!(opts && opts.noPing);
  this._readable.on("end", onEnd);
  this._writable.on("finish", onFinish);
  var self2 = this;
  var timer2 = null;
  this.once("eot", function() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    if (!self2._connected) {
      self2.emit("_ready");
    }
    this._writable.removeListener("finish", onFinish);
    if (this._endWritable) {
      debug("ending transport");
      this._writable.end();
    }
    this._readable.removeListener("data", onPing).removeListener("data", onMessage).removeListener("end", onEnd);
  });
  var hreq;
  if (this._connected) {
    this._readable.on("data", onMessage);
  } else {
    this._readable.on("data", onPing);
    process.nextTick(ping);
    if (self2.timeout) {
      timer2 = setTimeout(function() {
        self2.destroy(new Error("timeout"));
      }, self2.timeout);
    }
  }
  function ping(retry) {
    if (self2.destroyed) {
      return;
    }
    hreq = self2._createHandshakeRequest(self2._adapter, !retry);
    var payload = [
      HANDSHAKE_REQUEST_TYPE.toBuffer(hreq),
      utils$d.bufferFrom([0, 0])
    ];
    self2._writable.write({ id: self2._prefix, payload });
  }
  function onPing(obj2) {
    if (!self2._matchesPrefix(obj2.id)) {
      debug("discarding unscoped response %s (still connecting)", obj2.id);
      return;
    }
    var buf = Buffer.concat(obj2.payload);
    try {
      var hres = readHead(HANDSHAKE_RESPONSE_TYPE, buf).head;
      if (hres.serverHash) {
        self2._adapter = self2._getAdapter(hres);
      }
    } catch (cause) {
      self2.destroy(cause);
      return;
    }
    var match = hres.match;
    debug("handshake match: %s", match);
    self2.emit("handshake", hreq, hres);
    if (match === "NONE") {
      process.nextTick(function() {
        ping(true);
      });
    } else {
      debug("successfully connected");
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      self2._readable.removeListener("data", onPing).on("data", onMessage);
      self2._connected = true;
      self2.emit("_ready");
      hreq = null;
    }
  }
  function onMessage(obj2) {
    var id2 = obj2.id;
    if (!self2._matchesPrefix(id2)) {
      debug("discarding unscoped message %s", id2);
      return;
    }
    var cb = self2._registry.get(id2);
    if (cb) {
      process.nextTick(function() {
        debug("received message %s", id2);
        cb(null, Buffer.concat(obj2.payload), self2._adapter);
      });
    }
  }
  function onEnd() {
    self2.destroy(true);
  }
  function onFinish() {
    self2.destroy();
  }
}
util$2.inherits(StatefulClientChannel, ClientChannel);
StatefulClientChannel.prototype._emit = function() {
  if (this._connected || this.draining) {
    ClientChannel.prototype._emit.apply(this, arguments);
  } else {
    debug("queuing request");
    var args = [];
    var i, l;
    for (i = 0, l = arguments.length; i < l; i++) {
      args.push(arguments[i]);
    }
    this.once("_ready", function() {
      this._emit.apply(this, args);
    });
  }
};
StatefulClientChannel.prototype._send = function(id2, reqBuf, oneWay) {
  if (oneWay) {
    var self2 = this;
    process.nextTick(function() {
      self2._registry.get(id2)(null, utils$d.bufferFrom([0, 0, 0]), self2._adapter);
    });
  }
  return this._writable.write({ id: id2, payload: [reqBuf] });
};
function ServerChannel(server, opts) {
  opts = opts || {};
  events.EventEmitter.call(this);
  this.server = server;
  this._endWritable = !!utils$d.getOption(opts, "endWritable", true);
  this._prefix = normalizedPrefix(opts.scope);
  var cache = server._cache;
  var svc = server.service;
  var hash3 = svc.hash;
  if (!cache[hash3]) {
    cache[hash3] = new Adapter(svc, svc, hash3);
  }
  this._adapter = null;
  this.destroyed = false;
  this.draining = false;
  this.pending = 0;
  this.once("_eot", function(pending, err) {
    debug("server channel EOT");
    this.emit("eot", pending, err);
  });
}
util$2.inherits(ServerChannel, events.EventEmitter);
ServerChannel.prototype.destroy = function(noWait) {
  if (!this.draining) {
    this.draining = true;
    this.emit("_drain");
  }
  if (noWait || !this.pending) {
    this.destroyed = true;
    if (isError2(noWait)) {
      debug("fatal server channel error: %s", noWait);
      this.emit("_eot", this.pending, noWait);
    } else {
      this.emit("_eot", this.pending);
    }
  }
};
ServerChannel.prototype._createHandshakeResponse = function(err, hreq) {
  var svc = this.server.service;
  var buf = svc.hash;
  var serverMatch = hreq && hreq.serverHash.equals(buf);
  return {
    match: err ? "NONE" : serverMatch ? "BOTH" : "CLIENT",
    serverProtocol: serverMatch ? null : JSON.stringify(svc.protocol),
    serverHash: serverMatch ? null : buf
  };
};
ServerChannel.prototype._getAdapter = function(hreq) {
  var hash3 = hreq.clientHash;
  var adapter = this.server._cache[hash3];
  if (adapter) {
    return adapter;
  }
  if (!hreq.clientProtocol) {
    throw toRpcError("UNKNOWN_PROTOCOL");
  }
  var ptcl = JSON.parse(hreq.clientProtocol);
  var clientSvc = Service.forProtocol(ptcl);
  adapter = new Adapter(clientSvc, this.server.service, hash3, true);
  return this.server._cache[hash3] = adapter;
};
ServerChannel.prototype._matchesPrefix = function(id2) {
  return matchesPrefix(id2, this._prefix);
};
ServerChannel.prototype._receive = function(reqBuf, adapter, cb) {
  var self2 = this;
  var wreq;
  try {
    wreq = adapter._decodeRequest(reqBuf);
  } catch (cause) {
    cb(self2._encodeSystemError(toRpcError("INVALID_REQUEST", cause)));
    return;
  }
  var msg = wreq._msg;
  var wres = new WrappedResponse(msg, {});
  if (!msg.name) {
    wres.response = null;
    cb(wres.toBuffer(), false);
    return;
  }
  var ctx = new CallContext(msg, this);
  self2.emit("incomingCall", ctx);
  var fns = this.server._fns;
  debug("starting server middleware chain (%s middleware)", fns.length);
  self2.pending++;
  chainMiddleware({
    fns,
    ctx,
    wreq,
    wres,
    onTransition,
    onCompletion,
    onError
  });
  function onTransition(wreq2, wres2, prev) {
    var handler = self2.server._handlers[msg.name];
    if (!handler) {
      var defaultHandler = self2.server._defaultHandler;
      if (defaultHandler) {
        defaultHandler.call(ctx, wreq2, wres2, prev);
      } else {
        var cause = new Error(f$2("no handler for %s", msg.name));
        prev(toRpcError("NOT_IMPLEMENTED", cause));
      }
    } else {
      var pending = !msg.oneWay;
      try {
        if (pending) {
          handler.call(ctx, wreq2.request, function(err, res) {
            pending = false;
            wres2.error = err;
            wres2.response = res;
            prev();
          });
        } else {
          handler.call(ctx, wreq2.request);
          prev();
        }
      } catch (err) {
        if (pending) {
          pending = false;
          prev(err);
        } else {
          onError(err);
        }
      }
    }
  }
  function onCompletion(err) {
    self2.pending--;
    var server = self2.server;
    var resBuf;
    if (!err) {
      var resErr = wres.error;
      var isStrict = server._strict;
      if (!isStrict) {
        if (isError2(resErr)) {
          wres.error = msg.errorType.clone(resErr.message, { wrapUnions: true });
        } else if (resErr === null) {
          resErr = wres.error = void 0;
        }
        if (resErr === void 0 && wres.response === void 0 && msg.responseType.isValid(null)) {
          wres.response = null;
        }
      }
      try {
        resBuf = wres.toBuffer();
      } catch (cause) {
        if (wres.error !== void 0) {
          err = serializationError(
            f$2("invalid %j error", msg.name),
            wres,
            [
              { name: "headers", type: MAP_BYTES_TYPE$1 },
              { name: "error", type: msg.errorType }
            ]
          );
        } else {
          err = serializationError(
            f$2("invalid %j response", msg.name),
            wres,
            [
              { name: "headers", type: MAP_BYTES_TYPE$1 },
              { name: "response", type: msg.responseType }
            ]
          );
        }
      }
    }
    if (!resBuf) {
      resBuf = self2._encodeSystemError(err, wres.headers);
    } else if (resErr !== void 0) {
      server.emit("error", toRpcError("APPLICATION_ERROR", resErr));
    }
    cb(resBuf, msg.oneWay);
    if (self2.draining && !self2.pending) {
      self2.destroy();
    }
  }
  function onError(err) {
    self2.server.emit("error", err, self2);
  }
};
utils$d.addDeprecatedGetters(ServerChannel, ["pending"]);
ServerChannel.prototype.getCache = util$2.deprecate(
  function() {
    return this.server._cache;
  },
  "use `.remoteProtocols()` instead of `.getCache()`"
);
ServerChannel.prototype.getProtocol = util$2.deprecate(
  function() {
    return this.server.service;
  },
  "use `.service` instead of `.getProtocol()`"
);
ServerChannel.prototype.isDestroyed = util$2.deprecate(
  function() {
    return this.destroyed;
  },
  "use `.destroyed` instead of `.isDestroyed`"
);
ServerChannel.prototype._encodeSystemError = function(err, header) {
  var server = this.server;
  server.emit("error", err, this);
  var errStr;
  if (server._sysErrFormatter) {
    errStr = server._sysErrFormatter.call(this, err);
  } else if (err.rpcCode) {
    errStr = err.message;
  }
  var hdrBuf;
  if (header) {
    try {
      hdrBuf = MAP_BYTES_TYPE$1.toBuffer(header);
    } catch (cause) {
      server.emit("error", cause, this);
    }
  }
  return Buffer.concat([
    hdrBuf || utils$d.bufferFrom([0]),
    utils$d.bufferFrom([1, 0]),
    STRING_TYPE.toBuffer(errStr || "internal server error")
  ]);
};
function StatelessServerChannel(server, readableFactory, opts) {
  ServerChannel.call(this, server, opts);
  this._writable = void 0;
  var self2 = this;
  var readable;
  process.nextTick(function() {
    readable = readableFactory.call(self2, function(err, writable) {
      process.nextTick(function() {
        if (err) {
          onFinish(err);
          return;
        }
        self2._writable = writable.on("finish", onFinish);
        self2.emit("_writable");
      });
    }).on("data", onRequest).on("end", onEnd);
  });
  function onRequest(obj2) {
    var id2 = obj2.id;
    var buf = Buffer.concat(obj2.payload);
    var err;
    try {
      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);
      var hreq = parts.head;
      var adapter = self2._getAdapter(hreq);
    } catch (cause) {
      err = toRpcError("INVALID_HANDSHAKE_REQUEST", cause);
    }
    var hres = self2._createHandshakeResponse(err, hreq);
    self2.emit("handshake", hreq, hres);
    if (err) {
      done2(self2._encodeSystemError(err));
    } else {
      self2._receive(parts.tail, adapter, done2);
    }
    function done2(resBuf) {
      if (!self2.destroyed) {
        if (!self2._writable) {
          self2.once("_writable", function() {
            done2(resBuf);
          });
          return;
        }
        self2._writable.write({
          id: id2,
          payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]
        });
      }
      if (self2._writable && self2._endWritable) {
        self2._writable.end();
      }
    }
  }
  function onEnd() {
    self2.destroy();
  }
  function onFinish(err) {
    readable.removeListener("data", onRequest).removeListener("end", onEnd);
    self2.destroy(err || true);
  }
}
util$2.inherits(StatelessServerChannel, ServerChannel);
function StatefulServerChannel(server, readable, writable, opts) {
  ServerChannel.call(this, server, opts);
  this._adapter = void 0;
  this._writable = writable.on("finish", onFinish);
  this._readable = readable.on("data", onHandshake).on("end", onEnd);
  this.once("_drain", function() {
    this._readable.removeListener("data", onHandshake).removeListener("data", onRequest).removeListener("end", onEnd);
  }).once("eot", function() {
    this._writable.removeListener("finish", onFinish);
    if (this._endWritable) {
      this._writable.end();
    }
  });
  var self2 = this;
  function onHandshake(obj2) {
    var id2 = obj2.id;
    if (!self2._matchesPrefix(id2)) {
      return;
    }
    var buf = Buffer.concat(obj2.payload);
    var err;
    try {
      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);
      var hreq = parts.head;
      self2._adapter = self2._getAdapter(hreq);
    } catch (cause) {
      err = toRpcError("INVALID_HANDSHAKE_REQUEST", cause);
    }
    var hres = self2._createHandshakeResponse(err, hreq);
    self2.emit("handshake", hreq, hres);
    if (err) {
      done2(self2._encodeSystemError(err));
    } else {
      self2._readable.removeListener("data", onHandshake).on("data", onRequest);
      self2._receive(parts.tail, self2._adapter, done2);
    }
    function done2(resBuf) {
      if (self2.destroyed) {
        return;
      }
      self2._writable.write({
        id: id2,
        payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]
      });
    }
  }
  function onRequest(obj2) {
    var id2 = obj2.id;
    if (!self2._matchesPrefix(id2)) {
      return;
    }
    var reqBuf = Buffer.concat(obj2.payload);
    self2._receive(reqBuf, self2._adapter, function(resBuf, oneWay) {
      if (self2.destroyed || oneWay) {
        return;
      }
      self2._writable.write({ id: id2, payload: [resBuf] });
    });
  }
  function onEnd() {
    self2.destroy();
  }
  function onFinish() {
    self2.destroy(true);
  }
}
util$2.inherits(StatefulServerChannel, ServerChannel);
function WrappedRequest(msg, hdrs, req) {
  this._msg = msg;
  this.headers = hdrs || {};
  this.request = req || {};
}
WrappedRequest.prototype.toBuffer = function() {
  var msg = this._msg;
  return Buffer.concat([
    MAP_BYTES_TYPE$1.toBuffer(this.headers),
    STRING_TYPE.toBuffer(msg.name),
    msg.requestType.toBuffer(this.request)
  ]);
};
function WrappedResponse(msg, hdr, err, res) {
  this._msg = msg;
  this.headers = hdr;
  this.error = err;
  this.response = res;
}
WrappedResponse.prototype.toBuffer = function() {
  var hdr = MAP_BYTES_TYPE$1.toBuffer(this.headers);
  var hasError = this.error !== void 0;
  return Buffer.concat([
    hdr,
    BOOLEAN_TYPE.toBuffer(hasError),
    hasError ? this._msg.errorType.toBuffer(this.error) : this._msg.responseType.toBuffer(this.response)
  ]);
};
function CallContext(msg, channel) {
  this.channel = channel;
  this.locals = {};
  this.message = msg;
  Object.freeze(this);
}
function Registry(ctx, prefixLength) {
  this._ctx = ctx;
  this._mask = ~0 >>> (prefixLength | 0);
  this._id = 0;
  this._n = 0;
  this._cbs = {};
}
Registry.prototype.get = function(id2) {
  return this._cbs[id2 & this._mask];
};
Registry.prototype.add = function(timeout, fn) {
  this._id = this._id + 1 & this._mask;
  var self2 = this;
  var id2 = this._id;
  var timer2;
  if (timeout > 0) {
    timer2 = setTimeout(function() {
      cb(new Error("timeout"));
    }, timeout);
  }
  this._cbs[id2] = cb;
  this._n++;
  return id2;
  function cb() {
    if (!self2._cbs[id2]) {
      return;
    }
    delete self2._cbs[id2];
    self2._n--;
    if (timer2) {
      clearTimeout(timer2);
    }
    fn.apply(self2._ctx, arguments);
  }
};
Registry.prototype.clear = function() {
  Object.keys(this._cbs).forEach(function(id2) {
    this._cbs[id2](new Error("interrupted"));
  }, this);
};
function Adapter(clientSvc, serverSvc, hash3, isRemote) {
  this._clientSvc = clientSvc;
  this._serverSvc = serverSvc;
  this._hash = hash3;
  this._isRemote = !!isRemote;
  this._readers = createReaders(clientSvc, serverSvc);
}
Adapter.prototype._decodeRequest = function(buf) {
  var tap = new Tap$1(buf);
  var hdr = MAP_BYTES_TYPE$1._read(tap);
  var name2 = STRING_TYPE._read(tap);
  var msg, req;
  if (name2) {
    msg = this._serverSvc.message(name2);
    req = this._readers[name2 + "?"]._read(tap);
  } else {
    msg = PING_MESSAGE;
  }
  if (!tap.isValid()) {
    throw new Error(f$2("truncated %s request", name2 || "ping$"));
  }
  return new WrappedRequest(msg, hdr, req);
};
Adapter.prototype._decodeResponse = function(buf, wres, msg) {
  var tap = new Tap$1(buf);
  utils$d.copyOwnProperties(MAP_BYTES_TYPE$1._read(tap), wres.headers, true);
  var isError3 = BOOLEAN_TYPE._read(tap);
  var name2 = msg.name;
  if (name2) {
    var reader = this._readers[name2 + (isError3 ? "*" : "!")];
    msg = this._clientSvc.message(name2);
    if (isError3) {
      wres.error = reader._read(tap);
    } else {
      wres.response = reader._read(tap);
    }
    if (!tap.isValid()) {
      throw new Error(f$2("truncated %s response", name2));
    }
  } else {
    msg = PING_MESSAGE;
  }
};
function FrameDecoder() {
  stream$3.Transform.call(this, { readableObjectMode: true });
  this._id = void 0;
  this._buf = utils$d.newBuffer(0);
  this._bufs = [];
  this.on("finish", function() {
    this.push(null);
  });
}
util$2.inherits(FrameDecoder, stream$3.Transform);
FrameDecoder.prototype._transform = function(buf, encoding, cb) {
  buf = Buffer.concat([this._buf, buf]);
  var frameLength;
  while (buf.length >= 4 && buf.length >= (frameLength = buf.readInt32BE(0)) + 4) {
    if (frameLength) {
      this._bufs.push(buf.slice(4, frameLength + 4));
    } else {
      var bufs = this._bufs;
      this._bufs = [];
      this.push({ id: null, payload: bufs });
    }
    buf = buf.slice(frameLength + 4);
  }
  this._buf = buf;
  cb();
};
FrameDecoder.prototype._flush = function() {
  if (this._buf.length || this._bufs.length) {
    var bufs = this._bufs.slice();
    bufs.unshift(this._buf);
    var err = toRpcError("TRAILING_DATA");
    err.trailingData = Buffer.concat(bufs).toString();
    this.emit("error", err);
  }
};
function FrameEncoder() {
  stream$3.Transform.call(this, { writableObjectMode: true });
  this.on("finish", function() {
    this.push(null);
  });
}
util$2.inherits(FrameEncoder, stream$3.Transform);
FrameEncoder.prototype._transform = function(obj2, encoding, cb) {
  var bufs = obj2.payload;
  var i, l, buf;
  for (i = 0, l = bufs.length; i < l; i++) {
    buf = bufs[i];
    this.push(intBuffer(buf.length));
    this.push(buf);
  }
  this.push(intBuffer(0));
  cb();
};
function NettyDecoder() {
  stream$3.Transform.call(this, { readableObjectMode: true });
  this._id = void 0;
  this._frameCount = 0;
  this._buf = utils$d.newBuffer(0);
  this._bufs = [];
  this.on("finish", function() {
    this.push(null);
  });
}
util$2.inherits(NettyDecoder, stream$3.Transform);
NettyDecoder.prototype._transform = function(buf, encoding, cb) {
  buf = Buffer.concat([this._buf, buf]);
  while (true) {
    if (this._id === void 0) {
      if (buf.length < 8) {
        this._buf = buf;
        cb();
        return;
      }
      this._id = buf.readInt32BE(0);
      this._frameCount = buf.readInt32BE(4);
      buf = buf.slice(8);
    }
    var frameLength;
    while (this._frameCount && buf.length >= 4 && buf.length >= (frameLength = buf.readInt32BE(0)) + 4) {
      this._frameCount--;
      this._bufs.push(buf.slice(4, frameLength + 4));
      buf = buf.slice(frameLength + 4);
    }
    if (this._frameCount) {
      this._buf = buf;
      cb();
      return;
    } else {
      var obj2 = { id: this._id, payload: this._bufs };
      this._bufs = [];
      this._id = void 0;
      this.push(obj2);
    }
  }
};
NettyDecoder.prototype._flush = FrameDecoder.prototype._flush;
function NettyEncoder() {
  stream$3.Transform.call(this, { writableObjectMode: true });
  this.on("finish", function() {
    this.push(null);
  });
}
util$2.inherits(NettyEncoder, stream$3.Transform);
NettyEncoder.prototype._transform = function(obj2, encoding, cb) {
  var bufs = obj2.payload;
  var l = bufs.length;
  var buf;
  buf = utils$d.newBuffer(8);
  buf.writeInt32BE(obj2.id, 0);
  buf.writeInt32BE(l, 4);
  this.push(buf);
  var i;
  for (i = 0; i < l; i++) {
    buf = bufs[i];
    this.push(intBuffer(buf.length));
    this.push(buf);
  }
  cb();
};
function intBuffer(n) {
  var buf = utils$d.newBuffer(4);
  buf.writeInt32BE(n);
  return buf;
}
function readHead(type, buf) {
  var tap = new Tap$1(buf);
  var head = type._read(tap);
  if (!tap.isValid()) {
    throw new Error(f$2("truncated %s", type));
  }
  return { head, tail: tap.buf.slice(tap.pos) };
}
function createReader$1(rtype, wtype) {
  return rtype.equals(wtype) ? rtype : rtype.createResolver(wtype);
}
function createReaders(clientSvc, serverSvc) {
  var obj2 = {};
  clientSvc.messages.forEach(function(c) {
    var n = c.name;
    var s2 = serverSvc.message(n);
    try {
      if (!s2) {
        throw new Error(f$2("missing server message: %s", n));
      }
      if (s2.oneWay !== c.oneWay) {
        throw new Error(f$2("inconsistent one-way message: %s", n));
      }
      obj2[n + "?"] = createReader$1(s2.requestType, c.requestType);
      obj2[n + "*"] = createReader$1(c.errorType, s2.errorType);
      obj2[n + "!"] = createReader$1(c.responseType, s2.responseType);
    } catch (cause) {
      throw toRpcError("INCOMPATIBLE_PROTOCOL", cause);
    }
  });
  return obj2;
}
function insertRemoteProtocols(cache, ptcls, svc, isClient) {
  Object.keys(ptcls).forEach(function(hash3) {
    var ptcl = ptcls[hash3];
    var clientSvc, serverSvc;
    if (isClient) {
      clientSvc = svc;
      serverSvc = Service.forProtocol(ptcl);
    } else {
      clientSvc = Service.forProtocol(ptcl);
      serverSvc = svc;
    }
    cache[hash3] = new Adapter(clientSvc, serverSvc, hash3, true);
  });
}
function getRemoteProtocols(cache, isClient) {
  var ptcls = {};
  Object.keys(cache).forEach(function(hs) {
    var adapter = cache[hs];
    if (adapter._isRemote) {
      var svc = isClient ? adapter._serverSvc : adapter._clientSvc;
      ptcls[hs] = svc.protocol;
    }
  });
  return ptcls;
}
function isError2(any2) {
  return !!any2 && Object.prototype.toString.call(any2) === "[object Error]";
}
function forwardErrors$1(src2, dst) {
  return src2.on("error", function(err) {
    dst.emit("error", err, src2);
  });
}
function toError(msg, cause) {
  var err = new Error(msg);
  err.cause = cause;
  return err;
}
function toRpcError(rpcCode, cause) {
  var err = toError(rpcCode.toLowerCase().replace(/_/g, " "), cause);
  err.rpcCode = cause && cause.rpcCode ? cause.rpcCode : rpcCode;
  return err;
}
function serializationError(msg, obj2, fields) {
  var details = [];
  var i, l, field;
  for (i = 0, l = fields.length; i < l; i++) {
    field = fields[i];
    field.type.isValid(obj2[field.name], { errorHook });
  }
  var detailsStr = details.map(function(obj3) {
    return f$2("%s = %j but expected %s", obj3.path, obj3.value, obj3.type);
  }).join(", ");
  var err = new Error(f$2("%s (%s)", msg, detailsStr));
  err.details = details;
  return err;
  function errorHook(parts, any2, type) {
    var strs = [];
    var i2, l2, part;
    for (i2 = 0, l2 = parts.length; i2 < l2; i2++) {
      part = parts[i2];
      if (isNaN(part)) {
        strs.push("." + part);
      } else {
        strs.push("[" + part + "]");
      }
    }
    details.push({
      path: field.name + strs.join(""),
      value: any2,
      type
    });
  }
}
function normalizedPrefix(scope) {
  return scope ? utils$d.getHash(scope).readInt16BE(0) << 32 - PREFIX_LENGTH : 0;
}
function matchesPrefix(id2, prefix) {
  return (id2 ^ prefix) >> 32 - PREFIX_LENGTH === 0;
}
function isStream$1(any2) {
  return !!(any2 && any2.pipe);
}
function getExistingMessage(svc, name2) {
  var msg = svc.message(name2);
  if (!msg) {
    throw new Error(f$2("unknown message: %s", name2));
  }
  return msg;
}
function chainMiddleware(params) {
  var args = [params.wreq, params.wres];
  var cbs = [];
  var cause;
  forward(0);
  function forward(pos) {
    var isDone = false;
    if (pos < params.fns.length) {
      params.fns[pos].apply(params.ctx, args.concat(function(err, cb) {
        if (isDone) {
          params.onError(toError("duplicate forward middleware call", err));
          return;
        }
        isDone = true;
        if (err || params.wres && (params.wres.error !== void 0 || params.wres.response !== void 0)) {
          cause = err;
          backward();
          return;
        }
        if (cb) {
          cbs.push(cb);
        }
        forward(++pos);
      }));
    } else {
      params.onTransition.apply(params.ctx, args.concat(function(err) {
        if (isDone) {
          params.onError(toError("duplicate handler call", err));
          return;
        }
        isDone = true;
        cause = err;
        process.nextTick(backward);
      }));
    }
  }
  function backward() {
    var cb = cbs.pop();
    if (cb) {
      var isDone = false;
      cb.call(params.ctx, cause, function(err) {
        if (isDone) {
          params.onError(toError("duplicate backward middleware call", err));
          return;
        }
        cause = err;
        isDone = true;
        backward();
      });
    } else {
      params.onCompletion.call(params.ctx, cause);
    }
  }
}
var services = {
  Adapter,
  HANDSHAKE_REQUEST_TYPE,
  HANDSHAKE_RESPONSE_TYPE,
  Message,
  Registry,
  Service,
  discoverProtocol,
  streams: {
    FrameDecoder,
    FrameEncoder,
    NettyDecoder,
    NettyEncoder
  }
};
function createError$1() {
  return new Error("unsupported in the browser");
}
function createImportHook() {
  return function(fpath, kind, cb) {
    cb(createError$1());
  };
}
function createSyncImportHook() {
  return function() {
    throw createError$1();
  };
}
var files$1 = {
  createImportHook,
  createSyncImportHook,
  existsSync: function() {
    return false;
  },
  readFileSync: function() {
    throw createError$1();
  }
};
var files = files$1, utils$c = utils$f, path2 = require$$0$3, util$1 = requireUtil();
var f$1 = util$1.format;
var TYPE_REFS = {
  date: { type: "int", logicalType: "date" },
  decimal: { type: "bytes", logicalType: "decimal" },
  time_ms: { type: "long", logicalType: "time-millis" },
  timestamp_ms: { type: "long", logicalType: "timestamp-millis" }
};
function assembleProtocol(fpath, opts, cb) {
  if (!cb && typeof opts == "function") {
    cb = opts;
    opts = void 0;
  }
  opts = opts || {};
  if (!opts.importHook) {
    opts.importHook = files.createImportHook();
  }
  var importedTypes = [];
  var protocol, imports;
  opts.importHook(fpath, "idl", function(err, str) {
    if (err) {
      cb(err);
      return;
    }
    if (str === void 0) {
      cb(null, {});
      return;
    }
    try {
      var reader = new Reader$1(str, opts);
      var obj2 = reader._readProtocol(str, opts);
    } catch (err2) {
      err2.path = fpath;
      cb(err2);
      return;
    }
    protocol = obj2.protocol;
    imports = obj2.imports;
    fetchImports();
  });
  function fetchImports() {
    var info = imports.shift();
    if (!info) {
      if (importedTypes.length) {
        protocol.types = protocol.types ? importedTypes.concat(protocol.types) : importedTypes;
      }
      cb(null, protocol);
    } else {
      var importPath = path2.join(path2.dirname(fpath), info.name);
      if (info.kind === "idl") {
        assembleProtocol(importPath, opts, mergeImportedSchema);
      } else {
        opts.importHook(importPath, info.kind, function(err, str) {
          if (err) {
            cb(err);
            return;
          }
          switch (info.kind) {
            case "protocol":
            case "schema":
              if (str === void 0) {
                mergeImportedSchema(null, {});
                return;
              }
              try {
                var obj2 = JSON.parse(str);
              } catch (err2) {
                err2.path = importPath;
                cb(err2);
                return;
              }
              var schema = info.kind === "schema" ? { types: [obj2] } : obj2;
              mergeImportedSchema(null, schema);
              break;
            default:
              cb(new Error(f$1("invalid import kind: %s", info.kind)));
          }
        });
      }
    }
  }
  function mergeImportedSchema(err, importedSchema) {
    if (err) {
      cb(err);
      return;
    }
    (importedSchema.types || []).forEach(function(typeSchema) {
      if (typeSchema.namespace === void 0) {
        var namespace = importedSchema.namespace;
        if (!namespace) {
          var match = /^(.*)\.[^.]+$/.exec(importedSchema.protocol);
          if (match) {
            namespace = match[1];
          }
        }
        typeSchema.namespace = namespace || "";
      }
      importedTypes.push(typeSchema);
    });
    try {
      Object.keys(importedSchema.messages || {}).forEach(function(name2) {
        if (!protocol.messages) {
          protocol.messages = {};
        }
        if (protocol.messages[name2]) {
          throw new Error(f$1("duplicate message: %s", name2));
        }
        protocol.messages[name2] = importedSchema.messages[name2];
      });
    } catch (err2) {
      cb(err2);
      return;
    }
    fetchImports();
  }
}
function read$1(str) {
  var schema;
  if (typeof str == "string" && ~str.indexOf(path2.sep) && files.existsSync(str)) {
    var contents = files.readFileSync(str, { encoding: "utf8" });
    try {
      return JSON.parse(contents);
    } catch (err) {
      var opts = { importHook: files.createSyncImportHook() };
      assembleProtocol(str, opts, function(err2, protocolSchema) {
        schema = err2 ? contents : protocolSchema;
      });
    }
  } else {
    schema = str;
  }
  if (typeof schema != "string" || schema === "null") {
    return schema;
  }
  try {
    return JSON.parse(schema);
  } catch (err) {
    try {
      return Reader$1.readProtocol(schema);
    } catch (err2) {
      try {
        return Reader$1.readSchema(schema);
      } catch (err3) {
        return schema;
      }
    }
  }
}
function Reader$1(str, opts) {
  opts = opts || {};
  this._tk = new Tokenizer(str);
  this._ackVoidMessages = !!opts.ackVoidMessages;
  this._implicitTags = !opts.delimitedCollections;
  this._typeRefs = opts.typeRefs || TYPE_REFS;
}
Reader$1.readProtocol = function(str, opts) {
  var reader = new Reader$1(str, opts);
  var protocol = reader._readProtocol();
  if (protocol.imports.length) {
    throw new Error("unresolvable import");
  }
  return protocol.protocol;
};
Reader$1.readSchema = function(str, opts) {
  var reader = new Reader$1(str, opts);
  var javadoc = reader._readJavadoc();
  var schema = reader._readType(javadoc === void 0 ? {} : { doc: javadoc });
  reader._tk.next({ id: "(eof)" });
  return schema;
};
Reader$1.prototype._readProtocol = function() {
  var tk = this._tk;
  var imports = [];
  var types2 = [];
  var messages = {};
  var pos;
  this._readImports(imports);
  var protocolSchema = {};
  var protocolJavadoc = this._readJavadoc();
  if (protocolJavadoc !== void 0) {
    protocolSchema.doc = protocolJavadoc;
  }
  this._readAnnotations(protocolSchema);
  tk.next({ val: "protocol" });
  if (!tk.next({ val: "{", silent: true })) {
    protocolSchema.protocol = tk.next({ id: "name" }).val;
    tk.next({ val: "{" });
  }
  while (!tk.next({ val: "}", silent: true })) {
    if (!this._readImports(imports)) {
      var javadoc = this._readJavadoc();
      var typeSchema = this._readType();
      var numImports = this._readImports(imports, true);
      var message = void 0;
      pos = tk.pos;
      if (!numImports && (message = this._readMessage(typeSchema))) {
        if (javadoc !== void 0 && message.schema.doc === void 0) {
          message.schema.doc = javadoc;
        }
        var oneWay = false;
        if (message.schema.response === "void" || message.schema.response.type === "void") {
          oneWay = !this._ackVoidMessages && !message.schema.errors;
          if (message.schema.response === "void") {
            message.schema.response = "null";
          } else {
            message.schema.response.type = "null";
          }
        }
        if (oneWay) {
          message.schema["one-way"] = true;
        }
        if (messages[message.name]) {
          throw new Error(f$1("duplicate message: %s", message.name));
        }
        messages[message.name] = message.schema;
      } else {
        if (javadoc) {
          if (typeof typeSchema == "string") {
            typeSchema = { doc: javadoc, type: typeSchema };
          } else if (typeSchema.doc === void 0) {
            typeSchema.doc = javadoc;
          }
        }
        types2.push(typeSchema);
        tk.pos = pos;
        tk.next({ val: ";", silent: true });
      }
      javadoc = void 0;
    }
  }
  tk.next({ id: "(eof)" });
  if (types2.length) {
    protocolSchema.types = types2;
  }
  if (Object.keys(messages).length) {
    protocolSchema.messages = messages;
  }
  return { protocol: protocolSchema, imports };
};
Reader$1.prototype._readAnnotations = function(schema) {
  var tk = this._tk;
  while (tk.next({ val: "@", silent: true })) {
    var parts = [];
    while (!tk.next({ val: "(", silent: true })) {
      parts.push(tk.next().val);
    }
    schema[parts.join("")] = tk.next({ id: "json" }).val;
    tk.next({ val: ")" });
  }
};
Reader$1.prototype._readMessage = function(responseSchema) {
  var tk = this._tk;
  var schema = { request: [], response: responseSchema };
  this._readAnnotations(schema);
  var name2 = tk.next().val;
  if (tk.next().val !== "(") {
    return;
  }
  if (!tk.next({ val: ")", silent: true })) {
    do {
      schema.request.push(this._readField());
    } while (!tk.next({ val: ")", silent: true }) && tk.next({ val: "," }));
  }
  var token = tk.next();
  switch (token.val) {
    case "throws":
      schema.errors = [];
      do {
        schema.errors.push(this._readType());
      } while (!tk.next({ val: ";", silent: true }) && tk.next({ val: "," }));
      break;
    case "oneway":
      schema["one-way"] = true;
      tk.next({ val: ";" });
      break;
    case ";":
      break;
    default:
      throw tk.error("invalid message suffix", token);
  }
  return { name: name2, schema };
};
Reader$1.prototype._readJavadoc = function() {
  var token = this._tk.next({ id: "javadoc", emitJavadoc: true, silent: true });
  if (token) {
    return token.val;
  }
};
Reader$1.prototype._readField = function() {
  var tk = this._tk;
  var javadoc = this._readJavadoc();
  var schema = { type: this._readType() };
  if (javadoc !== void 0 && schema.doc === void 0) {
    schema.doc = javadoc;
  }
  this._readAnnotations(schema);
  schema.name = tk.next({ id: "name" }).val;
  if (tk.next({ val: "=", silent: true })) {
    schema["default"] = tk.next({ id: "json" }).val;
  }
  return schema;
};
Reader$1.prototype._readType = function(schema) {
  schema = schema || {};
  this._readAnnotations(schema);
  schema.type = this._tk.next({ id: "name" }).val;
  switch (schema.type) {
    case "record":
    case "error":
      return this._readRecord(schema);
    case "fixed":
      return this._readFixed(schema);
    case "enum":
      return this._readEnum(schema);
    case "map":
      return this._readMap(schema);
    case "array":
      return this._readArray(schema);
    case "union":
      if (Object.keys(schema).length > 1) {
        throw new Error("union annotations are not supported");
      }
      return this._readUnion();
    default:
      var ref = this._typeRefs[schema.type];
      if (ref) {
        delete schema.type;
        utils$c.copyOwnProperties(ref, schema);
      }
      return Object.keys(schema).length > 1 ? schema : schema.type;
  }
};
Reader$1.prototype._readFixed = function(schema) {
  var tk = this._tk;
  if (!tk.next({ val: "(", silent: true })) {
    schema.name = tk.next({ id: "name" }).val;
    tk.next({ val: "(" });
  }
  schema.size = parseInt(tk.next({ id: "number" }).val);
  tk.next({ val: ")" });
  return schema;
};
Reader$1.prototype._readMap = function(schema) {
  var tk = this._tk;
  var silent = this._implicitTags;
  var implicitTags = tk.next({ val: "<", silent }) === void 0;
  schema.values = this._readType();
  tk.next({ val: ">", silent: implicitTags });
  return schema;
};
Reader$1.prototype._readArray = function(schema) {
  var tk = this._tk;
  var silent = this._implicitTags;
  var implicitTags = tk.next({ val: "<", silent }) === void 0;
  schema.items = this._readType();
  tk.next({ val: ">", silent: implicitTags });
  return schema;
};
Reader$1.prototype._readEnum = function(schema) {
  var tk = this._tk;
  if (!tk.next({ val: "{", silent: true })) {
    schema.name = tk.next({ id: "name" }).val;
    tk.next({ val: "{" });
  }
  schema.symbols = [];
  do {
    schema.symbols.push(tk.next().val);
  } while (!tk.next({ val: "}", silent: true }) && tk.next({ val: "," }));
  return schema;
};
Reader$1.prototype._readUnion = function() {
  var tk = this._tk;
  var arr = [];
  tk.next({ val: "{" });
  do {
    arr.push(this._readType());
  } while (!tk.next({ val: "}", silent: true }) && tk.next({ val: "," }));
  return arr;
};
Reader$1.prototype._readRecord = function(schema) {
  var tk = this._tk;
  if (!tk.next({ val: "{", silent: true })) {
    schema.name = tk.next({ id: "name" }).val;
    tk.next({ val: "{" });
  }
  schema.fields = [];
  while (!tk.next({ val: "}", silent: true })) {
    schema.fields.push(this._readField());
    tk.next({ val: ";" });
  }
  return schema;
};
Reader$1.prototype._readImports = function(imports, maybeMessage) {
  var tk = this._tk;
  var numImports = 0;
  var pos = tk.pos;
  while (tk.next({ val: "import", silent: true })) {
    if (!numImports && maybeMessage && tk.next({ val: "(", silent: true })) {
      tk.pos = pos;
      return;
    }
    var kind = tk.next({ id: "name" }).val;
    var fname = JSON.parse(tk.next({ id: "string" }).val);
    tk.next({ val: ";" });
    imports.push({ kind, name: fname });
    numImports++;
  }
  return numImports;
};
function Tokenizer(str) {
  this._str = str;
  this.pos = 0;
}
Tokenizer.prototype.next = function(opts) {
  var token = { pos: this.pos, id: void 0, val: void 0 };
  var javadoc = this._skip(opts && opts.emitJavadoc);
  if (javadoc) {
    token.id = "javadoc";
    token.val = javadoc;
  } else {
    var pos = this.pos;
    var str = this._str;
    var c = str.charAt(pos);
    if (!c) {
      token.id = "(eof)";
    } else {
      if (opts && opts.id === "json") {
        token.id = "json";
        this.pos = this._endOfJson();
      } else if (c === '"') {
        token.id = "string";
        this.pos = this._endOfString();
      } else if (/[0-9]/.test(c)) {
        token.id = "number";
        this.pos = this._endOf(/[0-9]/);
      } else if (/[`A-Za-z_.]/.test(c)) {
        token.id = "name";
        this.pos = this._endOf(/[`A-Za-z0-9_.]/);
      } else {
        token.id = "operator";
        this.pos = pos + 1;
      }
      token.val = str.slice(pos, this.pos);
      if (token.id === "json") {
        try {
          token.val = JSON.parse(token.val);
        } catch (err2) {
          throw this.error("invalid JSON", token);
        }
      } else if (token.id === "name") {
        token.val = token.val.replace(/`/g, "");
      }
    }
  }
  var err;
  if (opts && opts.id && opts.id !== token.id) {
    err = this.error(f$1("expected ID %s", opts.id), token);
  } else if (opts && opts.val && opts.val !== token.val) {
    err = this.error(f$1("expected value %s", opts.val), token);
  }
  if (!err) {
    return token;
  } else if (opts && opts.silent) {
    this.pos = token.pos;
    return void 0;
  } else {
    throw err;
  }
};
Tokenizer.prototype.error = function(reason, context) {
  var isToken = typeof context != "number";
  var pos = isToken ? context.pos : context;
  var str = this._str;
  var lineNum = 1;
  var lineStart = 0;
  var i;
  for (i = 0; i < pos; i++) {
    if (str.charAt(i) === "\n") {
      lineNum++;
      lineStart = i;
    }
  }
  var msg = isToken ? f$1("invalid token %j: %s", context, reason) : reason;
  var err = new Error(msg);
  err.token = isToken ? context : void 0;
  err.lineNum = lineNum;
  err.colNum = pos - lineStart;
  return err;
};
Tokenizer.prototype._skip = function(emitJavadoc) {
  var str = this._str;
  var isJavadoc = false;
  var pos, c;
  while ((c = str.charAt(this.pos)) && /\s/.test(c)) {
    this.pos++;
  }
  pos = this.pos;
  if (c === "/") {
    switch (str.charAt(this.pos + 1)) {
      case "/":
        this.pos += 2;
        while ((c = str.charAt(this.pos)) && c !== "\n") {
          this.pos++;
        }
        return this._skip(emitJavadoc);
      case "*":
        this.pos += 2;
        if (str.charAt(this.pos) === "*") {
          isJavadoc = true;
        }
        while (c = str.charAt(this.pos++)) {
          if (c === "*" && str.charAt(this.pos) === "/") {
            this.pos++;
            if (isJavadoc && emitJavadoc) {
              return extractJavadoc(str.slice(pos + 3, this.pos - 2));
            }
            return this._skip(emitJavadoc);
          }
        }
        throw this.error("unterminated comment", pos);
    }
  }
};
Tokenizer.prototype._endOf = function(pat) {
  var pos = this.pos;
  var str = this._str;
  while (pat.test(str.charAt(pos))) {
    pos++;
  }
  return pos;
};
Tokenizer.prototype._endOfString = function() {
  var pos = this.pos + 1;
  var str = this._str;
  var c;
  while (c = str.charAt(pos)) {
    if (c === '"') {
      return pos + 1;
    }
    if (c === "\\") {
      pos += 2;
    } else {
      pos++;
    }
  }
  throw this.error("unterminated string", pos - 1);
};
Tokenizer.prototype._endOfJson = function() {
  var pos = utils$c.jsonEnd(this._str, this.pos);
  if (pos < 0) {
    throw this.error("invalid JSON", pos);
  }
  return pos;
};
function extractJavadoc(str) {
  var lines = str.replace(/^[ \t]+|[ \t]+$/g, "").split("\n").map(function(line, i) {
    return i ? line.replace(/^\s*\*\s?/, "") : line;
  });
  while (!lines[0]) {
    lines.shift();
  }
  while (!lines[lines.length - 1]) {
    lines.pop();
  }
  return lines.join("\n");
}
var specs = {
  Tokenizer,
  assembleProtocol,
  read: read$1,
  readProtocol: Reader$1.readProtocol,
  readSchema: Reader$1.readSchema
};
(function(module) {
  var avroTypes = avscTypes, services$1 = services, specs$1 = specs, utils2 = utils$f;
  function parse2(any2, opts) {
    var schemaOrProtocol = specs$1.read(any2);
    return schemaOrProtocol.protocol ? services$1.Service.forProtocol(schemaOrProtocol, opts) : avroTypes.Type.forSchema(schemaOrProtocol, opts);
  }
  module.exports = {
    Service: services$1.Service,
    assembleProtocol: specs$1.assembleProtocol,
    discoverProtocol: services$1.discoverProtocol,
    parse: parse2,
    readProtocol: specs$1.readProtocol,
    readSchema: specs$1.readSchema
  };
  utils2.copyOwnProperties(avroTypes, module.exports);
})(avscServices);
var types = types$3, utils$b = utils$f, stream$2 = streamBrowserify, util = requireUtil(), zlib = require$$0$3;
var OPTS = { namespace: "org.apache.avro.file" };
var LONG_TYPE = types.Type.forSchema("long", OPTS);
var MAP_BYTES_TYPE = types.Type.forSchema({ type: "map", values: "bytes" }, OPTS);
var HEADER_TYPE = types.Type.forSchema({
  name: "Header",
  type: "record",
  fields: [
    { name: "magic", type: { type: "fixed", name: "Magic", size: 4 } },
    { name: "meta", type: MAP_BYTES_TYPE },
    { name: "sync", type: { type: "fixed", name: "Sync", size: 16 } }
  ]
}, OPTS);
var BLOCK_TYPE = types.Type.forSchema({
  name: "Block",
  type: "record",
  fields: [
    { name: "count", type: "long" },
    { name: "data", type: "bytes" },
    { name: "sync", type: "Sync" }
  ]
}, OPTS);
var MAGIC_BYTES = utils$b.bufferFrom("Obj");
var f = util.format;
var Tap = utils$b.Tap;
function RawDecoder(schema, opts) {
  opts = opts || {};
  var noDecode = !!opts.noDecode;
  stream$2.Duplex.call(this, {
    readableObjectMode: !noDecode,
    allowHalfOpen: false
  });
  this._type = types.Type.forSchema(schema);
  this._tap = new Tap(utils$b.newBuffer(0));
  this._writeCb = null;
  this._needPush = false;
  this._readValue = createReader(noDecode, this._type);
  this._finished = false;
  this.on("finish", function() {
    this._finished = true;
    this._read();
  });
}
util.inherits(RawDecoder, stream$2.Duplex);
RawDecoder.prototype._write = function(chunk, encoding, cb) {
  this._writeCb = cb;
  var tap = this._tap;
  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);
  tap.pos = 0;
  if (this._needPush) {
    this._needPush = false;
    this._read();
  }
};
RawDecoder.prototype._read = function() {
  this._needPush = false;
  var tap = this._tap;
  var pos = tap.pos;
  var val = this._readValue(tap);
  if (tap.isValid()) {
    this.push(val);
  } else if (!this._finished) {
    tap.pos = pos;
    this._needPush = true;
    if (this._writeCb) {
      this._writeCb();
    }
  } else {
    this.push(null);
  }
};
function BlockDecoder(opts) {
  opts = opts || {};
  var noDecode = !!opts.noDecode;
  stream$2.Duplex.call(this, {
    allowHalfOpen: true,
    readableObjectMode: !noDecode
  });
  this._rType = opts.readerSchema !== void 0 ? types.Type.forSchema(opts.readerSchema) : void 0;
  this._wType = null;
  this._codecs = opts.codecs;
  this._codec = void 0;
  this._parseHook = opts.parseHook;
  this._tap = new Tap(utils$b.newBuffer(0));
  this._blockTap = new Tap(utils$b.newBuffer(0));
  this._syncMarker = null;
  this._readValue = null;
  this._noDecode = noDecode;
  this._queue = new utils$b.OrderedQueue();
  this._decompress = null;
  this._index = 0;
  this._remaining = void 0;
  this._needPush = false;
  this._finished = false;
  this.on("finish", function() {
    this._finished = true;
    if (this._needPush) {
      this._read();
    }
  });
}
util.inherits(BlockDecoder, stream$2.Duplex);
BlockDecoder.defaultCodecs = function() {
  return {
    "null": function(buf, cb) {
      cb(null, buf);
    },
    "deflate": zlib.inflateRaw
  };
};
BlockDecoder.getDefaultCodecs = BlockDecoder.defaultCodecs;
BlockDecoder.prototype._decodeHeader = function() {
  var tap = this._tap;
  if (tap.buf.length < MAGIC_BYTES.length) {
    return false;
  }
  if (!MAGIC_BYTES.equals(tap.buf.slice(0, MAGIC_BYTES.length))) {
    this.emit("error", new Error("invalid magic bytes"));
    return false;
  }
  var header = HEADER_TYPE._read(tap);
  if (!tap.isValid()) {
    return false;
  }
  this._codec = (header.meta["avro.codec"] || "null").toString();
  var codecs = this._codecs || BlockDecoder.getDefaultCodecs();
  this._decompress = codecs[this._codec];
  if (!this._decompress) {
    this.emit("error", new Error(f("unknown codec: %s", this._codec)));
    return;
  }
  try {
    var schema = JSON.parse(header.meta["avro.schema"].toString());
    if (this._parseHook) {
      schema = this._parseHook(schema);
    }
    this._wType = types.Type.forSchema(schema);
  } catch (err) {
    this.emit("error", err);
    return;
  }
  this._readValue = createReader(this._noDecode, this._wType, this._rType);
  this._syncMarker = header.sync;
  this.emit("metadata", this._wType, this._codec, header);
  return true;
};
BlockDecoder.prototype._write = function(chunk, encoding, cb) {
  var tap = this._tap;
  tap.buf = Buffer.concat([tap.buf, chunk]);
  tap.pos = 0;
  if (!this._decodeHeader()) {
    process.nextTick(cb);
    return;
  }
  this._write = this._writeChunk;
  this._write(utils$b.newBuffer(0), encoding, cb);
};
BlockDecoder.prototype._writeChunk = function(chunk, encoding, cb) {
  var tap = this._tap;
  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);
  tap.pos = 0;
  var nBlocks = 1;
  var block;
  while (block = tryReadBlock(tap)) {
    if (!this._syncMarker.equals(block.sync)) {
      this.emit("error", new Error("invalid sync marker"));
      return;
    }
    nBlocks++;
    this._decompress(
      block.data,
      this._createBlockCallback(block.count, chunkCb)
    );
  }
  chunkCb();
  function chunkCb() {
    if (!--nBlocks) {
      cb();
    }
  }
};
BlockDecoder.prototype._createBlockCallback = function(count, cb) {
  var self2 = this;
  var index2 = this._index++;
  return function(cause, data2) {
    if (cause) {
      var err = new Error(f("%s codec decompression error", self2._codec));
      err.cause = cause;
      self2.emit("error", err);
      cb();
    } else {
      self2._queue.push(new BlockData(index2, data2, cb, count));
      if (self2._needPush) {
        self2._read();
      }
    }
  };
};
BlockDecoder.prototype._read = function() {
  this._needPush = false;
  var tap = this._blockTap;
  if (!this._remaining) {
    var data2 = this._queue.pop();
    if (!data2 || !data2.count) {
      if (this._finished) {
        this.push(null);
      } else {
        this._needPush = true;
      }
      if (data2) {
        data2.cb();
      }
      return;
    }
    data2.cb();
    this._remaining = data2.count;
    tap.buf = data2.buf;
    tap.pos = 0;
  }
  this._remaining--;
  this.push(this._readValue(tap));
};
function RawEncoder(schema, opts) {
  opts = opts || {};
  stream$2.Transform.call(this, {
    writableObjectMode: true,
    allowHalfOpen: false
  });
  this._type = types.Type.forSchema(schema);
  this._writeValue = function(tap, val) {
    try {
      this._type._write(tap, val);
    } catch (err) {
      this.emit("error", err);
    }
  };
  this._tap = new Tap(utils$b.newBuffer(opts.batchSize || 65536));
}
util.inherits(RawEncoder, stream$2.Transform);
RawEncoder.prototype._transform = function(val, encoding, cb) {
  var tap = this._tap;
  var buf = tap.buf;
  var pos = tap.pos;
  this._writeValue(tap, val);
  if (!tap.isValid()) {
    if (pos) {
      this.push(copyBuffer(tap.buf, 0, pos));
    }
    var len = tap.pos - pos;
    if (len > buf.length) {
      tap.buf = utils$b.newBuffer(2 * len);
    }
    tap.pos = 0;
    this._writeValue(tap, val);
  }
  cb();
};
RawEncoder.prototype._flush = function(cb) {
  var tap = this._tap;
  var pos = tap.pos;
  if (pos) {
    this.push(tap.buf.slice(0, pos));
  }
  cb();
};
function BlockEncoder(schema, opts) {
  opts = opts || {};
  stream$2.Duplex.call(this, {
    allowHalfOpen: true,
    writableObjectMode: true
  });
  var type;
  if (types.Type.isType(schema)) {
    type = schema;
    schema = void 0;
  } else {
    type = types.Type.forSchema(schema);
  }
  this._schema = schema;
  this._type = type;
  this._writeValue = function(tap, val) {
    try {
      this._type._write(tap, val);
    } catch (err) {
      this.emit("error", err);
    }
  };
  this._blockSize = opts.blockSize || 65536;
  this._tap = new Tap(utils$b.newBuffer(this._blockSize));
  this._codecs = opts.codecs;
  this._codec = opts.codec || "null";
  this._blockCount = 0;
  this._syncMarker = opts.syncMarker || new utils$b.Lcg().nextBuffer(16);
  this._queue = new utils$b.OrderedQueue();
  this._pending = 0;
  this._finished = false;
  this._needHeader = false;
  this._needPush = false;
  this._metadata = opts.metadata || {};
  if (!MAP_BYTES_TYPE.isValid(this._metadata)) {
    throw new Error("invalid metadata");
  }
  var codec = this._codec;
  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];
  if (!this._compress) {
    throw new Error(f("unsupported codec: %s", codec));
  }
  if (opts.omitHeader !== void 0) {
    opts.writeHeader = opts.omitHeader ? "never" : "auto";
  }
  switch (opts.writeHeader) {
    case false:
    case "never":
      break;
    case void 0:
    case "auto":
      this._needHeader = true;
      break;
    default:
      this._writeHeader();
  }
  this.on("finish", function() {
    this._finished = true;
    if (this._blockCount) {
      this._flushChunk();
    } else if (this._finished && this._needPush) {
      this.push(null);
    }
  });
}
util.inherits(BlockEncoder, stream$2.Duplex);
BlockEncoder.defaultCodecs = function() {
  return {
    "null": function(buf, cb) {
      cb(null, buf);
    },
    "deflate": zlib.deflateRaw
  };
};
BlockEncoder.getDefaultCodecs = BlockEncoder.defaultCodecs;
BlockEncoder.prototype._writeHeader = function() {
  var schema = JSON.stringify(
    this._schema ? this._schema : this._type.getSchema({ exportAttrs: true })
  );
  var meta = utils$b.copyOwnProperties(
    this._metadata,
    { "avro.schema": utils$b.bufferFrom(schema), "avro.codec": utils$b.bufferFrom(this._codec) },
    true
  );
  var Header = HEADER_TYPE.getRecordConstructor();
  var header = new Header(MAGIC_BYTES, meta, this._syncMarker);
  this.push(header.toBuffer());
};
BlockEncoder.prototype._write = function(val, encoding, cb) {
  if (this._needHeader) {
    this._writeHeader();
    this._needHeader = false;
  }
  var tap = this._tap;
  var pos = tap.pos;
  var flushing = false;
  this._writeValue(tap, val);
  if (!tap.isValid()) {
    if (pos) {
      this._flushChunk(pos, cb);
      flushing = true;
    }
    var len = tap.pos - pos;
    if (len > this._blockSize) {
      this._blockSize = len * 2;
    }
    tap.buf = utils$b.newBuffer(this._blockSize);
    tap.pos = 0;
    this._writeValue(tap, val);
  }
  this._blockCount++;
  if (!flushing) {
    cb();
  }
};
BlockEncoder.prototype._flushChunk = function(pos, cb) {
  var tap = this._tap;
  pos = pos || tap.pos;
  this._compress(tap.buf.slice(0, pos), this._createBlockCallback(cb));
  this._blockCount = 0;
};
BlockEncoder.prototype._read = function() {
  var self2 = this;
  var data2 = this._queue.pop();
  if (!data2) {
    if (this._finished && !this._pending) {
      process.nextTick(function() {
        self2.push(null);
      });
    } else {
      this._needPush = true;
    }
    return;
  }
  this.push(LONG_TYPE.toBuffer(data2.count, true));
  this.push(LONG_TYPE.toBuffer(data2.buf.length, true));
  this.push(data2.buf);
  this.push(this._syncMarker);
  if (!this._finished) {
    data2.cb();
  }
};
BlockEncoder.prototype._createBlockCallback = function(cb) {
  var self2 = this;
  var index2 = this._index++;
  var count = this._blockCount;
  this._pending++;
  return function(cause, data2) {
    if (cause) {
      var err = new Error(f("%s codec compression error", self2._codec));
      err.cause = cause;
      self2.emit("error", err);
      return;
    }
    self2._pending--;
    self2._queue.push(new BlockData(index2, data2, cb, count));
    if (self2._needPush) {
      self2._needPush = false;
      self2._read();
    }
  };
};
function BlockData(index2, buf, cb, count) {
  this.index = index2;
  this.buf = buf;
  this.cb = cb;
  this.count = count | 0;
}
function tryReadBlock(tap) {
  var pos = tap.pos;
  var block = BLOCK_TYPE._read(tap);
  if (!tap.isValid()) {
    tap.pos = pos;
    return null;
  }
  return block;
}
function createReader(noDecode, writerType, readerType) {
  if (noDecode) {
    return function(skipper) {
      return function(tap) {
        var pos = tap.pos;
        skipper(tap);
        return tap.buf.slice(pos, tap.pos);
      };
    }(writerType._skip);
  } else if (readerType) {
    var resolver = readerType.createResolver(writerType);
    return function(tap) {
      return resolver._read(tap);
    };
  } else {
    return function(tap) {
      return writerType._read(tap);
    };
  }
}
function copyBuffer(buf, pos, len) {
  var copy = utils$b.newBuffer(len);
  buf.copy(copy, 0, pos, pos + len);
  return copy;
}
var containers = {
  BLOCK_TYPE,
  HEADER_TYPE,
  MAGIC_BYTES,
  streams: {
    BlockDecoder,
    BlockEncoder,
    RawDecoder,
    RawEncoder
  }
};
(function(module) {
  var avroServices = avscServices.exports, containers$1 = containers, utils2 = utils$f, stream2 = streamBrowserify, util2 = requireUtil();
  function BlobReader(blob, opts) {
    stream2.Readable.call(this);
    opts = opts || {};
    this._batchSize = opts.batchSize || 65536;
    this._blob = blob;
    this._pos = 0;
  }
  util2.inherits(BlobReader, stream2.Readable);
  BlobReader.prototype._read = function() {
    var pos = this._pos;
    if (pos >= this._blob.size) {
      this.push(null);
      return;
    }
    this._pos += this._batchSize;
    var blob = this._blob.slice(pos, this._pos, this._blob.type);
    var reader = new FileReader();
    var self2 = this;
    reader.addEventListener("loadend", function cb(evt) {
      reader.removeEventListener("loadend", cb, false);
      if (evt.error) {
        self2.emit("error", evt.error);
      } else {
        self2.push(utils2.bufferFrom(reader.result));
      }
    }, false);
    reader.readAsArrayBuffer(blob);
  };
  function BlobWriter() {
    stream2.Transform.call(this, { readableObjectMode: true });
    this._bufs = [];
  }
  util2.inherits(BlobWriter, stream2.Transform);
  BlobWriter.prototype._transform = function(buf, encoding, cb) {
    this._bufs.push(buf);
    cb();
  };
  BlobWriter.prototype._flush = function(cb) {
    this.push(new Blob(this._bufs, { type: "application/octet-binary" }));
    cb();
  };
  function createBlobDecoder(blob, opts) {
    return new BlobReader(blob).pipe(new containers$1.streams.BlockDecoder(opts));
  }
  function createBlobEncoder(schema, opts) {
    var encoder = new containers$1.streams.BlockEncoder(schema, opts);
    var builder = new BlobWriter();
    encoder.pipe(builder);
    return new stream2.Duplex({
      objectMode: true,
      read: function() {
        var val = builder.read();
        if (val) {
          done2(val);
        } else {
          builder.once("readable", done2);
        }
        var self2 = this;
        function done2(val2) {
          self2.push(val2 || builder.read());
          self2.push(null);
        }
      },
      write: function(val, encoding, cb) {
        return encoder.write(val, encoding, cb);
      }
    }).on("finish", function() {
      encoder.end();
    });
  }
  module.exports = {
    createBlobDecoder,
    createBlobEncoder,
    streams: containers$1.streams
  };
  utils2.copyOwnProperties(avroServices, module.exports);
})(avsc);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.serializeTags = exports2.tagsParser = exports2.tagParser = void 0;
  const avro = __importStar2(avsc.exports);
  exports2.tagParser = avro.Type.forSchema({
    type: "record",
    name: "Tag",
    fields: [
      { name: "name", type: "string" },
      { name: "value", type: "string" }
    ]
  });
  exports2.tagsParser = avro.Type.forSchema({
    type: "array",
    items: exports2.tagParser
  });
  function serializeTags(tags2) {
    if (tags2.length == 0) {
      return new Uint8Array(0);
    }
    let tagsBuffer;
    try {
      tagsBuffer = exports2.tagsParser.toBuffer(tags2);
    } catch (e) {
      throw new Error("Incorrect tag format used. Make sure your tags are { name: string!, value: string! }[]");
    }
    return Uint8Array.from(tagsBuffer);
  }
  exports2.serializeTags = serializeTags;
})(parser);
var signing = {};
var Signer$2 = {};
Object.defineProperty(Signer$2, "__esModule", { value: true });
Signer$2.Signer = void 0;
class Signer$1 {
  static verify(_) {
    throw new Error("You must implement verify method on child");
  }
}
Signer$2.Signer = Signer$1;
var constants$1 = {};
var curve25519 = {};
var lib$1 = {};
(function(exports2) {
  /*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.utils = exports2.curve25519 = exports2.getSharedSecret = exports2.sync = exports2.verify = exports2.sign = exports2.getPublicKey = exports2.Signature = exports2.Point = exports2.RistrettoPoint = exports2.ExtendedPoint = exports2.CURVE = void 0;
  const nodeCrypto = requireCryptoBrowserify();
  const _0n = BigInt(0);
  const _1n = BigInt(1);
  const _2n = BigInt(2);
  const _255n = BigInt(255);
  const CURVE_ORDER = _2n ** BigInt(252) + BigInt("27742317777372353535851937790883648493");
  const CURVE = Object.freeze({
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    P: _2n ** _255n - BigInt(19),
    l: CURVE_ORDER,
    n: CURVE_ORDER,
    h: BigInt(8),
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
  });
  exports2.CURVE = CURVE;
  const MAX_256B = _2n ** BigInt(256);
  const SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
  const SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  const INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  const ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  const D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  class ExtendedPoint {
    constructor(x, y, z, t) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.t = t;
    }
    static fromAffine(p) {
      if (!(p instanceof Point2)) {
        throw new TypeError("ExtendedPoint#fromAffine: expected Point");
      }
      if (p.equals(Point2.ZERO))
        return ExtendedPoint.ZERO;
      return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
    }
    static toAffineBatch(points) {
      const toInv = invertBatch(points.map((p) => p.z));
      return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
      return this.toAffineBatch(points).map(this.fromAffine);
    }
    equals(other) {
      assertExtPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      const X1Z2 = mod(X1 * Z2);
      const X2Z1 = mod(X2 * Z1);
      const Y1Z2 = mod(Y1 * Z2);
      const Y2Z1 = mod(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    negate() {
      return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
    }
    double() {
      const { x: X1, y: Y1, z: Z1 } = this;
      const { a } = CURVE;
      const A = mod(X1 ** _2n);
      const B = mod(Y1 ** _2n);
      const C = mod(_2n * mod(Z1 ** _2n));
      const D = mod(a * A);
      const E = mod(mod((X1 + Y1) ** _2n) - A - B);
      const G2 = D + B;
      const F = G2 - C;
      const H = D - B;
      const X3 = mod(E * F);
      const Y3 = mod(G2 * H);
      const T3 = mod(E * H);
      const Z3 = mod(F * G2);
      return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    add(other) {
      assertExtPoint(other);
      const { x: X1, y: Y1, z: Z1, t: T1 } = this;
      const { x: X2, y: Y2, z: Z2, t: T2 } = other;
      const A = mod((Y1 - X1) * (Y2 + X2));
      const B = mod((Y1 + X1) * (Y2 - X2));
      const F = mod(B - A);
      if (F === _0n)
        return this.double();
      const C = mod(Z1 * _2n * T2);
      const D = mod(T1 * _2n * Z2);
      const E = D + C;
      const G2 = B + A;
      const H = D - C;
      const X3 = mod(E * F);
      const Y3 = mod(G2 * H);
      const T3 = mod(E * H);
      const Z3 = mod(F * G2);
      return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    precomputeWindow(W2) {
      const windows = 1 + 256 / W2;
      const points = [];
      let p = this;
      let base3 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p;
        points.push(base3);
        for (let i = 1; i < 2 ** (W2 - 1); i++) {
          base3 = base3.add(p);
          points.push(base3);
        }
        p = base3.double();
      }
      return points;
    }
    wNAF(n, affinePoint) {
      if (!affinePoint && this.equals(ExtendedPoint.BASE))
        affinePoint = Point2.BASE;
      const W2 = affinePoint && affinePoint._WINDOW_SIZE || 1;
      if (256 % W2) {
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      }
      let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
      if (!precomputes) {
        precomputes = this.precomputeWindow(W2);
        if (affinePoint && W2 !== 1) {
          precomputes = ExtendedPoint.normalizeZ(precomputes);
          pointPrecomputes.set(affinePoint, precomputes);
        }
      }
      let p = ExtendedPoint.ZERO;
      let f2 = ExtendedPoint.ZERO;
      const windows = 1 + 256 / W2;
      const windowSize = 2 ** (W2 - 1);
      const mask = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n;
        }
        if (wbits === 0) {
          let pr = precomputes[offset];
          if (window2 % 2)
            pr = pr.negate();
          f2 = f2.add(pr);
        } else {
          let cached = precomputes[offset + Math.abs(wbits) - 1];
          if (wbits < 0)
            cached = cached.negate();
          p = p.add(cached);
        }
      }
      return ExtendedPoint.normalizeZ([p, f2])[0];
    }
    multiply(scalar, affinePoint) {
      return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
    }
    multiplyUnsafe(scalar) {
      let n = normalizeScalar(scalar, CURVE.l, false);
      const G2 = ExtendedPoint.BASE;
      const P0 = ExtendedPoint.ZERO;
      if (n === _0n)
        return P0;
      if (this.equals(P0) || n === _1n)
        return this;
      if (this.equals(G2))
        return this.wNAF(n);
      let p = P0;
      let d = this;
      while (n > _0n) {
        if (n & _1n)
          p = p.add(d);
        d = d.double();
        n >>= _1n;
      }
      return p;
    }
    isSmallOrder() {
      return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
    }
    isTorsionFree() {
      return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);
    }
    toAffine(invZ = invert2(this.z)) {
      const { x, y, z } = this;
      const ax = mod(x * invZ);
      const ay = mod(y * invZ);
      const zz = mod(z * invZ);
      if (zz !== _1n)
        throw new Error("invZ was invalid");
      return new Point2(ax, ay);
    }
    fromRistrettoBytes() {
      legacyRist();
    }
    toRistrettoBytes() {
      legacyRist();
    }
    fromRistrettoHash() {
      legacyRist();
    }
  }
  exports2.ExtendedPoint = ExtendedPoint;
  ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
  ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
  function assertExtPoint(other) {
    if (!(other instanceof ExtendedPoint))
      throw new TypeError("ExtendedPoint expected");
  }
  function assertRstPoint(other) {
    if (!(other instanceof RistrettoPoint))
      throw new TypeError("RistrettoPoint expected");
  }
  function legacyRist() {
    throw new Error("Legacy method: switch to RistrettoPoint");
  }
  class RistrettoPoint {
    constructor(ep) {
      this.ep = ep;
    }
    static calcElligatorRistrettoMap(r0) {
      const { d } = CURVE;
      const r2 = mod(SQRT_M1 * r0 * r0);
      const Ns = mod((r2 + _1n) * ONE_MINUS_D_SQ);
      let c = BigInt(-1);
      const D = mod((c - d * r2) * mod(r2 + d));
      let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
      let s_ = mod(s2 * r0);
      if (!edIsNegative(s_))
        s_ = mod(-s_);
      if (!Ns_D_is_sq)
        s2 = s_;
      if (!Ns_D_is_sq)
        c = r2;
      const Nt = mod(c * (r2 - _1n) * D_MINUS_ONE_SQ - D);
      const s22 = s2 * s2;
      const W0 = mod((s2 + s2) * D);
      const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
      const W2 = mod(_1n - s22);
      const W3 = mod(_1n + s22);
      return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    static hashToCurve(hex) {
      hex = ensureBytes(hex, 64);
      const r1 = bytes255ToNumberLE(hex.slice(0, 32));
      const R1 = this.calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(hex.slice(32, 64));
      const R2 = this.calcElligatorRistrettoMap(r2);
      return new RistrettoPoint(R1.add(R2));
    }
    static fromHex(hex) {
      hex = ensureBytes(hex, 32);
      const { a, d } = CURVE;
      const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
      const s2 = bytes255ToNumberLE(hex);
      if (!equalBytes(numberTo32BytesLE(s2), hex) || edIsNegative(s2))
        throw new Error(emsg);
      const s22 = mod(s2 * s2);
      const u1 = mod(_1n + a * s22);
      const u2 = mod(_1n - a * s22);
      const u1_2 = mod(u1 * u1);
      const u2_2 = mod(u2 * u2);
      const v = mod(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod(v * u2_2));
      const Dx = mod(I * u2);
      const Dy = mod(I * Dx * v);
      let x = mod((s2 + s2) * Dx);
      if (edIsNegative(x))
        x = mod(-x);
      const y = mod(u1 * Dy);
      const t = mod(x * y);
      if (!isValid || edIsNegative(t) || y === _0n)
        throw new Error(emsg);
      return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
    }
    toRawBytes() {
      let { x, y, z, t } = this.ep;
      const u1 = mod(mod(z + y) * mod(z - y));
      const u2 = mod(x * y);
      const { value: invsqrt } = invertSqrt(mod(u1 * u2 ** _2n));
      const D1 = mod(invsqrt * u1);
      const D2 = mod(invsqrt * u2);
      const zInv = mod(D1 * D2 * t);
      let D;
      if (edIsNegative(t * zInv)) {
        let _x = mod(y * SQRT_M1);
        let _y = mod(x * SQRT_M1);
        x = _x;
        y = _y;
        D = mod(D1 * INVSQRT_A_MINUS_D);
      } else {
        D = D2;
      }
      if (edIsNegative(x * zInv))
        y = mod(-y);
      let s2 = mod((z - y) * D);
      if (edIsNegative(s2))
        s2 = mod(-s2);
      return numberTo32BytesLE(s2);
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(other) {
      assertRstPoint(other);
      const a = this.ep;
      const b = other.ep;
      const one = mod(a.x * b.y) === mod(a.y * b.x);
      const two2 = mod(a.y * b.y) === mod(a.x * b.x);
      return one || two2;
    }
    add(other) {
      assertRstPoint(other);
      return new RistrettoPoint(this.ep.add(other.ep));
    }
    subtract(other) {
      assertRstPoint(other);
      return new RistrettoPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return new RistrettoPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
    }
  }
  exports2.RistrettoPoint = RistrettoPoint;
  RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
  RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
  const pointPrecomputes = /* @__PURE__ */ new WeakMap();
  class Point2 {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    static fromHex(hex, strict = true) {
      const { d, P } = CURVE;
      hex = ensureBytes(hex, 32);
      const normed = hex.slice();
      normed[31] = hex[31] & ~128;
      const y = bytesToNumberLE(normed);
      if (strict && y >= P)
        throw new Error("Expected 0 < hex < P");
      if (!strict && y >= MAX_256B)
        throw new Error("Expected 0 < hex < 2**256");
      const y2 = mod(y * y);
      const u = mod(y2 - _1n);
      const v = mod(d * y2 + _1n);
      let { isValid, value: x } = uvRatio(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n) === _1n;
      const isLastByteOdd = (hex[31] & 128) !== 0;
      if (isLastByteOdd !== isXOdd) {
        x = mod(-x);
      }
      return new Point2(x, y);
    }
    static async fromPrivateKey(privateKey) {
      return (await getExtendedPublicKey(privateKey)).point;
    }
    toRawBytes() {
      const bytes = numberTo32BytesLE(this.y);
      bytes[31] |= this.x & _1n ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
    toX25519() {
      const { y } = this;
      const u = mod((_1n + y) * invert2(_1n - y));
      return numberTo32BytesLE(u);
    }
    isTorsionFree() {
      return ExtendedPoint.fromAffine(this).isTorsionFree();
    }
    equals(other) {
      return this.x === other.x && this.y === other.y;
    }
    negate() {
      return new Point2(mod(-this.x), this.y);
    }
    add(other) {
      return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
  }
  exports2.Point = Point2;
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy);
  Point2.ZERO = new Point2(_0n, _1n);
  class Signature2 {
    constructor(r2, s2) {
      this.r = r2;
      this.s = s2;
      this.assertValidity();
    }
    static fromHex(hex) {
      const bytes = ensureBytes(hex, 64);
      const r2 = Point2.fromHex(bytes.slice(0, 32), false);
      const s2 = bytesToNumberLE(bytes.slice(32, 64));
      return new Signature2(r2, s2);
    }
    assertValidity() {
      const { r: r2, s: s2 } = this;
      if (!(r2 instanceof Point2))
        throw new Error("Expected Point instance");
      normalizeScalar(s2, CURVE.l, false);
      return this;
    }
    toRawBytes() {
      const u8 = new Uint8Array(64);
      u8.set(this.r.toRawBytes());
      u8.set(numberTo32BytesLE(this.s), 32);
      return u8;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  exports2.Signature = Signature2;
  function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
      throw new Error("Expected Uint8Array list");
    if (arrays.length === 1)
      return arrays[0];
    const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length2);
    for (let i = 0, pad3 = 0; i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad3);
      pad3 += arr.length;
    }
    return result;
  }
  const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0; i < uint8a.length; i++) {
      hex += hexes[uint8a[i]];
    }
    return hex;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    }
    if (hex.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function numberTo32BytesBE(num) {
    const length2 = 32;
    const hex = num.toString(16).padStart(length2 * 2, "0");
    return hexToBytes(hex);
  }
  function numberTo32BytesLE(num) {
    return numberTo32BytesBE(num).reverse();
  }
  function edIsNegative(num) {
    return (mod(num) & _1n) === _1n;
  }
  function bytesToNumberLE(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
  }
  function bytes255ToNumberLE(bytes) {
    return mod(bytesToNumberLE(bytes) & _2n ** _255n - _1n);
  }
  function mod(a, b = CURVE.P) {
    const res = a % b;
    return res >= _0n ? res : b + res;
  }
  function invert2(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
      throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, u = _1n;
    while (a !== _0n) {
      const q = b / a;
      const r2 = b % a;
      const m = x - u * q;
      b = a, a = r2, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function invertBatch(nums, p = CURVE.P) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (num === _0n)
        return acc;
      tmp[i] = acc;
      return mod(acc * num, p);
    }, _1n);
    const inverted = invert2(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
      if (num === _0n)
        return acc;
      tmp[i] = mod(acc * tmp[i], p);
      return mod(acc * num, p);
    }, inverted);
    return tmp;
  }
  function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n) {
      res *= res;
      res %= P;
    }
    return res;
  }
  function pow_2_252_3(x) {
    const { P } = CURVE;
    const _5n = BigInt(5);
    const _10n = BigInt(10);
    const _20n = BigInt(20);
    const _40n = BigInt(40);
    const _80n = BigInt(80);
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n) * b2 % P;
    const b5 = pow2(b4, _1n) * x % P;
    const b10 = pow2(b5, _5n) * b5 % P;
    const b20 = pow2(b10, _10n) * b10 % P;
    const b40 = pow2(b20, _20n) * b20 % P;
    const b80 = pow2(b40, _40n) * b40 % P;
    const b160 = pow2(b80, _80n) * b80 % P;
    const b240 = pow2(b160, _80n) * b80 % P;
    const b250 = pow2(b240, _10n) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n) * x % P;
    return { pow_p_5_8, b2 };
  }
  function uvRatio(u, v) {
    const v3 = mod(v * v * v);
    const v7 = mod(v3 * v3 * v);
    const pow = pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow);
    const vx2 = mod(v * x * x);
    const root1 = x;
    const root2 = mod(x * SQRT_M1);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u);
    const noRoot = vx2 === mod(-u * SQRT_M1);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (edIsNegative(x))
      x = mod(-x);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  function invertSqrt(number) {
    return uvRatio(_1n, number);
  }
  function modlLE(hash3) {
    return mod(bytesToNumberLE(hash3), CURVE.l);
  }
  function equalBytes(b1, b2) {
    if (b1.length !== b2.length) {
      return false;
    }
    for (let i = 0; i < b1.length; i++) {
      if (b1[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  }
  function ensureBytes(hex, expectedLength) {
    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
    if (typeof expectedLength === "number" && bytes.length !== expectedLength)
      throw new Error(`Expected ${expectedLength} bytes`);
    return bytes;
  }
  function normalizeScalar(num, max, strict = true) {
    if (!max)
      throw new TypeError("Specify max value");
    if (typeof num === "number" && Number.isSafeInteger(num))
      num = BigInt(num);
    if (typeof num === "bigint" && num < max) {
      if (strict) {
        if (_0n < num)
          return num;
      } else {
        if (_0n <= num)
          return num;
      }
    }
    throw new TypeError("Expected valid scalar: 0 < scalar < max");
  }
  function adjustBytes25519(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
  }
  function decodeScalar25519(n) {
    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));
  }
  function checkPrivateKey(key3) {
    key3 = typeof key3 === "bigint" || typeof key3 === "number" ? numberTo32BytesBE(normalizeScalar(key3, MAX_256B)) : ensureBytes(key3);
    if (key3.length !== 32)
      throw new Error(`Expected 32 bytes`);
    return key3;
  }
  function getKeyFromHash(hashed) {
    const head = adjustBytes25519(hashed.slice(0, 32));
    const prefix = hashed.slice(32, 64);
    const scalar = modlLE(head);
    const point7 = Point2.BASE.multiply(scalar);
    const pointBytes = point7.toRawBytes();
    return { head, prefix, scalar, point: point7, pointBytes };
  }
  let _sha512Sync;
  function sha512s(...m) {
    if (typeof _sha512Sync !== "function")
      throw new Error("utils.sha512Sync must be set to use sync methods");
    return _sha512Sync(...m);
  }
  async function getExtendedPublicKey(key3) {
    return getKeyFromHash(await exports2.utils.sha512(checkPrivateKey(key3)));
  }
  function getExtendedPublicKeySync(key3) {
    return getKeyFromHash(sha512s(checkPrivateKey(key3)));
  }
  async function getPublicKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).pointBytes;
  }
  exports2.getPublicKey = getPublicKey;
  function getPublicKeySync(privateKey) {
    return getExtendedPublicKeySync(privateKey).pointBytes;
  }
  async function sign7(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
    const r2 = modlLE(await exports2.utils.sha512(prefix, message));
    const R2 = Point2.BASE.multiply(r2);
    const k = modlLE(await exports2.utils.sha512(R2.toRawBytes(), pointBytes, message));
    const s2 = mod(r2 + k * scalar, CURVE.l);
    return new Signature2(R2, s2).toRawBytes();
  }
  exports2.sign = sign7;
  function signSync(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);
    const r2 = modlLE(sha512s(prefix, message));
    const R2 = Point2.BASE.multiply(r2);
    const k = modlLE(sha512s(R2.toRawBytes(), pointBytes, message));
    const s2 = mod(r2 + k * scalar, CURVE.l);
    return new Signature2(R2, s2).toRawBytes();
  }
  function prepareVerification(sig, message, publicKey) {
    message = ensureBytes(message);
    if (!(publicKey instanceof Point2))
      publicKey = Point2.fromHex(publicKey, false);
    const { r: r2, s: s2 } = sig instanceof Signature2 ? sig.assertValidity() : Signature2.fromHex(sig);
    const SB = ExtendedPoint.BASE.multiplyUnsafe(s2);
    return { r: r2, s: s2, SB, pub: publicKey, msg: message };
  }
  function finishVerification(publicKey, r2, SB, hashed) {
    const k = modlLE(hashed);
    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
    const RkA = ExtendedPoint.fromAffine(r2).add(kA);
    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
  }
  async function verify7(sig, message, publicKey) {
    const { r: r2, SB, msg, pub: pub2 } = prepareVerification(sig, message, publicKey);
    const hashed = await exports2.utils.sha512(r2.toRawBytes(), pub2.toRawBytes(), msg);
    return finishVerification(pub2, r2, SB, hashed);
  }
  exports2.verify = verify7;
  function verifySync(sig, message, publicKey) {
    const { r: r2, SB, msg, pub: pub2 } = prepareVerification(sig, message, publicKey);
    const hashed = sha512s(r2.toRawBytes(), pub2.toRawBytes(), msg);
    return finishVerification(pub2, r2, SB, hashed);
  }
  exports2.sync = {
    getExtendedPublicKey: getExtendedPublicKeySync,
    getPublicKey: getPublicKeySync,
    sign: signSync,
    verify: verifySync
  };
  async function getSharedSecret(privateKey, publicKey) {
    const { head } = await getExtendedPublicKey(privateKey);
    const u = Point2.fromHex(publicKey).toX25519();
    return exports2.curve25519.scalarMult(head, u);
  }
  exports2.getSharedSecret = getSharedSecret;
  Point2.BASE._setWindowSize(8);
  function cswap(swap, x_2, x_3) {
    const dummy = mod(swap * (x_2 - x_3));
    x_2 = mod(x_2 - dummy);
    x_3 = mod(x_3 + dummy);
    return [x_2, x_3];
  }
  function montgomeryLadder(pointU, scalar) {
    const { P } = CURVE;
    const u = normalizeScalar(pointU, P);
    const k = normalizeScalar(scalar, P);
    const a24 = BigInt(121665);
    const x_1 = u;
    let x_2 = _1n;
    let z_2 = _0n;
    let x_3 = u;
    let z_3 = _1n;
    let swap = _0n;
    let sw;
    for (let t = BigInt(255 - 1); t >= _0n; t--) {
      const k_t = k >> t & _1n;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A = x_2 + z_2;
      const AA = mod(A * A);
      const B = x_2 - z_2;
      const BB = mod(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = mod(D * A);
      const CB = mod(C * B);
      x_3 = mod((DA + CB) ** _2n);
      z_3 = mod(x_1 * (DA - CB) ** _2n);
      x_2 = mod(AA * BB);
      z_2 = mod(E * (AA + mod(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);
    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);
    return mod(x_2 * xp2);
  }
  function encodeUCoordinate(u) {
    return numberTo32BytesLE(mod(u, CURVE.P));
  }
  function decodeUCoordinate(uEnc) {
    const u = ensureBytes(uEnc, 32);
    u[31] &= 127;
    return bytesToNumberLE(u);
  }
  exports2.curve25519 = {
    BASE_POINT_U: "0900000000000000000000000000000000000000000000000000000000000000",
    scalarMult(privateKey, publicKey) {
      const u = decodeUCoordinate(publicKey);
      const p = decodeScalar25519(privateKey);
      const pu = montgomeryLadder(u, p);
      if (pu === _0n)
        throw new Error("Invalid private or public key received");
      return encodeUCoordinate(pu);
    },
    scalarMultBase(privateKey) {
      return exports2.curve25519.scalarMult(privateKey, exports2.curve25519.BASE_POINT_U);
    }
  };
  const crypto2 = {
    node: nodeCrypto,
    web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
  };
  exports2.utils = {
    TORSION_SUBGROUP: [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ],
    bytesToHex,
    hexToBytes,
    concatBytes,
    getExtendedPublicKey,
    mod,
    invert: invert2,
    hashToPrivateScalar: (hash3) => {
      hash3 = ensureBytes(hash3);
      if (hash3.length < 40 || hash3.length > 1024)
        throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
      return mod(bytesToNumberLE(hash3), CURVE.l - _1n) + _1n;
    },
    randomBytes: (bytesLength = 32) => {
      if (crypto2.web) {
        return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto2.node) {
        const { randomBytes: randomBytes2 } = crypto2.node;
        return new Uint8Array(randomBytes2(bytesLength).buffer);
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    },
    randomPrivateKey: () => {
      return exports2.utils.randomBytes(32);
    },
    sha512: async (...messages) => {
      const message = concatBytes(...messages);
      if (crypto2.web) {
        const buffer2 = await crypto2.web.subtle.digest("SHA-512", message.buffer);
        return new Uint8Array(buffer2);
      } else if (crypto2.node) {
        return Uint8Array.from(crypto2.node.createHash("sha512").update(message).digest());
      } else {
        throw new Error("The environment doesn't have sha512 function");
      }
    },
    precompute(windowSize = 8, point7 = Point2.BASE) {
      const cached = point7.equals(Point2.BASE) ? point7 : new Point2(point7.x, point7.y);
      cached._setWindowSize(windowSize);
      cached.multiply(_2n);
      return cached;
    },
    sha512Sync: void 0
  };
  Object.defineProperties(exports2.utils, {
    sha512Sync: {
      configurable: false,
      get() {
        return _sha512Sync;
      },
      set(val) {
        if (!_sha512Sync)
          _sha512Sync = val;
      }
    }
  });
})(lib$1);
var constants = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SIG_CONFIG = exports2.SignatureConfig = void 0;
  var SignatureConfig;
  (function(SignatureConfig2) {
    SignatureConfig2[SignatureConfig2["ARWEAVE"] = 1] = "ARWEAVE";
    SignatureConfig2[SignatureConfig2["ED25519"] = 2] = "ED25519";
    SignatureConfig2[SignatureConfig2["ETHEREUM"] = 3] = "ETHEREUM";
    SignatureConfig2[SignatureConfig2["SOLANA"] = 4] = "SOLANA";
  })(SignatureConfig = exports2.SignatureConfig || (exports2.SignatureConfig = {}));
  exports2.SIG_CONFIG = {
    [SignatureConfig.ARWEAVE]: {
      sigLength: 512,
      pubLength: 512,
      sigName: "arweave"
    },
    [SignatureConfig.ED25519]: {
      sigLength: 64,
      pubLength: 32,
      sigName: "ed25519"
    },
    [SignatureConfig.ETHEREUM]: {
      sigLength: 65,
      pubLength: 65,
      sigName: "ethereum"
    },
    [SignatureConfig.SOLANA]: {
      sigLength: 64,
      pubLength: 32,
      sigName: "solana"
    }
  };
})(constants);
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$2(result, mod, k);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
var __importDefault$e = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(curve25519, "__esModule", { value: true });
const base64url_1$5 = __importDefault$e(base64url$3.exports);
const ed25519$3 = __importStar$2(lib$1);
const constants_1$4 = constants;
class Curve25519 {
  constructor(_key, pk) {
    this._key = _key;
    this.pk = pk;
    this.ownerLength = constants_1$4.SIG_CONFIG[2].pubLength;
    this.signatureLength = constants_1$4.SIG_CONFIG[2].sigLength;
    this.signatureType = 2;
  }
  get publicKey() {
    return this._publicKey;
  }
  get key() {
    return new Uint8Array(0);
  }
  sign(message) {
    return ed25519$3.sign(Buffer.from(message), Buffer.from(this.key));
  }
  static async verify(pk, message, signature2) {
    let p = pk;
    if (typeof pk === "string")
      p = base64url_1$5.default.toBuffer(pk);
    return ed25519$3.verify(Buffer.from(signature2), Buffer.from(message), Buffer.from(p));
  }
}
curve25519.default = Curve25519;
var ethereumSigner = {};
var secp256k1 = {};
const errors$1 = {
  IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
  TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
  TWEAK_MUL: "The tweak was out of range or equal to zero",
  CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
  SECKEY_INVALID: "Private Key is invalid",
  PUBKEY_PARSE: "Public Key could not be parsed",
  PUBKEY_SERIALIZE: "Public Key serialization error",
  PUBKEY_COMBINE: "The sum of the public keys is not valid",
  SIG_PARSE: "Signature could not be parsed",
  SIGN: "The nonce generation function failed, or the private key was invalid",
  RECOVER: "Public key could not be recover",
  ECDH: "Scalar was invalid (zero or overflow)"
};
function assert$6(cond, msg) {
  if (!cond)
    throw new Error(msg);
}
function isUint8Array(name2, value, length2) {
  assert$6(value instanceof Uint8Array, `Expected ${name2} to be an Uint8Array`);
  if (length2 !== void 0) {
    if (Array.isArray(length2)) {
      const numbers = length2.join(", ");
      const msg = `Expected ${name2} to be an Uint8Array with length [${numbers}]`;
      assert$6(length2.includes(value.length), msg);
    } else {
      const msg = `Expected ${name2} to be an Uint8Array with length ${length2}`;
      assert$6(value.length === length2, msg);
    }
  }
}
function isCompressed(value) {
  assert$6(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
}
function getAssertedOutput(output = (len) => new Uint8Array(len), length2) {
  if (typeof output === "function")
    output = output(length2);
  isUint8Array("output", output, length2);
  return output;
}
function toTypeString(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
var lib = (secp256k12) => {
  return {
    contextRandomize(seed) {
      assert$6(
        seed === null || seed instanceof Uint8Array,
        "Expected seed to be an Uint8Array or null"
      );
      if (seed !== null)
        isUint8Array("seed", seed, 32);
      switch (secp256k12.contextRandomize(seed)) {
        case 1:
          throw new Error(errors$1.CONTEXT_RANDOMIZE_UNKNOW);
      }
    },
    privateKeyVerify(seckey) {
      isUint8Array("private key", seckey, 32);
      return secp256k12.privateKeyVerify(seckey) === 0;
    },
    privateKeyNegate(seckey) {
      isUint8Array("private key", seckey, 32);
      switch (secp256k12.privateKeyNegate(seckey)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors$1.IMPOSSIBLE_CASE);
      }
    },
    privateKeyTweakAdd(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors$1.TWEAK_ADD);
      }
    },
    privateKeyTweakMul(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors$1.TWEAK_MUL);
      }
    },
    publicKeyVerify(pubkey) {
      isUint8Array("public key", pubkey, [33, 65]);
      return secp256k12.publicKeyVerify(pubkey) === 0;
    },
    publicKeyCreate(seckey, compressed = true, output) {
      isUint8Array("private key", seckey, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCreate(output, seckey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.SECKEY_INVALID);
        case 2:
          throw new Error(errors$1.PUBKEY_SERIALIZE);
      }
    },
    publicKeyConvert(pubkey, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyConvert(output, pubkey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$1.PUBKEY_SERIALIZE);
      }
    },
    publicKeyNegate(pubkey, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyNegate(output, pubkey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$1.IMPOSSIBLE_CASE);
        case 3:
          throw new Error(errors$1.PUBKEY_SERIALIZE);
      }
    },
    publicKeyCombine(pubkeys, compressed = true, output) {
      assert$6(Array.isArray(pubkeys), "Expected public keys to be an Array");
      assert$6(pubkeys.length > 0, "Expected public keys array will have more than zero items");
      for (const pubkey of pubkeys) {
        isUint8Array("public key", pubkey, [33, 65]);
      }
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$1.PUBKEY_COMBINE);
        case 3:
          throw new Error(errors$1.PUBKEY_SERIALIZE);
      }
    },
    publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$1.TWEAK_ADD);
      }
    },
    publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$1.TWEAK_MUL);
      }
    },
    signatureNormalize(sig) {
      isUint8Array("signature", sig, 64);
      switch (secp256k12.signatureNormalize(sig)) {
        case 0:
          return sig;
        case 1:
          throw new Error(errors$1.SIG_PARSE);
      }
    },
    signatureExport(sig, output) {
      isUint8Array("signature", sig, 64);
      output = getAssertedOutput(output, 72);
      const obj2 = { output, outputlen: 72 };
      switch (secp256k12.signatureExport(obj2, sig)) {
        case 0:
          return output.slice(0, obj2.outputlen);
        case 1:
          throw new Error(errors$1.SIG_PARSE);
        case 2:
          throw new Error(errors$1.IMPOSSIBLE_CASE);
      }
    },
    signatureImport(sig, output) {
      isUint8Array("signature", sig);
      output = getAssertedOutput(output, 64);
      switch (secp256k12.signatureImport(output, sig)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.SIG_PARSE);
        case 2:
          throw new Error(errors$1.IMPOSSIBLE_CASE);
      }
    },
    ecdsaSign(msg32, seckey, options = {}, output) {
      isUint8Array("message", msg32, 32);
      isUint8Array("private key", seckey, 32);
      assert$6(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0)
        isUint8Array("options.data", options.data);
      if (options.noncefn !== void 0)
        assert$6(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
      output = getAssertedOutput(output, 64);
      const obj2 = { signature: output, recid: null };
      switch (secp256k12.ecdsaSign(obj2, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj2;
        case 1:
          throw new Error(errors$1.SIGN);
        case 2:
          throw new Error(errors$1.IMPOSSIBLE_CASE);
      }
    },
    ecdsaVerify(sig, msg32, pubkey) {
      isUint8Array("signature", sig, 64);
      isUint8Array("message", msg32, 32);
      isUint8Array("public key", pubkey, [33, 65]);
      switch (secp256k12.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true;
        case 3:
          return false;
        case 1:
          throw new Error(errors$1.SIG_PARSE);
        case 2:
          throw new Error(errors$1.PUBKEY_PARSE);
      }
    },
    ecdsaRecover(sig, recid, msg32, compressed = true, output) {
      isUint8Array("signature", sig, 64);
      assert$6(
        toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
        "Expected recovery id to be a Number within interval [0, 3]"
      );
      isUint8Array("message", msg32, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.SIG_PARSE);
        case 2:
          throw new Error(errors$1.RECOVER);
        case 3:
          throw new Error(errors$1.IMPOSSIBLE_CASE);
      }
    },
    ecdh(pubkey, seckey, options = {}, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("private key", seckey, 32);
      assert$6(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0)
        isUint8Array("options.data", options.data);
      if (options.hashfn !== void 0) {
        assert$6(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
        if (options.xbuf !== void 0)
          isUint8Array("options.xbuf", options.xbuf, 32);
        if (options.ybuf !== void 0)
          isUint8Array("options.ybuf", options.ybuf, 32);
        isUint8Array("output", output);
      } else {
        output = getAssertedOutput(output, 32);
      }
      switch (secp256k12.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$1.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$1.ECDH);
      }
    }
  };
};
const EC$2 = requireElliptic().ec;
const ec$1 = new EC$2("secp256k1");
const ecparams = ec$1.curve;
const BN$2 = ecparams.n.constructor;
function loadCompressedPublicKey(first, xbuf) {
  let x = new BN$2(xbuf);
  if (x.cmp(ecparams.p) >= 0)
    return null;
  x = x.toRed(ecparams.red);
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
  if (first === 3 !== y.isOdd())
    y = y.redNeg();
  return ec$1.keyPair({ pub: { x, y } });
}
function loadUncompressedPublicKey(first, xbuf, ybuf) {
  let x = new BN$2(xbuf);
  let y = new BN$2(ybuf);
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0)
    return null;
  x = x.toRed(ecparams.red);
  y = y.toRed(ecparams.red);
  if ((first === 6 || first === 7) && y.isOdd() !== (first === 7))
    return null;
  const x3 = x.redSqr().redIMul(x);
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
    return null;
  return ec$1.keyPair({ pub: { x, y } });
}
function loadPublicKey(pubkey) {
  const first = pubkey[0];
  switch (first) {
    case 2:
    case 3:
      if (pubkey.length !== 33)
        return null;
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
    case 4:
    case 6:
    case 7:
      if (pubkey.length !== 65)
        return null;
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
    default:
      return null;
  }
}
function savePublicKey(output, point7) {
  const pubkey = point7.encode(null, output.length === 33);
  for (let i = 0; i < output.length; ++i)
    output[i] = pubkey[i];
}
var elliptic$1 = {
  contextRandomize() {
    return 0;
  },
  privateKeyVerify(seckey) {
    const bn2 = new BN$2(seckey);
    return bn2.cmp(ecparams.n) < 0 && !bn2.isZero() ? 0 : 1;
  },
  privateKeyNegate(seckey) {
    const bn2 = new BN$2(seckey);
    const negate = ecparams.n.sub(bn2).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
    seckey.set(negate);
    return 0;
  },
  privateKeyTweakAdd(seckey, tweak) {
    const bn2 = new BN$2(tweak);
    if (bn2.cmp(ecparams.n) >= 0)
      return 1;
    bn2.iadd(new BN$2(seckey));
    if (bn2.cmp(ecparams.n) >= 0)
      bn2.isub(ecparams.n);
    if (bn2.isZero())
      return 1;
    const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
    seckey.set(tweaked);
    return 0;
  },
  privateKeyTweakMul(seckey, tweak) {
    let bn2 = new BN$2(tweak);
    if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
      return 1;
    bn2.imul(new BN$2(seckey));
    if (bn2.cmp(ecparams.n) >= 0)
      bn2 = bn2.umod(ecparams.n);
    const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
    seckey.set(tweaked);
    return 0;
  },
  publicKeyVerify(pubkey) {
    const pair = loadPublicKey(pubkey);
    return pair === null ? 1 : 0;
  },
  publicKeyCreate(output, seckey) {
    const bn2 = new BN$2(seckey);
    if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
      return 1;
    const point7 = ec$1.keyFromPrivate(seckey).getPublic();
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyConvert(output, pubkey) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    const point7 = pair.getPublic();
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyNegate(output, pubkey) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    const point7 = pair.getPublic();
    point7.y = point7.y.redNeg();
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyCombine(output, pubkeys) {
    const pairs = new Array(pubkeys.length);
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i]);
      if (pairs[i] === null)
        return 1;
    }
    let point7 = pairs[0].getPublic();
    for (let i = 1; i < pairs.length; ++i)
      point7 = point7.add(pairs[i].pub);
    if (point7.isInfinity())
      return 2;
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyTweakAdd(output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    tweak = new BN$2(tweak);
    if (tweak.cmp(ecparams.n) >= 0)
      return 2;
    const point7 = pair.getPublic().add(ecparams.g.mul(tweak));
    if (point7.isInfinity())
      return 2;
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyTweakMul(output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    tweak = new BN$2(tweak);
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
      return 2;
    const point7 = pair.getPublic().mul(tweak);
    savePublicKey(output, point7);
    return 0;
  },
  signatureNormalize(sig) {
    const r2 = new BN$2(sig.subarray(0, 32));
    const s2 = new BN$2(sig.subarray(32, 64));
    if (r2.cmp(ecparams.n) >= 0 || s2.cmp(ecparams.n) >= 0)
      return 1;
    if (s2.cmp(ec$1.nh) === 1) {
      sig.set(ecparams.n.sub(s2).toArrayLike(Uint8Array, "be", 32), 32);
    }
    return 0;
  },
  signatureExport(obj2, sig) {
    const sigR = sig.subarray(0, 32);
    const sigS = sig.subarray(32, 64);
    if (new BN$2(sigR).cmp(ecparams.n) >= 0)
      return 1;
    if (new BN$2(sigS).cmp(ecparams.n) >= 0)
      return 1;
    const { output } = obj2;
    let r2 = output.subarray(4, 4 + 33);
    r2[0] = 0;
    r2.set(sigR, 1);
    let lenR = 33;
    let posR = 0;
    for (; lenR > 1 && r2[posR] === 0 && !(r2[posR + 1] & 128); --lenR, ++posR)
      ;
    r2 = r2.subarray(posR);
    if (r2[0] & 128)
      return 1;
    if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
      return 1;
    let s2 = output.subarray(6 + 33, 6 + 33 + 33);
    s2[0] = 0;
    s2.set(sigS, 1);
    let lenS = 33;
    let posS = 0;
    for (; lenS > 1 && s2[posS] === 0 && !(s2[posS + 1] & 128); --lenS, ++posS)
      ;
    s2 = s2.subarray(posS);
    if (s2[0] & 128)
      return 1;
    if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128))
      return 1;
    obj2.outputlen = 6 + lenR + lenS;
    output[0] = 48;
    output[1] = obj2.outputlen - 2;
    output[2] = 2;
    output[3] = r2.length;
    output.set(r2, 4);
    output[4 + lenR] = 2;
    output[5 + lenR] = s2.length;
    output.set(s2, 6 + lenR);
    return 0;
  },
  signatureImport(output, sig) {
    if (sig.length < 8)
      return 1;
    if (sig.length > 72)
      return 1;
    if (sig[0] !== 48)
      return 1;
    if (sig[1] !== sig.length - 2)
      return 1;
    if (sig[2] !== 2)
      return 1;
    const lenR = sig[3];
    if (lenR === 0)
      return 1;
    if (5 + lenR >= sig.length)
      return 1;
    if (sig[4 + lenR] !== 2)
      return 1;
    const lenS = sig[5 + lenR];
    if (lenS === 0)
      return 1;
    if (6 + lenR + lenS !== sig.length)
      return 1;
    if (sig[4] & 128)
      return 1;
    if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
      return 1;
    if (sig[lenR + 6] & 128)
      return 1;
    if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
      return 1;
    let sigR = sig.subarray(4, 4 + lenR);
    if (sigR.length === 33 && sigR[0] === 0)
      sigR = sigR.subarray(1);
    if (sigR.length > 32)
      return 1;
    let sigS = sig.subarray(6 + lenR);
    if (sigS.length === 33 && sigS[0] === 0)
      sigS = sigS.slice(1);
    if (sigS.length > 32)
      throw new Error("S length is too long");
    let r2 = new BN$2(sigR);
    if (r2.cmp(ecparams.n) >= 0)
      r2 = new BN$2(0);
    let s2 = new BN$2(sig.subarray(6 + lenR));
    if (s2.cmp(ecparams.n) >= 0)
      s2 = new BN$2(0);
    output.set(r2.toArrayLike(Uint8Array, "be", 32), 0);
    output.set(s2.toArrayLike(Uint8Array, "be", 32), 32);
    return 0;
  },
  ecdsaSign(obj2, message, seckey, data2, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn;
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data2, counter);
        const isValid = nonce instanceof Uint8Array && nonce.length === 32;
        if (!isValid)
          throw new Error("This is the way");
        return new BN$2(nonce);
      };
    }
    const d = new BN$2(seckey);
    if (d.cmp(ecparams.n) >= 0 || d.isZero())
      return 1;
    let sig;
    try {
      sig = ec$1.sign(message, seckey, { canonical: true, k: noncefn, pers: data2 });
    } catch (err) {
      return 1;
    }
    obj2.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
    obj2.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
    obj2.recid = sig.recoveryParam;
    return 0;
  },
  ecdsaVerify(sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
    const sigr = new BN$2(sigObj.r);
    const sigs = new BN$2(sigObj.s);
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
      return 1;
    if (sigs.cmp(ec$1.nh) === 1 || sigr.isZero() || sigs.isZero())
      return 3;
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 2;
    const point7 = pair.getPublic();
    const isValid = ec$1.verify(msg32, sigObj, point7);
    return isValid ? 0 : 3;
  },
  ecdsaRecover(output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
    const sigr = new BN$2(sigObj.r);
    const sigs = new BN$2(sigObj.s);
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
      return 1;
    if (sigr.isZero() || sigs.isZero())
      return 2;
    let point7;
    try {
      point7 = ec$1.recoverPubKey(msg32, sigObj, recid);
    } catch (err) {
      return 2;
    }
    savePublicKey(output, point7);
    return 0;
  },
  ecdh(output, pubkey, seckey, data2, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    const scalar = new BN$2(seckey);
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
      return 2;
    const point7 = pair.getPublic().mul(scalar);
    if (hashfn === void 0) {
      const data3 = point7.encode(null, true);
      const sha2562 = ec$1.hash().update(data3).digest();
      for (let i = 0; i < 32; ++i)
        output[i] = sha2562[i];
    } else {
      if (!xbuf)
        xbuf = new Uint8Array(32);
      const x = point7.getX().toArray("be", 32);
      for (let i = 0; i < 32; ++i)
        xbuf[i] = x[i];
      if (!ybuf)
        ybuf = new Uint8Array(32);
      const y = point7.getY().toArray("be", 32);
      for (let i = 0; i < 32; ++i)
        ybuf[i] = y[i];
      const hash3 = hashfn(xbuf, ybuf, data2);
      const isValid = hash3 instanceof Uint8Array && hash3.length === output.length;
      if (!isValid)
        return 2;
      output.set(hash3);
    }
    return 0;
  }
};
var elliptic = lib(elliptic$1);
const { Transform: Transform$1 } = readableBrowser.exports;
var keccak$1 = (KeccakState) => class Keccak2 extends Transform$1 {
  constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._hashBitLength = hashBitLength;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error3 = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error3 = err;
    }
    callback(error3);
  }
  _flush(callback) {
    let error3 = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error3 = err;
    }
    callback(error3);
  }
  update(data2, encoding) {
    if (!Buffer.isBuffer(data2) && typeof data2 !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Digest already called");
    if (!Buffer.isBuffer(data2))
      data2 = Buffer.from(data2, encoding);
    this._state.absorb(data2);
    return this;
  }
  digest(encoding) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    if (this._delimitedSuffix)
      this._state.absorbLastFewBits(this._delimitedSuffix);
    let digest10 = this._state.squeeze(this._hashBitLength / 8);
    if (encoding !== void 0)
      digest10 = digest10.toString(encoding);
    this._resetState();
    return digest10;
  }
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  _clone() {
    const clone2 = new Keccak2(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    this._state.copy(clone2._state);
    clone2._finalized = this._finalized;
    return clone2;
  }
};
const { Transform } = readableBrowser.exports;
var shake = (KeccakState) => class Shake extends Transform {
  constructor(rate, capacity, delimitedSuffix, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error3 = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error3 = err;
    }
    callback(error3);
  }
  _flush() {
  }
  _read(size) {
    this.push(this.squeeze(size));
  }
  update(data2, encoding) {
    if (!Buffer.isBuffer(data2) && typeof data2 !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Squeeze already called");
    if (!Buffer.isBuffer(data2))
      data2 = Buffer.from(data2, encoding);
    this._state.absorb(data2);
    return this;
  }
  squeeze(dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true;
      this._state.absorbLastFewBits(this._delimitedSuffix);
    }
    let data2 = this._state.squeeze(dataByteLength);
    if (encoding !== void 0)
      data2 = data2.toString(encoding);
    return data2;
  }
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  _clone() {
    const clone2 = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
    this._state.copy(clone2._state);
    clone2._finalized = this._finalized;
    return clone2;
  }
};
const createKeccak = keccak$1;
const createShake = shake;
var api = function(KeccakState) {
  const Keccak2 = createKeccak(KeccakState);
  const Shake = createShake(KeccakState);
  return function(algorithm, options) {
    const hash3 = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
    switch (hash3) {
      case "keccak224":
        return new Keccak2(1152, 448, null, 224, options);
      case "keccak256":
        return new Keccak2(1088, 512, null, 256, options);
      case "keccak384":
        return new Keccak2(832, 768, null, 384, options);
      case "keccak512":
        return new Keccak2(576, 1024, null, 512, options);
      case "sha3-224":
        return new Keccak2(1152, 448, 6, 224, options);
      case "sha3-256":
        return new Keccak2(1088, 512, 6, 256, options);
      case "sha3-384":
        return new Keccak2(832, 768, 6, 384, options);
      case "sha3-512":
        return new Keccak2(576, 1024, 6, 512, options);
      case "shake128":
        return new Shake(1344, 256, 31, options);
      case "shake256":
        return new Shake(1088, 512, 31, options);
      default:
        throw new Error("Invald algorithm: " + algorithm);
    }
  };
};
var keccakStateUnroll = {};
const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
keccakStateUnroll.p1600 = function(s2) {
  for (let round = 0; round < 24; ++round) {
    const lo0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
    const hi0 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
    const lo1 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
    const hi1 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
    const lo2 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
    const hi2 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
    const lo3 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
    const hi3 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
    const lo4 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
    const hi4 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
    const t1slo0 = s2[0] ^ lo;
    const t1shi0 = s2[1] ^ hi;
    const t1slo5 = s2[10] ^ lo;
    const t1shi5 = s2[11] ^ hi;
    const t1slo10 = s2[20] ^ lo;
    const t1shi10 = s2[21] ^ hi;
    const t1slo15 = s2[30] ^ lo;
    const t1shi15 = s2[31] ^ hi;
    const t1slo20 = s2[40] ^ lo;
    const t1shi20 = s2[41] ^ hi;
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
    const t1slo1 = s2[2] ^ lo;
    const t1shi1 = s2[3] ^ hi;
    const t1slo6 = s2[12] ^ lo;
    const t1shi6 = s2[13] ^ hi;
    const t1slo11 = s2[22] ^ lo;
    const t1shi11 = s2[23] ^ hi;
    const t1slo16 = s2[32] ^ lo;
    const t1shi16 = s2[33] ^ hi;
    const t1slo21 = s2[42] ^ lo;
    const t1shi21 = s2[43] ^ hi;
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
    const t1slo2 = s2[4] ^ lo;
    const t1shi2 = s2[5] ^ hi;
    const t1slo7 = s2[14] ^ lo;
    const t1shi7 = s2[15] ^ hi;
    const t1slo12 = s2[24] ^ lo;
    const t1shi12 = s2[25] ^ hi;
    const t1slo17 = s2[34] ^ lo;
    const t1shi17 = s2[35] ^ hi;
    const t1slo22 = s2[44] ^ lo;
    const t1shi22 = s2[45] ^ hi;
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
    const t1slo3 = s2[6] ^ lo;
    const t1shi3 = s2[7] ^ hi;
    const t1slo8 = s2[16] ^ lo;
    const t1shi8 = s2[17] ^ hi;
    const t1slo13 = s2[26] ^ lo;
    const t1shi13 = s2[27] ^ hi;
    const t1slo18 = s2[36] ^ lo;
    const t1shi18 = s2[37] ^ hi;
    const t1slo23 = s2[46] ^ lo;
    const t1shi23 = s2[47] ^ hi;
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
    const t1slo4 = s2[8] ^ lo;
    const t1shi4 = s2[9] ^ hi;
    const t1slo9 = s2[18] ^ lo;
    const t1shi9 = s2[19] ^ hi;
    const t1slo14 = s2[28] ^ lo;
    const t1shi14 = s2[29] ^ hi;
    const t1slo19 = s2[38] ^ lo;
    const t1shi19 = s2[39] ^ hi;
    const t1slo24 = s2[48] ^ lo;
    const t1shi24 = s2[49] ^ hi;
    const t2slo0 = t1slo0;
    const t2shi0 = t1shi0;
    const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
    const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
    const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
    const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
    const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
    const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
    const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
    const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
    const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
    const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
    const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
    const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
    const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
    const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
    const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
    const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
    const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
    const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
    const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
    const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
    const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
    const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
    const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
    const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
    const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
    const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
    const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
    const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
    const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
    const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
    const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
    const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
    const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
    const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
    const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
    const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
    const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
    const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
    const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
    const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
    const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
    const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
    const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
    const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
    const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
    const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
    const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
    const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
    s2[0] = t2slo0 ^ ~t2slo1 & t2slo2;
    s2[1] = t2shi0 ^ ~t2shi1 & t2shi2;
    s2[10] = t2slo5 ^ ~t2slo6 & t2slo7;
    s2[11] = t2shi5 ^ ~t2shi6 & t2shi7;
    s2[20] = t2slo10 ^ ~t2slo11 & t2slo12;
    s2[21] = t2shi10 ^ ~t2shi11 & t2shi12;
    s2[30] = t2slo15 ^ ~t2slo16 & t2slo17;
    s2[31] = t2shi15 ^ ~t2shi16 & t2shi17;
    s2[40] = t2slo20 ^ ~t2slo21 & t2slo22;
    s2[41] = t2shi20 ^ ~t2shi21 & t2shi22;
    s2[2] = t2slo1 ^ ~t2slo2 & t2slo3;
    s2[3] = t2shi1 ^ ~t2shi2 & t2shi3;
    s2[12] = t2slo6 ^ ~t2slo7 & t2slo8;
    s2[13] = t2shi6 ^ ~t2shi7 & t2shi8;
    s2[22] = t2slo11 ^ ~t2slo12 & t2slo13;
    s2[23] = t2shi11 ^ ~t2shi12 & t2shi13;
    s2[32] = t2slo16 ^ ~t2slo17 & t2slo18;
    s2[33] = t2shi16 ^ ~t2shi17 & t2shi18;
    s2[42] = t2slo21 ^ ~t2slo22 & t2slo23;
    s2[43] = t2shi21 ^ ~t2shi22 & t2shi23;
    s2[4] = t2slo2 ^ ~t2slo3 & t2slo4;
    s2[5] = t2shi2 ^ ~t2shi3 & t2shi4;
    s2[14] = t2slo7 ^ ~t2slo8 & t2slo9;
    s2[15] = t2shi7 ^ ~t2shi8 & t2shi9;
    s2[24] = t2slo12 ^ ~t2slo13 & t2slo14;
    s2[25] = t2shi12 ^ ~t2shi13 & t2shi14;
    s2[34] = t2slo17 ^ ~t2slo18 & t2slo19;
    s2[35] = t2shi17 ^ ~t2shi18 & t2shi19;
    s2[44] = t2slo22 ^ ~t2slo23 & t2slo24;
    s2[45] = t2shi22 ^ ~t2shi23 & t2shi24;
    s2[6] = t2slo3 ^ ~t2slo4 & t2slo0;
    s2[7] = t2shi3 ^ ~t2shi4 & t2shi0;
    s2[16] = t2slo8 ^ ~t2slo9 & t2slo5;
    s2[17] = t2shi8 ^ ~t2shi9 & t2shi5;
    s2[26] = t2slo13 ^ ~t2slo14 & t2slo10;
    s2[27] = t2shi13 ^ ~t2shi14 & t2shi10;
    s2[36] = t2slo18 ^ ~t2slo19 & t2slo15;
    s2[37] = t2shi18 ^ ~t2shi19 & t2shi15;
    s2[46] = t2slo23 ^ ~t2slo24 & t2slo20;
    s2[47] = t2shi23 ^ ~t2shi24 & t2shi20;
    s2[8] = t2slo4 ^ ~t2slo0 & t2slo1;
    s2[9] = t2shi4 ^ ~t2shi0 & t2shi1;
    s2[18] = t2slo9 ^ ~t2slo5 & t2slo6;
    s2[19] = t2shi9 ^ ~t2shi5 & t2shi6;
    s2[28] = t2slo14 ^ ~t2slo10 & t2slo11;
    s2[29] = t2shi14 ^ ~t2shi10 & t2shi11;
    s2[38] = t2slo19 ^ ~t2slo15 & t2slo16;
    s2[39] = t2shi19 ^ ~t2shi15 & t2shi16;
    s2[48] = t2slo24 ^ ~t2slo20 & t2slo21;
    s2[49] = t2shi24 ^ ~t2shi20 & t2shi21;
    s2[0] ^= P1600_ROUND_CONSTANTS[round * 2];
    s2[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
  }
};
const keccakState = keccakStateUnroll;
function Keccak() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  this.blockSize = null;
  this.count = 0;
  this.squeezing = false;
}
Keccak.prototype.initialize = function(rate, capacity) {
  for (let i = 0; i < 50; ++i)
    this.state[i] = 0;
  this.blockSize = rate / 8;
  this.count = 0;
  this.squeezing = false;
};
Keccak.prototype.absorb = function(data2) {
  for (let i = 0; i < data2.length; ++i) {
    this.state[~~(this.count / 4)] ^= data2[i] << 8 * (this.count % 4);
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
};
Keccak.prototype.absorbLastFewBits = function(bits) {
  this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
  if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
    keccakState.p1600(this.state);
  this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
  keccakState.p1600(this.state);
  this.count = 0;
  this.squeezing = true;
};
Keccak.prototype.squeeze = function(length2) {
  if (!this.squeezing)
    this.absorbLastFewBits(1);
  const output = Buffer.alloc(length2);
  for (let i = 0; i < length2; ++i) {
    output[i] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
  return output;
};
Keccak.prototype.copy = function(dest) {
  for (let i = 0; i < 50; ++i)
    dest.state[i] = this.state[i];
  dest.blockSize = this.blockSize;
  dest.count = this.count;
  dest.squeezing = this.squeezing;
};
var keccak = Keccak;
var js = api(keccak);
var __importDefault$d = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
const bn_js_1 = __importDefault$d(bn$4.exports);
const buffer_1 = buffer$3;
const keccak_1 = __importDefault$d(js);
function keccak256$2(value) {
  value = toBuffer(value);
  return keccak_1.default("keccak256").update(value).digest();
}
function toBuffer(value) {
  if (!buffer_1.Buffer.isBuffer(value)) {
    if (Array.isArray(value)) {
      value = buffer_1.Buffer.from(value);
    } else if (typeof value === "string") {
      if (isHexString$1(value)) {
        value = buffer_1.Buffer.from(padToEven(stripHexPrefix(value)), "hex");
      } else {
        value = buffer_1.Buffer.from(value);
      }
    } else if (typeof value === "number") {
      value = intToBuffer(value);
    } else if (value === null || value === void 0) {
      value = buffer_1.Buffer.allocUnsafe(0);
    } else if (bn_js_1.default.isBN(value)) {
      value = value.toArrayLike(buffer_1.Buffer);
    } else if (value.toArray) {
      value = buffer_1.Buffer.from(value.toArray());
    } else {
      throw new Error("invalid type");
    }
  }
  return value;
}
function isHexString$1(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
function padToEven(value) {
  if (typeof value !== "string") {
    throw new Error(`while padding to even, value must be string, is currently ${typeof value}, while padToEven.`);
  }
  if (value.length % 2) {
    value = `0${value}`;
  }
  return value;
}
function stripHexPrefix(value) {
  if (typeof value !== "string") {
    return value;
  }
  return isHexPrefixed(value) ? value.slice(2) : value;
}
function isHexPrefixed(value) {
  if (typeof value !== "string") {
    throw new Error("value must be type 'string', is currently type " + typeof value + ", while checking isHexPrefixed.");
  }
  return value.slice(0, 2) === "0x";
}
function intToBuffer(i) {
  const hex = intToHex(i);
  return buffer_1.Buffer.from(padToEven(hex.slice(2)), "hex");
}
function intToHex(i) {
  const hex = i.toString(16);
  return `0x${hex}`;
}
if (typeof window !== "undefined") {
  window.keccak256 = keccak256$2;
}
var keccak256_1$1 = keccak256$2;
var __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(secp256k1, "__esModule", { value: true });
const base64url_1$4 = __importDefault$c(base64url$3.exports);
const secp256k1_1$1 = __importDefault$c(elliptic);
const constants_1$3 = constants;
const keccak256_1 = __importDefault$c(keccak256_1$1);
class Secp256k1 {
  constructor(_key, pk) {
    this._key = _key;
    this.ownerLength = constants_1$3.SIG_CONFIG[constants_1$3.SignatureConfig.ETHEREUM].pubLength;
    this.signatureLength = constants_1$3.SIG_CONFIG[constants_1$3.SignatureConfig.ETHEREUM].sigLength;
    this.signatureType = constants_1$3.SignatureConfig.ETHEREUM;
    this.pk = pk.toString("hex");
  }
  get publicKey() {
    return Buffer.alloc(0);
  }
  get key() {
    return Buffer.from(this._key, "hex");
  }
  static async verify(pk, message, signature2) {
    let p = pk;
    if (typeof pk === "string")
      p = base64url_1$4.default.toBuffer(pk);
    let verified = false;
    try {
      verified = secp256k1_1$1.default.ecdsaVerify(signature2, keccak256_1.default(Buffer.from(message)), p);
    } catch (e) {
    }
    return verified;
  }
  sign(message) {
    return secp256k1_1$1.default.ecdsaSign(keccak256_1.default(Buffer.from(message)), Buffer.from(this.key)).signature;
  }
}
secp256k1.default = Secp256k1;
var bn$1 = { exports: {} };
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base3, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$3.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init6(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base3, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c = string2.charCodeAt(index2);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul7) {
      var r2 = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul7;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert2(c >= 0 && b < mul7, "Invalid character");
        r2 += b;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base3);
        for (i = 0; i < mod; i++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect9;
      } catch (e) {
        BN2.prototype.inspect = inspect9;
      }
    } else {
      BN2.prototype.inspect = inspect9;
    }
    function inspect9() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modrn(groupBase).toString(base3);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON4() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length2) {
        return this.toArrayLike(Buffer2, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType2, size) {
      if (ArrayType2.allocUnsafe) {
        return ArrayType2.allocUnsafe(size);
      }
      return new ArrayType2(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length2) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType2, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t = w;
        var r2 = 0;
        if (t >= 4096) {
          r2 += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r2 += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r2 += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r2 += 2;
          t >>>= 2;
        }
        return r2 + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r2 = 0;
      if ((t & 8191) === 0) {
        r2 += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r2 += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r2 += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r2 += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r2 += b;
        if (b !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor4(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add7(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r2 = a * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r2 = a * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul7(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h -= s2;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2)
        return false;
      var w = this.words[s2];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul7, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul7;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a.cmp(b);
        if (r2 < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red2(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p) {
      this.name = name2;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg6(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add7(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul7(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r2 = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s2;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN2(1).iushln(m - i - 1));
        r2 = r2.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul7(a, b) {
      if (a.isZero() || b.isZero())
        return new BN2(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$1);
const _BN = bn$1.exports;
const version$q = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error3) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error3) {
    return error3.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode$1;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode$1 || (ErrorCode$1 = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key3) => {
      const value = params[key3];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 15];
          }
          messageDetails.push(key3 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key3 + "=" + JSON.stringify(value));
        }
      } catch (error4) {
        messageDetails.push(key3 + "=" + JSON.stringify(params[key3].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode$1.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode$1.CALL_EXCEPTION:
      case ErrorCode$1.INSUFFICIENT_FUNDS:
      case ErrorCode$1.MISSING_NEW:
      case ErrorCode$1.NONCE_EXPIRED:
      case ErrorCode$1.REPLACEMENT_UNDERPRICED:
      case ErrorCode$1.TRANSACTION_REPLACED:
      case ErrorCode$1.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error3 = new Error(message);
    error3.reason = reason;
    error3.code = code2;
    Object.keys(params).forEach(function(key3) {
      error3[key3] = params[key3];
    });
    return error3;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$q);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode$1;
Logger.levels = LogLevel;
const version$p = "bytes/5.7.0";
const logger$J = new Logger(version$p);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$J.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger$J.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$J.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length2) {
  value = arrayify(value);
  if (value.length > length2) {
    logger$J.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice(result);
}
function isHexString(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$J.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$J.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger$J.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data2) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    return null;
  }
  return (data2.length - 2) / 2;
}
function hexDataSlice(data2, offset, endOffset) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    logger$J.throwArgumentError("invalid hexData", "value", data2);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data2.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data2.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger$J.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger$J.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger$J.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger$J.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$J.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$J.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$J.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$J.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$J.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger$J.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger$J.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$J.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger$J.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$J.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
const version$o = "bignumber/5.7.0";
var BN$1 = _BN.BN;
const logger$I = new Logger(version$o);
const _constructorGuard$4 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard$4) {
      logger$I.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error3) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger$I.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$I.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$I.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$I.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key3) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$4, toHex2(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$4, toHex2(new BN$1(value)));
      }
      return logger$I.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger$I.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex2(value) {
  if (typeof value !== "string") {
    return toHex2(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$I.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex2(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex2(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN$1("-" + hex.substring(3), 16);
  }
  return new BN$1(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$I.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN$1(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN$1(value, 16).toString(36);
}
const logger$H = new Logger(version$o);
const _constructorGuard$3 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger$H.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
let zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger$H.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$H.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$H.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$H.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$H.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed")
        ;
      else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger$H.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key3, type, defaultValue) => {
        if (value[key3] == null) {
          return defaultValue;
        }
        if (typeof value[key3] !== type) {
          logger$H.throwArgumentError("invalid fixed format (" + key3 + " not " + type + ")", "format." + key3, value[key3]);
        }
        return value[key3];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$H.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$H.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$3, signed2, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$H.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$H.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$H.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$H.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error3) {
      if (error3.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error3;
      }
    }
    return logger$H.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
const version$n = "properties/5.7.0";
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$G = new Logger(version$n);
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key3) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key3]) {
      return ctor[key3];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter$f(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key3) => {
      const value = object[key3];
      return Promise.resolve(value).then((v) => ({ key: key3, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger$G.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key3) => {
    if (!properties[key3]) {
      logger$G.throwArgumentError("invalid object key - " + key3, "transaction:" + key3, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key3 in object) {
    result[key3] = object[key3];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys2 = Object.keys(object);
    for (let i = 0; i < keys2.length; i++) {
      let value = null;
      try {
        value = object[keys2[i]];
      } catch (error3) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$G.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key3 in object) {
      const value = object[key3];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key3, deepCopy(value));
    }
    return result;
  }
  return logger$G.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key3 in info) {
      this[key3] = deepCopy(info[key3]);
    }
  }
}
const version$m = "abi/5.7.0";
const logger$F = new Logger(version$m);
const _constructorGuard$2 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$F.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger$F.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node3 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node3.indexed = false;
    }
    return node3;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node2 = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node2.state.allowType && node2.type === "") {
          node2.type = "tuple";
        } else if (!node2.state.allowParams) {
          throwError(i);
        }
        node2.state.allowType = false;
        node2.type = verifyType(node2.type);
        node2.components = [newNode(node2)];
        node2 = node2.components[0];
        break;
      case ")":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let child = node2;
        node2 = node2.parent;
        if (!node2) {
          throwError(i);
        }
        delete child.parent;
        node2.state.allowParams = false;
        node2.state.allowName = true;
        node2.state.allowArray = true;
        break;
      case ",":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let sibling = newNode(node2.parent);
        node2.parent.components.push(sibling);
        delete node2.parent;
        node2 = sibling;
        break;
      case " ":
        if (node2.state.allowType) {
          if (node2.type !== "") {
            node2.type = verifyType(node2.type);
            delete node2.state.allowType;
            node2.state.allowName = true;
            node2.state.allowParams = true;
          }
        }
        if (node2.state.allowName) {
          if (node2.name !== "") {
            if (node2.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node2.indexed) {
                throwError(i);
              }
              node2.indexed = true;
              node2.name = "";
            } else if (checkModifier(node2.type, node2.name)) {
              node2.name = "";
            } else {
              node2.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node2.state.allowArray) {
          throwError(i);
        }
        node2.type += c;
        node2.state.allowArray = false;
        node2.state.allowName = false;
        node2.state.readArray = true;
        break;
      case "]":
        if (!node2.state.readArray) {
          throwError(i);
        }
        node2.type += c;
        node2.state.readArray = false;
        node2.state.allowArray = true;
        node2.state.allowName = true;
        break;
      default:
        if (node2.state.allowType) {
          node2.type += c;
          node2.state.allowParams = true;
          node2.state.allowArray = true;
        } else if (node2.state.allowName) {
          node2.name += c;
          delete node2.state.allowArray;
        } else if (node2.state.readArray) {
          node2.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node2.parent) {
    logger$F.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node2.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node2.indexed) {
      throwError(originalParam.length - 7);
    }
    node2.indexed = true;
    node2.name = "";
  } else if (checkModifier(node2.type, node2.name)) {
    node2.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key3 in params) {
    defineReadOnly(object, key3, params[key3]);
  }
}
const FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$F.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$2, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node2) {
      return ParamType.fromObject({
        name: node2.name,
        type: node2.type,
        indexed: node2.indexed,
        components: node2.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$F.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$F.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$F.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$F.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger$F.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$F.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$F.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$F.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$F.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$F.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$F.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$F.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$F.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger$F.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$F.throwArgumentError("invalid constructor object", "value", value);
    }
    let state2 = verifyState(value);
    if (state2.constant) {
      logger$F.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$F.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$F.throwArgumentError("invalid function object", "value", value);
    }
    let state2 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state2.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$F.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$F.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$F.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$F.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$F.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$2, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$F.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$F.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger$F.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$E = new Logger(version$m);
function checkResultErrors(result) {
  const errors2 = [];
  const checkErrors = function(path3, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key3 in object) {
      const childPath = path3.slice();
      childPath.push(key3);
      try {
        checkErrors(childPath, object[key3]);
      } catch (error3) {
        errors2.push({ path: childPath, error: error3 });
      }
    }
  };
  checkErrors([], result);
  return errors2;
}
class Coder {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger$E.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data2) {
    this._data.push(data2);
    this._dataLength += data2.length;
    return data2.length;
  }
  appendWriter(writer) {
    return this._writeData(concat(writer._data));
  }
  writeBytes(value) {
    let bytes = arrayify(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify(BigNumber.from(value));
    if (bytes.length > this.wordSize) {
      logger$E.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
}
class Reader {
  constructor(data2, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data2));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset, length2, loose) {
    let alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
        alignedLength = length2;
      } else {
        logger$E.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length2, loose) {
    let bytes = this._peekBytes(0, length2, !!loose);
    this._offset += bytes.length;
    return bytes.slice(0, length2);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING2 = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj2) {
        return Object.prototype.toString.call(obj2) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj2) {
        return typeof obj2 === "object" && obj2.buffer && obj2.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n, s2) {
        return methods2["cshake" + bits2].update(message, outputBits, n, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key3, message, outputBits, s2) {
        return methods2["kmac" + bits2].update(key3, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method[type] = createMethod2(bits2, padding2, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak2(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak2(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n, s2) {
        if (!n && !s2) {
          return methods2["shake" + bits2].create(outputBits);
        } else {
          return new Keccak2(bits2, padding2, outputBits).bytepad([n, s2], w);
        }
      };
      method.update = function(message, outputBits, n, s2) {
        return method.create(outputBits, n, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key3, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w).bytepad([key3], w);
      };
      method.update = function(key3, message, outputBits, s2) {
        return method.create(key3, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods2 = {}, methodNames = [];
    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + "_" + bits[j];
        methodNames.push(methodName);
        methods2[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods2[newMethodName] = methods2[methodName];
        }
      }
    }
    function Keccak2(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i2 = 0; i2 < 50; ++i2) {
        this.s[i2] = 0;
      }
    }
    Keccak2.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks2 = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i2, code2;
      while (index2 < length2) {
        if (this.reset) {
          this.reset = false;
          blocks2[0] = this.block;
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks2[i2] = 0;
          }
        }
        if (notString) {
          for (i2 = this.start; index2 < length2 && i2 < byteCount; ++index2) {
            blocks2[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start; index2 < length2 && i2 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks2[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
            } else if (code2 < 2048) {
              blocks2[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks2[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        if (i2 >= byteCount) {
          this.start = i2 - byteCount;
          this.block = blocks2[blockCount];
          for (i2 = 0; i2 < blockCount; ++i2) {
            s2[i2] ^= blocks2[i2];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i2;
        }
      }
      return this;
    };
    Keccak2.prototype.encode = function(x, right) {
      var o = x & 255, n = 1;
      var bytes = [o];
      x = x >> 8;
      o = x & 255;
      while (o > 0) {
        bytes.unshift(o);
        x = x >> 8;
        o = x & 255;
        ++n;
      }
      if (right) {
        bytes.push(n);
      } else {
        bytes.unshift(n);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak2.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0, length2 = str.length;
      if (notString) {
        bytes = length2;
      } else {
        for (var i2 = 0; i2 < str.length; ++i2) {
          var code2 = str.charCodeAt(i2);
          if (code2 < 128) {
            bytes += 1;
          } else if (code2 < 2048) {
            bytes += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i2) & 1023);
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak2.prototype.bytepad = function(strs, w) {
      var bytes = this.encode(w);
      for (var i2 = 0; i2 < strs.length; ++i2) {
        bytes += this.encodeString(strs[i2]);
      }
      var paddingBytes = w - bytes % w;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak2.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks2[i2 >> 2] |= this.padding[i2 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks2[0] = blocks2[blockCount];
        for (i2 = 1; i2 < blockCount + 1; ++i2) {
          blocks2[i2] = 0;
        }
      }
      blocks2[blockCount - 1] |= 2147483648;
      for (i2 = 0; i2 < blockCount; ++i2) {
        s2[i2] ^= blocks2[i2];
      }
      f2(s2);
    };
    Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var hex = "", block;
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          block = s2[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j2 % blockCount === 0) {
          f2(s2);
          i2 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i2];
        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak2.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var bytes = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer2);
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          array[j2] = s2[i2];
        }
        if (j2 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array[i2] = s2[i2];
        buffer2 = buffer2.slice(0, bytes);
      }
      return buffer2;
    };
    Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
    Keccak2.prototype.digest = Keccak2.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var array = [], offset, block;
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          offset = j2 << 2;
          block = s2[i2];
          array[offset] = block & 255;
          array[offset + 1] = block >> 8 & 255;
          array[offset + 2] = block >> 16 & 255;
          array[offset + 3] = block >> 24 & 255;
        }
        if (j2 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset = j2 << 2;
        block = s2[i2];
        array[offset] = block & 255;
        if (extraBytes > 1) {
          array[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak2.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak2();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak2.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h;
        s2[1] ^= l;
        s2[10] ^= h;
        s2[11] ^= l;
        s2[20] ^= h;
        s2[21] ^= l;
        s2[30] ^= h;
        s2[31] ^= l;
        s2[40] ^= h;
        s2[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h;
        s2[3] ^= l;
        s2[12] ^= h;
        s2[13] ^= l;
        s2[22] ^= h;
        s2[23] ^= l;
        s2[32] ^= h;
        s2[33] ^= l;
        s2[42] ^= h;
        s2[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h;
        s2[5] ^= l;
        s2[14] ^= h;
        s2[15] ^= l;
        s2[24] ^= h;
        s2[25] ^= l;
        s2[34] ^= h;
        s2[35] ^= l;
        s2[44] ^= h;
        s2[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h;
        s2[7] ^= l;
        s2[16] ^= h;
        s2[17] ^= l;
        s2[26] ^= h;
        s2[27] ^= l;
        s2[36] ^= h;
        s2[37] ^= l;
        s2[46] ^= h;
        s2[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h;
        s2[9] ^= l;
        s2[18] ^= h;
        s2[19] ^= l;
        s2[28] ^= h;
        s2[29] ^= l;
        s2[38] ^= h;
        s2[39] ^= l;
        s2[48] ^= h;
        s2[49] ^= l;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n];
        s2[1] ^= RC[n + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods2;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root[methodNames[i]] = methods2[methodNames[i]];
      }
    }
  })();
})(sha3$1);
const sha3 = sha3$1.exports;
function keccak256$1(data2) {
  return "0x" + sha3.keccak_256(arrayify(data2));
}
const version$l = "rlp/5.7.0";
const logger$D = new Logger(version$l);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data2, offset, length2) {
  let result = 0;
  for (let i = 0; i < length2; i++) {
    result = result * 256 + data2[offset + i];
  }
  return result;
}
function _encode3(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode3(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length3 = arrayifyInteger(payload.length);
    length3.unshift(247 + length3.length);
    return length3.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$D.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data2 = Array.prototype.slice.call(arrayify(object));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length2 = arrayifyInteger(data2.length);
  length2.unshift(183 + length2.length);
  return length2.concat(data2);
}
function encode$7(object) {
  return hexlify(_encode3(object));
}
function _decodeChildren(data2, offset, childOffset, length2) {
  const result = [];
  while (childOffset < offset + 1 + length2) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length2) {
      logger$D.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length2, result };
}
function _decode(data2, offset) {
  if (data2.length === 0) {
    logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    if (offset + 1 + lengthLength > data2.length) {
      logger$D.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data2.length) {
      logger$D.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length2);
  } else if (data2[offset] >= 192) {
    const length2 = data2[offset] - 192;
    if (offset + 1 + length2 > data2.length) {
      logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1, length2);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    if (offset + 1 + lengthLength > data2.length) {
      logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data2.length) {
      logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
    return { consumed: 1 + lengthLength + length2, result };
  } else if (data2[offset] >= 128) {
    const length2 = data2[offset] - 128;
    if (offset + 1 + length2 > data2.length) {
      logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1, offset + 1 + length2));
    return { consumed: 1 + length2, result };
  }
  return { consumed: 1, result: hexlify(data2[offset]) };
}
function decode$5(data2) {
  const bytes = arrayify(data2);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger$D.throwArgumentError("invalid rlp data", "data", data2);
  }
  return decoded.result;
}
const index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encode: encode$7,
  decode: decode$5
}, Symbol.toStringTag, { value: "Module" }));
const version$k = "address/5.7.0";
const logger$C = new Logger(version$k);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger$C.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256$1(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$C.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$C.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$C.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$C.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error3) {
  }
  return false;
}
function getIcapAddress(address) {
  let base362 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base362.length < 30) {
    base362 = "0" + base362;
  }
  return "XE" + ibanChecksum("XE00" + base362) + base362;
}
function getContractAddress(transaction2) {
  let from2 = null;
  try {
    from2 = getAddress(transaction2.from);
  } catch (error3) {
    logger$C.throwArgumentError("missing from address", "transaction", transaction2);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction2.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$7([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger$C.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger$C.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256$1(concat(["0xff", getAddress(from2), salt, initCodeHash])), 12));
}
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error3) {
      this._throwError(error3.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
const logger$B = new Logger(version$m);
function pack$1(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$B.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger$B.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger$B.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$B.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length2 = writer.appendWriter(staticWriter);
  length2 += writer.appendWriter(dynamicWriter);
  return length2;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error3) {
        if (error3.code === Logger.errors.BUFFER_OVERRUN) {
          throw error3;
        }
        value = error3;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error3) {
        if (error3.code === Logger.errors.BUFFER_OVERRUN) {
          throw error3;
        }
        value = error3;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index2];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length2, localName) {
    const type = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
    const dynamic = length2 === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length2;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger$B.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack$1(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger$B.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length2 = writer.writeValue(value.length);
    length2 += writer.writeBytes(value);
    return length2;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name2 = "bytes" + String(size);
    super(name2, name2, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data2 = arrayify(value);
    if (data2.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data2);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const Two = /* @__PURE__ */ BigNumber.from(2);
const WeiPerEther = /* @__PURE__ */ BigNumber.from("1000000000000000000");
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const MinInt256 = /* @__PURE__ */ BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
const MaxInt256 = /* @__PURE__ */ BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
const EtherSymbol = "\u039E";
const index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AddressZero,
  NegativeOne: NegativeOne$1,
  Zero: Zero$1,
  One: One$1,
  Two,
  WeiPerEther,
  MaxUint256: MaxUint256$1,
  MinInt256,
  MaxInt256,
  HashZero,
  EtherSymbol
}, Symbol.toStringTag, { value: "Module" }));
class NumberCoder extends Coder {
  constructor(size, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size * 8;
    super(name2, name2, localName, false);
    this.size = size;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v = BigNumber.from(value);
    let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v.gt(bounds) || v.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v.lt(Zero$1) || v.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v = v.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
}
const version$j = "strings/5.7.0";
const logger$A = new Logger(version$j);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger$A.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$A.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function formatBytes32String(text2) {
  const bytes = toUtf8Bytes(text2);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data2 = arrayify(bytes);
  if (data2.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data2[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length2 = 31;
  while (data2[length2 - 1] === 0) {
    length2--;
  }
  return toUtf8String(data2.slice(0, length2));
}
function bytes2(data2) {
  if (data2.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data2.length; i += 4) {
    result.push(parseInt(data2.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data2, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data2.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data2) {
  let hi = 0;
  return data2.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range = ranges[i];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
const Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes2 = Table_B_2_lut_abs[codepoint];
  if (codes2) {
    return codes2;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes2 = toUtf8CodePoints(value);
  codes2 = flatten(codes2.map((code2) => {
    if (Table_B_1_flags.indexOf(code2) >= 0) {
      return [];
    }
    if (code2 >= 65024 && code2 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code2);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code2];
  }));
  codes2 = toUtf8CodePoints(_toUtf8String(codes2), UnicodeNormalizationForm.NFKC);
  codes2.forEach((code2) => {
    if (_nameprepTableC(code2)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes2.forEach((code2) => {
    if (_nameprepTableA1(code2)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes2);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name2;
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack$1(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
}
const logger$z = new Logger(version$m);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger$z.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger$z.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger$z.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data2, allowLoose) {
    return new Reader(data2, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types2) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types2, values) {
    if (types2.length !== values.length) {
      logger$z.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types2.length, values: values.length },
        value: { types: types2, values }
      });
    }
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types2, data2, loose) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data2), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(text2) {
  return keccak256$1(toUtf8Bytes(text2));
}
const version$i = "hash/5.7.0";
function decode$4(textData) {
  textData = atob(textData);
  const data2 = [];
  for (let i = 0; i < textData.length; i++) {
    data2.push(textData.charCodeAt(i));
  }
  return arrayify(data2);
}
function encode$6(data2) {
  data2 = arrayify(data2);
  let textData = "";
  for (let i = 0; i < data2.length; i++) {
    textData += String.fromCharCode(data2[i]);
  }
  return btoa(textData);
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$4,
  encode: encode$6
}, Symbol.toStringTag, { value: "Module" }));
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach4 = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach4.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip2 = u16();
  let pos_payload = pos;
  pos += skip2;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N10 = 31;
  const FULL = Math.pow(2, N10);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N10; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(bytes) {
  return read_payload(decode_arithmetic(bytes));
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n, next) {
  let v = Array(n);
  for (let i = 0; i < n; i++)
    v[i] = 1 + next();
  return v;
}
function read_ascending(n, next) {
  let v = Array(n);
  for (let i = 0, x = -1; i < n; i++)
    v[i] = x += 1 + next();
  return v;
}
function read_deltas(n, next) {
  let v = Array(n);
  for (let i = 0, x = 0; i < n; i++)
    v[i] = x += signed(next());
  return v;
}
function read_member_array(next, lookup) {
  let v = read_ascending(next(), next);
  let n = next();
  let vX = read_ascending(n, next);
  let vN = read_counts(n, next);
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < vN[i]; j++) {
      v.push(vX[i] + j);
    }
  }
  return lookup ? v.map((x) => lookup[x]) : v;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v = [];
  while (true) {
    let i = next();
    if (i == 0)
      break;
    v.push(i);
  }
  return v;
}
function read_transposed(n, w, next) {
  let m = Array(n).fill(void 0).map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return flat(m.map((v, i) => {
    const x = v[0], ys = v.slice(1);
    return Array(vN[i]).fill(void 0).map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  }));
}
function read_replacement_table(w, next) {
  let n = 1 + next();
  let m = read_transposed(n, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a, b) => a - b);
  return read2();
  function read2() {
    let branches = [];
    while (true) {
      let keys2 = read_member_array(next, sorted);
      if (keys2.length == 0)
        break;
      branches.push({ set: new Set(keys2), node: read2() });
    }
    branches.sort((a, b) => b.set.size - a.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save3 = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save: save3, check };
  }
}
function getData() {
  return read_compressed_payload(decode$4("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"));
}
const r = getData();
const VALID = new Set(read_member_array(r));
const IGNORED = new Set(read_member_array(r));
const MAPPED = read_mapped_map(r);
const EMOJI_ROOT = read_emoji_trie(r);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
        if (cps[i] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize3(name2, filter_fe0f));
}
function normalize3(name2, emoji_filter) {
  let input = explode_cp(name2).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s2) {
  return s2.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a;
  let node2 = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node2 = (_a = node2.branches.find((x) => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
    if (!node2)
      break;
    if (node2.save) {
      saved = cp;
    } else if (node2.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node2.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node2.valid) {
      emoji = stack.slice();
      if (node2.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$y = new Logger(version$i);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes.length; i++) {
    const d = bytes[i];
    if (d === 46) {
      comps.push(checkComponent(bytes.slice(last, i)));
      last = i + 1;
    }
  }
  if (last >= bytes.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
function isValidName(name2) {
  try {
    return ensNameSplit(name2).length !== 0;
  } catch (error3) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger$y.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros$1;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256$1(concat([result, keccak256$1(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
const messagePrefix2 = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256$1(concat([
    toUtf8Bytes(messagePrefix2),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$x = new Logger(version$i);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key3) {
  return function(value) {
    if (typeof value !== "string") {
      logger$x.throwArgumentError(`invalid domain value for ${JSON.stringify(key3)}`, `domain.${key3}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error3) {
    }
    return logger$x.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error3) {
    }
    return logger$x.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes);
    } catch (error3) {
    }
    return logger$x.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$x.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v = BigNumber.from(value);
        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger$x.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$x.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger$x.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256$1(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types2) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types2)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types2).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types2) {
      const uniqueNames = {};
      types2[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$x.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types2);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types2);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$x.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types2);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n) => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger$x.throwArgumentError("missing primary type", "types", types2);
    } else if (primaryTypes.length > 1) {
      logger$x.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types2);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types2);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types2[name2]) + st.map((t) => encodeType(t, types2[t])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length2 = parseInt(match[3]);
      return (value) => {
        if (length2 >= 0 && value.length !== length2) {
          logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256$1);
        }
        return keccak256$1(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak256$1(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$x.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$x.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak256$1(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length2 = parseInt(match[3]);
      if (length2 >= 0 && value.length !== length2) {
        logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v) => this._visit(subtype, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger$x.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name2, types2, value) {
    return TypedDataEncoder.from(types2).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger$x.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a, b) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types2, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  static hash(domain, types2, value) {
    return keccak256$1(TypedDataEncoder.encode(domain, types2, value));
  }
  static resolveNames(domain, types2, value, resolveName2) {
    return __awaiter$e(this, void 0, void 0, function* () {
      domain = shallowCopy(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types2);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types2, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder.from(types2);
    const typesWithDomain = shallowCopy(types2);
    if (typesWithDomain.EIP712Domain) {
      logger$x.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$x.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$x.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
const logger$w = new Logger(version$m);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error3) {
  const wrap2 = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap2.error = error3;
  return wrap2;
}
class Interface {
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$w.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger$w.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger$w.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi.map((j) => JSON.parse(j)));
    }
    return abi;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$w.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$w.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$w.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$w.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$w.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$w.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$w.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$w.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error3 = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error3)) {
          return this.errors[name2];
        }
      }
      logger$w.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$w.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$w.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$w.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error3) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error3;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data2) {
    return this._abiCoder.decode(params, data2);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data2) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify(data2);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$w.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  decodeFunctionData(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify(data2);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$w.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  decodeFunctionResult(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify(data2);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error3) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error3 = this.getError(selector);
            errorArgs = this._abiCoder.decode(error3.inputs, bytes.slice(4));
            errorName = error3.name;
            errorSignature = error3.format();
          } catch (error3) {
          }
        }
        break;
      }
    }
    return logger$w.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data2),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$w.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256$1(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value != null) {
          logger$w.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$w.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$w.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256$1(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(eventFragment, data2, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$w.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data2, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index2]) {
          result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error3) {
            result[index2] = error3;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error3) {
          result[index2] = error3;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index2];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i = 0; i < result.length; i++) {
      const value = result[i];
      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data2) {
    const hexData = hexlify(data2);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const version$h = "abstract-provider/5.7.0";
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$v = new Logger(version$h);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$v.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error3) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$g = "abstract-signer/5.7.0";
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$u = new Logger(version$g);
const allowedTransactionKeys$3 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  constructor() {
    logger$u.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction2));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction2, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction2));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction2);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network2 = yield this.provider.getNetwork();
      return network2.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction2) {
    for (const key3 in transaction2) {
      if (allowedTransactionKeys$3.indexOf(key3) === -1) {
        logger$u.throwArgumentError("invalid transaction key: " + key3, "transaction", transaction2);
      }
    }
    const tx = shallowCopy(transaction2);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$u.throwArgumentError("from address mismatch", "transaction", transaction2);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction2));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$c(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$u.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error3) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$u.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction2);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$u.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction2);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$u.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$u.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error3) => {
          if (forwardErrors.indexOf(error3.code) >= 0) {
            throw error3;
          }
          return logger$u.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error: error3,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$u.throwArgumentError("chainId address mismatch", "transaction", transaction2);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger$u.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$u.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction2) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types2, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
}
var bn = { exports: {} };
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base3, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$3.Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init6(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base3, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c = string2.charCodeAt(index2);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul7) {
      var r2 = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul7;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert2(c >= 0 && b < mul7, "Invalid character");
        r2 += b;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base3);
        for (i = 0; i < mod; i++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect9;
      } catch (e) {
        BN2.prototype.inspect = inspect9;
      }
    } else {
      BN2.prototype.inspect = inspect9;
    }
    function inspect9() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modrn(groupBase).toString(base3);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON4() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length2) {
        return this.toArrayLike(Buffer2, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType2, size) {
      if (ArrayType2.allocUnsafe) {
        return ArrayType2.allocUnsafe(size);
      }
      return new ArrayType2(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length2) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType2, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t = w;
        var r2 = 0;
        if (t >= 4096) {
          r2 += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r2 += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r2 += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r2 += 2;
          t >>>= 2;
        }
        return r2 + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r2 = 0;
      if ((t & 8191) === 0) {
        r2 += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r2 += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r2 += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r2 += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r2 += b;
        if (b !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor4(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add7(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r2 = a * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r2 = a * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul7(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h -= s2;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2)
        return false;
      var w = this.words[s2];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul7, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul7;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a.cmp(b);
        if (r2 < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red2(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p) {
      this.name = name2;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg6(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add7(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul7(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r2 = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s2;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN2(1).iushln(m - i - 1));
        r2 = r2.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul7(a, b) {
      if (a.isZero() || b.isZero())
        return new BN2(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
const BN = bn.exports;
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path3, base3) {
      return commonjsRequire$1(path3, base3 === void 0 || base3 === null ? module.path : base3);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire$1() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$1;
function assert$1(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$1.equal = function assertEqual2(l, r2, msg) {
  if (l != r2)
    throw new Error(msg || "Assertion failed: " + l + " != " + r2);
};
var utils_1$1 = createCommonjsModule(function(module, exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero22(msg[i].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode8(arr, enc) {
    if (enc === "hex")
      return toHex3(arr);
    else
      return arr;
  };
});
var utils_1$1$1 = createCommonjsModule(function(module, exports2) {
  var utils2 = exports2;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1$1.toArray;
  utils2.zero2 = utils_1$1.zero2;
  utils2.toHex = utils_1$1.toHex;
  utils2.encode = utils_1$1.encode;
  function getNAF2(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj2, name2, computer) {
    var key3 = "_" + name2;
    obj2.prototype[name2] = function cachedProperty3() {
      return this[key3] !== void 0 ? this[key3] : this[key3] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes) {
    return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes) {
    return new BN(bytes, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1$1.getNAF;
var getJSF = utils_1$1$1.getJSF;
var assert$1$1 = utils_1$1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$2 = BaseCurve;
BaseCurve.prototype.point = function point5() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate7() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul2(p, k) {
  assert$1$1(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul2(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$1$1(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index2 = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq6() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate8() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint4(bytes, enc) {
  bytes = utils_1$1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed2(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode4(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode6(enc, compact) {
  return utils_1$1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute3(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles2(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles2(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl7 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl7);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta3() {
  return null;
};
BasePoint.prototype.dblp = function dblp3(k) {
  var r2 = this;
  for (var i = 0; i < k; i++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1$1.assert;
function ShortCurve(conf) {
  base$2.call(this, "short", conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base$2);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism2(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots2(num) {
  var red2 = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red2).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN(3).toRed(red2).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r2;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r2 = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r2;
    v = u;
    u = r2;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit2(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve.prototype.pointFromX = function pointFromX3(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve.prototype.validate = function validate9(point7) {
  if (point7.inf)
    return true;
  var x = point7.x;
  var y = point7.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point(curve2, x, y, isRed) {
  base$2.BasePoint.call(this, curve2, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base$2.BasePoint);
ShortCurve.prototype.point = function point6(x, y, isRed) {
  return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON4(obj2, red2) {
  return Point.fromJSON(this, obj2, red2);
};
Point.prototype._getBeta = function _getBeta4() {
  if (!this.curve.endo)
    return;
  var pre2 = this.precomputed;
  if (pre2 && pre2.beta)
    return pre2.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre2) {
    var curve2 = this.curve;
    var endoMul = function(p) {
      return curve2.point(p.x.redMul(curve2.endo.beta), p.y);
    };
    pre2.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre2.naf && {
        wnd: pre2.naf.wnd,
        points: pre2.naf.points.map(endoMul)
      },
      doubles: pre2.doubles && {
        step: pre2.doubles.step,
        points: pre2.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON3() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON4(curve2, obj2, red2) {
  if (typeof obj2 === "string")
    obj2 = JSON.parse(obj2);
  var res = curve2.point(obj2[0], obj2[1], red2);
  if (!obj2[2])
    return res;
  function obj2point(obj3) {
    return curve2.point(obj3[0], obj3[1], red2);
  }
  var pre2 = obj2[2];
  res.precomputed = {
    beta: null,
    doubles: pre2.doubles && {
      step: pre2.doubles.step,
      points: [res].concat(pre2.doubles.points.map(obj2point))
    },
    naf: pre2.naf && {
      wnd: pre2.naf.wnd,
      points: [res].concat(pre2.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect6() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity5() {
  return this.inf;
};
Point.prototype.add = function add5(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl5() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX4() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY3() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul5(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd4(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd3(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq7(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg4(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre2 = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre2.naf && {
        wnd: pre2.naf.wnd,
        points: pre2.naf.points.map(negate)
      },
      doubles: pre2.doubles && {
        step: pre2.doubles.step,
        points: pre2.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ2() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve2, x, y, z) {
  base$2.BasePoint.call(this, curve2, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base$2.BasePoint);
ShortCurve.prototype.jpoint = function jpoint3(x, y, z) {
  return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP2() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg5() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add6(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd2(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp4(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i = 0; i < pow; i++)
      r2 = r2.dbl();
    return r2;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl6() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f2 = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s2).redISub(s2);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl2() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl2() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul6(k, kbase) {
  k = new BN(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq8(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP3(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect7() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity6() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports2) {
  var curve2 = exports2;
  curve2.base = base$2;
  curve2.short = short_1;
  curve2.mont = null;
  curve2.edwards = null;
});
var curves_1 = createCommonjsModule(function(module, exports2) {
  var curves2 = exports2;
  var assert2 = utils_1$1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$2.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$2.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre2;
  try {
    pre2 = null.crash();
  } catch (e) {
    pre2 = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$2.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre2
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1$1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1$1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1$1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init5(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac3() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update6(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed2(entropy, entropyEnc, add7, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add7;
    add7 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1$1.toArray(entropy, entropyEnc);
  add7 = utils_1$1.toArray(add7, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add7 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate2(len, enc, add7, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add7;
    add7 = enc;
    enc = null;
  }
  if (add7) {
    add7 = utils_1$1.toArray(add7, addEnc || "hex");
    this._update(add7);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add7);
  this._reseed++;
  return utils_1$1.encode(res, enc);
};
var assert$3 = utils_1$1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key2 = KeyPair;
KeyPair.fromPublic = function fromPublic3(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair)
    return pub2;
  return new KeyPair(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate2(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair)
    return priv2;
  return new KeyPair(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate10() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic3(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate2(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate2(key3, enc) {
  this.priv = new BN(key3, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic2(key3, enc) {
  if (key3.x || key3.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key3.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key3.x && key3.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key3.x, key3.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key3, enc);
};
KeyPair.prototype.derive = function derive2(pub2) {
  if (!pub2.validate()) {
    assert$3(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign5(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify5(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect8() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature.prototype._importDER = function _importDER2(data2, enc) {
  data2 = utils_1$1$1.toArray(data2, enc);
  var p = new Position();
  if (data2[p.place++] !== 48) {
    return false;
  }
  var len = getLength(data2, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data2.length) {
    return false;
  }
  if (data2[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data2, p);
  if (rlen === false) {
    return false;
  }
  var r2 = data2.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data2[p.place++] !== 2) {
    return false;
  }
  var slen = getLength(data2, p);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p.place) {
    return false;
  }
  var s2 = data2.slice(p.place, slen + p.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN(r2);
  this.s = new BN(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER2(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1$1.encode(res, enc);
};
var rand = function() {
  throw new Error("unsupported");
};
var assert$5 = utils_1$1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key2(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv2, enc) {
  return key2.fromPrivate(this, priv2, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic2(pub2, enc) {
  return key2.fromPublic(this, pub2, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (; ; ) {
    var priv2 = new BN(drbg.generate(bytes));
    if (priv2.cmp(ns2) > 0)
      continue;
    priv2.iaddn(1);
    return this.keyFromPrivate(priv2);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign6(msg, key3, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key3 = this.keyFromPrivate(key3, enc);
  msg = this._truncateToN(new BN(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key3.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k.invm(this.n).mul(r2.mul(key3.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify6(msg, signature$12, key3, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key3 = this.keyFromPublic(key3, enc);
  signature$12 = new signature(signature$12, "hex");
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key3.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r2) === 0;
  }
  p = this.g.jmulAdd(u1, key3.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$12, j, enc) {
  assert$5((3 & j) === j, "The recovery param is more than two bits");
  signature$12 = new signature(signature$12, enc);
  var n = this.n;
  var e = new BN(msg);
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$12.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e, signature$12, Q, enc) {
  signature$12 = new signature(signature$12, enc);
  if (signature$12.recoveryParam !== null)
    return signature$12.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$12, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports2) {
  var elliptic2 = exports2;
  elliptic2.version = { version: "6.5.4" }.version;
  elliptic2.utils = utils_1$1$1;
  elliptic2.rand = function() {
    throw new Error("unsupported");
  };
  elliptic2.curve = curve_1;
  elliptic2.curves = curves_1;
  elliptic2.ec = ec;
  elliptic2.eddsa = null;
});
var EC$1 = elliptic_1.ec;
const version$f = "signing-key/5.7.0";
const logger$t = new Logger(version$f);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$t.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest10) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest10);
    if (digestBytes.length !== 32) {
      logger$t.throwArgumentError("bad digest length", "digest", digest10);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest10, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest10), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key3, compressed) {
  const bytes = arrayify(key3);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger$t.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$e = "transactions/5.7.0";
const logger$s = new Logger(version$e);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
const transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
const allowedTransactionKeys$2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key3) {
  const publicKey = computePublicKey(key3);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest10, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest10), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$s.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index2) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$s.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index2) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger$s.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b) => a.address.localeCompare(b.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction2, signature2) {
  if (transaction2.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction2.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction2.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$s.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction2.chainId || 0, "chainId"),
    formatNumber(transaction2.nonce || 0, "nonce"),
    formatNumber(transaction2.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction2.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction2.gasLimit || 0, "gasLimit"),
    transaction2.to != null ? getAddress(transaction2.to) : "0x",
    formatNumber(transaction2.value || 0, "value"),
    transaction2.data || "0x",
    formatAccessList(transaction2.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$7(fields)]);
}
function _serializeEip2930(transaction2, signature2) {
  const fields = [
    formatNumber(transaction2.chainId || 0, "chainId"),
    formatNumber(transaction2.nonce || 0, "nonce"),
    formatNumber(transaction2.gasPrice || 0, "gasPrice"),
    formatNumber(transaction2.gasLimit || 0, "gasLimit"),
    transaction2.to != null ? getAddress(transaction2.to) : "0x",
    formatNumber(transaction2.value || 0, "value"),
    transaction2.data || "0x",
    formatAccessList(transaction2.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$7(fields)]);
}
function _serialize(transaction2, signature2) {
  checkProperties(transaction2, allowedTransactionKeys$2);
  const raw2 = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction2[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger$s.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger$s.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw2.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction2.chainId != null) {
    chainId = transaction2.chainId;
    if (typeof chainId !== "number") {
      logger$s.throwArgumentError("invalid transaction.chainId", "transaction", transaction2);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw2.push(hexlify(chainId));
    raw2.push("0x");
    raw2.push("0x");
  }
  if (!signature2) {
    return encode$7(raw2);
  }
  const sig = splitSignature(signature2);
  let v = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw2.pop();
    raw2.pop();
    raw2.pop();
    v += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v) {
      logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v) {
    logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw2.push(hexlify(v));
  raw2.push(stripZeros(arrayify(sig.r)));
  raw2.push(stripZeros(arrayify(sig.s)));
  return encode$7(raw2);
}
function serialize$1(transaction2, signature2) {
  if (transaction2.type == null || transaction2.type === 0) {
    if (transaction2.accessList != null) {
      logger$s.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction2);
    }
    return _serialize(transaction2, signature2);
  }
  switch (transaction2.type) {
    case 1:
      return _serializeEip2930(transaction2, signature2);
    case 2:
      return _serializeEip1559(transaction2, signature2);
  }
  return logger$s.throwError(`unsupported transaction type: ${transaction2.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction2.type
  });
}
function _parseEipSignature(tx, fields, serialize2) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error3) {
    logger$s.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest10 = keccak256$1(serialize2(tx));
    tx.from = recoverAddress(digest10, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error3) {
  }
}
function _parseEip1559(payload) {
  const transaction2 = decode$5(payload.slice(1));
  if (transaction2.length !== 9 && transaction2.length !== 12) {
    logger$s.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction2[2]);
  const maxFeePerGas = handleNumber(transaction2[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction2[0]).toNumber(),
    nonce: handleNumber(transaction2[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction2[4]),
    to: handleAddress(transaction2[5]),
    value: handleNumber(transaction2[6]),
    data: transaction2[7],
    accessList: accessListify(transaction2[8])
  };
  if (transaction2.length === 9) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction2.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction2 = decode$5(payload.slice(1));
  if (transaction2.length !== 8 && transaction2.length !== 11) {
    logger$s.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction2[0]).toNumber(),
    nonce: handleNumber(transaction2[1]).toNumber(),
    gasPrice: handleNumber(transaction2[2]),
    gasLimit: handleNumber(transaction2[3]),
    to: handleAddress(transaction2[4]),
    value: handleNumber(transaction2[5]),
    data: transaction2[6],
    accessList: accessListify(transaction2[7])
  };
  if (transaction2.length === 8) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction2.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction2 = decode$5(rawTransaction);
  if (transaction2.length !== 9 && transaction2.length !== 6) {
    logger$s.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction2[0]).toNumber(),
    gasPrice: handleNumber(transaction2[1]),
    gasLimit: handleNumber(transaction2[2]),
    to: handleAddress(transaction2[3]),
    value: handleNumber(transaction2[4]),
    data: transaction2[5],
    chainId: 0
  };
  if (transaction2.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction2[6]).toNumber();
  } catch (error3) {
    return tx;
  }
  tx.r = hexZeroPad(transaction2[7], 32);
  tx.s = hexZeroPad(transaction2[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw2 = transaction2.slice(0, 6);
    if (tx.chainId !== 0) {
      raw2.push(hexlify(tx.chainId));
      raw2.push("0x");
      raw2.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest10 = keccak256$1(encode$7(raw2));
    try {
      tx.from = recoverAddress(digest10, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error3) {
    }
    tx.hash = keccak256$1(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse$1(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$s.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const version$d = "contracts/5.7.0";
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$r = new Logger(version$d);
const allowedTransactionKeys$1 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter$b(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger$r.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error3) {
    }
    if (!resolver) {
      logger$r.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger$r.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter$b(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index2) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger$r.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$b(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger$r.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter$b(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger$r.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data2 = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data2,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data2);
      for (let i = 0; i < bytes.length; i++) {
        intrinsic += 4;
        if (bytes[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger$r.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key3) => overrides[key3] != null);
    if (leftovers.length) {
      logger$r.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger$r.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data2, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data2, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error3) {
        if (error3.code === Logger.errors.CALL_EXCEPTION) {
          error3.address = contract.address;
          error3.args = args;
          error3.transaction = tx;
        }
        throw error3;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger$r.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag$1(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter);
    this._listeners = [];
  }
  addListener(listener, once2) {
    this._listeners.push({ listener, once: once2 });
  }
  removeListener(listener) {
    let done2 = false;
    this._listeners = this._listeners.filter((item) => {
      if (done2 || item.listener !== listener) {
        return true;
      }
      done2 = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i) => i.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger$r.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }
    super(getEventTag$1(filter), filter);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data2, topics) => {
      return this.interface.decodeEventLog(this.fragment, data2, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error3) {
      event.args = null;
      event.decodeError = error3;
    }
  }
  getEmit(event) {
    const errors2 = checkResultErrors(event.args);
    if (errors2.length) {
      throw errors2[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data2, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data2, topics);
      };
      event.args = parsed.args;
    } catch (error3) {
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger$r.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger$r.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger$r.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error3) {
        logger$r.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger$r.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction2) {
    return getContractAddress(transaction2);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger$r.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  fallback(overrides) {
    if (!this.signer) {
      logger$r.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key3) {
      if (tx[key3] == null) {
        return;
      }
      logger$r.throwError("cannot override " + key3, Logger.errors.UNSUPPORTED_OPERATION, { operation: key3 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error3) {
      }
      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter), filter));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once2) {
    if (!this.provider) {
      logger$r.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once2);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error3) {
            event.decodeError = error3.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger$r.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key3) => {
        return accum + this._runningEvents[key3].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
class Contract extends BaseContract {
}
class ContractFactory {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger$r.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger$r.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key3 in tx) {
        if (!allowedTransactionKeys$1[key3]) {
          throw new Error("unknown transaction override " + key3);
        }
      }
    }
    ["data", "from", "to"].forEach((key3) => {
      if (tx[key3] == null) {
        return;
      }
      logger$r.throwError("cannot override " + key3, Logger.errors.UNSUPPORTED_OPERATION, { operation: key3 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger$r.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger$r.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger$r.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger$r.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
}
class BaseX {
  constructor(alphabet2) {
    defineReadOnly(this, "alphabet", alphabet2);
    defineReadOnly(this, "base", alphabet2.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet2.charAt(0));
    for (let i = 0; i < alphabet2.length; i++) {
      this._alphabetMap[alphabet2.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string2 += this._leader;
    }
    for (let q = digits.length - 1; q >= 0; --q) {
      string2 += this.alphabet[digits[q]];
    }
    return string2;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }
    return arrayify(new Uint8Array(bytes.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$c = "sha2/5.7.0";
const logger$q = new Logger(version$c);
function ripemd160(data2) {
  return "0x" + hash$2.ripemd160().update(arrayify(data2)).digest("hex");
}
function sha256$3(data2) {
  return "0x" + hash$2.sha256().update(arrayify(data2)).digest("hex");
}
function sha512$2(data2) {
  return "0x" + hash$2.sha512().update(arrayify(data2)).digest("hex");
}
function computeHmac(algorithm, key3, data2) {
  if (!SupportedAlgorithm[algorithm]) {
    logger$q.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + hash$2.hmac(hash$2[algorithm], arrayify(key3)).update(arrayify(data2)).digest("hex");
}
function pbkdf2$1(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T;
  for (let i = 1; i <= l; i++) {
    block1[salt.length] = i >> 24 & 255;
    block1[salt.length + 1] = i >> 16 & 255;
    block1[salt.length + 2] = i >> 8 & 255;
    block1[salt.length + 3] = i & 255;
    let U = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U.length;
      T = new Uint8Array(hLen);
      l = Math.ceil(keylen / hLen);
      r2 = keylen - (l - 1) * hLen;
    }
    T.set(U);
    for (let j = 1; j < iterations; j++) {
      U = arrayify(computeHmac(hashAlgorithm, password, U));
      for (let k = 0; k < hLen; k++)
        T[k] ^= U[k];
    }
    const destPos = (i - 1) * hLen;
    const len = i === l ? r2 : hLen;
    DK.set(arrayify(T).slice(0, len), destPos);
  }
  return hexlify(DK);
}
const version$b = "wordlists/5.7.0";
const logger$p = new Logger(version$b);
class Wordlist {
  constructor(locale) {
    logger$p.checkAbstract(new.target, Wordlist);
    defineReadOnly(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i = 0; i < 2048; i++) {
      const word = wordlist2.getWord(i);
      if (i !== wordlist2.getWordIndex(word)) {
        return "0x";
      }
      words2.push(word);
    }
    return id(words2.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index2) {
    loadWords(this);
    return wordlist[index2];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
};
const version$a = "hdnode/5.7.0";
const logger$o = new Logger(version$a);
const N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const MasterSecret = toUtf8Bytes("Bitcoin seed");
const HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data2) {
  return Base58.encode(concat([data2, hexDataSlice(sha256$3(sha256$3(data2)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger$o.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
const _constructorGuard$1 = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
    if (constructorGuard !== _constructorGuard$1) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256$3(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index2);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index2) {
    if (index2 > 4294967295) {
      throw new Error("invalid index - " + String(index2));
    }
    let path3 = this.path;
    if (path3) {
      path3 += "/" + (index2 & ~HardenedBit);
    }
    const data2 = new Uint8Array(37);
    if (index2 & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data2.set(arrayify(this.privateKey), 1);
      if (path3) {
        path3 += "'";
      }
    } else {
      data2.set(arrayify(this.publicKey));
    }
    for (let i = 24; i >= 0; i -= 8) {
      data2[33 + (i >> 3)] = index2 >> 24 - i & 255;
    }
    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data2));
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    let ki = null;
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek = new SigningKey(hexlify(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path3;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path: path3,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard$1, ki, Ki, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path3) {
    const components = path3.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path3);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      if (component.match(/^[0-9]+'$/)) {
        const index2 = parseInt(component.substring(0, component.length - 1));
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index2);
      } else if (component.match(/^[0-9]+$/)) {
        const index2 = parseInt(component);
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index2);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard$1, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes = Base58.decode(extendedKey);
    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify(bytes.slice(5, 9));
    const index2 = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes.slice(13, 45));
    const key3 = bytes.slice(45, 78);
    switch (hexlify(bytes.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard$1, null, hexlify(key3), parentFingerprint, chainCode, index2, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key3[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard$1, hexlify(key3.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
    }
    return logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2$1(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger$o.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index2 = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    if (index2 === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256$3(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256$3(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error3) {
  }
  return false;
}
function getAccountPath(index2) {
  if (typeof index2 !== "number" || index2 < 0 || index2 >= HardenedBit || index2 % 1) {
    logger$o.throwArgumentError("invalid account index", "index", index2);
  }
  return `m/44'/60'/${index2}'/0/0`;
}
const version$9 = "random/5.7.0";
const logger$n = new Logger(version$9);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto$1 || !crypto$1.getRandomValues) {
  logger$n.warn("WARNING: Missing strong random number source");
  crypto$1 = {
    getRandomValues: function(buffer2) {
      return logger$n.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes(length2) {
  if (length2 <= 0 || length2 > 1024 || length2 % 1 || length2 != length2) {
    logger$n.throwArgumentError("invalid length", "length", length2);
  }
  const result = new Uint8Array(length2);
  crypto$1.getRandomValues(result);
  return arrayify(result);
}
function shuffled(array) {
  array = array.slice();
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
  return array;
}
var aesJs = { exports: {} };
(function(module, exports2) {
  (function(root) {
    function checkInt(value) {
      return parseInt(value) === value;
    }
    function checkInts(arrayish) {
      if (!checkInt(arrayish.length)) {
        return false;
      }
      for (var i = 0; i < arrayish.length; i++) {
        if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
          return false;
        }
      }
      return true;
    }
    function coerceArray(arg, copy) {
      if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
        if (copy) {
          if (arg.slice) {
            arg = arg.slice();
          } else {
            arg = Array.prototype.slice.call(arg);
          }
        }
        return arg;
      }
      if (Array.isArray(arg)) {
        if (!checkInts(arg)) {
          throw new Error("Array contains invalid value: " + arg);
        }
        return new Uint8Array(arg);
      }
      if (checkInt(arg.length) && checkInts(arg)) {
        return new Uint8Array(arg);
      }
      throw new Error("unsupported array-like object");
    }
    function createArray(length2) {
      return new Uint8Array(length2);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
      if (sourceStart != null || sourceEnd != null) {
        if (sourceArray.slice) {
          sourceArray = sourceArray.slice(sourceStart, sourceEnd);
        } else {
          sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
      }
      targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function() {
      function toBytes2(text2) {
        var result = [], i = 0;
        text2 = encodeURI(text2);
        while (i < text2.length) {
          var c = text2.charCodeAt(i++);
          if (c === 37) {
            result.push(parseInt(text2.substr(i, 2), 16));
            i += 2;
          } else {
            result.push(c);
          }
        }
        return coerceArray(result);
      }
      function fromBytes(bytes) {
        var result = [], i = 0;
        while (i < bytes.length) {
          var c = bytes[i];
          if (c < 128) {
            result.push(String.fromCharCode(c));
            i++;
          } else if (c > 191 && c < 224) {
            result.push(String.fromCharCode((c & 31) << 6 | bytes[i + 1] & 63));
            i += 2;
          } else {
            result.push(String.fromCharCode((c & 15) << 12 | (bytes[i + 1] & 63) << 6 | bytes[i + 2] & 63));
            i += 3;
          }
        }
        return result.join("");
      }
      return {
        toBytes: toBytes2,
        fromBytes
      };
    }();
    var convertHex = function() {
      function toBytes2(text2) {
        var result = [];
        for (var i = 0; i < text2.length; i += 2) {
          result.push(parseInt(text2.substr(i, 2), 16));
        }
        return result;
      }
      var Hex = "0123456789abcdef";
      function fromBytes(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i++) {
          var v = bytes[i];
          result.push(Hex[(v & 240) >> 4] + Hex[v & 15]);
        }
        return result.join("");
      }
      return {
        toBytes: toBytes2,
        fromBytes
      };
    }();
    var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function convertToInt32(bytes) {
      var result = [];
      for (var i = 0; i < bytes.length; i += 4) {
        result.push(
          bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]
        );
      }
      return result;
    }
    var AES2 = function(key3) {
      if (!(this instanceof AES2)) {
        throw Error("AES must be instanitated with `new`");
      }
      Object.defineProperty(this, "key", {
        value: coerceArray(key3, true)
      });
      this._prepare();
    };
    AES2.prototype._prepare = function() {
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      }
      this._Ke = [];
      this._Kd = [];
      for (var i = 0; i <= rounds; i++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;
      var tk = convertToInt32(this.key);
      var index2;
      for (var i = 0; i < KC; i++) {
        index2 = i >> 2;
        this._Ke[index2][i % 4] = tk[i];
        this._Kd[rounds - index2][i % 4] = tk[i];
      }
      var rconpointer = 0;
      var t = KC, tt;
      while (t < roundKeyCount) {
        tt = tk[KC - 1];
        tk[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
        rconpointer += 1;
        if (KC != 8) {
          for (var i = 1; i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }
        } else {
          for (var i = 1; i < KC / 2; i++) {
            tk[i] ^= tk[i - 1];
          }
          tt = tk[KC / 2 - 1];
          tk[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
          for (var i = KC / 2 + 1; i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }
        }
        var i = 0, r2, c;
        while (i < KC && t < roundKeyCount) {
          r2 = t >> 2;
          c = t % 4;
          this._Ke[r2][c] = tk[i];
          this._Kd[rounds - r2][c] = tk[i++];
          t++;
        }
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var c = 0; c < 4; c++) {
          tt = this._Kd[r2][c];
          this._Kd[r2][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
        }
      }
    };
    AES2.prototype.encrypt = function(plaintext) {
      if (plaintext.length != 16) {
        throw new Error("invalid plaintext size (must be 16 bytes)");
      }
      var rounds = this._Ke.length - 1;
      var a = [0, 0, 0, 0];
      var t = convertToInt32(plaintext);
      for (var i = 0; i < 4; i++) {
        t[i] ^= this._Ke[0][i];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i = 0; i < 4; i++) {
          a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ this._Ke[r2][i];
        }
        t = a.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Ke[rounds][i];
        result[4 * i] = (S2[t[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (S2[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (S2[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (S2[t[(i + 3) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    AES2.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length != 16) {
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      }
      var rounds = this._Kd.length - 1;
      var a = [0, 0, 0, 0];
      var t = convertToInt32(ciphertext);
      for (var i = 0; i < 4; i++) {
        t[i] ^= this._Kd[0][i];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i = 0; i < 4; i++) {
          a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ this._Kd[r2][i];
        }
        t = a.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Kd[rounds][i];
        result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    var ModeOfOperationECB = function(key3) {
      if (!(this instanceof ModeOfOperationECB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Electronic Code Block";
      this.name = "ecb";
      this._aes = new AES2(key3);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        block = this._aes.encrypt(block);
        copyArray(block, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        copyArray(block, plaintext, i);
      }
      return plaintext;
    };
    var ModeOfOperationCBC = function(key3, iv) {
      if (!(this instanceof ModeOfOperationCBC)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Block Chaining";
      this.name = "cbc";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastCipherblock = coerceArray(iv, true);
      this._aes = new AES2(key3);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        for (var j = 0; j < 16; j++) {
          block[j] ^= this._lastCipherblock[j];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyArray(this._lastCipherblock, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        for (var j = 0; j < 16; j++) {
          plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
        }
        copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
      }
      return plaintext;
    };
    var ModeOfOperationCFB = function(key3, iv, segmentSize) {
      if (!(this instanceof ModeOfOperationCFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Feedback";
      this.name = "cfb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 size)");
      }
      if (!segmentSize) {
        segmentSize = 1;
      }
      this.segmentSize = segmentSize;
      this._shiftRegister = coerceArray(iv, true);
      this._aes = new AES2(key3);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
      if (plaintext.length % this.segmentSize != 0) {
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      }
      var encrypted = coerceArray(plaintext, true);
      var xorSegment;
      for (var i = 0; i < encrypted.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0; j < this.segmentSize; j++) {
          encrypted[i + j] ^= xorSegment[j];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length % this.segmentSize != 0) {
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      }
      var plaintext = coerceArray(ciphertext, true);
      var xorSegment;
      for (var i = 0; i < plaintext.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0; j < this.segmentSize; j++) {
          plaintext[i + j] ^= xorSegment[j];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return plaintext;
    };
    var ModeOfOperationOFB = function(key3, iv) {
      if (!(this instanceof ModeOfOperationOFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Output Feedback";
      this.name = "ofb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastPrecipher = coerceArray(iv, true);
      this._lastPrecipherIndex = 16;
      this._aes = new AES2(key3);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._lastPrecipherIndex === 16) {
          this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
          this._lastPrecipherIndex = 0;
        }
        encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      }
      return encrypted;
    };
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    var Counter = function(initialValue) {
      if (!(this instanceof Counter)) {
        throw Error("Counter must be instanitated with `new`");
      }
      if (initialValue !== 0 && !initialValue) {
        initialValue = 1;
      }
      if (typeof initialValue === "number") {
        this._counter = createArray(16);
        this.setValue(initialValue);
      } else {
        this.setBytes(initialValue);
      }
    };
    Counter.prototype.setValue = function(value) {
      if (typeof value !== "number" || parseInt(value) != value) {
        throw new Error("invalid counter value (must be an integer)");
      }
      for (var index2 = 15; index2 >= 0; --index2) {
        this._counter[index2] = value % 256;
        value = value >> 8;
      }
    };
    Counter.prototype.setBytes = function(bytes) {
      bytes = coerceArray(bytes, true);
      if (bytes.length != 16) {
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      }
      this._counter = bytes;
    };
    Counter.prototype.increment = function() {
      for (var i = 15; i >= 0; i--) {
        if (this._counter[i] === 255) {
          this._counter[i] = 0;
        } else {
          this._counter[i]++;
          break;
        }
      }
    };
    var ModeOfOperationCTR = function(key3, counter) {
      if (!(this instanceof ModeOfOperationCTR)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Counter";
      this.name = "ctr";
      if (!(counter instanceof Counter)) {
        counter = new Counter(counter);
      }
      this._counter = counter;
      this._remainingCounter = null;
      this._remainingCounterIndex = 16;
      this._aes = new AES2(key3);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._remainingCounterIndex === 16) {
          this._remainingCounter = this._aes.encrypt(this._counter._counter);
          this._remainingCounterIndex = 0;
          this._counter.increment();
        }
        encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
      }
      return encrypted;
    };
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    function pkcs7pad(data2) {
      data2 = coerceArray(data2, true);
      var padder = 16 - data2.length % 16;
      var result = createArray(data2.length + padder);
      copyArray(data2, result);
      for (var i = data2.length; i < result.length; i++) {
        result[i] = padder;
      }
      return result;
    }
    function pkcs7strip(data2) {
      data2 = coerceArray(data2, true);
      if (data2.length < 16) {
        throw new Error("PKCS#7 invalid length");
      }
      var padder = data2[data2.length - 1];
      if (padder > 16) {
        throw new Error("PKCS#7 padding byte out of range");
      }
      var length2 = data2.length - padder;
      for (var i = 0; i < padder; i++) {
        if (data2[length2 + i] !== padder) {
          throw new Error("PKCS#7 invalid padding byte");
        }
      }
      var result = createArray(length2);
      copyArray(data2, result, 0, 0, length2);
      return result;
    }
    var aesjs = {
      AES: AES2,
      Counter,
      ModeOfOperation: {
        ecb: ModeOfOperationECB,
        cbc: ModeOfOperationCBC,
        cfb: ModeOfOperationCFB,
        ofb: ModeOfOperationOFB,
        ctr: ModeOfOperationCTR
      },
      utils: {
        hex: convertHex,
        utf8: convertUtf8
      },
      padding: {
        pkcs7: {
          pad: pkcs7pad,
          strip: pkcs7strip
        }
      },
      _arrayTest: {
        coerceArray,
        createArray,
        copyArray
      }
    };
    {
      module.exports = aesjs;
    }
  })();
})(aesJs);
const aes = aesJs.exports;
const version$8 = "json-wallets/5.7.0";
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length2) {
  value = String(value);
  while (value.length < length2) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object, path3) {
  let currentChild = object;
  const comps = path3.toLowerCase().split("/");
  for (let i = 0; i < comps.length; i++) {
    let matchingChild = null;
    for (const key3 in currentChild) {
      if (key3.toLowerCase() === comps[i]) {
        matchingChild = currentChild[key3];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes2) {
  const bytes = arrayify(randomBytes2);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = hexlify(bytes);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const logger$m = new Logger(version$8);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
}
function decrypt$1(json, password) {
  const data2 = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data2, "ethaddr"));
  const encseed = looseArrayify(searchPath(data2, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger$m.throwArgumentError("invalid encseed", "json", json);
  }
  const key3 = arrayify(pbkdf2$1(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new aes.ModeOfOperation.cbc(key3, iv);
  const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256$1(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
function isCrowdsaleWallet(json) {
  let data2 = null;
  try {
    data2 = JSON.parse(json);
  } catch (error3) {
    return false;
  }
  return data2.encseed && data2.ethaddr;
}
function isKeystoreWallet(json) {
  let data2 = null;
  try {
    data2 = JSON.parse(json);
  } catch (error3) {
    return false;
  }
  if (!data2.version || parseInt(data2.version) !== data2.version || parseInt(data2.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error3) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error3) {
      return null;
    }
  }
  return null;
}
var scrypt$1 = { exports: {} };
(function(module, exports2) {
  (function(root) {
    const MAX_VALUE = 2147483647;
    function SHA2562(m) {
      const K2 = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
      let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
      const w = new Uint32Array(64);
      function blocks2(p2) {
        let off = 0, len = p2.length;
        while (len >= 64) {
          let a = h0, b = h1, c = h2, d = h3, e = h4, f2 = h5, g = h6, h = h7, u, i2, j, t1, t2;
          for (i2 = 0; i2 < 16; i2++) {
            j = off + i2 * 4;
            w[i2] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
          }
          for (i2 = 16; i2 < 64; i2++) {
            u = w[i2 - 2];
            t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w[i2 - 15];
            t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0) | 0;
          }
          for (i2 = 0; i2 < 64; i2++) {
            t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f2 ^ ~e & g) | 0) + (h + (K2[i2] + w[i2] | 0) | 0) | 0;
            t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
            h = g;
            g = f2;
            f2 = e;
            e = d + t1 | 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 | 0;
          }
          h0 = h0 + a | 0;
          h1 = h1 + b | 0;
          h2 = h2 + c | 0;
          h3 = h3 + d | 0;
          h4 = h4 + e | 0;
          h5 = h5 + f2 | 0;
          h6 = h6 + g | 0;
          h7 = h7 + h | 0;
          off += 64;
          len -= 64;
        }
      }
      blocks2(m);
      let i, bytesLeft = m.length % 64, bitLenHi = m.length / 536870912 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
      p.push(128);
      for (i = bytesLeft + 1; i < numZeros; i++) {
        p.push(0);
      }
      p.push(bitLenHi >>> 24 & 255);
      p.push(bitLenHi >>> 16 & 255);
      p.push(bitLenHi >>> 8 & 255);
      p.push(bitLenHi >>> 0 & 255);
      p.push(bitLenLo >>> 24 & 255);
      p.push(bitLenLo >>> 16 & 255);
      p.push(bitLenLo >>> 8 & 255);
      p.push(bitLenLo >>> 0 & 255);
      blocks2(p);
      return [
        h0 >>> 24 & 255,
        h0 >>> 16 & 255,
        h0 >>> 8 & 255,
        h0 >>> 0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 >>> 0 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 >>> 0 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 >>> 0 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 >>> 0 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 >>> 0 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 >>> 0 & 255,
        h7 >>> 24 & 255,
        h7 >>> 16 & 255,
        h7 >>> 8 & 255,
        h7 >>> 0 & 255
      ];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
      password = password.length <= 64 ? password : SHA2562(password);
      const innerLen = 64 + salt.length + 4;
      const inner = new Array(innerLen);
      const outerKey = new Array(64);
      let i;
      let dk = [];
      for (i = 0; i < 64; i++) {
        inner[i] = 54;
      }
      for (i = 0; i < password.length; i++) {
        inner[i] ^= password[i];
      }
      for (i = 0; i < salt.length; i++) {
        inner[64 + i] = salt[i];
      }
      for (i = innerLen - 4; i < innerLen; i++) {
        inner[i] = 0;
      }
      for (i = 0; i < 64; i++)
        outerKey[i] = 92;
      for (i = 0; i < password.length; i++)
        outerKey[i] ^= password[i];
      function incrementCounter2() {
        for (let i2 = innerLen - 1; i2 >= innerLen - 4; i2--) {
          inner[i2]++;
          if (inner[i2] <= 255)
            return;
          inner[i2] = 0;
        }
      }
      while (dkLen >= 32) {
        incrementCounter2();
        dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))));
        dkLen -= 32;
      }
      if (dkLen > 0) {
        incrementCounter2();
        dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
      }
      return dk;
    }
    function blockmix_salsa8(BY, Yi, r2, x, _X) {
      let i;
      arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
      for (i = 0; i < 2 * r2; i++) {
        blockxor(BY, i * 16, _X, 16);
        salsa20_8(_X, x);
        arraycopy(_X, 0, BY, Yi + i * 16, 16);
      }
      for (i = 0; i < r2; i++) {
        arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
      }
      for (i = 0; i < r2; i++) {
        arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r2) * 16, 16);
      }
    }
    function R2(a, b) {
      return a << b | a >>> 32 - b;
    }
    function salsa20_8(B, x) {
      arraycopy(B, 0, x, 0, 16);
      for (let i = 8; i > 0; i -= 2) {
        x[4] ^= R2(x[0] + x[12], 7);
        x[8] ^= R2(x[4] + x[0], 9);
        x[12] ^= R2(x[8] + x[4], 13);
        x[0] ^= R2(x[12] + x[8], 18);
        x[9] ^= R2(x[5] + x[1], 7);
        x[13] ^= R2(x[9] + x[5], 9);
        x[1] ^= R2(x[13] + x[9], 13);
        x[5] ^= R2(x[1] + x[13], 18);
        x[14] ^= R2(x[10] + x[6], 7);
        x[2] ^= R2(x[14] + x[10], 9);
        x[6] ^= R2(x[2] + x[14], 13);
        x[10] ^= R2(x[6] + x[2], 18);
        x[3] ^= R2(x[15] + x[11], 7);
        x[7] ^= R2(x[3] + x[15], 9);
        x[11] ^= R2(x[7] + x[3], 13);
        x[15] ^= R2(x[11] + x[7], 18);
        x[1] ^= R2(x[0] + x[3], 7);
        x[2] ^= R2(x[1] + x[0], 9);
        x[3] ^= R2(x[2] + x[1], 13);
        x[0] ^= R2(x[3] + x[2], 18);
        x[6] ^= R2(x[5] + x[4], 7);
        x[7] ^= R2(x[6] + x[5], 9);
        x[4] ^= R2(x[7] + x[6], 13);
        x[5] ^= R2(x[4] + x[7], 18);
        x[11] ^= R2(x[10] + x[9], 7);
        x[8] ^= R2(x[11] + x[10], 9);
        x[9] ^= R2(x[8] + x[11], 13);
        x[10] ^= R2(x[9] + x[8], 18);
        x[12] ^= R2(x[15] + x[14], 7);
        x[13] ^= R2(x[12] + x[15], 9);
        x[14] ^= R2(x[13] + x[12], 13);
        x[15] ^= R2(x[14] + x[13], 18);
      }
      for (let i = 0; i < 16; ++i) {
        B[i] += x[i];
      }
    }
    function blockxor(S2, Si, D, len) {
      for (let i = 0; i < len; i++) {
        D[i] ^= S2[Si + i];
      }
    }
    function arraycopy(src2, srcPos, dest, destPos, length2) {
      while (length2--) {
        dest[destPos++] = src2[srcPos++];
      }
    }
    function checkBufferish(o) {
      if (!o || typeof o.length !== "number") {
        return false;
      }
      for (let i = 0; i < o.length; i++) {
        const v = o[i];
        if (typeof v !== "number" || v % 1 || v < 0 || v >= 256) {
          return false;
        }
      }
      return true;
    }
    function ensureInteger(value, name2) {
      if (typeof value !== "number" || value % 1) {
        throw new Error("invalid " + name2);
      }
      return value;
    }
    function _scrypt(password, salt, N10, r2, p, dkLen, callback) {
      N10 = ensureInteger(N10, "N");
      r2 = ensureInteger(r2, "r");
      p = ensureInteger(p, "p");
      dkLen = ensureInteger(dkLen, "dkLen");
      if (N10 === 0 || (N10 & N10 - 1) !== 0) {
        throw new Error("N must be power of 2");
      }
      if (N10 > MAX_VALUE / 128 / r2) {
        throw new Error("N too large");
      }
      if (r2 > MAX_VALUE / 128 / p) {
        throw new Error("r too large");
      }
      if (!checkBufferish(password)) {
        throw new Error("password must be an array or buffer");
      }
      password = Array.prototype.slice.call(password);
      if (!checkBufferish(salt)) {
        throw new Error("salt must be an array or buffer");
      }
      salt = Array.prototype.slice.call(salt);
      let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r2);
      const B = new Uint32Array(p * 32 * r2);
      for (let i = 0; i < B.length; i++) {
        const j = i * 4;
        B[i] = (b[j + 3] & 255) << 24 | (b[j + 2] & 255) << 16 | (b[j + 1] & 255) << 8 | (b[j + 0] & 255) << 0;
      }
      const XY = new Uint32Array(64 * r2);
      const V = new Uint32Array(32 * r2 * N10);
      const Yi = 32 * r2;
      const x = new Uint32Array(16);
      const _X = new Uint32Array(16);
      const totalOps = p * N10 * 2;
      let currentOp = 0;
      let lastPercent10 = null;
      let stop = false;
      let state2 = 0;
      let i0 = 0, i1;
      let Bi;
      const limit = callback ? parseInt(1e3 / r2) : 4294967295;
      const nextTick2 = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      const incrementalSMix = function() {
        if (stop) {
          return callback(new Error("cancelled"), currentOp / totalOps);
        }
        let steps;
        switch (state2) {
          case 0:
            Bi = i0 * 32 * r2;
            arraycopy(B, Bi, XY, 0, Yi);
            state2 = 1;
            i1 = 0;
          case 1:
            steps = N10 - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0; i < steps; i++) {
              arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);
              blockmix_salsa8(XY, Yi, r2, x, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N10) {
              break;
            }
            i1 = 0;
            state2 = 2;
          case 2:
            steps = N10 - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0; i < steps; i++) {
              const offset = (2 * r2 - 1) * 16;
              const j = XY[offset] & N10 - 1;
              blockxor(V, j * Yi, XY, Yi);
              blockmix_salsa8(XY, Yi, r2, x, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N10) {
              break;
            }
            arraycopy(XY, 0, B, Bi, Yi);
            i0++;
            if (i0 < p) {
              state2 = 0;
              break;
            }
            b = [];
            for (let i = 0; i < B.length; i++) {
              b.push(B[i] >> 0 & 255);
              b.push(B[i] >> 8 & 255);
              b.push(B[i] >> 16 & 255);
              b.push(B[i] >> 24 & 255);
            }
            const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);
            if (callback) {
              callback(null, 1, derivedKey);
            }
            return derivedKey;
        }
        if (callback) {
          nextTick2(incrementalSMix);
        }
      };
      if (!callback) {
        while (true) {
          const derivedKey = incrementalSMix();
          if (derivedKey != void 0) {
            return derivedKey;
          }
        }
      }
      incrementalSMix();
    }
    const lib2 = {
      scrypt: function(password, salt, N10, r2, p, dkLen, progressCallback) {
        return new Promise(function(resolve, reject) {
          let lastProgress = 0;
          if (progressCallback) {
            progressCallback(0);
          }
          _scrypt(password, salt, N10, r2, p, dkLen, function(error3, progress, key3) {
            if (error3) {
              reject(error3);
            } else if (key3) {
              if (progressCallback && lastProgress !== 1) {
                progressCallback(1);
              }
              resolve(new Uint8Array(key3));
            } else if (progressCallback && progress !== lastProgress) {
              lastProgress = progress;
              return progressCallback(progress);
            }
          });
        });
      },
      syncScrypt: function(password, salt, N10, r2, p, dkLen) {
        return new Uint8Array(_scrypt(password, salt, N10, r2, p, dkLen));
      }
    };
    {
      module.exports = lib2;
    }
  })();
})(scrypt$1);
const scrypt = scrypt$1.exports;
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$l = new Logger(version$8);
function hasMnemonic$1(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
}
function _decrypt2(data2, key3, ciphertext) {
  const cipher2 = searchPath(data2, "crypto/cipher");
  if (cipher2 === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data2, "crypto/cipherparams/iv"));
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(key3, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data2, key3) {
  const ciphertext = looseArrayify(searchPath(data2, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256$1(concat([key3.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data2, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt2(data2, key3.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger$l.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key3.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data2.address) {
    let check = data2.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data2, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data2, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data2, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new aes.Counter(mnemonicIv);
    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path3 = searchPath(data2, "x-ethers/path") || defaultPath;
    const locale = searchPath(data2, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node2 = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path3);
      if (node2.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node2.mnemonic;
    } catch (error3) {
      if (error3.code !== Logger.errors.INVALID_ARGUMENT || error3.argument !== "wordlist") {
        throw error3;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return arrayify(pbkdf2$1(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data2, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data2, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError = function(name2, value) {
      return logger$l.throwArgumentError("invalid key-derivation function parameters", name2, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data2, "crypto/kdfparams/salt"));
      const N10 = parseInt(searchPath(data2, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data2, "crypto/kdfparams/r"));
      const p = parseInt(searchPath(data2, "crypto/kdfparams/p"));
      if (!N10 || !r2 || !p) {
        throwError("kdf", kdf);
      }
      if ((N10 & N10 - 1) !== 0) {
        throwError("N", N10);
      }
      const dkLen = parseInt(searchPath(data2, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N10, r2, p, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data2, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data2, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }
      const count = parseInt(searchPath(data2, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data2, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger$l.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data2 = JSON.parse(json);
  const key3 = _computeKdfKey(data2, password, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(data2, key3);
}
function decrypt(json, password, progressCallback) {
  return __awaiter$a(this, void 0, void 0, function* () {
    const data2 = JSON.parse(json);
    const key3 = yield _computeKdfKey(data2, password, pbkdf2, scrypt.scrypt, progressCallback);
    return _getAccount(data2, key3);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic$1(account)) {
      const mnemonic = account.mnemonic;
      const node2 = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node2.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e) {
    return Promise.reject(e);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path3 = null;
  let locale = null;
  if (hasMnemonic$1(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path3 = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N10 = 1 << 17, r2 = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N10 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  return scrypt.scrypt(passwordBytes, salt, N10, r2, p, 64, progressCallback).then((key3) => {
    key3 = arrayify(key3);
    const derivedKey = key3.slice(0, 16);
    const macPrefix = key3.slice(16, 32);
    const mnemonicKey = key3.slice(32, 64);
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256$1(concat([macPrefix, ciphertext]));
    const data2 = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N10,
          dklen: 32,
          p,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new aes.Counter(mnemonicIv);
      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = new Date();
      const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data2["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp + "--" + data2.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path: path3,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data2);
  });
}
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt$1(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt$1(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
const version$7 = "wallet/5.7.0";
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$k = new Logger(version$7);
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
class Wallet extends Signer {
  constructor(privateKey, provider) {
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger$k.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node2 = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node2.privateKey) !== this.address) {
          logger$k.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger$k.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider && !Provider.isProvider(provider)) {
      logger$k.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new Wallet(this, provider);
  }
  signTransaction(transaction2) {
    return resolveProperties(transaction2).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger$k.throwArgumentError("transaction from address mismatch", "transaction.from", transaction2.from);
        }
        delete tx.from;
      }
      const signature2 = this._signingKey().signDigest(keccak256$1(serialize$1(tx)));
      return serialize$1(tx, signature2);
    });
  }
  signMessage(message) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain, types2, value) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types2, value, (name2) => {
        if (this.provider == null) {
          logger$k.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types2, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt(this, password, options, progressCallback);
  }
  static createRandom(options) {
    let entropy = randomBytes(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256$1(concat([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json, password, progressCallback) {
    return decryptJsonWallet(json, password, progressCallback).then((account) => {
      return new Wallet(account);
    });
  }
  static fromEncryptedJsonSync(json, password) {
    return new Wallet(decryptJsonWalletSync(json, password));
  }
  static fromMnemonic(mnemonic, path3, wordlist2) {
    if (!path3) {
      path3 = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path3));
  }
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain, types2, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types2, value), signature2);
}
const version$6 = "networks/5.7.0";
const logger$j = new Logger(version$6);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network2) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network2, options.infura));
      } catch (error3) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network2, options.etherscan));
      } catch (error3) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network2, options.alchemy));
      } catch (error3) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip2 = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network2, options.pocket);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error3) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network2));
      } catch (error3) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip2 = ["ropsten"];
        const provider = new providers.AnkrProvider(network2, options.ankr);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error3) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network2 === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network3) {
    return ethDefaultProvider(network3);
  };
  return func;
}
function etcDefaultProvider(url, network2) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network2);
    }
    return null;
  };
  func.renetwork = function(network3) {
    return etcDefaultProvider(url, network3);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network2) {
  if (network2 == null) {
    return null;
  }
  if (typeof network2 === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network2) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network2,
      name: "unknown"
    };
  }
  if (typeof network2 === "string") {
    const standard2 = networks[network2];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network2.name];
  if (!standard) {
    if (typeof network2.chainId !== "number") {
      logger$j.throwArgumentError("invalid network chainId", "network", network2);
    }
    return network2;
  }
  if (network2.chainId !== 0 && network2.chainId !== standard.chainId) {
    logger$j.throwArgumentError("network chainId mismatch", "network", network2);
  }
  let defaultProvider = network2._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network2);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network2.name,
    chainId: standard.chainId,
    ensAddress: network2.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
const version$5 = "web/5.7.0";
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request3 = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request3.mode = "cors";
      request3.cache = "no-cache";
      request3.credentials = "same-origin";
      request3.redirect = "follow";
      request3.referrer = "client";
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request3.mode = opts.mode;
      }
      if (opts.cache) {
        request3.cache = opts.cache;
      }
      if (opts.credentials) {
        request3.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request3.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request3.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request3);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key3) => {
        headers[key3.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key3) => {
        headers[key3.toLowerCase()] = response.headers.get(key3);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$i = new Logger(version$5);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error3) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$i.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$i.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$i.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key3 in connection.headers) {
        headers[key3.toLowerCase()] = { key: key3, value: String(connection.headers[key3]) };
        if (["if-none-match", "if-modified-since"].indexOf(key3.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$i.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$6(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode$4(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error3) {
      logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error: error3,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key3) => {
    const header = headers[key3];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$i.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$7(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error3) {
          response = error3.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$i.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error3,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$i.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error3) {
            if (error3.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error: error3,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$i.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error3) {
        logger$i.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error: error3
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k) => k.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done2 = false;
    const cancel = () => {
      if (done2) {
        return false;
      }
      done2 = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done2) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error3) {
        if (cancel()) {
          reject(error3);
        }
      });
    }
    check();
  });
}
var ALPHABET$2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP$1 = {};
for (var z = 0; z < ALPHABET$2.length; z++) {
  var x = ALPHABET$2.charAt(z);
  if (ALPHABET_MAP$1[x] !== void 0)
    throw new TypeError(x + " is ambiguous");
  ALPHABET_MAP$1[x] = z;
}
function polymodStep$1(pre2) {
  var b = pre2 >> 25;
  return (pre2 & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
}
function prefixChk$1(prefix) {
  var chk = 1;
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep$1(chk) ^ c >> 5;
  }
  chk = polymodStep$1(chk);
  for (i = 0; i < prefix.length; ++i) {
    var v = prefix.charCodeAt(i);
    chk = polymodStep$1(chk) ^ v & 31;
  }
  return chk;
}
function encode$5(prefix, words2, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words2.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix = prefix.toLowerCase();
  var chk = prefixChk$1(prefix);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix + "1";
  for (var i = 0; i < words2.length; ++i) {
    var x = words2[i];
    if (x >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep$1(chk) ^ x;
    result += ALPHABET$2.charAt(x);
  }
  for (i = 0; i < 6; ++i) {
    chk = polymodStep$1(chk);
  }
  chk ^= 1;
  for (i = 0; i < 6; ++i) {
    var v = chk >> (5 - i) * 5 & 31;
    result += ALPHABET$2.charAt(v);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split = str.lastIndexOf("1");
  if (split === -1)
    return "No separator character for " + str;
  if (split === 0)
    return "Missing prefix for " + str;
  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk$1(prefix);
  if (typeof chk === "string")
    return chk;
  var words2 = [];
  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i);
    var v = ALPHABET_MAP$1[c];
    if (v === void 0)
      return "Unknown character " + c;
    chk = polymodStep$1(chk) ^ v;
    if (i + 6 >= wordChars.length)
      continue;
    words2.push(v);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix, words: words2 };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$3(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert$1(data2, inBits, outBits, pad3) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i = 0; i < data2.length; ++i) {
    value = value << inBits | data2[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad3) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes) {
  var res = convert$1(bytes, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords$1(bytes) {
  var res = convert$1(bytes, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe$1(words2) {
  var res = convert$1(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords$1(words2) {
  var res = convert$1(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$3,
  encode: encode$5,
  toWordsUnsafe,
  toWords: toWords$1,
  fromWordsUnsafe: fromWordsUnsafe$1,
  fromWords: fromWords$1
};
const bech32$1 = bech32;
const version$4 = "providers/5.7.0";
const logger$h = new Logger(version$4);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data2 = this.data.bind(this);
    const hash3 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v) => {
      return this.data(v, true);
    };
    formats.transaction = {
      hash: hash3,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash3, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data: data2,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data2)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash3,
      address,
      topics: Formatter.arrayOf(hash3),
      data: data2,
      logIndex: number,
      blockHash: hash3
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data2),
      blockHash: hash3,
      transactionHash: hash3,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash3),
      parentHash: hash3,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data2,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash3)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash3, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash3),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data2, "0x"),
      topics: Formatter.arrayOf(hash3),
      transactionHash: hash3,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  bigNumber(value) {
    return BigNumber.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger$h.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$h.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v = BigNumber.from(value);
    try {
      return v.toNumber();
    } catch (error3) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction2) {
    if (transaction2.gas != null && transaction2.gasLimit == null) {
      transaction2.gasLimit = transaction2.gas;
    }
    if (transaction2.to && BigNumber.from(transaction2.to).isZero()) {
      transaction2.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction2.input != null && transaction2.data == null) {
      transaction2.data = transaction2.input;
    }
    if (transaction2.to == null && transaction2.creates == null) {
      transaction2.creates = this.contractAddress(transaction2);
    }
    if ((transaction2.type === 1 || transaction2.type === 2) && transaction2.accessList == null) {
      transaction2.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction2);
    if (transaction2.chainId != null) {
      let chainId = transaction2.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction2.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction2.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse$1(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$h.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$h.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$h.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v) => this.topics(v));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key3 in format) {
      try {
        const value = format[key3](object[key3]);
        if (value !== void 0) {
          result[key3] = value;
        }
      } catch (error3) {
        error3.checkKey = key3;
        error3.checkValue = object[key3];
        throw error3;
      }
    }
    return result;
  }
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
}
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
let throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$g = new Logger(version$4);
const MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$g.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data2) {
  if (data2 === "") {
    return [];
  }
  return data2.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$g.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(tag, listener, once2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once2);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== "*") {
      filter.address = address;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data2) {
  return Base58.encode(concat([data2, hexDataSlice(sha256$3(sha256$3(data2)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error3) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length2 = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length2);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$g.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data2 = arrayify(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error3) => {
        if (error3.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error3;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes2 = false;
      if (yield this.supportsWildcard()) {
        parseBytes2 = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger$g.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes2) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error3) {
        if (error3.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error3;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$g.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length2 = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length2 = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length2 = bytes[1];
      let version2 = bytes[0];
      if (version2 === 0) {
        if (length2 !== 20 && length2 !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
        const words2 = bech32$1.toWords(bytes.slice(2));
        words2.unshift(version2);
        return bech32$1.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error3) {
          if (error3.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error3;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$g.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i = 0; i < matchers.length; i++) {
          const match = avatar.match(matchers[i]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error3) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length2 = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length2 * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length2 = parseInt(ipns[3], 16);
        if (ipns[4].length === length2 * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash3 = encode$6("0x" + skynet[1]).replace(/[=+\/]/g, (a) => urlSafe[a]);
          return "sia://" + hash3;
        }
      }
      return logger$g.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key3) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key3);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key3.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  constructor(network2) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network2 === "any");
    if (this.anyNetwork) {
      network2 = this.detectNetwork();
    }
    if (network2 instanceof Promise) {
      this._networkPromise = network2;
      network2.catch((error3) => {
      });
      this._ready().catch((error3) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network2);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$g.throwArgumentError("invalid network", "network", network2);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network2 = null;
        if (this._networkPromise) {
          try {
            network2 = yield this._networkPromise;
          } catch (error3) {
          }
        }
        if (network2 == null) {
          network2 = yield this.detectNetwork();
        }
        if (!network2) {
          logger$g.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network2;
          } else {
            defineReadOnly(this, "_network", network2);
          }
          this.emit("network", network2, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network2) => {
        return network2;
      }, (error3) => {
        if (error3.code === Logger.errors.NETWORK_ERROR && error3.event === "noNetwork") {
          return void 0;
        }
        throw error3;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network2) {
    return getNetwork(network2 == null ? "homestead" : network2);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data2 = calldata.toLowerCase();
      const errorMessages = [];
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const href = url.replace("{sender}", sender).replace("{data}", data2);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data2, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger$g.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger$g.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error3) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network2) => null, (error3) => error3)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error3) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error3) {
        this.emit("error", error3);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$g.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$g.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
          this.emit("block", i);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key3) => {
          if (key3 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key3];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key3];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash3 = event.hash;
            let runner = this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash3] = receipt.blockNumber;
              this.emit(hash3, receipt);
              return null;
            }).catch((error3) => {
              this.emit("error", error3);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter = event.filter;
              filter.fromBlock = event._lastBlockNumber + 1;
              filter.toBlock = blockNumber;
              const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter.fromBlock) {
                filter.fromBlock = minFromBlock;
              }
              if (filter.fromBlock < 0) {
                filter.fromBlock = 0;
              }
              const runner = this.getLogs(filter).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter, log);
                });
              }).catch((error3) => {
                this.emit("error", error3);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error3) => {
        this.emit("error", error3);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return logger$g.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const network2 = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network2.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network2);
          yield stall$1(0);
          return this._network;
        }
        const error3 = logger$g.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network: network2,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error3);
        throw error3;
      }
      return network2;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error3) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done2 = false;
        const alreadyDone = function() {
          if (done2) {
            return true;
          }
          done2 = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$6(this, void 0, void 0, function* () {
            if (done2) {
              return;
            }
            yield stall$1(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$6(this, void 0, void 0, function* () {
              if (done2) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done2) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done2) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$g.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error3) => {
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done2) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$g.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error3) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error: error3
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error3) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error: error3
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error3) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error: error3
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error3) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error: error3
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p) => hexValue(p))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error3) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error: error3
        });
      }
    });
  }
  _wrapTransaction(tx, hash3, startBlock) {
    if (hash3 != null && hexDataLength(hash3) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash3 != null && tx.hash !== hash3) {
      logger$g.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
    }
    result.wait = (confirms, timeout) => __awaiter$6(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$g.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t) => hexlify(t));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash3, blockNumber);
      } catch (error3) {
        error3.transaction = tx;
        error3.transactionHash = tx.hash;
        throw error3;
      }
    });
  }
  _getTransactionRequest(transaction2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const values = yield transaction2;
      const tx = {};
      ["from", "to"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v ? this._getAddress(v) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v ? BigNumber.from(v) : null);
      });
      ["type"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v != null ? v : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key3) => {
        if (values[key3] == null) {
          return;
        }
        tx[key3] = Promise.resolve(values[key3]).then((v) => v ? hexlify(v) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter$6(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach((key3) => {
        if (filter[key3] == null) {
          return;
        }
        result[key3] = filter[key3];
      });
      ["fromBlock", "toBlock"].forEach((key3) => {
        if (filter[key3] == null) {
          return;
        }
        result[key3] = this._getBlockTag(filter[key3]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction2, blockTag, attempt) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$g.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction: transaction2
        });
      }
      const txSender = transaction2.to;
      const result = yield this.perform("call", { transaction: transaction2, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data2 = hexDataSlice(result, 4);
          const sender = hexDataSlice(data2, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$g.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: transaction2,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data2, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data2, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data2, urlsOffset + 32);
          for (let u = 0; u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);
            if (url == null) {
              logger$g.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: transaction2,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data2, 64);
          if (!BigNumber.from(hexDataSlice(data2, 100, 128)).isZero()) {
            logger$g.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: transaction2,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data2, 96, 100);
          const extraData = _parseBytes(data2, 128);
          const ccipResult = yield this.ccipReadFetch(transaction2, calldata, urls);
          if (ccipResult == null) {
            logger$g.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: transaction2,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error3) {
          if (error3.code === Logger.errors.SERVER_ERROR) {
            throw error3;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error3) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: transaction2, blockTag },
          result,
          error: error3
        });
      }
    });
  }
  call(transaction2, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction2),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction2.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction2)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error3) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error: error3
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$6(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$g.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$g.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error3) {
          logger$g.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i = 0; i < block.transactions.length; i++) {
            const tx = block.transactions[i];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$g.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network2 = yield this.getNetwork();
      if (!network2.ensAddress) {
        logger$g.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network2.name });
      }
      try {
        const addrData = yield this.call({
          to: network2.ensAddress,
          data: "0x0178b8bf" + namehash(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error3) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error3) {
        if (isHexString(name2)) {
          throw error3;
        }
      }
      if (typeof name2 !== "string") {
        logger$g.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$6(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node2, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node2).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node2, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node2);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error3) {
          if (error3.code !== Logger.errors.CALL_EXCEPTION) {
            throw error3;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node2).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error3) {
          if (error3.code !== Logger.errors.CALL_EXCEPTION) {
            throw error3;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$g.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once2) {
    const event = new Event(getEventTag(eventName), listener, once2);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$f = new Logger(version$4);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData2) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data2 = isHexString(value.data) ? value.data : null;
    if (!requireData2 || data2) {
      return { message: value.message, data: data2 };
    }
  }
  if (typeof value === "object") {
    for (const key3 in value) {
      const result = spelunk(value[key3], requireData2);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData2);
    } catch (error3) {
    }
  }
  return null;
}
function checkError$1(method, error3, params) {
  const transaction2 = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error3, true);
    if (result) {
      return result.data;
    }
    logger$f.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: transaction2,
      error: error3
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error3.body, false);
    if (result == null) {
      result = spelunk(error3, false);
    }
    if (result) {
      logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction: transaction2,
        error: error3
      });
    }
  }
  let message = error3.message;
  if (error3.code === Logger.errors.SERVER_ERROR && error3.error && typeof error3.error.message === "string") {
    message = error3.error.message;
  } else if (typeof error3.body === "string") {
    message = error3.body;
  } else if (typeof error3.responseText === "string") {
    message = error3.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
    logger$f.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger$f.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$f.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger$f.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  throw error3;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult$1(payload) {
  if (payload.error) {
    const error3 = new Error(payload.error.message);
    error3.code = payload.error.code;
    error3.data = payload.error.data;
    throw error3;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$f.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$f.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$f.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction2) {
    transaction2 = shallowCopy(transaction2);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction2.gasLimit == null) {
      const estimate = shallowCopy(transaction2);
      estimate.from = fromAddress;
      transaction2.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction2.to != null) {
      transaction2.to = Promise.resolve(transaction2.to).then((to) => __awaiter$5(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$f.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction2),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$f.throwArgumentError("from address mismatch", "transaction", transaction2);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error3) => {
        if (typeof error3.message === "string" && error3.message.match(/user denied/i)) {
          logger$f.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError$1("sendTransaction", error3, hexTx);
      });
    });
  }
  signTransaction(transaction2) {
    return logger$f.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction2);
      try {
        return yield poll(() => __awaiter$5(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error3) {
        error3.transactionHash = hash3;
        throw error3;
      }
    });
  }
  signMessage(message) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data2), address.toLowerCase()]);
      } catch (error3) {
        if (typeof error3.message === "string" && error3.message.match(/user denied/i)) {
          logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            message: data2
          });
        }
        throw error3;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data2)]);
      } catch (error3) {
        if (typeof error3.message === "string" && error3.message.match(/user denied/i)) {
          logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            message: data2
          });
        }
        throw error3;
      }
    });
  }
  _signTypedData(domain, types2, value) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types2, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
        ]);
      } catch (error3) {
        if (typeof error3.message === "string" && error3.message.match(/user denied/i)) {
          logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            message: { domain: populated.domain, types: types2, value: populated.value }
          });
        }
        throw error3;
      }
    });
  }
  unlock(password) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction2) {
    return this.sendUncheckedTransaction(transaction2).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url, network2) {
    let networkOrReady = network2;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network3) => {
            resolve(network3);
          }, (error3) => {
            reject(error3);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error3) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error4) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error3) {
          return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error3
          });
        }
      }
      return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a) => this.formatter.address(a));
    });
  }
  send(method, params) {
    const request3 = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request3),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request3), getResult$1).then((result2) => {
      this.emit("debug", {
        action: "response",
        request: request3,
        response: result2,
        provider: this
      });
      return result2;
    }, (error3) => {
      this.emit("debug", {
        action: "response",
        error: error3,
        request: request3,
        provider: this
      });
      throw error3;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$f.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error3) {
        return checkError$1(method, error3, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error3) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error3) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction2, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key3 in allowExtra) {
        if (allowExtra[key3]) {
          allowed[key3] = true;
        }
      }
    }
    checkProperties(transaction2, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key3) {
      if (transaction2[key3] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction2[key3]));
      if (key3 === "gasLimit") {
        key3 = "gas";
      }
      result[key3] = value;
    });
    ["from", "to", "data"].forEach(function(key3) {
      if (transaction2[key3] == null) {
        return;
      }
      result[key3] = hexlify(transaction2[key3]);
    });
    if (transaction2.accessList) {
      result["accessList"] = accessListify(transaction2.accessList);
    }
    return result;
  }
}
let WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error3) {
  const logger2 = new Logger(version$4);
  WS = function() {
    logger2.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$e = new Logger(version$4);
let NextId = 1;
class WebSocketProvider extends JsonRpcProvider {
  constructor(url, network2) {
    if (network2 === "any") {
      logger$e.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network2);
    } else {
      super("_websocket", network2);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data2 = messageEvent.data;
      const result = JSON.parse(data2);
      if (result.id != null) {
        const id2 = String(result.id);
        const request3 = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request3.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request3.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error3 = null;
          if (result.error) {
            error3 = new Error(result.error.message || "unknown error");
            defineReadOnly(error3, "code", result.error.code || null);
            defineReadOnly(error3, "response", data2);
          } else {
            error3 = new Error("unknown error");
          }
          request3.callback(error3, void 0);
          this.emit("debug", {
            action: "response",
            error: error3,
            request: JSON.parse(request3.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger$e.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger$e.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger$e.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error3, result) {
        if (error3) {
          return reject(error3);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash3 = event2.hash;
          this.getTransactionReceipt(hash3).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash3, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e) => e.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
}
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$d = new Logger(version$4);
class StaticJsonRpcProvider extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      let network2 = this.network;
      if (network2 == null) {
        network2 = yield _super.detectNetwork.call(this);
        if (!network2) {
          logger$d.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network2);
          this.emit("network", network2, null);
        }
      }
      return network2;
    });
  }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network2, apiKey) {
    logger$d.checkAbstract(new.target, UrlJsonRpcProvider);
    network2 = getStatic(new.target, "getNetwork")(network2);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network2, apiKey);
    super(connection, network2);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key3) => {
        defineReadOnly(this, key3, apiKey[key3]);
      });
    }
  }
  _startPending() {
    logger$d.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger$d.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network2, apiKey) {
    return logger$d.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
}
const logger$c = new Logger(version$4);
const defaultApiKey$2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends WebSocketProvider {
  constructor(network2, apiKey) {
    const provider = new AlchemyProvider(network2, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}
class AlchemyProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network2, apiKey) {
    return new AlchemyWebSocketProvider(network2, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey$2;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger$c.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network2, apiKey) {
    let host = null;
    switch (network2.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "ropsten":
        host = "eth-ropsten.alchemyapi.io/v2/";
        break;
      case "rinkeby":
        host = "eth-rinkeby.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.alchemyapi.io/v2/";
        break;
      case "kovan":
        host = "eth-kovan.alchemyapi.io/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-rinkeby":
        host = "arb-rinkeby.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-kovan":
        host = "opt-kovan.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger$c.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey$2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}
const logger$b = new Logger(version$4);
const defaultApiKey$1 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name2) {
  switch (name2) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger$b.throwArgumentError("unsupported network", "name", name2);
}
class AnkrProvider extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey$1;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey$1;
    }
    return apiKey;
  }
  static getUrl(network2, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey$1;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network2.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey$1) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$a = new Logger(version$4);
class CloudflareProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger$a.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network2, apiKey) {
    let host = null;
    switch (network2.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger$a.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter$2(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger(version$4);
function getTransactionPostData(transaction2) {
  const result = {};
  for (let key3 in transaction2) {
    if (transaction2[key3] == null) {
      continue;
    }
    let value = transaction2[key3];
    if (key3 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key3]) {
      value = hexValue(hexlify(value));
    } else if (key3 === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key3] = value;
  }
  return result;
}
function getResult(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error3 = new Error("invalid response");
    error3.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error3.throttleRetry = true;
    }
    throw error3;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error3 = new Error("throttled response");
    error3.result = JSON.stringify(result);
    error3.throttleRetry = true;
    throw error3;
  }
  if (result.jsonrpc != "2.0") {
    const error3 = new Error("invalid response");
    error3.result = JSON.stringify(result);
    throw error3;
  }
  if (result.error) {
    const error3 = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error3.code = result.error.code;
    }
    if (result.error.data) {
      error3.data = result.error.data;
    }
    throw error3;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError(method, error3, transaction2) {
  if (method === "call" && error3.code === Logger.errors.SERVER_ERROR) {
    const e = error3.error;
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      let data2 = e.data;
      if (data2) {
        data2 = "0x" + data2.replace(/^.*0x/i, "");
      }
      if (isHexString(data2)) {
        return data2;
      }
      logger$9.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error: error3,
        data: "0x"
      });
    }
  }
  let message = error3.message;
  if (error3.code === Logger.errors.SERVER_ERROR) {
    if (error3.error && typeof error3.error.message === "string") {
      message = error3.error.message;
    } else if (typeof error3.body === "string") {
      message = error3.body;
    } else if (typeof error3.responseText === "string") {
      message = error3.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger$9.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger$9.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger$9.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger$9.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error: error3,
      method,
      transaction: transaction2
    });
  }
  throw error3;
}
class EtherscanProvider extends BaseProvider {
  constructor(network2, apiKey) {
    super(network2);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "ropsten":
        return "https://api-ropsten.etherscan.io";
      case "rinkeby":
        return "https://api-rinkeby.etherscan.io";
      case "kovan":
        return "https://api-kovan.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-kovan":
        return "https://api-kovan-optimistic.etherscan.io";
    }
    return logger$9.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key3) => {
      const value = params[key3];
      if (value != null) {
        accum += `&${key3}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key3) => {
          return `${key3}=${payload[key3]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter$1(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error3) => {
            return checkError("sendTransaction", error3, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error3) {
            return checkError("call", error3, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error3) {
            return checkError("estimateGas", error3, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger$9.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger$9.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks2 = {};
          for (let i = 0; i < logs.length; i++) {
            const log = logs[i];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks2[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks2[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks2[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
      }
      return _super.perform.call(this, method, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key3) {
          if (tx[key3] == "") {
            delete tx[key3];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$8 = new Logger(version$4);
function now() {
  return new Date().getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i = 0; i < networks2.length; i++) {
    const network2 = networks2[i];
    if (network2 == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network2.name && result.chainId === network2.chainId && (result.ensAddress === network2.ensAddress || result.ensAddress == null && network2.ensAddress == null))) {
        logger$8.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network2;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a = values[middle - 1], b = values[middle];
  if (maxDelta != null && Math.abs(a - b) > maxDelta) {
    return null;
  }
  return (a + b) / 2;
}
function serialize(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i) => serialize(i)));
  } else if (typeof value === "object") {
    const keys2 = Object.keys(value);
    keys2.sort();
    return "{" + keys2.map((key3) => {
      let v = value[key3];
      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize(v);
      }
      return JSON.stringify(key3) + ":" + v;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
let nextRid = 1;
function stall(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
const ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
const ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now2) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now2) {
    result.duration = now2 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize4, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c) => {
      const value = normalize4(c.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c.result };
      }
      tally[value].count++;
    });
    const keys2 = Object.keys(tally);
    for (let i = 0; i < keys2.length; i++) {
      const check = tally[keys2[i]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize4 = serialize;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c) => c.result);
        let blockNumber = median(configs.map((c) => c.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c) => c.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c) => c.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize4 = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize4 = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize(block);
        };
      } else {
        normalize4 = function(block) {
          if (block == null) {
            return null;
          }
          return serialize(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize4, provider.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter(this, void 0, void 0, function* () {
    const provider = config2.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter(this, void 0, void 0, function* () {
    let provider = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter = params.filter;
        if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getLogs(filter);
      }
    }
    return logger$8.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
class FallbackProvider extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger$8.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index2) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger$8.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index2}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger$8.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c) => c.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c) => {
          return c.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error3) => {
            return error3;
          });
        }));
        for (let i2 = 0; i2 < results.length; i2++) {
          const result = results[i2];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a, b) => a.priority - b.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i = 0;
      let first = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c) => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0);
        while (inflightWeight < this.quorum && i < configs.length) {
          const config2 = configs[i++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error3) => {
            config2.done = true;
            config2.error = error3;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c) => {
          if (c.done || !c.runner) {
            return;
          }
          waiting.push(c.runner);
          if (c.staller) {
            waiting.push(c.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c) => c.done && c.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== void 0) {
            configs.forEach((c) => {
              if (c.staller) {
                c.staller.cancel();
              }
              c.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall(100).getPromise();
          }
          first = false;
        }
        const errors2 = configs.reduce((accum, c) => {
          if (!c.done || c.error == null) {
            return accum;
          }
          const code2 = c.error.code;
          if (ForwardErrors.indexOf(code2) >= 0) {
            if (!accum[code2]) {
              accum[code2] = { error: c.error, weight: 0 };
            }
            accum[code2].weight += c.weight;
          }
          return accum;
        }, {});
        Object.keys(errors2).forEach((errorCode) => {
          const tally = errors2[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c) => {
            if (c.staller) {
              c.staller.cancel();
            }
            c.cancelled = true;
          });
          const e = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e[name2] == null) {
              return;
            }
            props[name2] = e[name2];
          });
          logger$8.throwError(e.reason || e.message, errorCode, props);
        });
        if (configs.filter((c) => !c.done).length === 0) {
          break;
        }
      }
      configs.forEach((c) => {
        if (c.staller) {
          c.staller.cancel();
        }
        c.cancelled = true;
      });
      return logger$8.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method,
        params,
        results: configs.map((c) => exposeDebugConfig(c)),
        provider: this
      });
    });
  }
}
const IpcProvider = null;
const logger$7 = new Logger(version$4);
const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends WebSocketProvider {
  constructor(network2, apiKey) {
    const provider = new InfuraProvider(network2, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger$7.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network2);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class InfuraProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network2, apiKey) {
    return new InfuraWebSocketProvider(network2, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger$7.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger$7.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network2, apiKey) {
    let host = null;
    switch (network2 ? network2.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "ropsten":
        host = "ropsten.infura.io";
        break;
      case "rinkeby":
        host = "rinkeby.infura.io";
        break;
      case "kovan":
        host = "kovan.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-kovan":
        host = "optimism-kovan.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-rinkeby":
        host = "arbitrum-rinkeby.infura.io";
        break;
      default:
        logger$7.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network2
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class JsonRpcBatchProvider extends JsonRpcProvider {
  send(method, params) {
    const request3 = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request: request3, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request4 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request4),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request4)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request4,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index2) => {
            const payload = result[index2];
            if (payload.error) {
              const error3 = new Error(payload.error.message);
              error3.code = payload.error.code;
              error3.data = payload.error.data;
              inflightRequest2.reject(error3);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error3) => {
          this.emit("debug", {
            action: "response",
            error: error3,
            request: request4,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error3);
          });
        });
      }, 10);
    }
    return promise;
  }
}
const logger$6 = new Logger(version$4);
const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger$6.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey;
  }
  static getUrl(network2, apiKey) {
    logger$6.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network2.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger$6.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
}
const logger$5 = new Logger(version$4);
const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
class PocketProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger$5.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network2, apiKey) {
    let host = null;
    switch (network2 ? network2.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger$5.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network2
        });
    }
    const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    const connection = { headers: {}, url };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}
const logger$4 = new Logger(version$4);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request3 = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request3),
        provider: this
      });
      sendFunc(request3, (error3, response) => {
        if (error3) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error: error3,
            request: request3,
            provider: this
          });
          return reject(error3);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request: request3,
          response,
          provider: this
        });
        if (response.error) {
          const error4 = new Error(response.error.message);
          error4.code = response.error.code;
          error4.data = response.error.data;
          return reject(error4);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request3 = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request3),
      provider: this
    });
    return provider.request(request3).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request3,
        response,
        provider: this
      });
      return response;
    }, (error3) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request3,
        error: error3,
        provider: this
      });
      throw error3;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(provider, network2) {
    if (provider == null) {
      logger$4.throwArgumentError("missing provider", "provider", provider);
    }
    let path3 = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path3 = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path3 = provider.host || provider.path || "";
      if (!path3 && provider.isMetaMask) {
        path3 = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path3 === "") {
          path3 = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger$4.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path3) {
        path3 = "unknown:";
      }
    }
    super(path3, network2);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}
const logger$3 = new Logger(version$4);
function getDefaultProvider(network2, options) {
  if (network2 == null) {
    network2 = "homestead";
  }
  if (typeof network2 === "string") {
    const match = network2.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network2);
        case "ws":
        case "wss":
          return new WebSocketProvider(network2);
        default:
          logger$3.throwArgumentError("unsupported URL scheme", "network", network2);
      }
    }
  }
  const n = getNetwork(network2);
  if (!n || !n._defaultProvider) {
    logger$3.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network: network2
    });
  }
  return n._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Provider,
  BaseProvider,
  Resolver,
  UrlJsonRpcProvider,
  FallbackProvider,
  AlchemyProvider,
  AlchemyWebSocketProvider,
  AnkrProvider,
  CloudflareProvider,
  EtherscanProvider,
  InfuraProvider,
  InfuraWebSocketProvider,
  JsonRpcProvider,
  JsonRpcBatchProvider,
  NodesmithProvider,
  PocketProvider,
  StaticJsonRpcProvider,
  Web3Provider,
  WebSocketProvider,
  IpcProvider,
  JsonRpcSigner,
  getDefaultProvider,
  getNetwork,
  isCommunityResource,
  isCommunityResourcable,
  showThrottleMessage,
  Formatter
}, Symbol.toStringTag, { value: "Module" }));
const version$3 = "solidity/5.7.0";
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$2 = new Logger(version$3);
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger$2.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray2) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger$2.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger$2.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray2) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger$2.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger$2.throwArgumentError("invalid type", "type", type);
}
function pack(types2, values) {
  if (types2.length != values.length) {
    logger$2.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types2.forEach(function(type, index2) {
    tight.push(_pack(type, values[index2]));
  });
  return hexlify(concat(tight));
}
function keccak256(types2, values) {
  return keccak256$1(pack(types2, values));
}
function sha256$2(types2, values) {
  return sha256$3(pack(types2, values));
}
const version$2 = "units/5.7.0";
const logger$1 = new Logger(version$2);
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger$1.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index2 = whole.length - 3;
      formatted.unshift(whole.substring(index2));
      whole = whole.substring(0, index2);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger$1.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
const utils$a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder,
  defaultAbiCoder,
  Fragment,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FunctionFragment,
  ParamType,
  FormatTypes,
  checkResultErrors,
  Logger,
  RLP: index$3,
  _fetchData,
  fetchJson,
  poll,
  checkProperties,
  deepCopy,
  defineReadOnly,
  getStatic,
  resolveProperties,
  shallowCopy,
  arrayify,
  concat,
  stripZeros,
  zeroPad,
  isBytes,
  isBytesLike,
  defaultPath,
  HDNode,
  SigningKey,
  Interface,
  LogDescription,
  TransactionDescription,
  base58: Base58,
  base64: index$1,
  hexlify,
  isHexString,
  hexConcat,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexDataLength,
  hexDataSlice,
  nameprep,
  _toEscapedUtf8String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  Utf8ErrorFuncs,
  formatBytes32String,
  parseBytes32String,
  dnsEncode,
  hashMessage,
  namehash,
  isValidName,
  id,
  _TypedDataEncoder: TypedDataEncoder,
  getAddress,
  getIcapAddress,
  getContractAddress,
  getCreate2Address,
  isAddress,
  formatEther,
  parseEther,
  formatUnits,
  parseUnits,
  commify,
  computeHmac,
  keccak256: keccak256$1,
  ripemd160,
  sha256: sha256$3,
  sha512: sha512$2,
  randomBytes,
  shuffled,
  solidityPack: pack,
  solidityKeccak256: keccak256,
  soliditySha256: sha256$2,
  splitSignature,
  joinSignature,
  accessListify,
  parseTransaction: parse$1,
  serializeTransaction: serialize$1,
  get TransactionTypes() {
    return TransactionTypes;
  },
  getJsonWalletAddress,
  computeAddress,
  recoverAddress,
  computePublicKey,
  recoverPublicKey,
  verifyMessage,
  verifyTypedData,
  getAccountPath,
  mnemonicToEntropy,
  entropyToMnemonic,
  isValidMnemonic,
  mnemonicToSeed,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  },
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  Indexed
}, Symbol.toStringTag, { value: "Module" }));
const version$1 = "ethers/5.7.0";
const logger = new Logger(version$1);
const ethers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Signer,
  Wallet,
  VoidSigner,
  getDefaultProvider,
  providers: index,
  BaseContract,
  Contract,
  ContractFactory,
  BigNumber,
  FixedNumber,
  constants: index$2,
  get errors() {
    return ErrorCode$1;
  },
  logger,
  utils: utils$a,
  wordlists,
  version: version$1,
  Wordlist
}, Symbol.toStringTag, { value: "Module" }));
try {
  const anyGlobal2 = window;
  if (anyGlobal2._ethers == null) {
    anyGlobal2._ethers = ethers;
  }
} catch (error3) {
}
const lib_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ethers,
  Signer,
  Wallet,
  VoidSigner,
  getDefaultProvider,
  providers: index,
  BaseContract,
  Contract,
  ContractFactory,
  BigNumber,
  FixedNumber,
  constants: index$2,
  get errors() {
    return ErrorCode$1;
  },
  logger,
  utils: utils$a,
  wordlists,
  version: version$1,
  Wordlist
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ethereumSigner, "__esModule", { value: true });
const secp256k1_1 = __importDefault$b(secp256k1);
const secp256k1_2 = __importDefault$b(elliptic);
const ethers_1$1 = require$$0$1;
class EthereumSigner extends secp256k1_1.default {
  get publicKey() {
    return Buffer.from(this.pk, "hex");
  }
  constructor(key3) {
    const b = Buffer.from(key3, "hex");
    const pub2 = secp256k1_2.default.publicKeyCreate(b, false);
    super(key3, Buffer.from(pub2));
  }
  sign(message) {
    const wallet2 = new ethers_1$1.ethers.Wallet(this._key);
    return wallet2.signMessage(message).then((r2) => Buffer.from(r2.slice(2), "hex"));
  }
  static async verify(pk, message, signature2) {
    const address = ethers_1$1.ethers.utils.computeAddress(pk);
    return ethers_1$1.ethers.utils.verifyMessage(message, signature2) === address;
  }
}
ethereumSigner.default = EthereumSigner;
var chains = {};
var ArweaveSigner$1 = {};
var Rsa4096Pss$1 = {};
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(Rsa4096Pss$1, "__esModule", { value: true });
const crypto_1 = requireCryptoBrowserify();
const arweave_1$1 = __importDefault$a(web);
const base64url_1$3 = __importDefault$a(base64url$3.exports);
const constants_1$2 = constants;
class Rsa4096Pss {
  constructor(_key, pk) {
    this._key = _key;
    this.pk = pk;
    this.signatureType = 1;
    this.ownerLength = constants_1$2.SIG_CONFIG[1].pubLength;
    this.signatureLength = constants_1$2.SIG_CONFIG[1].sigLength;
    if (!pk) {
      this.pk = crypto_1.createPublicKey({
        key: _key,
        type: "pkcs1",
        format: "pem"
      }).export({
        format: "pem",
        type: "pkcs1"
      }).toString();
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  sign(message) {
    return crypto_1.createSign("sha256").update(message).sign({
      key: this._key,
      padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING
    });
  }
  static async verify(pk, message, signature2) {
    return await arweave_1$1.default.crypto.verify(Buffer.isBuffer(pk) ? base64url_1$3.default.encode(pk) : pk, message, signature2);
  }
}
Rsa4096Pss$1.default = Rsa4096Pss;
var pem = {};
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$1(result, mod, k);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
Object.defineProperty(pem, "__esModule", { value: true });
pem.jwkTopem = pem.pemTojwk = void 0;
const asn = __importStar$1(asn1$2);
function urlize(base642) {
  return base642.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hex2b64url(str) {
  return urlize(Buffer.from(str, "hex").toString("base64"));
}
var RSAPublicKey = asn.define("RSAPublicKey", function() {
  this.seq().obj(this.key("n").int(), this.key("e").int());
});
var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
});
var PublicKeyInfo = asn.define("PublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("publicKey").bitstr());
});
var Version = asn.define("Version", function() {
  this.int({
    0: "two-prime",
    1: "multi"
  });
});
var OtherPrimeInfos = asn.define("OtherPrimeInfos", function() {
  this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
});
var RSAPrivateKey = asn.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").use(Version), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos));
});
var PrivateKeyInfo = asn.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").use(Version), this.key("algorithm").use(AlgorithmIdentifier), this.key("privateKey").bitstr());
});
function addExtras(obj2, extras) {
  extras = extras || {};
  Object.keys(extras).forEach(function(key3) {
    obj2[key3] = extras[key3];
  });
  return obj2;
}
function pad2(hex) {
  return hex.length % 2 === 1 ? "0" + hex : hex;
}
function decodeRsaPublic(buffer2, extras) {
  var key3 = RSAPublicKey.decode(buffer2, "der");
  var e = pad2(key3.e.toString(16));
  var jwk = {
    kty: "RSA",
    n: bn2base64url(key3.n),
    e: hex2b64url(e)
  };
  return addExtras(jwk, extras);
}
function decodeRsaPrivate(buffer2, extras) {
  var key3 = RSAPrivateKey.decode(buffer2, "der");
  var e = pad2(key3.e.toString(16));
  var jwk = {
    kty: "RSA",
    n: bn2base64url(key3.n),
    e: hex2b64url(e),
    d: bn2base64url(key3.d),
    p: bn2base64url(key3.p),
    q: bn2base64url(key3.q),
    dp: bn2base64url(key3.dp),
    dq: bn2base64url(key3.dq),
    qi: bn2base64url(key3.qi)
  };
  return addExtras(jwk, extras);
}
function decodePublic(buffer2, extras) {
  var info = PublicKeyInfo.decode(buffer2, "der");
  return decodeRsaPublic(info.publicKey.data, extras);
}
function decodePrivate(buffer2, extras) {
  var info = PrivateKeyInfo.decode(buffer2, "der");
  return decodeRsaPrivate(info.privateKey.data, extras);
}
function getDecoder(header) {
  var match = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(header);
  if (!match) {
    return null;
  }
  var isRSA = !!match[1];
  var isPrivate = match[2] === "PRIVATE";
  if (isPrivate) {
    return isRSA ? decodeRsaPrivate : decodePrivate;
  } else {
    return isRSA ? decodeRsaPublic : decodePublic;
  }
}
function parse(jwk) {
  return {
    n: string2bn(jwk.n),
    e: string2bn(jwk.e),
    d: jwk.d && string2bn(jwk.d),
    p: jwk.p && string2bn(jwk.p),
    q: jwk.q && string2bn(jwk.q),
    dp: jwk.dp && string2bn(jwk.dp),
    dq: jwk.dq && string2bn(jwk.dq),
    qi: jwk.qi && string2bn(jwk.qi)
  };
}
function bn2base64url(bn2) {
  return hex2b64url(pad2(bn2.toString(16)));
}
function base64url2bn(str) {
  return new asn.bignum(Buffer.from(str, "base64"));
}
function string2bn(str) {
  if (/^[0-9]+$/.test(str)) {
    return new asn.bignum(str, 10);
  }
  return base64url2bn(str);
}
function pemTojwk(pem2, extras) {
  var text2 = pem2.toString().split(/(\r\n|\r|\n)+/g);
  text2 = text2.filter(function(line) {
    return line.trim().length !== 0;
  });
  var decoder = getDecoder(text2[0]);
  text2 = text2.slice(1, -1).join("");
  return decoder(Buffer.from(text2.replace(/[^\w\d\+\/=]+/g, ""), "base64"), extras);
}
pem.pemTojwk = pemTojwk;
function jwkTopem(json) {
  var jwk = parse(json);
  var isPrivate = !!jwk.d;
  var t = isPrivate ? "PRIVATE" : "PUBLIC";
  var header = "-----BEGIN RSA " + t + " KEY-----\n";
  var footer = "\n-----END RSA " + t + " KEY-----\n";
  var data2 = Buffer.alloc(0);
  if (isPrivate) {
    jwk.version = "two-prime";
    data2 = RSAPrivateKey.encode(jwk, "der");
  } else {
    data2 = RSAPublicKey.encode(jwk, "der");
  }
  var body = data2.toString("base64").match(/.{1,64}/g).join("\n");
  return header + body + footer;
}
pem.jwkTopem = jwkTopem;
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ArweaveSigner$1, "__esModule", { value: true });
const Rsa4096Pss_1 = __importDefault$9(Rsa4096Pss$1);
const pem_1 = pem;
const base64url_1$2 = __importDefault$9(base64url$3.exports);
const arweave_1 = __importDefault$9(web);
class ArweaveSigner extends Rsa4096Pss_1.default {
  constructor(jwk) {
    super(pem_1.jwkTopem(jwk), jwk.n);
    this.jwk = jwk;
  }
  get publicKey() {
    return base64url_1$2.default.toBuffer(this.pk);
  }
  sign(message) {
    return arweave_1.default.crypto.sign(this.jwk, message);
  }
  static async verify(pk, message, signature2) {
    return await arweave_1.default.crypto.verify(pk, message, signature2);
  }
}
ArweaveSigner$1.default = ArweaveSigner;
var PolygonSigner$1 = {};
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(PolygonSigner$1, "__esModule", { value: true });
const ethereumSigner_1$1 = __importDefault$8(ethereumSigner);
class PolygonSigner extends ethereumSigner_1$1.default {
}
PolygonSigner$1.default = PolygonSigner;
var SolanaSigner$1 = {};
var _Buffer = safeBuffer$1.exports.Buffer;
function base$1(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode8(source) {
    if (Array.isArray(source) || source instanceof Uint8Array) {
      source = _Buffer.from(source);
    }
    if (!_Buffer.isBuffer(source)) {
      throw new TypeError("Expected Buffer");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return _Buffer.alloc(0);
    }
    var psz = 0;
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    vch.fill(0, 0, zeroes);
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode5(string2) {
    var buffer2 = decodeUnsafe2(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode8,
    decodeUnsafe: decodeUnsafe2,
    decode: decode5
  };
}
var src$1 = base$1;
var basex = src$1;
var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1);
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(SolanaSigner$1, "__esModule", { value: true });
const curve25519_1$2 = __importDefault$7(curve25519);
const bs58_1 = __importDefault$7(bs58);
class SolanaSigner extends curve25519_1$2.default {
  get publicKey() {
    return bs58_1.default.decode(this.pk);
  }
  get key() {
    return bs58_1.default.decode(this._key);
  }
  constructor(_key) {
    const b = bs58_1.default.decode(_key);
    super(bs58_1.default.encode(b.subarray(0, 32)), bs58_1.default.encode(b.subarray(32, 64)));
  }
}
SolanaSigner$1.default = SolanaSigner;
var injectedEthereumSigner = {};
Object.defineProperty(injectedEthereumSigner, "__esModule", { value: true });
const ethers_1 = require$$0$1;
const constants_1$1 = constants;
class InjectedEthereumSigner {
  constructor(provider) {
    this.ownerLength = constants_1$1.SIG_CONFIG[constants_1$1.SignatureConfig.ETHEREUM].pubLength;
    this.signatureLength = constants_1$1.SIG_CONFIG[constants_1$1.SignatureConfig.ETHEREUM].sigLength;
    this.signatureType = constants_1$1.SignatureConfig.ETHEREUM;
    this.signer = provider.getSigner();
  }
  async setPublicKey() {
    const address = "sign this message to connect to Bundlr.Network";
    const signedMsg = await this.signer.signMessage(address);
    const hash3 = await ethers_1.ethers.utils.hashMessage(address);
    const recoveredKey = ethers_1.ethers.utils.recoverPublicKey(ethers_1.ethers.utils.arrayify(hash3), signedMsg);
    this.publicKey = Buffer.from(ethers_1.ethers.utils.arrayify(recoveredKey));
  }
  async sign(message) {
    if (!this.publicKey) {
      await this.setPublicKey();
    }
    const sig = await this.signer.signMessage(message);
    return Buffer.from(sig.slice(2), "hex");
  }
  static verify(pk, message, signature2) {
    const address = ethers_1.ethers.utils.computeAddress(pk);
    return ethers_1.ethers.utils.verifyMessage(message, signature2) === address;
  }
}
injectedEthereumSigner.default = InjectedEthereumSigner;
var injectedSolanaSigner = {};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(injectedSolanaSigner, "__esModule", { value: true });
const ed25519$2 = __importStar(lib$1);
const base64url_1$1 = __importDefault$6(base64url$3.exports);
const constants_1 = constants;
class InjectedSolanaSigner {
  constructor(provider) {
    this.ownerLength = constants_1.SIG_CONFIG[2].pubLength;
    this.signatureLength = constants_1.SIG_CONFIG[2].sigLength;
    this.signatureType = 2;
    this.provider = provider;
    this._publicKey = this.provider.publicKey.toBuffer();
  }
  get publicKey() {
    return this._publicKey;
  }
  async sign(message) {
    if (!this.provider.signMessage)
      throw new Error("Selected Wallet does not support message signing");
    return await this.provider.signMessage(message);
  }
  static async verify(pk, message, signature2) {
    let p = pk;
    if (typeof pk === "string")
      p = base64url_1$1.default.toBuffer(pk);
    return ed25519$2.verify(Buffer.from(signature2), Buffer.from(message), Buffer.from(p));
  }
}
injectedSolanaSigner.default = InjectedSolanaSigner;
var NearSigner$1 = {};
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(NearSigner$1, "__esModule", { value: true });
const SolanaSigner_1$1 = __importDefault$5(SolanaSigner$1);
class NearSigner extends SolanaSigner_1$1.default {
  constructor(_key) {
    super(_key.replace("ed25519:", ""));
  }
}
NearSigner$1.default = NearSigner;
var AlgorandSigner$1 = {};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(AlgorandSigner$1, "__esModule", { value: true });
const curve25519_1$1 = __importDefault$4(curve25519);
class AlgorandSigner extends curve25519_1$1.default {
  get publicKey() {
    return Buffer.from(this.pk);
  }
  get key() {
    return Buffer.from(this._key);
  }
  constructor(key3, pk) {
    super(key3.subarray(0, 32), pk);
  }
}
AlgorandSigner$1.default = AlgorandSigner;
var HexInjectedSolanaSigner = {};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(HexInjectedSolanaSigner, "__esModule", { value: true });
const injectedSolanaSigner_1 = __importDefault$3(injectedSolanaSigner);
class HexSolanaSigner$2 extends injectedSolanaSigner_1.default {
  constructor(provider) {
    super(provider);
    this.signatureType = 4;
  }
  async sign(message) {
    return super.sign(Buffer.from(Buffer.from(message).toString("hex")));
  }
  static async verify(pk, message, signature2) {
    return super.verify(pk, Buffer.from(Buffer.from(message).toString("hex")), signature2);
  }
}
HexInjectedSolanaSigner.default = HexSolanaSigner$2;
var HexSolanaSigner$1 = {};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(HexSolanaSigner$1, "__esModule", { value: true });
const SolanaSigner_1 = __importDefault$2(SolanaSigner$1);
class HexSolanaSigner extends SolanaSigner_1.default {
  constructor(provider) {
    super(provider);
    this.signatureType = 4;
  }
  async sign(message) {
    return super.sign(Buffer.from(Buffer.from(message).toString("hex")));
  }
  static async verify(pk, message, signature2) {
    return super.verify(pk, Buffer.from(Buffer.from(message).toString("hex")), signature2);
  }
}
HexSolanaSigner$1.default = HexSolanaSigner;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.HexSolanaSigner = exports2.HexInjectedSolanaSigner = exports2.AlgorandSigner = exports2.NearSigner = exports2.InjectedEthereumSigner = exports2.PolygonSigner = exports2.ArweaveSigner = exports2.InjectedSolanaSigner = void 0;
  const ArweaveSigner_1 = __importDefault2(ArweaveSigner$1);
  exports2.ArweaveSigner = ArweaveSigner_1.default;
  __exportStar(ethereumSigner, exports2);
  const PolygonSigner_1 = __importDefault2(PolygonSigner$1);
  exports2.PolygonSigner = PolygonSigner_1.default;
  __exportStar(SolanaSigner$1, exports2);
  const injectedEthereumSigner_1 = __importDefault2(injectedEthereumSigner);
  exports2.InjectedEthereumSigner = injectedEthereumSigner_1.default;
  var injectedSolanaSigner_12 = injectedSolanaSigner;
  Object.defineProperty(exports2, "InjectedSolanaSigner", { enumerable: true, get: function() {
    return __importDefault2(injectedSolanaSigner_12).default;
  } });
  var NearSigner_1 = NearSigner$1;
  Object.defineProperty(exports2, "NearSigner", { enumerable: true, get: function() {
    return __importDefault2(NearSigner_1).default;
  } });
  var AlgorandSigner_1 = AlgorandSigner$1;
  Object.defineProperty(exports2, "AlgorandSigner", { enumerable: true, get: function() {
    return __importDefault2(AlgorandSigner_1).default;
  } });
  var HexInjectedSolanaSigner_1 = HexInjectedSolanaSigner;
  Object.defineProperty(exports2, "HexInjectedSolanaSigner", { enumerable: true, get: function() {
    return __importDefault2(HexInjectedSolanaSigner_1).default;
  } });
  var HexSolanaSigner_1 = HexSolanaSigner$1;
  Object.defineProperty(exports2, "HexSolanaSigner", { enumerable: true, get: function() {
    return __importDefault2(HexSolanaSigner_1).default;
  } });
})(chains);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(constants$1, "__esModule", { value: true });
constants$1.indexToType = void 0;
const curve25519_1 = __importDefault$1(curve25519);
const ethereumSigner_1 = __importDefault$1(ethereumSigner);
const chains_1 = chains;
constants$1.indexToType = {
  1: chains_1.ArweaveSigner,
  2: curve25519_1.default,
  3: ethereumSigner_1.default,
  4: chains_1.HexInjectedSolanaSigner
};
var keys = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(Rsa4096Pss$1, exports2);
})(keys);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(Signer$2, exports2);
  __exportStar(constants$1, exports2);
  __exportStar(keys, exports2);
  __exportStar(chains, exports2);
})(signing);
var axios$2 = { exports: {} };
var axios$1 = { exports: {} };
var bind$2 = function bind2(fn, thisArg) {
  return function wrap2() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString$3 = Object.prototype.toString;
function isArray(val) {
  return toString$3.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString$3.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString$3.call(val) !== "[object Object]") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
function isDate(val) {
  return toString$3.call(val) === "[object Date]";
}
function isFile(val) {
  return toString$3.call(val) === "[object File]";
}
function isBlob(val) {
  return toString$3.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString$3.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach2(obj2, fn) {
  if (obj2 === null || typeof obj2 === "undefined") {
    return;
  }
  if (typeof obj2 !== "object") {
    obj2 = [obj2];
  }
  if (isArray(obj2)) {
    for (var i = 0, l = obj2.length; i < l; i++) {
      fn.call(null, obj2[i], i, obj2);
    }
  } else {
    for (var key3 in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, key3)) {
        fn.call(null, obj2[key3], key3, obj2);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key3) {
    if (isPlainObject(result[key3]) && isPlainObject(val)) {
      result[key3] = merge(result[key3], val);
    } else if (isPlainObject(val)) {
      result[key3] = merge({}, val);
    } else if (isArray(val)) {
      result[key3] = val.slice();
    } else {
      result[key3] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach2(arguments[i], assignValue);
  }
  return result;
}
function extend(a, b, thisArg) {
  forEach2(b, function assignValue(val, key3) {
    if (thisArg && typeof val === "function") {
      a[key3] = bind$1(val, thisArg);
    } else {
      a[key3] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$9 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach: forEach2,
  merge,
  extend,
  trim,
  stripBOM
};
var utils$8 = utils$9;
function encode$4(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL2(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$8.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$8.forEach(params, function serialize2(val, key3) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$8.isArray(val)) {
        key3 = key3 + "[]";
      } else {
        val = [val];
      }
      utils$8.forEach(val, function parseValue(v) {
        if (utils$8.isDate(v)) {
          v = v.toISOString();
        } else if (utils$8.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode$4(key3) + "=" + encode$4(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$7 = utils$9;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use5(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject2(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach3(fn) {
  utils$7.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$6 = utils$9;
var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
  utils$6.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$1 = function enhanceError(error3, config2, code2, request3, response) {
  error3.config = config2;
  if (code2) {
    error3.code = code2;
  }
  error3.request = request3;
  error3.response = response;
  error3.isAxiosError = true;
  error3.toJSON = function toJSON4() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  };
  return error3;
};
var createError;
var hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var enhanceError3 = enhanceError$1;
  createError = function createError2(message, config2, code2, request3, response) {
    var error3 = new Error(message);
    return enhanceError3(error3, config2, code2, request3, response);
  };
  return createError;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var createError2 = requireCreateError();
  settle = function settle2(resolve, reject, response) {
    var validateStatus3 = response.config.validateStatus;
    if (!response.status || !validateStatus3 || validateStatus3(response.status)) {
      resolve(response);
    } else {
      reject(createError2(
        "Request failed with status code " + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$9;
  cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path3, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path3)) {
          cookie.push("path=" + path3);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  return cookies;
}
var isAbsoluteURL2;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL)
    return isAbsoluteURL2;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL2 = function isAbsoluteURL3(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
  return isAbsoluteURL2;
}
var combineURLs2;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs)
    return combineURLs2;
  hasRequiredCombineURLs = 1;
  combineURLs2 = function combineURLs3(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs2;
}
var buildFullPath2;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath2;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL3 = requireIsAbsoluteURL();
  var combineURLs3 = requireCombineURLs();
  buildFullPath2 = function buildFullPath3(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL3(requestedURL)) {
      return combineURLs3(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath2;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$9;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key3;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser2(line) {
      i = line.indexOf(":");
      key3 = utils2.trim(line.substr(0, i)).toLowerCase();
      val = utils2.trim(line.substr(i + 1));
      if (key3) {
        if (parsed[key3] && ignoreDuplicateOf.indexOf(key3) >= 0) {
          return;
        }
        if (key3 === "set-cookie") {
          parsed[key3] = (parsed[key3] ? parsed[key3] : []).concat([val]);
        } else {
          parsed[key3] = parsed[key3] ? parsed[key3] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$9;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$9;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL4 = buildURL$1;
  var buildFullPath3 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var createError2 = requireCreateError();
  xhr = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      var responseType = config2.responseType;
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request3 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath3(config2.baseURL, config2.url);
      request3.open(config2.method.toUpperCase(), buildURL4(fullPath, config2.params, config2.paramsSerializer), true);
      request3.timeout = config2.timeout;
      function onloadend() {
        if (!request3) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders2(request3.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
        var response = {
          data: responseData,
          status: request3.status,
          statusText: request3.statusText,
          headers: responseHeaders,
          config: config2,
          request: request3
        };
        settle2(resolve, reject, response);
        request3 = null;
      }
      if ("onloadend" in request3) {
        request3.onloadend = onloadend;
      } else {
        request3.onreadystatechange = function handleLoad() {
          if (!request3 || request3.readyState !== 4) {
            return;
          }
          if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request3.onabort = function handleAbort() {
        if (!request3) {
          return;
        }
        reject(createError2("Request aborted", config2, "ECONNABORTED", request3));
        request3 = null;
      };
      request3.onerror = function handleError2() {
        reject(createError2("Network Error", config2, null, request3));
        request3 = null;
      };
      request3.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(createError2(
          timeoutErrorMessage,
          config2,
          config2.transitional && config2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          request3
        ));
        request3 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request3) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key3) {
          if (typeof requestData === "undefined" && key3.toLowerCase() === "content-type") {
            delete requestHeaders[key3];
          } else {
            request3.setRequestHeader(key3, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request3.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request3.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request3.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request3.upload) {
        request3.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken) {
        config2.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request3) {
            return;
          }
          request3.abort();
          reject(cancel);
          request3 = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request3.send(requestData);
    });
  };
  return xhr;
}
var utils$5 = utils$9;
var normalizeHeaderName3 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser2, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest2(data2, headers) {
    normalizeHeaderName3(headers, "Accept");
    normalizeHeaderName3(headers, "Content-Type");
    if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
      return data2;
    }
    if (utils$5.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$5.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$5.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse2(data2) {
    var transitional4 = this.transitional;
    var silentJSONParsing = transitional4 && transitional4.silentJSONParsing;
    var forcedJSONParsing = transitional4 && transitional4.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw enhanceError2(e, this, "E_JSON_PARSE");
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus2(status) {
    return status >= 200 && status < 300;
  }
};
defaults$3.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData3(method) {
  defaults$3.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData3(method) {
  defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$4 = utils$9;
var defaults$2 = defaults_1;
var transformData$1 = function transformData2(data2, headers, fns) {
  var context = this || defaults$2;
  utils$4.forEach(fns, function transform(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$3 = utils$9;
var transformData3 = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = defaults_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest2(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData3.call(
    config2,
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$3.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData3.call(
      config2,
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData3.call(
          config2,
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$9;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge(target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$2.forEach(directMergeKeys, function merge2(prop) {
    if (prop in config2) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key3) {
    return axiosKeys.indexOf(key3) === -1;
  });
  utils$2.forEach(otherKeys, mergeDeepProperties);
  return config3;
};
const name$1 = "axios";
const version = "0.21.4";
const description = "Promise based HTTP client for the browser and node.js";
const main = "index.js";
const scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
};
const repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
};
const keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
];
const author = "Matt Zabriskie";
const license = "MIT";
const bugs = {
  url: "https://github.com/axios/axios/issues"
};
const homepage = "https://axios-http.com";
const devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
};
const browser$2 = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
};
const jsdelivr = "dist/axios.min.js";
const unpkg = "dist/axios.min.js";
const typings = "./index.d.ts";
const dependencies = {
  "follow-redirects": "^1.14.0"
};
const bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
];
const require$$0 = {
  name: name$1,
  version,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser: browser$2,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
function isOlderVersion(version2, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
  var destVer = version2.split(".");
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}
validators$1.transitional = function transitional3(validator2, version2, message) {
  var isDeprecated = version2 && isOlderVersion(version2);
  function formatMessage(opt, desc) {
    return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed in " + version2));
    }
    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i = keys2.length;
  while (i-- > 0) {
    var opt = keys2[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$9;
var buildURL3 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest3 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request2(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional4 = config2.transitional;
  if (transitional4 !== void 0) {
    validator.assertOptions(transitional4, {
      silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest3, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error3) {
      onRejected(error3);
      break;
    }
  }
  try {
    promise = dispatchRequest3(newConfig);
  } catch (error3) {
    return Promise.reject(error3);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri2(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL3(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData4(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData4(method) {
  Axios$1.prototype[method] = function(url, data2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel(message) {
    this.message = message;
  }
  Cancel.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel;
  return Cancel_1;
}
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var Cancel = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise2;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise2 = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise2(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  isAxiosError = function isAxiosError2(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils = utils$9;
var bind3 = bind$2;
var Axios = Axios_1;
var mergeConfig3 = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance2 = bind3(Axios.prototype.request, context);
  utils.extend(instance2, Axios.prototype, context);
  utils.extend(instance2, context);
  return instance2;
}
var axios = createInstance(defaults);
axios.Axios = Axios;
axios.create = function create3(instanceConfig) {
  return createInstance(mergeConfig3(axios.defaults, instanceConfig));
};
axios.Cancel = requireCancel();
axios.CancelToken = requireCancelToken();
axios.isCancel = requireIsCancel();
axios.all = function all2(promises) {
  return Promise.all(promises);
};
axios.spread = requireSpread();
axios.isAxiosError = requireIsAxiosError();
axios$1.exports = axios;
axios$1.exports.default = axios;
(function(module) {
  module.exports = axios$1.exports;
})(axios$2);
var hasRequiredDataItem;
function requireDataItem() {
  if (hasRequiredDataItem)
    return DataItem;
  hasRequiredDataItem = 1;
  (function(exports2) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MIN_BINARY_SIZE = void 0;
    const utils_12 = utils$E;
    const parser_12 = parser;
    const base64url_12 = __importDefault2(base64url$3.exports);
    const buffer_12 = buffer$3;
    const ar_data_bundle_1 = requireArDataBundle();
    const index_1 = signing;
    const ar_data_base_1 = arDataBase;
    const axios_12 = __importDefault2(axios$2.exports);
    const constants_12 = constants;
    const crypto2 = __importStar2(requireCryptoBrowserify());
    const arweave_12 = __importDefault2(web);
    exports2.MIN_BINARY_SIZE = 80;
    class DataItem2 {
      constructor(binary2) {
        this.binary = binary2;
      }
      static isDataItem(obj2) {
        return obj2.binary !== void 0;
      }
      get signatureType() {
        const signatureTypeVal = utils_12.byteArrayToLong(this.binary.subarray(0, 2));
        switch (signatureTypeVal) {
          case 1: {
            return constants_12.SignatureConfig.ARWEAVE;
          }
          case 2: {
            return constants_12.SignatureConfig.ED25519;
          }
          case 3: {
            return constants_12.SignatureConfig.ETHEREUM;
          }
          case 4: {
            return constants_12.SignatureConfig.SOLANA;
          }
          default: {
            throw new Error("Unknown signature type: " + signatureTypeVal);
          }
        }
      }
      async isValid() {
        return DataItem2.verify(this.binary);
      }
      get id() {
        return base64url_12.default.encode(this.rawId);
      }
      set id(id2) {
        this._id = base64url_12.default.toBuffer(id2);
      }
      get rawId() {
        return crypto2.createHash("sha256").update(this.rawSignature).digest();
      }
      set rawId(id2) {
        this._id = id2;
      }
      get rawSignature() {
        return this.binary.subarray(2, 2 + this.signatureLength);
      }
      get signature() {
        return base64url_12.default.encode(this.rawSignature);
      }
      get signatureLength() {
        return constants_12.SIG_CONFIG[this.signatureType].sigLength;
      }
      get rawOwner() {
        return this.binary.subarray(2 + this.signatureLength, 2 + this.signatureLength + this.ownerLength);
      }
      get owner() {
        return base64url_12.default.encode(this.rawOwner);
      }
      get ownerLength() {
        return constants_12.SIG_CONFIG[this.signatureType].pubLength;
      }
      get rawTarget() {
        const targetStart = this.getTargetStart();
        const isPresent = this.binary[targetStart] == 1;
        return isPresent ? this.binary.subarray(targetStart + 1, targetStart + 33) : buffer_12.Buffer.alloc(0);
      }
      get target() {
        return base64url_12.default.encode(this.rawTarget);
      }
      get rawAnchor() {
        const anchorStart = this.getAnchorStart();
        const isPresent = this.binary[anchorStart] == 1;
        return isPresent ? this.binary.subarray(anchorStart + 1, anchorStart + 33) : buffer_12.Buffer.alloc(0);
      }
      get anchor() {
        return this.rawAnchor.toString();
      }
      get rawTags() {
        const tagsStart = this.getTagsStart();
        const tagsSize = utils_12.byteArrayToLong(this.binary.subarray(tagsStart + 8, tagsStart + 16));
        return this.binary.subarray(tagsStart + 16, tagsStart + 16 + tagsSize);
      }
      get tags() {
        const tagsStart = this.getTagsStart();
        const tagsCount = utils_12.byteArrayToLong(this.binary.subarray(tagsStart, tagsStart + 8));
        if (tagsCount == 0) {
          return [];
        }
        const tagsSize = utils_12.byteArrayToLong(this.binary.subarray(tagsStart + 8, tagsStart + 16));
        return parser_12.tagsParser.fromBuffer(buffer_12.Buffer.from(this.binary.subarray(tagsStart + 16, tagsStart + 16 + tagsSize)));
      }
      get tagsB64Url() {
        const _tags = this.tags;
        return _tags.map((t) => ({
          name: base64url_12.default.encode(t.name),
          value: base64url_12.default.encode(t.value)
        }));
      }
      getStartOfData() {
        const tagsStart = this.getTagsStart();
        const numberOfTagBytesArray = this.binary.subarray(tagsStart + 8, tagsStart + 16);
        const numberOfTagBytes = utils_12.byteArrayToLong(numberOfTagBytesArray);
        return tagsStart + 16 + numberOfTagBytes;
      }
      get rawData() {
        const tagsStart = this.getTagsStart();
        const numberOfTagBytesArray = this.binary.subarray(tagsStart + 8, tagsStart + 16);
        const numberOfTagBytes = utils_12.byteArrayToLong(numberOfTagBytesArray);
        const dataStart = tagsStart + 16 + numberOfTagBytes;
        return this.binary.subarray(dataStart, this.binary.length);
      }
      get data() {
        return base64url_12.default.encode(this.rawData);
      }
      getRaw() {
        return this.binary;
      }
      async sign(signer) {
        this._id = await ar_data_bundle_1.sign(this, signer);
        return this.rawId;
      }
      async setSignature(signature2) {
        this.binary.set(signature2, 2);
        this._id = buffer_12.Buffer.from(await arweave_12.default.crypto.hash(signature2));
      }
      isSigned() {
        var _a, _b;
        return ((_b = (_a = this._id) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0;
      }
      toJSON() {
        return {
          signature: this.signature,
          owner: this.owner,
          target: this.target,
          tags: this.tags.map((t) => ({
            name: base64url_12.default.encode(t.name),
            value: base64url_12.default.encode(t.value)
          })),
          data: this.data
        };
      }
      async sendToBundler(bundler) {
        const headers = {
          "Content-Type": "application/octet-stream"
        };
        if (!this.isSigned())
          throw new Error("You must sign before sending to bundler");
        const response = await axios_12.default.post(`${bundler}/tx`, this.getRaw(), {
          headers,
          timeout: 1e5,
          maxBodyLength: Infinity,
          validateStatus: (status) => status > 200 && status < 300 || status !== 402
        });
        if (response.status === 402)
          throw new Error("Not enough funds to send data");
        return response;
      }
      static async verify(buffer2) {
        if (buffer2.byteLength < exports2.MIN_BINARY_SIZE) {
          return false;
        }
        const item = new DataItem2(buffer2);
        const sigType = item.signatureType;
        const tagsStart = item.getTagsStart();
        const numberOfTags = utils_12.byteArrayToLong(buffer2.subarray(tagsStart, tagsStart + 8));
        const numberOfTagBytesArray = buffer2.subarray(tagsStart + 8, tagsStart + 16);
        const numberOfTagBytes = utils_12.byteArrayToLong(numberOfTagBytesArray);
        if (numberOfTagBytes > 4096)
          return false;
        if (numberOfTags > 0) {
          try {
            const tags2 = parser_12.tagsParser.fromBuffer(buffer_12.Buffer.from(buffer2.subarray(tagsStart + 16, tagsStart + 16 + numberOfTagBytes)));
            if (tags2.length !== numberOfTags) {
              return false;
            }
          } catch (e) {
            return false;
          }
        }
        const Signer2 = index_1.indexToType[sigType];
        const signatureData = await ar_data_base_1.getSignatureData(item);
        return await Signer2.verify(item.rawOwner, signatureData, item.rawSignature);
      }
      async getSignatureData() {
        return ar_data_base_1.getSignatureData(this);
      }
      getTagsStart() {
        const targetStart = this.getTargetStart();
        const targetPresent = this.binary[targetStart] == 1;
        let tagsStart = targetStart + (targetPresent ? 33 : 1);
        const anchorPresent = this.binary[tagsStart] == 1;
        tagsStart += anchorPresent ? 33 : 1;
        return tagsStart;
      }
      getTargetStart() {
        return 2 + this.signatureLength + this.ownerLength;
      }
      getAnchorStart() {
        let anchorStart = this.getTargetStart() + 1;
        const targetPresent = this.binary[this.getTargetStart()] == 1;
        anchorStart += targetPresent ? 32 : 0;
        return anchorStart;
      }
    }
    exports2.default = DataItem2;
  })(DataItem);
  return DataItem;
}
var hasRequiredBundle;
function requireBundle() {
  if (hasRequiredBundle)
    return Bundle;
  hasRequiredBundle = 1;
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(Bundle, "__esModule", { value: true });
  const base64url_12 = __importDefault2(base64url$3.exports);
  const utils_12 = utils$E;
  const DataItem_12 = __importDefault2(requireDataItem());
  const crypto_12 = requireCryptoBrowserify();
  const HEADER_START = 32;
  class Bundle$1 {
    constructor(binary2) {
      this.binary = binary2;
      this.length = this.getDataItemCount();
      this.items = this.getItems();
    }
    getRaw() {
      return this.binary;
    }
    get(index2) {
      if (typeof index2 === "number") {
        if (index2 >= this.length) {
          throw new RangeError("Index out of range");
        }
        return this.getByIndex(index2);
      } else {
        return this.getById(index2);
      }
    }
    getSizes() {
      const ids = [];
      for (let i = HEADER_START; i < HEADER_START + 64 * this.length; i += 64) {
        ids.push(utils_12.byteArrayToLong(this.binary.subarray(i, i + 32)));
      }
      return ids;
    }
    getIds() {
      const ids = [];
      for (let i = HEADER_START; i < HEADER_START + 64 * this.length; i += 64) {
        ids.push(base64url_12.default.encode(this.binary.subarray(i + 32, i + 64)));
      }
      return ids;
    }
    getIdBy(index2) {
      if (index2 > this.length - 1) {
        throw new RangeError("Index of bundle out of range");
      }
      const start = 64 + 64 * index2;
      return base64url_12.default.encode(this.binary.subarray(start, start + 32));
    }
    async toTransaction(attributes, arweave, jwk) {
      const tx = await arweave.createTransaction({ data: this.binary, ...attributes }, jwk);
      tx.addTag("Bundle-Format", "binary");
      tx.addTag("Bundle-Version", "2.0.0");
      return tx;
    }
    async verify() {
      for (const item of this.items) {
        const valid = await item.isValid();
        const expected = base64url_12.default(crypto_12.createHash("sha256").update(item.rawSignature).digest());
        if (!(valid && item.id === expected)) {
          return false;
        }
      }
      return true;
    }
    getOffset(id2) {
      let offset = 0;
      for (let i = HEADER_START; i < HEADER_START + 64 * this.length; i += 64) {
        const _offset = utils_12.byteArrayToLong(this.binary.subarray(i, i + 32));
        offset += _offset;
        const _id = this.binary.subarray(i + 32, i + 64);
        if (utils_12.arraybufferEqual(_id, id2)) {
          return { startOffset: offset, size: _offset };
        }
      }
      return { startOffset: -1, size: -1 };
    }
    getByIndex(index2) {
      let offset = 0;
      const headerStart = 32 + 64 * index2;
      const dataItemSize = utils_12.byteArrayToLong(this.binary.subarray(headerStart, headerStart + 32));
      let counter = 0;
      for (let i = HEADER_START; i < HEADER_START + 64 * this.length; i += 64) {
        if (counter == index2) {
          break;
        }
        const _offset = utils_12.byteArrayToLong(this.binary.subarray(i, i + 32));
        offset += _offset;
        counter++;
      }
      const bundleStart = this.getBundleStart();
      const dataItemStart = bundleStart + offset;
      const slice = this.binary.subarray(dataItemStart, dataItemStart + dataItemSize + 200);
      const item = new DataItem_12.default(slice);
      item.rawId = this.binary.slice(32 + 64 * index2, 64 + 64 * index2);
      return item;
    }
    getById(id2) {
      const _id = base64url_12.default.toBuffer(id2);
      const offset = this.getOffset(_id);
      if (offset.startOffset === -1) {
        throw new Error("Transaction not found");
      }
      const bundleStart = this.getBundleStart();
      const dataItemStart = bundleStart + offset.startOffset;
      return new DataItem_12.default(this.binary.subarray(dataItemStart, dataItemStart + offset.size));
    }
    getDataItemCount() {
      return utils_12.byteArrayToLong(this.binary.subarray(0, 32));
    }
    getBundleStart() {
      return 32 + 64 * this.length;
    }
    getItems() {
      const items = new Array(this.length);
      let offset = 0;
      const bundleStart = this.getBundleStart();
      let counter = 0;
      for (let i = HEADER_START; i < HEADER_START + 64 * this.length; i += 64) {
        const _offset = utils_12.byteArrayToLong(this.binary.subarray(i, i + 32));
        const _id = this.binary.subarray(i + 32, i + 64);
        const dataItemStart = bundleStart + offset;
        const bytes = this.binary.subarray(dataItemStart, dataItemStart + _offset);
        offset += _offset;
        const item = new DataItem_12.default(bytes);
        item.rawId = _id;
        items[counter] = item;
        counter++;
      }
      return items;
    }
  }
  Bundle.default = Bundle$1;
  return Bundle;
}
var hasRequiredArDataBundle;
function requireArDataBundle() {
  if (hasRequiredArDataBundle)
    return arDataBundle;
  hasRequiredArDataBundle = 1;
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(arDataBundle, "__esModule", { value: true });
  arDataBundle.sign = arDataBundle.getSignatureAndId = arDataBundle.bundleAndSignData = arDataBundle.unbundleData = void 0;
  const ar_data_base_1 = arDataBase;
  const utils_12 = utils$E;
  const arweave_12 = __importDefault2(web);
  const Bundle_1 = __importDefault2(requireBundle());
  function unbundleData(txData) {
    return new Bundle_1.default(txData);
  }
  arDataBundle.unbundleData = unbundleData;
  async function bundleAndSignData(dataItems, signer) {
    const headers = new Uint8Array(64 * dataItems.length);
    const binaries = await Promise.all(dataItems.map(async (d, index2) => {
      const id2 = d.isSigned() ? d.rawId : await sign7(d, signer);
      const header = new Uint8Array(64);
      header.set(utils_12.longTo32ByteArray(d.getRaw().byteLength), 0);
      header.set(id2, 32);
      headers.set(header, 64 * index2);
      return d.getRaw();
    })).then((a) => {
      return Buffer.concat(a);
    });
    const buffer2 = Buffer.concat([
      utils_12.longTo32ByteArray(dataItems.length),
      headers,
      binaries
    ]);
    return new Bundle_1.default(buffer2);
  }
  arDataBundle.bundleAndSignData = bundleAndSignData;
  async function getSignatureAndId(item, signer) {
    const signatureData = await ar_data_base_1.getSignatureData(item);
    const signatureBytes = await signer.sign(signatureData);
    const idBytes = await arweave_12.default.crypto.hash(signatureBytes);
    return { signature: Buffer.from(signatureBytes), id: Buffer.from(idBytes) };
  }
  arDataBundle.getSignatureAndId = getSignatureAndId;
  async function sign7(item, signer) {
    const { signature: signature2, id: id2 } = await getSignatureAndId(item, signer);
    item.getRaw().set(signature2, 2);
    return id2;
  }
  arDataBundle.sign = sign7;
  return arDataBundle;
}
var arDataCreate = {};
var assert = { exports: {} };
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors)
    return errors;
  hasRequiredErrors = 1;
  function _typeof(obj2) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj3) {
        return typeof obj3;
      };
    } else {
      _typeof = function _typeof2(obj3) {
        return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
      };
    }
    return _typeof(obj2);
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
      return call2;
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var codes2 = {};
  var assert2;
  var util2;
  function createErrorType2(code2, message, Base2) {
    if (!Base2) {
      Base2 = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inherits(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        var _this;
        _classCallCheck(this, NodeError2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
        _this.code = code2;
        return _this;
      }
      return NodeError2;
    }(Base2);
    codes2[code2] = NodeError;
  }
  function oneOf2(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith2(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith2(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes2(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType2("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
  createErrorType2("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    if (assert2 === void 0)
      assert2 = requireAssert();
    assert2(typeof name2 === "string", "'name' must be a string");
    var determiner;
    if (typeof expected === "string" && startsWith2(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith2(name2, " argument")) {
      msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
    } else {
      var type = includes2(name2, ".") ? "property" : "argument";
      msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
    }
    msg += ". Received type ".concat(_typeof(actual));
    return msg;
  }, TypeError);
  createErrorType2("ERR_INVALID_ARG_VALUE", function(name2, value) {
    var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    if (util2 === void 0)
      util2 = requireUtil();
    var inspected = util2.inspect(value);
    if (inspected.length > 128) {
      inspected = "".concat(inspected.slice(0, 128), "...");
    }
    return "The argument '".concat(name2, "' ").concat(reason, ". Received ").concat(inspected);
  }, TypeError);
  createErrorType2("ERR_INVALID_RETURN_VALUE", function(input, name2, value) {
    var type;
    if (value && value.constructor && value.constructor.name) {
      type = "instance of ".concat(value.constructor.name);
    } else {
      type = "type ".concat(_typeof(value));
    }
    return "Expected ".concat(input, ' to be returned from the "').concat(name2, '"') + " function but got ".concat(type, ".");
  }, TypeError);
  createErrorType2("ERR_MISSING_ARGS", function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (assert2 === void 0)
      assert2 = requireAssert();
    assert2(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a) {
      return '"'.concat(a, '"');
    });
    switch (len) {
      case 1:
        msg += "".concat(args[0], " argument");
        break;
      case 2:
        msg += "".concat(args[0], " and ").concat(args[1], " arguments");
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += ", and ".concat(args[len - 1], " arguments");
        break;
    }
    return "".concat(msg, " must be specified");
  }, TypeError);
  errors.codes = codes2;
  return errors;
}
var assertion_error;
var hasRequiredAssertion_error;
function requireAssertion_error() {
  if (hasRequiredAssertion_error)
    return assertion_error;
  hasRequiredAssertion_error = 1;
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key3) {
        _defineProperty(target, key3, source[key3]);
      });
    }
    return target;
  }
  function _defineProperty(obj2, key3, value) {
    if (key3 in obj2) {
      Object.defineProperty(obj2, key3, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key3] = value;
    }
    return obj2;
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
      return call2;
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance2 = new Constructor();
        if (Class2)
          _setPrototypeOf(instance2, Class2.prototype);
        return instance2;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _typeof(obj2) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj3) {
        return typeof obj3;
      };
    } else {
      _typeof = function _typeof2(obj3) {
        return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
      };
    }
    return _typeof(obj2);
  }
  var _require = requireUtil(), inspect9 = _require.inspect;
  var _require2 = requireErrors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
  function endsWith2(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function repeat(str, count) {
    count = Math.floor(count);
    if (str.length == 0 || count == 0)
      return "";
    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while (count) {
      str += str;
      count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
  }
  var blue2 = "";
  var green2 = "";
  var red2 = "";
  var white2 = "";
  var kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  };
  var kMaxShortLength = 10;
  function copyError(source) {
    var keys2 = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys2.forEach(function(key3) {
      target[key3] = source[key3];
    });
    Object.defineProperty(target, "message", {
      value: source.message
    });
    return target;
  }
  function inspectValue(val) {
    return inspect9(val, {
      compact: false,
      customInspect: false,
      depth: 1e3,
      maxArrayLength: Infinity,
      showHidden: false,
      breakLength: Infinity,
      showProxy: false,
      sorted: true,
      getters: true
    });
  }
  function createErrDiff(actual, expected, operator) {
    var other = "";
    var res = "";
    var lastPos = 0;
    var end = "";
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split("\n");
    var expectedLines = inspectValue(expected).split("\n");
    var i = 0;
    var indicator = "";
    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
      operator = "strictEqualObject";
    }
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
      var inputLength = actualLines[0].length + expectedLines[0].length;
      if (inputLength <= kMaxShortLength) {
        if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
          return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        }
      } else if (operator !== "strictEqualObject") {
        var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
        if (inputLength < maxLength) {
          while (actualLines[0][i] === expectedLines[0][i]) {
            i++;
          }
          if (i > 2) {
            indicator = "\n  ".concat(repeat(" ", i), "^");
            i = 0;
          }
        }
      }
    }
    var a = actualLines[actualLines.length - 1];
    var b = expectedLines[expectedLines.length - 1];
    while (a === b) {
      if (i++ < 2) {
        end = "\n  ".concat(a).concat(end);
      } else {
        other = a;
      }
      actualLines.pop();
      expectedLines.pop();
      if (actualLines.length === 0 || expectedLines.length === 0)
        break;
      a = actualLines[actualLines.length - 1];
      b = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length);
    if (maxLines === 0) {
      var _actualLines = actualInspected.split("\n");
      if (_actualLines.length > 30) {
        _actualLines[26] = "".concat(blue2, "...").concat(white2);
        while (_actualLines.length > 27) {
          _actualLines.pop();
        }
      }
      return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
    }
    if (i > 3) {
      end = "\n".concat(blue2, "...").concat(white2).concat(end);
      skipped = true;
    }
    if (other !== "") {
      end = "\n  ".concat(other).concat(end);
      other = "";
    }
    var printedLines = 0;
    var msg = kReadableOperator[operator] + "\n".concat(green2, "+ actual").concat(white2, " ").concat(red2, "- expected").concat(white2);
    var skippedMsg = " ".concat(blue2, "...").concat(white2, " Lines skipped");
    for (i = 0; i < maxLines; i++) {
      var cur = i - lastPos;
      if (actualLines.length < i + 1) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue2, "...").concat(white2);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(expectedLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(expectedLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        other += "\n".concat(red2, "-").concat(white2, " ").concat(expectedLines[i]);
        printedLines++;
      } else if (expectedLines.length < i + 1) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue2, "...").concat(white2);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        res += "\n".concat(green2, "+").concat(white2, " ").concat(actualLines[i]);
        printedLines++;
      } else {
        var expectedLine = expectedLines[i];
        var actualLine = actualLines[i];
        var divergingLines = actualLine !== expectedLine && (!endsWith2(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
        if (divergingLines && endsWith2(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
          divergingLines = false;
          actualLine += ",";
        }
        if (divergingLines) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue2, "...").concat(white2);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green2, "+").concat(white2, " ").concat(actualLine);
          other += "\n".concat(red2, "-").concat(white2, " ").concat(expectedLine);
          printedLines += 2;
        } else {
          res += other;
          other = "";
          if (cur === 1 || i === 0) {
            res += "\n  ".concat(actualLine);
            printedLines++;
          }
        }
      }
      if (printedLines > 20 && i < maxLines - 2) {
        return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue2, "...").concat(white2).concat(other, "\n") + "".concat(blue2, "...").concat(white2);
      }
    }
    return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
  }
  var AssertionError = /* @__PURE__ */ function(_Error) {
    _inherits(AssertionError2, _Error);
    function AssertionError2(options) {
      var _this;
      _classCallCheck(this, AssertionError2);
      if (_typeof(options) !== "object" || options === null) {
        throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
      var actual = options.actual, expected = options.expected;
      var limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      if (message != null) {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));
      } else {
        if (process.stderr && process.stderr.isTTY) {
          if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
            blue2 = "\x1B[34m";
            green2 = "\x1B[32m";
            white2 = "\x1B[39m";
            red2 = "\x1B[31m";
          } else {
            blue2 = "";
            green2 = "";
            white2 = "";
            red2 = "";
          }
        }
        if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
          actual = copyError(actual);
          expected = copyError(expected);
        }
        if (operator === "deepStrictEqual" || operator === "strictEqual") {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));
        } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
          var base3 = kReadableOperator[operator];
          var res = inspectValue(actual).split("\n");
          if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
            base3 = kReadableOperator.notStrictEqualObject;
          }
          if (res.length > 30) {
            res[26] = "".concat(blue2, "...").concat(white2);
            while (res.length > 27) {
              res.pop();
            }
          }
          if (res.length === 1) {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base3, " ").concat(res[0])));
          } else {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base3, "\n\n").concat(res.join("\n"), "\n")));
          }
        } else {
          var _res = inspectValue(actual);
          var other = "";
          var knownOperators = kReadableOperator[operator];
          if (operator === "notDeepEqual" || operator === "notEqual") {
            _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
            if (_res.length > 1024) {
              _res = "".concat(_res.slice(0, 1021), "...");
            }
          } else {
            other = "".concat(inspectValue(expected));
            if (_res.length > 512) {
              _res = "".concat(_res.slice(0, 509), "...");
            }
            if (other.length > 512) {
              other = "".concat(other.slice(0, 509), "...");
            }
            if (operator === "deepEqual" || operator === "equal") {
              _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
            } else {
              other = " ".concat(operator, " ").concat(other);
            }
          }
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(_res).concat(other)));
        }
      }
      Error.stackTraceLimit = limit;
      _this.generatedMessage = !message;
      Object.defineProperty(_assertThisInitialized(_this), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: false,
        writable: true,
        configurable: true
      });
      _this.code = "ERR_ASSERTION";
      _this.actual = actual;
      _this.expected = expected;
      _this.operator = operator;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
      }
      _this.stack;
      _this.name = "AssertionError";
      return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError2, [{
      key: "toString",
      value: function toString2() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: inspect9.custom,
      value: function value(recurseTimes, ctx) {
        return inspect9(this, _objectSpread({}, ctx, {
          customInspect: false,
          depth: 0
        }));
      }
    }]);
    return AssertionError2;
  }(_wrapNativeSuper(Error));
  assertion_error = AssertionError;
  return assertion_error;
}
var es6ObjectAssign;
var hasRequiredEs6ObjectAssign;
function requireEs6ObjectAssign() {
  if (hasRequiredEs6ObjectAssign)
    return es6ObjectAssign;
  hasRequiredEs6ObjectAssign = 1;
  function assign(target, firstSource) {
    if (target === void 0 || target === null) {
      throw new TypeError("Cannot convert first argument to object");
    }
    var to = Object(target);
    for (var i = 1; i < arguments.length; i++) {
      var nextSource = arguments[i];
      if (nextSource === void 0 || nextSource === null) {
        continue;
      }
      var keysArray = Object.keys(Object(nextSource));
      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
    return to;
  }
  function polyfill2() {
    if (!Object.assign) {
      Object.defineProperty(Object, "assign", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: assign
      });
    }
  }
  es6ObjectAssign = {
    assign,
    polyfill: polyfill2
  };
  return es6ObjectAssign;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var toStr = Object.prototype.toString;
  isArguments = function isArguments2(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) {
      isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
  return isArguments;
}
var implementation$2;
var hasRequiredImplementation$2;
function requireImplementation$2() {
  if (hasRequiredImplementation$2)
    return implementation$2;
  hasRequiredImplementation$2 = 1;
  var keysShim;
  if (!Object.keys) {
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = requireIsArguments();
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys2(object) {
      var isObject2 = object !== null && typeof object === "object";
      var isFunction2 = toStr.call(object) === "[object Function]";
      var isArguments2 = isArgs(object);
      var isString2 = isObject2 && toStr.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction2 && !isArguments2) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString2 && object.length > 0 && !has.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments2 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name2 in object) {
          if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$2 = keysShim;
  return implementation$2;
}
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys)
    return objectKeys;
  hasRequiredObjectKeys = 1;
  var slice = Array.prototype.slice;
  var isArgs = requireIsArguments();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys2(o) {
    return origKeys(o);
  } : requireImplementation$2();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys2(object) {
          if (isArgs(object)) {
            return originalKeys(slice.call(object));
          }
          return originalKeys(object);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  objectKeys = keysShim;
  return objectKeys;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
        return true;
      } catch (e) {
        return false;
      }
    }
    return false;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!hasPropertyDescriptors()) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var defineProperties_1;
var hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties)
    return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var keys2 = requireObjectKeys();
  var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat2 = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;
  var isFunction2 = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
  };
  var hasPropertyDescriptors = requireHasPropertyDescriptors()();
  var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
  var defineProperty = function(object, name2, value, predicate) {
    if (name2 in object && (!isFunction2(predicate) || !predicate())) {
      return;
    }
    if (supportsDescriptors) {
      origDefineProperty(object, name2, {
        configurable: true,
        enumerable: false,
        value,
        writable: true
      });
    } else {
      object[name2] = value;
    }
  };
  var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys2(map);
    if (hasSymbols2) {
      props = concat2.call(props, Object.getOwnPropertySymbols(map));
    }
    for (var i = 0; i < props.length; i += 1) {
      defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  defineProperties_1 = defineProperties;
  return defineProperties_1;
}
var implementation$1;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1)
    return implementation$1;
  hasRequiredImplementation$1 = 1;
  var numberIsNaN = function(value) {
    return value !== value;
  };
  implementation$1 = function is(a, b) {
    if (a === 0 && b === 0) {
      return 1 / a === 1 / b;
    }
    if (a === b) {
      return true;
    }
    if (numberIsNaN(a) && numberIsNaN(b)) {
      return true;
    }
    return false;
  };
  return implementation$1;
}
var polyfill$1;
var hasRequiredPolyfill$1;
function requirePolyfill$1() {
  if (hasRequiredPolyfill$1)
    return polyfill$1;
  hasRequiredPolyfill$1 = 1;
  var implementation2 = requireImplementation$1();
  polyfill$1 = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation2;
  };
  return polyfill$1;
}
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1)
    return shim$1;
  hasRequiredShim$1 = 1;
  var getPolyfill = requirePolyfill$1();
  var define = requireDefineProperties();
  shim$1 = function shimObjectIs() {
    var polyfill2 = getPolyfill();
    define(Object, { is: polyfill2 }, {
      is: function testObjectIs() {
        return Object.is !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim$1;
}
var objectIs;
var hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs)
    return objectIs;
  hasRequiredObjectIs = 1;
  var define = requireDefineProperties();
  var callBind2 = requireCallBind();
  var implementation2 = requireImplementation$1();
  var getPolyfill = requirePolyfill$1();
  var shim2 = requireShim$1();
  var polyfill2 = callBind2(getPolyfill(), Object);
  define(polyfill2, {
    getPolyfill,
    implementation: implementation2,
    shim: shim2
  });
  objectIs = polyfill2;
  return objectIs;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  implementation = function isNaN2(value) {
    return value !== value;
  };
  return implementation;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill)
    return polyfill;
  hasRequiredPolyfill = 1;
  var implementation2 = requireImplementation();
  polyfill = function getPolyfill() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
      return Number.isNaN;
    }
    return implementation2;
  };
  return polyfill;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim)
    return shim;
  hasRequiredShim = 1;
  var define = requireDefineProperties();
  var getPolyfill = requirePolyfill();
  shim = function shimNumberIsNaN() {
    var polyfill2 = getPolyfill();
    define(Number, { isNaN: polyfill2 }, {
      isNaN: function testIsNaN() {
        return Number.isNaN !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim;
}
var isNan;
var hasRequiredIsNan;
function requireIsNan() {
  if (hasRequiredIsNan)
    return isNan;
  hasRequiredIsNan = 1;
  var callBind2 = requireCallBind();
  var define = requireDefineProperties();
  var implementation2 = requireImplementation();
  var getPolyfill = requirePolyfill();
  var shim2 = requireShim();
  var polyfill2 = callBind2(getPolyfill(), Number);
  define(polyfill2, {
    getPolyfill,
    implementation: implementation2,
    shim: shim2
  });
  isNan = polyfill2;
  return isNan;
}
var comparisons;
var hasRequiredComparisons;
function requireComparisons() {
  if (hasRequiredComparisons)
    return comparisons;
  hasRequiredComparisons = 1;
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _typeof(obj2) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj3) {
        return typeof obj3;
      };
    } else {
      _typeof = function _typeof2(obj3) {
        return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
      };
    }
    return _typeof(obj2);
  }
  var regexFlagsSupported = /a/g.flags !== void 0;
  var arrayFromSet = function arrayFromSet2(set) {
    var array = [];
    set.forEach(function(value) {
      return array.push(value);
    });
    return array;
  };
  var arrayFromMap = function arrayFromMap2(map) {
    var array = [];
    map.forEach(function(value, key3) {
      return array.push([key3, value]);
    });
    return array;
  };
  var objectIs2 = Object.is ? Object.is : requireObjectIs();
  var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  };
  var numberIsNaN = Number.isNaN ? Number.isNaN : requireIsNan();
  function uncurryThis(f2) {
    return f2.call.bind(f2);
  }
  var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
  var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
  var objectToString = uncurryThis(Object.prototype.toString);
  var _require$types = requireUtil().types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView2 = _require$types.isArrayBufferView, isDate2 = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
  function isNonIndex(key3) {
    if (key3.length === 0 || key3.length > 10)
      return true;
    for (var i = 0; i < key3.length; i++) {
      var code2 = key3.charCodeAt(i);
      if (code2 < 48 || code2 > 57)
        return true;
    }
    return key3.length === 10 && key3 >= Math.pow(2, 32);
  }
  function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function compare2(a, b) {
    if (a === b) {
      return 0;
    }
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) {
      return -1;
    }
    if (y < x) {
      return 1;
    }
    return 0;
  }
  var kStrict = true;
  var kLoose = false;
  var kNoIterator = 0;
  var kIsArray = 1;
  var kIsSet = 2;
  var kIsMap = 3;
  function areSimilarRegExps(a, b) {
    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
  }
  function areSimilarFloatArrays(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (var offset = 0; offset < a.byteLength; offset++) {
      if (a[offset] !== b[offset]) {
        return false;
      }
    }
    return true;
  }
  function areSimilarTypedArrays(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    return compare2(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
  }
  function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare2(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
  }
  function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) {
      return isNumberObject(val2) && objectIs2(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    }
    if (isStringObject(val1)) {
      return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    }
    if (isBooleanObject(val1)) {
      return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    }
    if (isBigIntObject(val1)) {
      return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    }
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
  }
  function innerDeepEqual(val1, val2, strict, memos) {
    if (val1 === val2) {
      if (val1 !== 0)
        return true;
      return strict ? objectIs2(val1, val2) : true;
    }
    if (strict) {
      if (_typeof(val1) !== "object") {
        return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
      }
      if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
        return false;
      }
      if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
        return false;
      }
    } else {
      if (val1 === null || _typeof(val1) !== "object") {
        if (val2 === null || _typeof(val2) !== "object") {
          return val1 == val2;
        }
        return false;
      }
      if (val2 === null || _typeof(val2) !== "object") {
        return false;
      }
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) {
      return false;
    }
    if (Array.isArray(val1)) {
      if (val1.length !== val2.length) {
        return false;
      }
      var keys1 = getOwnNonIndexProperties(val1);
      var keys2 = getOwnNonIndexProperties(val2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    }
    if (val1Tag === "[object Object]") {
      if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
        return false;
      }
    }
    if (isDate2(val1)) {
      if (!isDate2(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
        return false;
      }
    } else if (isRegExp(val1)) {
      if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
        return false;
      }
    } else if (isNativeError(val1) || val1 instanceof Error) {
      if (val1.message !== val2.message || val1.name !== val2.name) {
        return false;
      }
    } else if (isArrayBufferView2(val1)) {
      if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
        if (!areSimilarFloatArrays(val1, val2)) {
          return false;
        }
      } else if (!areSimilarTypedArrays(val1, val2)) {
        return false;
      }
      var _keys = getOwnNonIndexProperties(val1);
      var _keys2 = getOwnNonIndexProperties(val2);
      if (_keys.length !== _keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
      if (!isSet(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
      if (!isMap(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
      if (!areEqualArrayBuffers(val1, val2)) {
        return false;
      }
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator);
  }
  function getEnumerables(val, keys2) {
    return keys2.filter(function(k) {
      return propertyIsEnumerable(val, k);
    });
  }
  function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    if (arguments.length === 5) {
      aKeys = Object.keys(val1);
      var bKeys = Object.keys(val2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
    }
    var i = 0;
    for (; i < aKeys.length; i++) {
      if (!hasOwnProperty(val2, aKeys[i])) {
        return false;
      }
    }
    if (strict && arguments.length === 5) {
      var symbolKeysA = objectGetOwnPropertySymbols(val1);
      if (symbolKeysA.length !== 0) {
        var count = 0;
        for (i = 0; i < symbolKeysA.length; i++) {
          var key3 = symbolKeysA[i];
          if (propertyIsEnumerable(val1, key3)) {
            if (!propertyIsEnumerable(val2, key3)) {
              return false;
            }
            aKeys.push(key3);
            count++;
          } else if (propertyIsEnumerable(val2, key3)) {
            return false;
          }
        }
        var symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
          return false;
        }
      } else {
        var _symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
          return false;
        }
      }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
      return true;
    }
    if (memos === void 0) {
      memos = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    } else {
      var val2MemoA = memos.val1.get(val1);
      if (val2MemoA !== void 0) {
        var val2MemoB = memos.val2.get(val2);
        if (val2MemoB !== void 0) {
          return val2MemoA === val2MemoB;
        }
      }
      memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
  }
  function setHasEqualElement(set, val1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i = 0; i < setValues.length; i++) {
      var val2 = setValues[i];
      if (innerDeepEqual(val1, val2, strict, memo)) {
        set.delete(val2);
        return true;
      }
    }
    return false;
  }
  function findLooseMatchingPrimitives(prim) {
    switch (_typeof(prim)) {
      case "undefined":
        return null;
      case "object":
        return void 0;
      case "symbol":
        return false;
      case "string":
        prim = +prim;
      case "number":
        if (numberIsNaN(prim)) {
          return false;
        }
    }
    return true;
  }
  function setMightHaveLoosePrim(a, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null)
      return altValue;
    return b.has(altValue) && !a.has(altValue);
  }
  function mapMightHaveLoosePrim(a, b, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    var curB = b.get(altValue);
    if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
      return false;
    }
    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
  }
  function setEquiv(a, b, strict, memo) {
    var set = null;
    var aValues = arrayFromSet(a);
    for (var i = 0; i < aValues.length; i++) {
      var val = aValues[i];
      if (_typeof(val) === "object" && val !== null) {
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(val);
      } else if (!b.has(val)) {
        if (strict)
          return false;
        if (!setMightHaveLoosePrim(a, b, val)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(val);
      }
    }
    if (set !== null) {
      var bValues = arrayFromSet(b);
      for (var _i = 0; _i < bValues.length; _i++) {
        var _val = bValues[_i];
        if (_typeof(_val) === "object" && _val !== null) {
          if (!setHasEqualElement(set, _val, strict, memo))
            return false;
        } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i = 0; i < setValues.length; i++) {
      var key22 = setValues[i];
      if (innerDeepEqual(key1, key22, strict, memo) && innerDeepEqual(item1, map.get(key22), strict, memo)) {
        set.delete(key22);
        return true;
      }
    }
    return false;
  }
  function mapEquiv(a, b, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a);
    for (var i = 0; i < aEntries.length; i++) {
      var _aEntries$i = _slicedToArray(aEntries[i], 2), key3 = _aEntries$i[0], item1 = _aEntries$i[1];
      if (_typeof(key3) === "object" && key3 !== null) {
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key3);
      } else {
        var item2 = b.get(key3);
        if (item2 === void 0 && !b.has(key3) || !innerDeepEqual(item1, item2, strict, memo)) {
          if (strict)
            return false;
          if (!mapMightHaveLoosePrim(a, b, key3, item1, memo))
            return false;
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key3);
        }
      }
    }
    if (set !== null) {
      var bEntries = arrayFromMap(b);
      for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
        var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key3 = _bEntries$_i[0], item = _bEntries$_i[1];
        if (_typeof(key3) === "object" && key3 !== null) {
          if (!mapHasEqualEntry(set, a, key3, item, strict, memo))
            return false;
        } else if (!strict && (!a.has(key3) || !innerDeepEqual(a.get(key3), item, false, memo)) && !mapHasEqualEntry(set, a, key3, item, false, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function objEquiv(a, b, strict, keys2, memos, iterationType) {
    var i = 0;
    if (iterationType === kIsSet) {
      if (!setEquiv(a, b, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsMap) {
      if (!mapEquiv(a, b, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsArray) {
      for (; i < a.length; i++) {
        if (hasOwnProperty(a, i)) {
          if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
            return false;
          }
        } else if (hasOwnProperty(b, i)) {
          return false;
        } else {
          var keysA = Object.keys(a);
          for (; i < keysA.length; i++) {
            var key3 = keysA[i];
            if (!hasOwnProperty(b, key3) || !innerDeepEqual(a[key3], b[key3], strict, memos)) {
              return false;
            }
          }
          if (keysA.length !== Object.keys(b).length) {
            return false;
          }
          return true;
        }
      }
    }
    for (i = 0; i < keys2.length; i++) {
      var _key = keys2[i];
      if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
        return false;
      }
    }
    return true;
  }
  function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
  }
  function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
  }
  comparisons = {
    isDeepEqual,
    isDeepStrictEqual
  };
  return comparisons;
}
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert)
    return assert.exports;
  hasRequiredAssert = 1;
  function _typeof(obj2) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj3) {
        return typeof obj3;
      };
    } else {
      _typeof = function _typeof2(obj3) {
        return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
      };
    }
    return _typeof(obj2);
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _require = requireErrors(), _require$codes2 = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes2.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes2.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes2.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS2 = _require$codes2.ERR_MISSING_ARGS;
  var AssertionError = requireAssertion_error();
  var _require2 = requireUtil(), inspect9 = _require2.inspect;
  var _require$types = requireUtil().types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
  var objectAssign = Object.assign ? Object.assign : requireEs6ObjectAssign().assign;
  var objectIs2 = Object.is ? Object.is : requireObjectIs();
  var isDeepEqual;
  var isDeepStrictEqual;
  function lazyLoadComparison() {
    var comparison = requireComparisons();
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
  }
  var warned = false;
  var assert$12 = assert.exports = ok;
  var NO_EXCEPTION_SENTINEL = {};
  function innerFail(obj2) {
    if (obj2.message instanceof Error)
      throw obj2.message;
    throw new AssertionError(obj2);
  }
  function fail(actual, expected, message, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) {
      internalMessage = "Failed";
    } else if (argsLen === 1) {
      message = actual;
      actual = void 0;
    } else {
      if (warned === false) {
        warned = true;
        var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
        warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      if (argsLen === 2)
        operator = "!=";
    }
    if (message instanceof Error)
      throw message;
    var errArgs = {
      actual,
      expected,
      operator: operator === void 0 ? "fail" : operator,
      stackStartFn: stackStartFn || fail
    };
    if (message !== void 0) {
      errArgs.message = message;
    }
    var err = new AssertionError(errArgs);
    if (internalMessage) {
      err.message = internalMessage;
      err.generatedMessage = true;
    }
    throw err;
  }
  assert$12.fail = fail;
  assert$12.AssertionError = AssertionError;
  function innerOk(fn, argLen, value, message) {
    if (!value) {
      var generatedMessage = false;
      if (argLen === 0) {
        generatedMessage = true;
        message = "No value argument passed to `assert.ok()`";
      } else if (message instanceof Error) {
        throw message;
      }
      var err = new AssertionError({
        actual: value,
        expected: true,
        message,
        operator: "==",
        stackStartFn: fn
      });
      err.generatedMessage = generatedMessage;
      throw err;
    }
  }
  function ok() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    innerOk.apply(void 0, [ok, args.length].concat(args));
  }
  assert$12.ok = ok;
  assert$12.equal = function equal2(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (actual != expected) {
      innerFail({
        actual,
        expected,
        message,
        operator: "==",
        stackStartFn: equal2
      });
    }
  };
  assert$12.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (actual == expected) {
      innerFail({
        actual,
        expected,
        message,
        operator: "!=",
        stackStartFn: notEqual
      });
    }
  };
  assert$12.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "deepEqual",
        stackStartFn: deepEqual
      });
    }
  };
  assert$12.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notDeepEqual",
        stackStartFn: notDeepEqual
      });
    }
  };
  assert$12.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
      });
    }
  };
  assert$12.notDeepStrictEqual = notDeepStrictEqual;
  function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
      });
    }
  }
  assert$12.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (!objectIs2(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "strictEqual",
        stackStartFn: strictEqual
      });
    }
  };
  assert$12.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS2("actual", "expected");
    }
    if (objectIs2(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notStrictEqual",
        stackStartFn: notStrictEqual
      });
    }
  };
  var Comparison = function Comparison2(obj2, keys2, actual) {
    var _this = this;
    _classCallCheck(this, Comparison2);
    keys2.forEach(function(key3) {
      if (key3 in obj2) {
        if (actual !== void 0 && typeof actual[key3] === "string" && isRegExp(obj2[key3]) && obj2[key3].test(actual[key3])) {
          _this[key3] = actual[key3];
        } else {
          _this[key3] = obj2[key3];
        }
      }
    });
  };
  function compareExceptionKey(actual, expected, key3, message, keys2, fn) {
    if (!(key3 in actual) || !isDeepStrictEqual(actual[key3], expected[key3])) {
      if (!message) {
        var a = new Comparison(actual, keys2);
        var b = new Comparison(expected, keys2, actual);
        var err = new AssertionError({
          actual: a,
          expected: b,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err.actual = actual;
        err.expected = expected;
        err.operator = fn.name;
        throw err;
      }
      innerFail({
        actual,
        expected,
        message,
        operator: fn.name,
        stackStartFn: fn
      });
    }
  }
  function expectedException(actual, expected, msg, fn) {
    if (typeof expected !== "function") {
      if (isRegExp(expected))
        return expected.test(actual);
      if (arguments.length === 2) {
        throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
      }
      if (_typeof(actual) !== "object" || actual === null) {
        var err = new AssertionError({
          actual,
          expected,
          message: msg,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err.operator = fn.name;
        throw err;
      }
      var keys2 = Object.keys(expected);
      if (expected instanceof Error) {
        keys2.push("name", "message");
      } else if (keys2.length === 0) {
        throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      keys2.forEach(function(key3) {
        if (typeof actual[key3] === "string" && isRegExp(expected[key3]) && expected[key3].test(actual[key3])) {
          return;
        }
        compareExceptionKey(actual, expected, key3, msg, keys2, fn);
      });
      return true;
    }
    if (expected.prototype !== void 0 && actual instanceof expected) {
      return true;
    }
    if (Error.isPrototypeOf(expected)) {
      return false;
    }
    return expected.call({}, actual) === true;
  }
  function getActual(fn) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
    }
    try {
      fn();
    } catch (e) {
      return e;
    }
    return NO_EXCEPTION_SENTINEL;
  }
  function checkIsPromise(obj2) {
    return isPromise(obj2) || obj2 !== null && _typeof(obj2) === "object" && typeof obj2.then === "function" && typeof obj2.catch === "function";
  }
  function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
      var resultPromise;
      if (typeof promiseFn === "function") {
        resultPromise = promiseFn();
        if (!checkIsPromise(resultPromise)) {
          throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
        }
      } else if (checkIsPromise(promiseFn)) {
        resultPromise = promiseFn;
      } else {
        throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
      }
      return Promise.resolve().then(function() {
        return resultPromise;
      }).then(function() {
        return NO_EXCEPTION_SENTINEL;
      }).catch(function(e) {
        return e;
      });
    });
  }
  function expectsError(stackStartFn, actual, error3, message) {
    if (typeof error3 === "string") {
      if (arguments.length === 4) {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error3);
      }
      if (_typeof(actual) === "object" && actual !== null) {
        if (actual.message === error3) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
        }
      } else if (actual === error3) {
        throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
      }
      message = error3;
      error3 = void 0;
    } else if (error3 != null && _typeof(error3) !== "object" && typeof error3 !== "function") {
      throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error3);
    }
    if (actual === NO_EXCEPTION_SENTINEL) {
      var details = "";
      if (error3 && error3.name) {
        details += " (".concat(error3.name, ")");
      }
      details += message ? ": ".concat(message) : ".";
      var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
      innerFail({
        actual: void 0,
        expected: error3,
        operator: stackStartFn.name,
        message: "Missing expected ".concat(fnType).concat(details),
        stackStartFn
      });
    }
    if (error3 && !expectedException(actual, error3, message, stackStartFn)) {
      throw actual;
    }
  }
  function expectsNoError(stackStartFn, actual, error3, message) {
    if (actual === NO_EXCEPTION_SENTINEL)
      return;
    if (typeof error3 === "string") {
      message = error3;
      error3 = void 0;
    }
    if (!error3 || expectedException(actual, error3)) {
      var details = message ? ": ".concat(message) : ".";
      var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
      innerFail({
        actual,
        expected: error3,
        operator: stackStartFn.name,
        message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
        stackStartFn
      });
    }
    throw actual;
  }
  assert$12.throws = function throws(promiseFn) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
  };
  assert$12.rejects = function rejects(promiseFn) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return waitForActual(promiseFn).then(function(result) {
      return expectsError.apply(void 0, [rejects, result].concat(args));
    });
  };
  assert$12.doesNotThrow = function doesNotThrow(fn) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
  };
  assert$12.doesNotReject = function doesNotReject(fn) {
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    return waitForActual(fn).then(function(result) {
      return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
    });
  };
  assert$12.ifError = function ifError(err) {
    if (err !== null && err !== void 0) {
      var message = "ifError got unwanted exception: ";
      if (_typeof(err) === "object" && typeof err.message === "string") {
        if (err.message.length === 0 && err.constructor) {
          message += err.constructor.name;
        } else {
          message += err.message;
        }
      } else {
        message += inspect9(err);
      }
      var newErr = new AssertionError({
        actual: err,
        expected: null,
        operator: "ifError",
        message,
        stackStartFn: ifError
      });
      var origStack = err.stack;
      if (typeof origStack === "string") {
        var tmp2 = origStack.split("\n");
        tmp2.shift();
        var tmp1 = newErr.stack.split("\n");
        for (var i = 0; i < tmp2.length; i++) {
          var pos = tmp1.indexOf(tmp2[i]);
          if (pos !== -1) {
            tmp1 = tmp1.slice(0, pos);
            break;
          }
        }
        newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
      }
      throw newErr;
    }
  };
  function strict() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    innerOk.apply(void 0, [strict, args.length].concat(args));
  }
  assert$12.strict = objectAssign(strict, assert$12, {
    equal: assert$12.strictEqual,
    deepEqual: assert$12.deepStrictEqual,
    notEqual: assert$12.notStrictEqual,
    notDeepEqual: assert$12.notDeepStrictEqual
  });
  assert$12.strict.strict = assert$12.strict;
  return assert.exports;
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(arDataCreate, "__esModule", { value: true });
arDataCreate.createData = void 0;
const assert_1 = __importDefault(requireAssert());
const base64url_1 = __importDefault(base64url$3.exports);
const utils_1 = utils$E;
const DataItem_1 = __importDefault(requireDataItem());
const parser_1 = parser;
function createData(data2, signer, opts) {
  var _a, _b, _c, _d, _e, _f, _g;
  const _owner = signer.publicKey;
  const _target = (opts === null || opts === void 0 ? void 0 : opts.target) ? base64url_1.default.toBuffer(opts.target) : null;
  const target_length = 1 + ((_a = _target === null || _target === void 0 ? void 0 : _target.byteLength) !== null && _a !== void 0 ? _a : 0);
  const _anchor = (opts === null || opts === void 0 ? void 0 : opts.anchor) ? Buffer.from(opts.anchor) : null;
  const anchor_length = 1 + ((_b = _anchor === null || _anchor === void 0 ? void 0 : _anchor.byteLength) !== null && _b !== void 0 ? _b : 0);
  const _tags = ((_d = (_c = opts === null || opts === void 0 ? void 0 : opts.tags) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0 ? parser_1.serializeTags(opts.tags) : null;
  const tags_length = 16 + (_tags ? _tags.byteLength : 0);
  const _data = typeof data2 === "string" ? Buffer.from(data2) : Buffer.from(data2);
  const data_length = _data.byteLength;
  const length2 = 2 + signer.signatureLength + signer.ownerLength + target_length + anchor_length + tags_length + data_length;
  const bytes = Buffer.alloc(length2);
  bytes.set(utils_1.shortTo2ByteArray(signer.signatureType), 0);
  bytes.set(new Uint8Array(signer.signatureLength).fill(0), 2);
  assert_1.default(_owner.byteLength == signer.ownerLength, new Error(`Owner must be ${signer.ownerLength} bytes, but was incorrectly ${_owner.byteLength}`));
  bytes.set(_owner, 2 + signer.signatureLength);
  const position = 2 + signer.signatureLength + signer.ownerLength;
  bytes[position] = _target ? 1 : 0;
  if (_target) {
    assert_1.default(_target.byteLength == 32, new Error("Target must be 32 bytes but was incorrectly ${_target.byteLength}"));
    bytes.set(_target, position + 1);
  }
  const anchor_start = position + target_length;
  let tags_start = anchor_start + 1;
  bytes[anchor_start] = _anchor ? 1 : 0;
  if (_anchor) {
    tags_start += _anchor.byteLength;
    assert_1.default(_anchor.byteLength == 32, new Error("Anchor must be 32 bytes"));
    bytes.set(_anchor, anchor_start + 1);
  }
  bytes.set(utils_1.longTo8ByteArray((_f = (_e = opts === null || opts === void 0 ? void 0 : opts.tags) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0), tags_start);
  const bytesCount = utils_1.longTo8ByteArray((_g = _tags === null || _tags === void 0 ? void 0 : _tags.byteLength) !== null && _g !== void 0 ? _g : 0);
  bytes.set(bytesCount, tags_start + 8);
  if (_tags) {
    bytes.set(_tags, tags_start + 16);
  }
  const data_start = tags_start + tags_length;
  bytes.set(_data, data_start);
  return new DataItem_1.default(bytes);
}
arDataCreate.createData = createData;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.signers = exports2.deepHash = exports2.unbundleData = exports2.bundleAndSignData = exports2.createData = exports2.DataItem = exports2.Bundle = exports2.MIN_BINARY_SIZE = void 0;
  const ar_data_bundle_1 = requireArDataBundle();
  Object.defineProperty(exports2, "bundleAndSignData", { enumerable: true, get: function() {
    return ar_data_bundle_1.bundleAndSignData;
  } });
  Object.defineProperty(exports2, "unbundleData", { enumerable: true, get: function() {
    return ar_data_bundle_1.unbundleData;
  } });
  const Bundle_1 = __importDefault2(requireBundle());
  exports2.Bundle = Bundle_1.default;
  const DataItem_12 = __importStar2(requireDataItem());
  exports2.DataItem = DataItem_12.default;
  Object.defineProperty(exports2, "MIN_BINARY_SIZE", { enumerable: true, get: function() {
    return DataItem_12.MIN_BINARY_SIZE;
  } });
  const deepHash_12 = deepHash$2;
  Object.defineProperty(exports2, "deepHash", { enumerable: true, get: function() {
    return deepHash_12.deepHash;
  } });
  const ar_data_create_1 = arDataCreate;
  Object.defineProperty(exports2, "createData", { enumerable: true, get: function() {
    return ar_data_create_1.createData;
  } });
  const signing_1 = signing;
  const SolanaSigner_12 = __importDefault2(SolanaSigner$1);
  const ethereumSigner_12 = __importDefault2(ethereumSigner);
  const signers = {
    ArweaveSigner: signing_1.ArweaveSigner,
    SolanaSigner: SolanaSigner_12.default,
    EthereumSigner: ethereumSigner_12.default
  };
  exports2.signers = signers;
})(src$2);
let storedPermissions;
const jwkToCryptoKey = async (jwk) => {
  return crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: "RSA-PSS",
      hash: {
        name: "SHA-256"
      }
    },
    false,
    ["sign"]
  );
};
const subtleSign = async (jwk, data2, { saltLength } = { saltLength: 32 }) => {
  let signature2 = await crypto.subtle.sign(
    {
      name: "RSA-PSS",
      saltLength
    },
    await jwkToCryptoKey(jwk),
    data2
  );
  return new Uint8Array(signature2);
};
const generateJWK = async () => {
  let cryptoKey = await crypto.subtle.generateKey(
    {
      name: "RSA-PSS",
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: {
        name: "SHA-256"
      }
    },
    true,
    ["sign"]
  );
  let jwk = await crypto.subtle.exportKey("jwk", cryptoKey.privateKey);
  const kid = await ownerToAddress(jwk.n);
  return {
    kty: jwk.kty,
    e: jwk.e,
    n: jwk.n,
    d: jwk.d,
    p: jwk.p,
    q: jwk.q,
    dp: jwk.dp,
    dq: jwk.dq,
    qi: jwk.qi,
    kid
  };
};
async function ownerToAddress(owner) {
  return bufferTob64Url$3(
    await crypto.subtle.digest("SHA-256", b64UrlToBuffer$3(owner))
  );
}
async function getJWK() {
  let jwk;
  const address = await arweaveWalletAPI.getActiveAddress();
  rsa.forEach((value, key3, map) => {
    if (value.kty == "RSA" && (value == null ? void 0 : value.kid) == address) {
      jwk = value;
    }
  });
  return jwk;
}
const arweaveWalletAPI = {
  generateJWK: async () => {
    const jwk = await generateJWK();
    return jwk;
  },
  async connect(permissions, appInfo = {}) {
    storedPermissions = permissions;
    return true;
  },
  async disconnect() {
    return true;
  },
  async getActiveAddress() {
    try {
      let jwk;
      rsa.forEach((value, key3, map) => {
        if (value.kty == "RSA") {
          jwk = value;
        }
      });
      const addr = await ownerToAddress(jwk.n);
      return addr;
    } catch (e) {
      throw new Error(e);
    }
  },
  async getActivePublicKey() {
  },
  async getAllAddresses() {
  },
  async getWalletNames() {
  },
  async addToken(id2) {
  },
  async dispatch(transaction2) {
    let tx = new Transaction$1(transaction2);
    let jwk = await getJWK();
    tx.setOwner(jwk.n);
    const data2 = tx.get("data", { decode: true, string: false });
    const tags2 = tx.get("tags").map((tag) => ({
      name: tag.get("name", { decode: true, string: true }),
      value: tag.get("value", { decode: true, string: true })
    }));
    try {
      const dataSigner = new ArweaveSigner$2(jwk);
      const dataEntry = src$2.createData(data2, dataSigner, { tags: tags2 });
      if (transaction2.data_size > 1e5) {
        const methodName = "arweaveWalletAPI.sign";
        let confirmed = await getConfig().confirm(methodName, transaction2);
        if (!confirmed)
          return false;
      }
      await dataEntry.sign(dataSigner);
      await uploadDataToBundlr(dataEntry);
      return {
        id: dataEntry.id,
        type: "BUNDLED"
      };
    } catch (e) {
      console.log("Error signing", e);
    }
  },
  async sign(transaction2, options) {
    const methodName = "arweaveWalletAPI.sign";
    let confirmed = await getConfig().confirm(methodName, transaction2);
    if (!confirmed)
      return false;
    await arweaveWalletAPI.getActiveAddress();
    let jwk = await getJWK();
    let tx = new Transaction$1(transaction2);
    tx.setOwner(jwk.n);
    let dataToSign = await tx.getSignatureData();
    const rawSignature = await subtleSign(jwk, dataToSign, options);
    let id2 = await crypto.subtle.digest("SHA-256", rawSignature);
    tx.setSignature({
      id: bufferTob64Url$3(id2),
      owner: jwk.n,
      signature: bufferTob64Url$3(rawSignature)
    });
    return tx;
  },
  async getPermissions() {
    const permissions = storedPermissions;
    return permissions;
  },
  async getArweaveConfig() {
  },
  async encrypt(data2, options) {
  },
  async decrypt(data2, options) {
  },
  async signature(data2, algorithm) {
  },
  noop() {
    return true;
  }
};
const pre = /* @__PURE__ */ new Map();
const rsa = /* @__PURE__ */ new Map();
const DEFAULT_NAME = "Master Key";
const DEFAULT_RSA_NAME = "Arweave_1";
let wallet;
loadWallet();
function browser$1() {
  return ![typeof document].includes("undefined");
}
async function loadWallet() {
  if (!browser$1())
    return;
  const resolved = await getWallet();
  wallet = resolved;
}
async function assertWallet() {
  if (!wallet)
    await wallet;
}
const generateMnemonic = async function() {
  await assertWallet();
  return wallet.generate_mnemonic();
};
const generateRsaJwk = async function() {
  const jwk = await generateJWK();
  rsa.set(DEFAULT_RSA_NAME, jwk);
  return jwk;
};
const loadSecrets = async function({ mnemonic, rsajwk }) {
  rsa.set(DEFAULT_RSA_NAME, rsajwk);
  await loadMnemonicInProxcryptor(mnemonic);
};
const loadMnemonicInProxcryptor = async function(mnemonic, pre_name = DEFAULT_NAME) {
  await assertWallet();
  const proxcryptor2 = wallet.mnemonic_to_proxcryptor(mnemonic);
  pre.set(pre_name, proxcryptor2);
  return pre_name;
};
const getLoadedKeys = () => {
  let results = [];
  pre.forEach((proxcryptor2, pre_name) => {
    results.push({
      name: pre_name,
      publicKey: proxcryptor2.public_key(),
      publicKeyJWK: proxcryptor2.public_key_jwk(),
      publicKeyBase58: proxcryptor2.public_key_base58()
    });
  });
  rsa.forEach((keyDetails, nickname) => {
    results.push({
      name: nickname,
      publicKey: keyDetails.n,
      publicKeyJWK: {
        kty: "RSA",
        kid: keyDetails.kid,
        e: "AQAB",
        n: keyDetails.n
      },
      publicKeyBase58: null
    });
  });
  return results;
};
new TextDecoder();
const proxcryptor = {
  selfEncrypt: (data2, tag, pre_name = DEFAULT_NAME) => {
    if (!(pre && pre_name && pre.get(pre_name)))
      return new Error("No proxy encryptor available for this name.");
    let encrypted_message = pre.get(pre_name).self_encrypt(data2, tag);
    return encrypted_message;
  },
  selfDecrypt: async (encryptedMessage, pre_name = DEFAULT_NAME) => {
    const methodName = "proxcryptor.selfDecrypt";
    const args = { tag: new Uint8Array(encryptedMessage.tag) };
    const config2 = getConfig();
    let confirmed = await config2.confirm(methodName, args);
    if (!confirmed)
      return false;
    {
      let decrypted_message = pre.get(pre_name).self_decrypt(encryptedMessage);
      return decrypted_message;
    }
  },
  generateReKey: async (targetPublicKey, tag, pre_name = DEFAULT_NAME) => {
    if (!(pre && pre_name && pre.get(pre_name)))
      return new Error("No proxy encryptor available for this name.");
    const methodName = "proxcryptor.generateReKey";
    const args = { tag, targetPublicKey };
    const config2 = getConfig();
    let confirmed = await config2.confirm(methodName, args);
    if (!confirmed)
      return false;
    let re_key = pre.get(pre_name).generate_re_key(targetPublicKey, tag);
    return re_key;
  },
  reEncrypt: async (targetPublicKey, encrypted_message, re_key) => {
    if (!wallet)
      return new Error("No wallet encryptor available");
    const methodName = "proxcryptor.reEncrypt";
    const args = { tag: encrypted_message.tag, targetPublicKey };
    const config2 = getConfig();
    let confirmed = await config2.confirm(methodName, args);
    if (!confirmed)
      return false;
    let re_encrypted_message = wallet.re_encrypt(targetPublicKey, encrypted_message, re_key);
    return re_encrypted_message;
  },
  transformTagKey: async (targetPublicKey, tag, encrypted_message, pre_name = DEFAULT_NAME) => {
    if (!(pre && pre_name && pre.get(pre_name)))
      return new Error("No proxy encryptor available for this name.");
    const methodName = "proxcryptor.transformTagKey";
    const args = { tag, targetPublicKey };
    const config2 = getConfig();
    let confirmed = await config2.confirm(methodName, args);
    if (!confirmed)
      return false;
    let re_key = pre.get(pre_name).generate_re_key(targetPublicKey, tag);
    let re_encrypted_message = wallet.re_encrypt(targetPublicKey, encrypted_message, re_key);
    return re_encrypted_message;
  },
  reDecrypt: async (re_encrypted_message, pre_name = DEFAULT_NAME) => {
    if (!(pre && pre_name && pre.get(pre_name)))
      return new Error("No proxy encryptor available for this name.");
    const methodName = "proxcryptor.reDecrypt";
    const args = {};
    const config2 = getConfig();
    let confirmed = await config2.confirm(methodName, args);
    if (!confirmed)
      return false;
    let decrypted = pre.get(pre_name).re_decrypt(re_encrypted_message);
    return new Uint8Array(decrypted);
  },
  getPublicKey: (pre_name = DEFAULT_NAME) => {
    if (!pre || !pre_name || !pre.get(pre_name))
      return new Error(`No proxy encryptor available for name ${pre_name}.`);
    let publicKey = pre.get(pre_name).public_key();
    if (publicKey.length == 32)
      return publicKey;
    return false;
  }
};
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size);
  }
  return new Uint8Array(size);
}
function base(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode8(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode5(string2) {
    var buffer2 = decodeUnsafe2(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode8,
    decodeUnsafe: decodeUnsafe2,
    decode: decode5
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString = (str) => new TextEncoder().encode(str);
const toString$2 = (b) => new TextDecoder().decode(b);
class Encoder {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text2) {
    if (typeof text2 === "string") {
      if (text2.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text2.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$1 = ({ name: name2, prefix, encode: encode8, decode: decode5 }) => new Codec(name2, prefix, encode8, decode5);
const baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode8, decode: decode5 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from$1({
    prefix,
    name: name2,
    encode: encode8,
    decode: (text2) => coerce(decode5(text2))
  });
};
const decode$2 = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes2[alphabet2[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$3 = (data2, alphabet2, bitsPerChar) => {
  const pad3 = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data2.length; ++i) {
    buffer2 = buffer2 << 8 | data2[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad3) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$1({
    prefix,
    name: name2,
    encode(input) {
      return encode$3(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$2(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const identity$2 = from$1({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$2(buf),
  decode: (str) => fromString(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$2
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32upper,
  base32pad,
  base32padupper,
  base32hex,
  base32hexupper,
  base32hexpad,
  base32hexpadupper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
const alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode$2(data2) {
  return data2.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode$1(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$1({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode$2,
  decode: decode$1
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
var encode_1 = encode$1;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode$1(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$1.bytes = offset - oldOffset + 1;
  return out;
}
var decode4 = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode4,
  encodingLength: length
};
var _brrp_varint = varint;
const encodeTo = (int2, target, offset = 0) => {
  _brrp_varint.encode(int2, target, offset);
  return target;
};
const encodingLength = (int2) => {
  return _brrp_varint.encodingLength(int2);
};
const create4 = (code2, digest10) => {
  const size = digest10.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest10, digestOffset);
  return new Digest(code2, size, digest10, bytes);
};
class Digest {
  constructor(code2, size, digest10, bytes) {
    this.code = code2;
    this.size = size;
    this.digest = digest10;
    this.bytes = bytes;
  }
}
const from = ({ name: name2, code: code2, encode: encode8 }) => new Hasher(name2, code2, encode8);
class Hasher {
  constructor(name2, code2, encode8) {
    this.name = name2;
    this.code = code2;
    this.encode = encode8;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest10) => create4(this.code, digest10));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const sha = (name2) => async (data2) => new Uint8Array(await crypto.subtle.digest(name2, data2));
const sha256$1 = from({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
const sha512$1 = from({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});
const sha2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: sha256$1,
  sha512: sha512$1
}, Symbol.toStringTag, { value: "Module" }));
const code = 0;
const name = "identity";
const encode7 = coerce;
const digest9 = (input) => create4(code, encode7(input));
const identity = {
  code,
  name,
  encode: encode7,
  digest: digest9
};
const identity$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
({
  ...sha2,
  ...identity$1
});
function createCodec(name2, prefix, encode8, decode5) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode8
    },
    decoder: { decode: decode5 }
  };
}
const string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i = 0; i < buf.length; i++) {
    string2 += String.fromCharCode(buf[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString$1(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var sha256 = {};
var binary = {};
var int = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  function imulShim(a, b) {
    var ah = a >>> 16 & 65535, al = a & 65535;
    var bh = b >>> 16 & 65535, bl = b & 65535;
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  }
  exports2.mul = Math.imul || imulShim;
  function add7(a, b) {
    return a + b | 0;
  }
  exports2.add = add7;
  function sub(a, b) {
    return a - b | 0;
  }
  exports2.sub = sub;
  function rotl2(x, n) {
    return x << n | x >>> 32 - n;
  }
  exports2.rotl = rotl2;
  function rotr(x, n) {
    return x << 32 - n | x >>> n;
  }
  exports2.rotr = rotr;
  function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
  }
  exports2.isInteger = Number.isInteger || isIntegerShim;
  exports2.MAX_SAFE_INTEGER = 9007199254740991;
  exports2.isSafeInteger = function(n) {
    return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: true });
var int_1 = int;
function readInt16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  return out;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  out[offset + 2] = value >>> 16;
  out[offset + 3] = value >>> 24;
  return out;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi = readInt32BE(array, offset);
  var lo = readInt32BE(array, offset + 4);
  return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi = readUint32BE(array, offset);
  var lo = readUint32BE(array, offset + 4);
  return hi * 4294967296 + lo;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array, offset);
  var hi = readInt32LE(array, offset + 4);
  return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array, offset);
  var hi = readUint32LE(array, offset + 4);
  return hi * 4294967296 + lo;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value / 4294967296 >>> 0, out, offset);
  writeUint32BE(value >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value >>> 0, out, offset);
  writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul7 = 1;
  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
    result += array[i] * mul7;
    mul7 *= 256;
  }
  return result;
}
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul7 = 1;
  for (var i = offset; i < offset + bitLength / 8; i++) {
    result += array[i] * mul7;
    mul7 *= 256;
  }
  return result;
}
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
    out[i] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i = offset; i < offset + bitLength / 8; i++) {
    out[i] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, true);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, true);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value);
  return out;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value, true);
  return out;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value);
  return out;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value, true);
  return out;
}
binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: true });
function wipe(array) {
  for (var i = 0; i < array.length; i++) {
    array[i] = 0;
  }
  return array;
}
wipe$1.wipe = wipe;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var binary_12 = binary;
  var wipe_12 = wipe$1;
  exports2.DIGEST_LENGTH = 32;
  exports2.BLOCK_SIZE = 64;
  var SHA2562 = function() {
    function SHA2563() {
      this.digestLength = exports2.DIGEST_LENGTH;
      this.blockSize = exports2.BLOCK_SIZE;
      this._state = new Int32Array(8);
      this._temp = new Int32Array(64);
      this._buffer = new Uint8Array(128);
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      this.reset();
    }
    SHA2563.prototype._initState = function() {
      this._state[0] = 1779033703;
      this._state[1] = 3144134277;
      this._state[2] = 1013904242;
      this._state[3] = 2773480762;
      this._state[4] = 1359893119;
      this._state[5] = 2600822924;
      this._state[6] = 528734635;
      this._state[7] = 1541459225;
    };
    SHA2563.prototype.reset = function() {
      this._initState();
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      return this;
    };
    SHA2563.prototype.clean = function() {
      wipe_12.wipe(this._buffer);
      wipe_12.wipe(this._temp);
      this.reset();
    };
    SHA2563.prototype.update = function(data2, dataLength) {
      if (dataLength === void 0) {
        dataLength = data2.length;
      }
      if (this._finished) {
        throw new Error("SHA256: can't update because hash was finished.");
      }
      var dataPos = 0;
      this._bytesHashed += dataLength;
      if (this._bufferLength > 0) {
        while (this._bufferLength < this.blockSize && dataLength > 0) {
          this._buffer[this._bufferLength++] = data2[dataPos++];
          dataLength--;
        }
        if (this._bufferLength === this.blockSize) {
          hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
          this._bufferLength = 0;
        }
      }
      if (dataLength >= this.blockSize) {
        dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
        dataLength %= this.blockSize;
      }
      while (dataLength > 0) {
        this._buffer[this._bufferLength++] = data2[dataPos++];
        dataLength--;
      }
      return this;
    };
    SHA2563.prototype.finish = function(out) {
      if (!this._finished) {
        var bytesHashed = this._bytesHashed;
        var left = this._bufferLength;
        var bitLenHi = bytesHashed / 536870912 | 0;
        var bitLenLo = bytesHashed << 3;
        var padLength = bytesHashed % 64 < 56 ? 64 : 128;
        this._buffer[left] = 128;
        for (var i = left + 1; i < padLength - 8; i++) {
          this._buffer[i] = 0;
        }
        binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
        binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
        hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
        this._finished = true;
      }
      for (var i = 0; i < this.digestLength / 4; i++) {
        binary_12.writeUint32BE(this._state[i], out, i * 4);
      }
      return this;
    };
    SHA2563.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    SHA2563.prototype.saveState = function() {
      if (this._finished) {
        throw new Error("SHA256: cannot save finished state");
      }
      return {
        state: new Int32Array(this._state),
        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
        bufferLength: this._bufferLength,
        bytesHashed: this._bytesHashed
      };
    };
    SHA2563.prototype.restoreState = function(savedState) {
      this._state.set(savedState.state);
      this._bufferLength = savedState.bufferLength;
      if (savedState.buffer) {
        this._buffer.set(savedState.buffer);
      }
      this._bytesHashed = savedState.bytesHashed;
      this._finished = false;
      return this;
    };
    SHA2563.prototype.cleanSavedState = function(savedState) {
      wipe_12.wipe(savedState.state);
      if (savedState.buffer) {
        wipe_12.wipe(savedState.buffer);
      }
      savedState.bufferLength = 0;
      savedState.bytesHashed = 0;
    };
    return SHA2563;
  }();
  exports2.SHA256 = SHA2562;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w, v, p, pos, len) {
    while (len >= 64) {
      var a = v[0];
      var b = v[1];
      var c = v[2];
      var d = v[3];
      var e = v[4];
      var f2 = v[5];
      var g = v[6];
      var h = v[7];
      for (var i = 0; i < 16; i++) {
        var j = pos + i * 4;
        w[i] = binary_12.readUint32BE(p, j);
      }
      for (var i = 16; i < 64; i++) {
        var u = w[i - 2];
        var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
        u = w[i - 15];
        var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
        w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
      }
      for (var i = 0; i < 64; i++) {
        var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f2 ^ ~e & g) | 0) + (h + (K2[i] + w[i] | 0) | 0) | 0;
        var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
        h = g;
        g = f2;
        f2 = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }
      v[0] += a;
      v[1] += b;
      v[2] += c;
      v[3] += d;
      v[4] += e;
      v[5] += f2;
      v[6] += g;
      v[7] += h;
      pos += 64;
      len -= 64;
    }
    return pos;
  }
  function hash3(data2) {
    var h = new SHA2562();
    h.update(data2);
    var digest10 = h.digest();
    h.clean();
    return digest10;
  }
  exports2.hash = hash3;
})(sha256);
var ellipticExports = requireElliptic();
var ed25519$1 = {};
var random = {};
var system = {};
var browser = {};
Object.defineProperty(browser, "__esModule", { value: true });
var QUOTA = 65536;
var BrowserRandomSource = function() {
  function BrowserRandomSource2() {
    this.isAvailable = false;
    this.isInstantiated = false;
    var browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  BrowserRandomSource2.prototype.randomBytes = function(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    var out = new Uint8Array(length2);
    for (var i = 0; i < out.length; i += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
    }
    return out;
  };
  return BrowserRandomSource2;
}();
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire(path3) {
  throw new Error('Could not dynamically require "' + path3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node = {};
Object.defineProperty(node, "__esModule", { value: true });
var wipe_1$2 = wipe$1;
var NodeRandomSource = function() {
  function NodeRandomSource2() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire !== "undefined") {
      var nodeCrypto = requireCryptoBrowserify();
      if (nodeCrypto && nodeCrypto.randomBytes) {
        this._crypto = nodeCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  NodeRandomSource2.prototype.randomBytes = function(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    var buffer2 = this._crypto.randomBytes(length2);
    if (buffer2.length !== length2) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    var out = new Uint8Array(length2);
    for (var i = 0; i < out.length; i++) {
      out[i] = buffer2[i];
    }
    wipe_1$2.wipe(buffer2);
    return out;
  };
  return NodeRandomSource2;
}();
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: true });
var browser_1 = browser;
var node_1 = node;
var SystemRandomSource = function() {
  function SystemRandomSource2() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  SystemRandomSource2.prototype.randomBytes = function(length2) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length2);
  };
  return SystemRandomSource2;
}();
system.SystemRandomSource = SystemRandomSource;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var system_1 = system;
  var binary_12 = binary;
  var wipe_12 = wipe$1;
  exports2.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes2(length2, prng) {
    if (prng === void 0) {
      prng = exports2.defaultRandomSource;
    }
    return prng.randomBytes(length2);
  }
  exports2.randomBytes = randomBytes2;
  function randomUint32(prng) {
    if (prng === void 0) {
      prng = exports2.defaultRandomSource;
    }
    var buf = randomBytes2(4, prng);
    var result = binary_12.readUint32LE(buf);
    wipe_12.wipe(buf);
    return result;
  }
  exports2.randomUint32 = randomUint32;
  var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset, prng) {
    if (charset === void 0) {
      charset = ALPHANUMERIC;
    }
    if (prng === void 0) {
      prng = exports2.defaultRandomSource;
    }
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    var out = "";
    var charsLen = charset.length;
    var maxByte = 256 - 256 % charsLen;
    while (length2 > 0) {
      var buf = randomBytes2(Math.ceil(length2 * 256 / maxByte), prng);
      for (var i = 0; i < buf.length && length2 > 0; i++) {
        var randomByte = buf[i];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length2--;
        }
      }
      wipe_12.wipe(buf);
    }
    return out;
  }
  exports2.randomString = randomString;
  function randomStringForEntropy(bits, charset, prng) {
    if (charset === void 0) {
      charset = ALPHANUMERIC;
    }
    if (prng === void 0) {
      prng = exports2.defaultRandomSource;
    }
    var length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  exports2.randomStringForEntropy = randomStringForEntropy;
})(random);
var sha512 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var binary_12 = binary;
  var wipe_12 = wipe$1;
  exports2.DIGEST_LENGTH = 64;
  exports2.BLOCK_SIZE = 128;
  var SHA5122 = function() {
    function SHA5123() {
      this.digestLength = exports2.DIGEST_LENGTH;
      this.blockSize = exports2.BLOCK_SIZE;
      this._stateHi = new Int32Array(8);
      this._stateLo = new Int32Array(8);
      this._tempHi = new Int32Array(16);
      this._tempLo = new Int32Array(16);
      this._buffer = new Uint8Array(256);
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      this.reset();
    }
    SHA5123.prototype._initState = function() {
      this._stateHi[0] = 1779033703;
      this._stateHi[1] = 3144134277;
      this._stateHi[2] = 1013904242;
      this._stateHi[3] = 2773480762;
      this._stateHi[4] = 1359893119;
      this._stateHi[5] = 2600822924;
      this._stateHi[6] = 528734635;
      this._stateHi[7] = 1541459225;
      this._stateLo[0] = 4089235720;
      this._stateLo[1] = 2227873595;
      this._stateLo[2] = 4271175723;
      this._stateLo[3] = 1595750129;
      this._stateLo[4] = 2917565137;
      this._stateLo[5] = 725511199;
      this._stateLo[6] = 4215389547;
      this._stateLo[7] = 327033209;
    };
    SHA5123.prototype.reset = function() {
      this._initState();
      this._bufferLength = 0;
      this._bytesHashed = 0;
      this._finished = false;
      return this;
    };
    SHA5123.prototype.clean = function() {
      wipe_12.wipe(this._buffer);
      wipe_12.wipe(this._tempHi);
      wipe_12.wipe(this._tempLo);
      this.reset();
    };
    SHA5123.prototype.update = function(data2, dataLength) {
      if (dataLength === void 0) {
        dataLength = data2.length;
      }
      if (this._finished) {
        throw new Error("SHA512: can't update because hash was finished.");
      }
      var dataPos = 0;
      this._bytesHashed += dataLength;
      if (this._bufferLength > 0) {
        while (this._bufferLength < exports2.BLOCK_SIZE && dataLength > 0) {
          this._buffer[this._bufferLength++] = data2[dataPos++];
          dataLength--;
        }
        if (this._bufferLength === this.blockSize) {
          hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
          this._bufferLength = 0;
        }
      }
      if (dataLength >= this.blockSize) {
        dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data2, dataPos, dataLength);
        dataLength %= this.blockSize;
      }
      while (dataLength > 0) {
        this._buffer[this._bufferLength++] = data2[dataPos++];
        dataLength--;
      }
      return this;
    };
    SHA5123.prototype.finish = function(out) {
      if (!this._finished) {
        var bytesHashed = this._bytesHashed;
        var left = this._bufferLength;
        var bitLenHi = bytesHashed / 536870912 | 0;
        var bitLenLo = bytesHashed << 3;
        var padLength = bytesHashed % 128 < 112 ? 128 : 256;
        this._buffer[left] = 128;
        for (var i = left + 1; i < padLength - 8; i++) {
          this._buffer[i] = 0;
        }
        binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
        binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
        hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
        this._finished = true;
      }
      for (var i = 0; i < this.digestLength / 8; i++) {
        binary_12.writeUint32BE(this._stateHi[i], out, i * 8);
        binary_12.writeUint32BE(this._stateLo[i], out, i * 8 + 4);
      }
      return this;
    };
    SHA5123.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    SHA5123.prototype.saveState = function() {
      if (this._finished) {
        throw new Error("SHA256: cannot save finished state");
      }
      return {
        stateHi: new Int32Array(this._stateHi),
        stateLo: new Int32Array(this._stateLo),
        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
        bufferLength: this._bufferLength,
        bytesHashed: this._bytesHashed
      };
    };
    SHA5123.prototype.restoreState = function(savedState) {
      this._stateHi.set(savedState.stateHi);
      this._stateLo.set(savedState.stateLo);
      this._bufferLength = savedState.bufferLength;
      if (savedState.buffer) {
        this._buffer.set(savedState.buffer);
      }
      this._bytesHashed = savedState.bytesHashed;
      this._finished = false;
      return this;
    };
    SHA5123.prototype.cleanSavedState = function(savedState) {
      wipe_12.wipe(savedState.stateHi);
      wipe_12.wipe(savedState.stateLo);
      if (savedState.buffer) {
        wipe_12.wipe(savedState.buffer);
      }
      savedState.bufferLength = 0;
      savedState.bytesHashed = 0;
    };
    return SHA5123;
  }();
  exports2.SHA512 = SHA5122;
  var K2 = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function hashBlocks(wh, wl, hh, hl2, m, pos, len) {
    var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
    var h, l;
    var th, tl;
    var a, b, c, d;
    while (len >= 128) {
      for (var i = 0; i < 16; i++) {
        var j = 8 * i + pos;
        wh[i] = binary_12.readUint32BE(m, j);
        wl[i] = binary_12.readUint32BE(m, j + 4);
      }
      for (var i = 0; i < 80; i++) {
        var bh0 = ah0;
        var bh1 = ah1;
        var bh2 = ah2;
        var bh3 = ah3;
        var bh4 = ah4;
        var bh5 = ah5;
        var bh6 = ah6;
        var bh7 = ah7;
        var bl0 = al0;
        var bl1 = al1;
        var bl2 = al2;
        var bl3 = al3;
        var bl4 = al4;
        var bl5 = al5;
        var bl6 = al6;
        var bl7 = al7;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
        l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        h = ah4 & ah5 ^ ~ah4 & ah6;
        l = al4 & al5 ^ ~al4 & al6;
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        h = K2[i * 2];
        l = K2[i * 2 + 1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        h = wh[i % 16];
        l = wl[i % 16];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        th = c & 65535 | d << 16;
        tl = a & 65535 | b << 16;
        h = th;
        l = tl;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
        l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
        l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        bh7 = c & 65535 | d << 16;
        bl7 = a & 65535 | b << 16;
        h = bh3;
        l = bl3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = th;
        l = tl;
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        bh3 = c & 65535 | d << 16;
        bl3 = a & 65535 | b << 16;
        ah1 = bh0;
        ah2 = bh1;
        ah3 = bh2;
        ah4 = bh3;
        ah5 = bh4;
        ah6 = bh5;
        ah7 = bh6;
        ah0 = bh7;
        al1 = bl0;
        al2 = bl1;
        al3 = bl2;
        al4 = bl3;
        al5 = bl4;
        al6 = bl5;
        al7 = bl6;
        al0 = bl7;
        if (i % 16 === 15) {
          for (var j = 0; j < 16; j++) {
            h = wh[j];
            l = wl[j];
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = wh[(j + 9) % 16];
            l = wl[(j + 9) % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            th = wh[(j + 1) % 16];
            tl = wl[(j + 1) % 16];
            h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
            l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            th = wh[(j + 14) % 16];
            tl = wl[(j + 14) % 16];
            h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
            l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            wh[j] = c & 65535 | d << 16;
            wl[j] = a & 65535 | b << 16;
          }
        }
      }
      h = ah0;
      l = al0;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[0];
      l = hl2[0];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[0] = ah0 = c & 65535 | d << 16;
      hl2[0] = al0 = a & 65535 | b << 16;
      h = ah1;
      l = al1;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[1];
      l = hl2[1];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[1] = ah1 = c & 65535 | d << 16;
      hl2[1] = al1 = a & 65535 | b << 16;
      h = ah2;
      l = al2;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[2];
      l = hl2[2];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[2] = ah2 = c & 65535 | d << 16;
      hl2[2] = al2 = a & 65535 | b << 16;
      h = ah3;
      l = al3;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[3];
      l = hl2[3];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[3] = ah3 = c & 65535 | d << 16;
      hl2[3] = al3 = a & 65535 | b << 16;
      h = ah4;
      l = al4;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[4];
      l = hl2[4];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[4] = ah4 = c & 65535 | d << 16;
      hl2[4] = al4 = a & 65535 | b << 16;
      h = ah5;
      l = al5;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[5];
      l = hl2[5];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[5] = ah5 = c & 65535 | d << 16;
      hl2[5] = al5 = a & 65535 | b << 16;
      h = ah6;
      l = al6;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[6];
      l = hl2[6];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[6] = ah6 = c & 65535 | d << 16;
      hl2[6] = al6 = a & 65535 | b << 16;
      h = ah7;
      l = al7;
      a = l & 65535;
      b = l >>> 16;
      c = h & 65535;
      d = h >>> 16;
      h = hh[7];
      l = hl2[7];
      a += l & 65535;
      b += l >>> 16;
      c += h & 65535;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      hh[7] = ah7 = c & 65535 | d << 16;
      hl2[7] = al7 = a & 65535 | b << 16;
      pos += 128;
      len -= 128;
    }
    return pos;
  }
  function hash3(data2) {
    var h = new SHA5122();
    h.update(data2);
    var digest10 = h.digest();
    h.clean();
    return digest10;
  }
  exports2.hash = hash3;
})(sha512);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var random_1 = random;
  var sha512_1 = sha512;
  var wipe_12 = wipe$1;
  exports2.SIGNATURE_LENGTH = 64;
  exports2.PUBLIC_KEY_LENGTH = 32;
  exports2.SECRET_KEY_LENGTH = 64;
  exports2.SEED_LENGTH = 32;
  function gf(init6) {
    var r2 = new Float64Array(16);
    if (init6) {
      for (var i = 0; i < init6.length; i++) {
        r2[i] = init6[i];
      }
    }
    return r2;
  }
  var _9 = new Uint8Array(32);
  _9[0] = 9;
  var gf0 = gf();
  var gf1 = gf([1]);
  var D = gf([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]);
  var D2 = gf([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]);
  var X = gf([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]);
  var Y = gf([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]);
  var I = gf([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function set25519(r2, a) {
    for (var i = 0; i < 16; i++) {
      r2[i] = a[i] | 0;
    }
  }
  function car25519(o) {
    var c = 1;
    for (var i = 0; i < 16; i++) {
      var v = o[i] + c + 65535;
      c = Math.floor(v / 65536);
      o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
  }
  function sel25519(p, q, b) {
    var c = ~(b - 1);
    for (var i = 0; i < 16; i++) {
      var t = c & (p[i] ^ q[i]);
      p[i] ^= t;
      q[i] ^= t;
    }
  }
  function pack25519(o, n) {
    var m = gf();
    var t = gf();
    for (var i = 0; i < 16; i++) {
      t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (var j = 0; j < 2; j++) {
      m[0] = t[0] - 65517;
      for (var i = 1; i < 15; i++) {
        m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
        m[i - 1] &= 65535;
      }
      m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
      var b = m[15] >> 16 & 1;
      m[14] &= 65535;
      sel25519(t, m, 1 - b);
    }
    for (var i = 0; i < 16; i++) {
      o[2 * i] = t[i] & 255;
      o[2 * i + 1] = t[i] >> 8;
    }
  }
  function verify32(x, y) {
    var d = 0;
    for (var i = 0; i < 32; i++) {
      d |= x[i] ^ y[i];
    }
    return (1 & d - 1 >>> 8) - 1;
  }
  function neq25519(a, b) {
    var c = new Uint8Array(32);
    var d = new Uint8Array(32);
    pack25519(c, a);
    pack25519(d, b);
    return verify32(c, d);
  }
  function par25519(a) {
    var d = new Uint8Array(32);
    pack25519(d, a);
    return d[0] & 1;
  }
  function unpack25519(o, n) {
    for (var i = 0; i < 16; i++) {
      o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 32767;
  }
  function add7(o, a, b) {
    for (var i = 0; i < 16; i++) {
      o[i] = a[i] + b[i];
    }
  }
  function sub(o, a, b) {
    for (var i = 0; i < 16; i++) {
      o[i] = a[i] - b[i];
    }
  }
  function mul7(o, a, b) {
    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
  function square(o, a) {
    mul7(o, a, a);
  }
  function inv25519(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; a++) {
      c[a] = i[a];
    }
    for (a = 253; a >= 0; a--) {
      square(c, c);
      if (a !== 2 && a !== 4) {
        mul7(c, c, i);
      }
    }
    for (a = 0; a < 16; a++) {
      o[a] = c[a];
    }
  }
  function pow2523(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; a++) {
      c[a] = i[a];
    }
    for (a = 250; a >= 0; a--) {
      square(c, c);
      if (a !== 1) {
        mul7(c, c, i);
      }
    }
    for (a = 0; a < 16; a++) {
      o[a] = c[a];
    }
  }
  function edadd(p, q) {
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f2 = gf(), g = gf(), h = gf(), t = gf();
    sub(a, p[1], p[0]);
    sub(t, q[1], q[0]);
    mul7(a, a, t);
    add7(b, p[0], p[1]);
    add7(t, q[0], q[1]);
    mul7(b, b, t);
    mul7(c, p[3], q[3]);
    mul7(c, c, D2);
    mul7(d, p[2], q[2]);
    add7(d, d, d);
    sub(e, b, a);
    sub(f2, d, c);
    add7(g, d, c);
    add7(h, b, a);
    mul7(p[0], e, f2);
    mul7(p[1], h, g);
    mul7(p[2], g, f2);
    mul7(p[3], e, h);
  }
  function cswap(p, q, b) {
    for (var i = 0; i < 4; i++) {
      sel25519(p[i], q[i], b);
    }
  }
  function pack2(r2, p) {
    var tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    mul7(tx, p[0], zi);
    mul7(ty, p[1], zi);
    pack25519(r2, ty);
    r2[31] ^= par25519(tx) << 7;
  }
  function scalarmult(p, q, s2) {
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (var i = 255; i >= 0; --i) {
      var b = s2[i / 8 | 0] >> (i & 7) & 1;
      cswap(p, q, b);
      edadd(q, p);
      edadd(p, p);
      cswap(p, q, b);
    }
  }
  function scalarbase(p, s2) {
    var q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    mul7(q[3], X, Y);
    scalarmult(p, q, s2);
  }
  function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports2.SEED_LENGTH) {
      throw new Error("ed25519: seed must be " + exports2.SEED_LENGTH + " bytes");
    }
    var d = sha512_1.hash(seed);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    var publicKey = new Uint8Array(32);
    var p = [gf(), gf(), gf(), gf()];
    scalarbase(p, d);
    pack2(publicKey, p);
    var secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey, 32);
    return {
      publicKey,
      secretKey
    };
  }
  exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    var seed = random_1.randomBytes(32, prng);
    var result = generateKeyPairFromSeed(seed);
    wipe_12.wipe(seed);
    return result;
  }
  exports2.generateKeyPair = generateKeyPair;
  function extractPublicKeyFromSecretKey(secretKey) {
    if (secretKey.length !== exports2.SECRET_KEY_LENGTH) {
      throw new Error("ed25519: secret key must be " + exports2.SECRET_KEY_LENGTH + " bytes");
    }
    return new Uint8Array(secretKey.subarray(32));
  }
  exports2.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
  var L = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function modL(r2, x) {
    var carry;
    var i;
    var j;
    var k;
    for (i = 63; i >= 32; --i) {
      carry = 0;
      for (j = i - 32, k = i - 12; j < k; ++j) {
        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
        carry = Math.floor((x[j] + 128) / 256);
        x[j] -= carry * 256;
      }
      x[j] += carry;
      x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; j++) {
      x[j] += carry - (x[31] >> 4) * L[j];
      carry = x[j] >> 8;
      x[j] &= 255;
    }
    for (j = 0; j < 32; j++) {
      x[j] -= carry * L[j];
    }
    for (i = 0; i < 32; i++) {
      x[i + 1] += x[i] >> 8;
      r2[i] = x[i] & 255;
    }
  }
  function reduce(r2) {
    var x = new Float64Array(64);
    for (var i = 0; i < 64; i++) {
      x[i] = r2[i];
    }
    for (var i = 0; i < 64; i++) {
      r2[i] = 0;
    }
    modL(r2, x);
  }
  function sign7(secretKey, message) {
    var x = new Float64Array(64);
    var p = [gf(), gf(), gf(), gf()];
    var d = sha512_1.hash(secretKey.subarray(0, 32));
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    var signature2 = new Uint8Array(64);
    signature2.set(d.subarray(32), 32);
    var hs = new sha512_1.SHA512();
    hs.update(signature2.subarray(32));
    hs.update(message);
    var r2 = hs.digest();
    hs.clean();
    reduce(r2);
    scalarbase(p, r2);
    pack2(signature2, p);
    hs.reset();
    hs.update(signature2.subarray(0, 32));
    hs.update(secretKey.subarray(32));
    hs.update(message);
    var h = hs.digest();
    reduce(h);
    for (var i = 0; i < 32; i++) {
      x[i] = r2[i];
    }
    for (var i = 0; i < 32; i++) {
      for (var j = 0; j < 32; j++) {
        x[i + j] += h[i] * d[j];
      }
    }
    modL(signature2.subarray(32), x);
    return signature2;
  }
  exports2.sign = sign7;
  function unpackneg(r2, p) {
    var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r2[2], gf1);
    unpack25519(r2[1], p);
    square(num, r2[1]);
    mul7(den, num, D);
    sub(num, num, r2[2]);
    add7(den, r2[2], den);
    square(den2, den);
    square(den4, den2);
    mul7(den6, den4, den2);
    mul7(t, den6, num);
    mul7(t, t, den);
    pow2523(t, t);
    mul7(t, t, num);
    mul7(t, t, den);
    mul7(t, t, den);
    mul7(r2[0], t, den);
    square(chk, r2[0]);
    mul7(chk, chk, den);
    if (neq25519(chk, num)) {
      mul7(r2[0], r2[0], I);
    }
    square(chk, r2[0]);
    mul7(chk, chk, den);
    if (neq25519(chk, num)) {
      return -1;
    }
    if (par25519(r2[0]) === p[31] >> 7) {
      sub(r2[0], gf0, r2[0]);
    }
    mul7(r2[3], r2[0], r2[1]);
    return 0;
  }
  function verify7(publicKey, message, signature2) {
    var t = new Uint8Array(32);
    var p = [gf(), gf(), gf(), gf()];
    var q = [gf(), gf(), gf(), gf()];
    if (signature2.length !== exports2.SIGNATURE_LENGTH) {
      throw new Error("ed25519: signature must be " + exports2.SIGNATURE_LENGTH + " bytes");
    }
    if (unpackneg(q, publicKey)) {
      return false;
    }
    var hs = new sha512_1.SHA512();
    hs.update(signature2.subarray(0, 32));
    hs.update(publicKey);
    hs.update(message);
    var h = hs.digest();
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, signature2.subarray(32));
    edadd(p, q);
    pack2(t, p);
    if (verify32(signature2, t)) {
      return false;
    }
    return true;
  }
  exports2.verify = verify7;
  function convertPublicKeyToX25519(publicKey) {
    var q = [gf(), gf(), gf(), gf()];
    if (unpackneg(q, publicKey)) {
      throw new Error("Ed25519: invalid public key");
    }
    var a = gf();
    var b = gf();
    var y = q[1];
    add7(a, gf1, y);
    sub(b, gf1, y);
    inv25519(b, b);
    mul7(a, a, b);
    var z = new Uint8Array(32);
    pack25519(z, a);
    return z;
  }
  exports2.convertPublicKeyToX25519 = convertPublicKeyToX25519;
  function convertSecretKeyToX25519(secretKey) {
    var d = sha512_1.hash(secretKey.subarray(0, 32));
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    var o = new Uint8Array(d.subarray(0, 32));
    wipe_12.wipe(d);
    return o;
  }
  exports2.convertSecretKeyToX25519 = convertSecretKeyToX25519;
})(ed25519$1);
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
  const x = ALPHABET.charAt(z);
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre2) {
  const b = pre2 >> 25;
  return (pre2 & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  let chk = 1;
  for (let i = 0; i < prefix.length; ++i) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c >> 5;
  }
  chk = polymodStep(chk);
  for (let i = 0; i < prefix.length; ++i) {
    const v = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v & 31;
  }
  return chk;
}
function convert(data2, inBits, outBits, pad3) {
  let value = 0;
  let bits = 0;
  const maxV = (1 << outBits) - 1;
  const result = [];
  for (let i = 0; i < data2.length; ++i) {
    value = value << inBits | data2[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad3) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWords(bytes) {
  return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words2) {
  const res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words2) {
  const res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
  let ENCODING_CONST;
  if (encoding === "bech32") {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 734539939;
  }
  function encode8(prefix, words2, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words2.length > LIMIT)
      throw new TypeError("Exceeds length limit");
    prefix = prefix.toLowerCase();
    let chk = prefixChk(prefix);
    if (typeof chk === "string")
      throw new Error(chk);
    let result = prefix + "1";
    for (let i = 0; i < words2.length; ++i) {
      const x = words2[i];
      if (x >> 5 !== 0)
        throw new Error("Non 5-bit word");
      chk = polymodStep(chk) ^ x;
      result += ALPHABET.charAt(x);
    }
    for (let i = 0; i < 6; ++i) {
      chk = polymodStep(chk);
    }
    chk ^= ENCODING_CONST;
    for (let i = 0; i < 6; ++i) {
      const v = chk >> (5 - i) * 5 & 31;
      result += ALPHABET.charAt(v);
    }
    return result;
  }
  function __decode2(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8)
      return str + " too short";
    if (str.length > LIMIT)
      return "Exceeds length limit";
    const lowered = str.toLowerCase();
    const uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered)
      return "Mixed-case string " + str;
    str = lowered;
    const split = str.lastIndexOf("1");
    if (split === -1)
      return "No separator character for " + str;
    if (split === 0)
      return "Missing prefix for " + str;
    const prefix = str.slice(0, split);
    const wordChars = str.slice(split + 1);
    if (wordChars.length < 6)
      return "Data too short";
    let chk = prefixChk(prefix);
    if (typeof chk === "string")
      return chk;
    const words2 = [];
    for (let i = 0; i < wordChars.length; ++i) {
      const c = wordChars.charAt(i);
      const v = ALPHABET_MAP[c];
      if (v === void 0)
        return "Unknown character " + c;
      chk = polymodStep(chk) ^ v;
      if (i + 6 >= wordChars.length)
        continue;
      words2.push(v);
    }
    if (chk !== ENCODING_CONST)
      return "Invalid checksum for " + str;
    return { prefix, words: words2 };
  }
  function decodeUnsafe2(str, LIMIT) {
    const res = __decode2(str, LIMIT);
    if (typeof res === "object")
      return res;
  }
  function decode5(str, LIMIT) {
    const res = __decode2(str, LIMIT);
    if (typeof res === "object")
      return res;
    throw new Error(res);
  }
  return {
    decodeUnsafe: decodeUnsafe2,
    decode: decode5,
    encode: encode8,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
var x25519 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var random_1 = random;
  var wipe_12 = wipe$1;
  exports2.PUBLIC_KEY_LENGTH = 32;
  exports2.SECRET_KEY_LENGTH = 32;
  exports2.SHARED_KEY_LENGTH = 32;
  function gf(init6) {
    var r2 = new Float64Array(16);
    if (init6) {
      for (var i = 0; i < init6.length; i++) {
        r2[i] = init6[i];
      }
    }
    return r2;
  }
  var _9 = new Uint8Array(32);
  _9[0] = 9;
  var _121665 = gf([56129, 1]);
  function car25519(o) {
    var c = 1;
    for (var i = 0; i < 16; i++) {
      var v = o[i] + c + 65535;
      c = Math.floor(v / 65536);
      o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
  }
  function sel25519(p, q, b) {
    var c = ~(b - 1);
    for (var i = 0; i < 16; i++) {
      var t = c & (p[i] ^ q[i]);
      p[i] ^= t;
      q[i] ^= t;
    }
  }
  function pack25519(o, n) {
    var m = gf();
    var t = gf();
    for (var i = 0; i < 16; i++) {
      t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (var j = 0; j < 2; j++) {
      m[0] = t[0] - 65517;
      for (var i = 1; i < 15; i++) {
        m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
        m[i - 1] &= 65535;
      }
      m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
      var b = m[15] >> 16 & 1;
      m[14] &= 65535;
      sel25519(t, m, 1 - b);
    }
    for (var i = 0; i < 16; i++) {
      o[2 * i] = t[i] & 255;
      o[2 * i + 1] = t[i] >> 8;
    }
  }
  function unpack25519(o, n) {
    for (var i = 0; i < 16; i++) {
      o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 32767;
  }
  function add7(o, a, b) {
    for (var i = 0; i < 16; i++) {
      o[i] = a[i] + b[i];
    }
  }
  function sub(o, a, b) {
    for (var i = 0; i < 16; i++) {
      o[i] = a[i] - b[i];
    }
  }
  function mul7(o, a, b) {
    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
  function square(o, a) {
    mul7(o, a, a);
  }
  function inv25519(o, inp) {
    var c = gf();
    for (var i = 0; i < 16; i++) {
      c[i] = inp[i];
    }
    for (var i = 253; i >= 0; i--) {
      square(c, c);
      if (i !== 2 && i !== 4) {
        mul7(c, c, inp);
      }
    }
    for (var i = 0; i < 16; i++) {
      o[i] = c[i];
    }
  }
  function scalarMult(n, p) {
    var z = new Uint8Array(32);
    var x = new Float64Array(80);
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f2 = gf();
    for (var i = 0; i < 31; i++) {
      z[i] = n[i];
    }
    z[31] = n[31] & 127 | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (var i = 0; i < 16; i++) {
      b[i] = x[i];
    }
    a[0] = d[0] = 1;
    for (var i = 254; i >= 0; --i) {
      var r2 = z[i >>> 3] >>> (i & 7) & 1;
      sel25519(a, b, r2);
      sel25519(c, d, r2);
      add7(e, a, c);
      sub(a, a, c);
      add7(c, b, d);
      sub(b, b, d);
      square(d, e);
      square(f2, a);
      mul7(a, c, a);
      mul7(c, b, e);
      add7(e, a, c);
      sub(a, a, c);
      square(b, a);
      sub(c, d, f2);
      mul7(a, c, _121665);
      add7(a, a, d);
      mul7(c, c, a);
      mul7(a, d, f2);
      mul7(d, b, x);
      square(b, e);
      sel25519(a, b, r2);
      sel25519(c, d, r2);
    }
    for (var i = 0; i < 16; i++) {
      x[i + 16] = a[i];
      x[i + 32] = c[i];
      x[i + 48] = b[i];
      x[i + 64] = d[i];
    }
    var x32 = x.subarray(32);
    var x16 = x.subarray(16);
    inv25519(x32, x32);
    mul7(x16, x16, x32);
    var q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
  }
  exports2.scalarMult = scalarMult;
  function scalarMultBase(n) {
    return scalarMult(n, _9);
  }
  exports2.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports2.SECRET_KEY_LENGTH) {
      throw new Error("x25519: seed must be " + exports2.SECRET_KEY_LENGTH + " bytes");
    }
    var secretKey = new Uint8Array(seed);
    var publicKey = scalarMultBase(secretKey);
    return {
      publicKey,
      secretKey
    };
  }
  exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    var seed = random_1.randomBytes(32, prng);
    var result = generateKeyPairFromSeed(seed);
    wipe_12.wipe(seed);
    return result;
  }
  exports2.generateKeyPair = generateKeyPair;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero) {
    if (rejectZero === void 0) {
      rejectZero = false;
    }
    if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect public key length");
    }
    var result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      var zeros2 = 0;
      for (var i = 0; i < result.length; i++) {
        zeros2 |= result[i];
      }
      if (zeros2 === 0) {
        throw new Error("X25519: invalid shared key");
      }
    }
    return result;
  }
  exports2.sharedKey = sharedKey;
})(x25519);
var xchacha20poly1305 = {};
var xchacha20 = {};
var chacha = {};
Object.defineProperty(chacha, "__esModule", { value: true });
var binary_1$1 = binary;
var wipe_1$1 = wipe$1;
var ROUNDS$1 = 20;
function core(out, input, key3) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key3[3] << 24 | key3[2] << 16 | key3[1] << 8 | key3[0];
  var j5 = key3[7] << 24 | key3[6] << 16 | key3[5] << 8 | key3[4];
  var j6 = key3[11] << 24 | key3[10] << 16 | key3[9] << 8 | key3[8];
  var j7 = key3[15] << 24 | key3[14] << 16 | key3[13] << 8 | key3[12];
  var j8 = key3[19] << 24 | key3[18] << 16 | key3[17] << 8 | key3[16];
  var j9 = key3[23] << 24 | key3[22] << 16 | key3[21] << 8 | key3[20];
  var j10 = key3[27] << 24 | key3[26] << 16 | key3[25] << 8 | key3[24];
  var j11 = key3[31] << 24 | key3[30] << 16 | key3[29] << 8 | key3[28];
  var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
  var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
  var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
  var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i = 0; i < ROUNDS$1; i += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1$1.writeUint32LE(x0 + j0 | 0, out, 0);
  binary_1$1.writeUint32LE(x1 + j1 | 0, out, 4);
  binary_1$1.writeUint32LE(x2 + j2 | 0, out, 8);
  binary_1$1.writeUint32LE(x3 + j3 | 0, out, 12);
  binary_1$1.writeUint32LE(x4 + j4 | 0, out, 16);
  binary_1$1.writeUint32LE(x5 + j5 | 0, out, 20);
  binary_1$1.writeUint32LE(x6 + j6 | 0, out, 24);
  binary_1$1.writeUint32LE(x7 + j7 | 0, out, 28);
  binary_1$1.writeUint32LE(x8 + j8 | 0, out, 32);
  binary_1$1.writeUint32LE(x9 + j9 | 0, out, 36);
  binary_1$1.writeUint32LE(x10 + j10 | 0, out, 40);
  binary_1$1.writeUint32LE(x11 + j11 | 0, out, 44);
  binary_1$1.writeUint32LE(x12 + j12 | 0, out, 48);
  binary_1$1.writeUint32LE(x13 + j13 | 0, out, 52);
  binary_1$1.writeUint32LE(x14 + j14 | 0, out, 56);
  binary_1$1.writeUint32LE(x15 + j15 | 0, out, 60);
}
function streamXOR$1(key3, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  if (key3.length !== 32) {
    throw new Error("ChaCha: key size must be 32 bytes");
  }
  if (dst.length < src2.length) {
    throw new Error("ChaCha: destination is shorter than source");
  }
  var nc;
  var counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12) {
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    }
    nc = new Uint8Array(16);
    counterLength = nc.length - nonce.length;
    nc.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16) {
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    }
    nc = nonce;
    counterLength = nonceInplaceCounterLength;
  }
  var block = new Uint8Array(64);
  for (var i = 0; i < src2.length; i += 64) {
    core(block, nc, key3);
    for (var j = i; j < i + 64 && j < src2.length; j++) {
      dst[j] = src2[j] ^ block[j - i];
    }
    incrementCounter(nc, 0, counterLength);
  }
  wipe_1$1.wipe(block);
  if (nonceInplaceCounterLength === 0) {
    wipe_1$1.wipe(nc);
  }
  return dst;
}
chacha.streamXOR = streamXOR$1;
function stream$1(key3, nonce, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  wipe_1$1.wipe(dst);
  return streamXOR$1(key3, nonce, dst, dst, nonceInplaceCounterLength);
}
chacha.stream = stream$1;
function incrementCounter(counter, pos, len) {
  var carry = 1;
  while (len--) {
    carry = carry + (counter[pos] & 255) | 0;
    counter[pos] = carry & 255;
    carry >>>= 8;
    pos++;
  }
  if (carry > 0) {
    throw new Error("ChaCha: counter overflow");
  }
}
Object.defineProperty(xchacha20, "__esModule", { value: true });
var binary_1 = binary;
var wipe_1 = wipe$1;
var chacha_1 = chacha;
var ROUNDS = 20;
function streamXOR(key3, nonce, src2, dst) {
  if (nonce.length !== 24) {
    throw new Error("XChaCha20 nonce must be 24 bytes");
  }
  var subkey = hchacha(key3, nonce.subarray(0, 16), new Uint8Array(32));
  var modifiedNonce = new Uint8Array(12);
  modifiedNonce.set(nonce.subarray(16), 4);
  var result = chacha_1.streamXOR(subkey, modifiedNonce, src2, dst);
  wipe_1.wipe(subkey);
  return result;
}
xchacha20.streamXOR = streamXOR;
function stream(key3, nonce, dst) {
  wipe_1.wipe(dst);
  return streamXOR(key3, nonce, dst, dst);
}
xchacha20.stream = stream;
function hchacha(key3, src2, dst) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key3[3] << 24 | key3[2] << 16 | key3[1] << 8 | key3[0];
  var j5 = key3[7] << 24 | key3[6] << 16 | key3[5] << 8 | key3[4];
  var j6 = key3[11] << 24 | key3[10] << 16 | key3[9] << 8 | key3[8];
  var j7 = key3[15] << 24 | key3[14] << 16 | key3[13] << 8 | key3[12];
  var j8 = key3[19] << 24 | key3[18] << 16 | key3[17] << 8 | key3[16];
  var j9 = key3[23] << 24 | key3[22] << 16 | key3[21] << 8 | key3[20];
  var j10 = key3[27] << 24 | key3[26] << 16 | key3[25] << 8 | key3[24];
  var j11 = key3[31] << 24 | key3[30] << 16 | key3[29] << 8 | key3[28];
  var j12 = src2[3] << 24 | src2[2] << 16 | src2[1] << 8 | src2[0];
  var j13 = src2[7] << 24 | src2[6] << 16 | src2[5] << 8 | src2[4];
  var j14 = src2[11] << 24 | src2[10] << 16 | src2[9] << 8 | src2[8];
  var j15 = src2[15] << 24 | src2[14] << 16 | src2[13] << 8 | src2[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i = 0; i < ROUNDS; i += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1.writeUint32LE(x0, dst, 0);
  binary_1.writeUint32LE(x1, dst, 4);
  binary_1.writeUint32LE(x2, dst, 8);
  binary_1.writeUint32LE(x3, dst, 12);
  binary_1.writeUint32LE(x12, dst, 16);
  binary_1.writeUint32LE(x13, dst, 20);
  binary_1.writeUint32LE(x14, dst, 24);
  binary_1.writeUint32LE(x15, dst, 28);
  return dst;
}
xchacha20.hchacha = hchacha;
var chacha20poly1305 = {};
var poly1305 = {};
var constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: true });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
constantTime.select = select;
function lessOrEqual(a, b) {
  return (a | 0) - (b | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(a, b) {
  if (a.length !== b.length) {
    return 0;
  }
  var result = 0;
  for (var i = 0; i < a.length; i++) {
    result |= a[i] ^ b[i];
  }
  return 1 & result - 1 >>> 8;
}
constantTime.compare = compare;
function equal(a, b) {
  if (a.length === 0 || b.length === 0) {
    return false;
  }
  return compare(a, b) !== 0;
}
constantTime.equal = equal;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var constant_time_1 = constantTime;
  var wipe_12 = wipe$1;
  exports2.DIGEST_LENGTH = 16;
  var Poly1305 = function() {
    function Poly13052(key3) {
      this.digestLength = exports2.DIGEST_LENGTH;
      this._buffer = new Uint8Array(16);
      this._r = new Uint16Array(10);
      this._h = new Uint16Array(10);
      this._pad = new Uint16Array(8);
      this._leftover = 0;
      this._fin = 0;
      this._finished = false;
      var t0 = key3[0] | key3[1] << 8;
      this._r[0] = t0 & 8191;
      var t1 = key3[2] | key3[3] << 8;
      this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      var t2 = key3[4] | key3[5] << 8;
      this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      var t3 = key3[6] | key3[7] << 8;
      this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      var t4 = key3[8] | key3[9] << 8;
      this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this._r[5] = t4 >>> 1 & 8190;
      var t5 = key3[10] | key3[11] << 8;
      this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      var t6 = key3[12] | key3[13] << 8;
      this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      var t7 = key3[14] | key3[15] << 8;
      this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this._r[9] = t7 >>> 5 & 127;
      this._pad[0] = key3[16] | key3[17] << 8;
      this._pad[1] = key3[18] | key3[19] << 8;
      this._pad[2] = key3[20] | key3[21] << 8;
      this._pad[3] = key3[22] | key3[23] << 8;
      this._pad[4] = key3[24] | key3[25] << 8;
      this._pad[5] = key3[26] | key3[27] << 8;
      this._pad[6] = key3[28] | key3[29] << 8;
      this._pad[7] = key3[30] | key3[31] << 8;
    }
    Poly13052.prototype._blocks = function(m, mpos, bytes) {
      var hibit = this._fin ? 0 : 1 << 11;
      var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
      var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
      while (bytes >= 16) {
        var t0 = m[mpos + 0] | m[mpos + 1] << 8;
        h0 += t0 & 8191;
        var t1 = m[mpos + 2] | m[mpos + 3] << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = m[mpos + 4] | m[mpos + 5] << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        var t3 = m[mpos + 6] | m[mpos + 7] << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = m[mpos + 8] | m[mpos + 9] << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        var t5 = m[mpos + 10] | m[mpos + 11] << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = m[mpos + 12] | m[mpos + 13] << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        var t7 = m[mpos + 14] | m[mpos + 15] << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        var c = 0;
        var d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        var d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        var d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        var d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        var d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        var d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        var d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        var d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        var d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        var d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this._h[0] = h0;
      this._h[1] = h1;
      this._h[2] = h2;
      this._h[3] = h3;
      this._h[4] = h4;
      this._h[5] = h5;
      this._h[6] = h6;
      this._h[7] = h7;
      this._h[8] = h8;
      this._h[9] = h9;
    };
    Poly13052.prototype.finish = function(mac, macpos) {
      if (macpos === void 0) {
        macpos = 0;
      }
      var g = new Uint16Array(10);
      var c;
      var mask;
      var f2;
      var i;
      if (this._leftover) {
        i = this._leftover;
        this._buffer[i++] = 1;
        for (; i < 16; i++) {
          this._buffer[i] = 0;
        }
        this._fin = 1;
        this._blocks(this._buffer, 0, 16);
      }
      c = this._h[1] >>> 13;
      this._h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this._h[i] += c;
        c = this._h[i] >>> 13;
        this._h[i] &= 8191;
      }
      this._h[0] += c * 5;
      c = this._h[0] >>> 13;
      this._h[0] &= 8191;
      this._h[1] += c;
      c = this._h[1] >>> 13;
      this._h[1] &= 8191;
      this._h[2] += c;
      g[0] = this._h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this._h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++) {
        g[i] &= mask;
      }
      mask = ~mask;
      for (i = 0; i < 10; i++) {
        this._h[i] = this._h[i] & mask | g[i];
      }
      this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
      this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
      this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
      this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
      this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
      this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
      this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
      this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
      f2 = this._h[0] + this._pad[0];
      this._h[0] = f2 & 65535;
      for (i = 1; i < 8; i++) {
        f2 = (this._h[i] + this._pad[i] | 0) + (f2 >>> 16) | 0;
        this._h[i] = f2 & 65535;
      }
      mac[macpos + 0] = this._h[0] >>> 0;
      mac[macpos + 1] = this._h[0] >>> 8;
      mac[macpos + 2] = this._h[1] >>> 0;
      mac[macpos + 3] = this._h[1] >>> 8;
      mac[macpos + 4] = this._h[2] >>> 0;
      mac[macpos + 5] = this._h[2] >>> 8;
      mac[macpos + 6] = this._h[3] >>> 0;
      mac[macpos + 7] = this._h[3] >>> 8;
      mac[macpos + 8] = this._h[4] >>> 0;
      mac[macpos + 9] = this._h[4] >>> 8;
      mac[macpos + 10] = this._h[5] >>> 0;
      mac[macpos + 11] = this._h[5] >>> 8;
      mac[macpos + 12] = this._h[6] >>> 0;
      mac[macpos + 13] = this._h[6] >>> 8;
      mac[macpos + 14] = this._h[7] >>> 0;
      mac[macpos + 15] = this._h[7] >>> 8;
      this._finished = true;
      return this;
    };
    Poly13052.prototype.update = function(m) {
      var mpos = 0;
      var bytes = m.length;
      var want;
      if (this._leftover) {
        want = 16 - this._leftover;
        if (want > bytes) {
          want = bytes;
        }
        for (var i = 0; i < want; i++) {
          this._buffer[this._leftover + i] = m[mpos + i];
        }
        bytes -= want;
        mpos += want;
        this._leftover += want;
        if (this._leftover < 16) {
          return this;
        }
        this._blocks(this._buffer, 0, 16);
        this._leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this._blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (var i = 0; i < bytes; i++) {
          this._buffer[this._leftover + i] = m[mpos + i];
        }
        this._leftover += bytes;
      }
      return this;
    };
    Poly13052.prototype.digest = function() {
      if (this._finished) {
        throw new Error("Poly1305 was finished");
      }
      var mac = new Uint8Array(16);
      this.finish(mac);
      return mac;
    };
    Poly13052.prototype.clean = function() {
      wipe_12.wipe(this._buffer);
      wipe_12.wipe(this._r);
      wipe_12.wipe(this._h);
      wipe_12.wipe(this._pad);
      this._leftover = 0;
      this._fin = 0;
      this._finished = true;
      return this;
    };
    return Poly13052;
  }();
  exports2.Poly1305 = Poly1305;
  function oneTimeAuth(key3, data2) {
    var h = new Poly1305(key3);
    h.update(data2);
    var digest10 = h.digest();
    h.clean();
    return digest10;
  }
  exports2.oneTimeAuth = oneTimeAuth;
  function equal2(a, b) {
    if (a.length !== exports2.DIGEST_LENGTH || b.length !== exports2.DIGEST_LENGTH) {
      return false;
    }
    return constant_time_1.equal(a, b);
  }
  exports2.equal = equal2;
})(poly1305);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var chacha_12 = chacha;
  var poly1305_1 = poly1305;
  var wipe_12 = wipe$1;
  var binary_12 = binary;
  var constant_time_1 = constantTime;
  exports2.KEY_LENGTH = 32;
  exports2.NONCE_LENGTH = 12;
  exports2.TAG_LENGTH = 16;
  var ZEROS2 = new Uint8Array(16);
  var ChaCha20Poly1305 = function() {
    function ChaCha20Poly13052(key3) {
      this.nonceLength = exports2.NONCE_LENGTH;
      this.tagLength = exports2.TAG_LENGTH;
      if (key3.length !== exports2.KEY_LENGTH) {
        throw new Error("ChaCha20Poly1305 needs 32-byte key");
      }
      this._key = new Uint8Array(key3);
    }
    ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
      if (nonce.length > 16) {
        throw new Error("ChaCha20Poly1305: incorrect nonce length");
      }
      var counter = new Uint8Array(16);
      counter.set(nonce, counter.length - nonce.length);
      var authKey = new Uint8Array(32);
      chacha_12.stream(this._key, counter, authKey, 4);
      var resultLength = plaintext.length + this.tagLength;
      var result;
      if (dst) {
        if (dst.length !== resultLength) {
          throw new Error("ChaCha20Poly1305: incorrect destination length");
        }
        result = dst;
      } else {
        result = new Uint8Array(resultLength);
      }
      chacha_12.streamXOR(this._key, counter, plaintext, result, 4);
      this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
      wipe_12.wipe(counter);
      return result;
    };
    ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
      if (nonce.length > 16) {
        throw new Error("ChaCha20Poly1305: incorrect nonce length");
      }
      if (sealed.length < this.tagLength) {
        return null;
      }
      var counter = new Uint8Array(16);
      counter.set(nonce, counter.length - nonce.length);
      var authKey = new Uint8Array(32);
      chacha_12.stream(this._key, counter, authKey, 4);
      var calculatedTag = new Uint8Array(this.tagLength);
      this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
      if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
        return null;
      }
      var resultLength = sealed.length - this.tagLength;
      var result;
      if (dst) {
        if (dst.length !== resultLength) {
          throw new Error("ChaCha20Poly1305: incorrect destination length");
        }
        result = dst;
      } else {
        result = new Uint8Array(resultLength);
      }
      chacha_12.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
      wipe_12.wipe(counter);
      return result;
    };
    ChaCha20Poly13052.prototype.clean = function() {
      wipe_12.wipe(this._key);
      return this;
    };
    ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
      var h = new poly1305_1.Poly1305(authKey);
      if (associatedData) {
        h.update(associatedData);
        if (associatedData.length % 16 > 0) {
          h.update(ZEROS2.subarray(associatedData.length % 16));
        }
      }
      h.update(ciphertext);
      if (ciphertext.length % 16 > 0) {
        h.update(ZEROS2.subarray(ciphertext.length % 16));
      }
      var length2 = new Uint8Array(8);
      if (associatedData) {
        binary_12.writeUint64LE(associatedData.length, length2);
      }
      h.update(length2);
      binary_12.writeUint64LE(ciphertext.length, length2);
      h.update(length2);
      var tag = h.digest();
      for (var i = 0; i < tag.length; i++) {
        tagOut[i] = tag[i];
      }
      h.clean();
      wipe_12.wipe(tag);
      wipe_12.wipe(length2);
    };
    return ChaCha20Poly13052;
  }();
  exports2.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var xchacha20_1 = xchacha20;
  var chacha20poly1305_1 = chacha20poly1305;
  var wipe_12 = wipe$1;
  exports2.KEY_LENGTH = 32;
  exports2.NONCE_LENGTH = 24;
  exports2.TAG_LENGTH = 16;
  var XChaCha20Poly1305 = function() {
    function XChaCha20Poly13052(key3) {
      this.nonceLength = exports2.NONCE_LENGTH;
      this.tagLength = exports2.TAG_LENGTH;
      if (key3.length !== exports2.KEY_LENGTH) {
        throw new Error("ChaCha20Poly1305 needs 32-byte key");
      }
      this._key = new Uint8Array(key3);
    }
    XChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
      if (nonce.length !== 24) {
        throw new Error("XChaCha20Poly1305: incorrect nonce length");
      }
      var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
      var modifiedNonce = new Uint8Array(12);
      modifiedNonce.set(nonce.subarray(16), 4);
      var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
      var result = chaChaPoly.seal(modifiedNonce, plaintext, associatedData, dst);
      wipe_12.wipe(subKey);
      wipe_12.wipe(modifiedNonce);
      chaChaPoly.clean();
      return result;
    };
    XChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
      if (nonce.length !== 24) {
        throw new Error("XChaCha20Poly1305: incorrect nonce length");
      }
      if (sealed.length < this.tagLength) {
        return null;
      }
      var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
      var modifiedNonce = new Uint8Array(12);
      modifiedNonce.set(nonce.subarray(16), 4);
      var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
      var result = chaChaPoly.open(modifiedNonce, sealed, associatedData, dst);
      wipe_12.wipe(subKey);
      wipe_12.wipe(modifiedNonce);
      chaChaPoly.clean();
      return result;
    };
    XChaCha20Poly13052.prototype.clean = function() {
      wipe_12.wipe(this._key);
      return this;
    };
    return XChaCha20Poly13052;
  }();
  exports2.XChaCha20Poly1305 = XChaCha20Poly1305;
})(xchacha20poly1305);
new ellipticExports.ec("secp256k1");
ellipticExports.ec;
new ellipticExports.ec("secp256k1");
typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
let wasmWallet;
const ed25519 = {
  setWasmWallet: (w, publicKeyGetter) => {
    wasmWallet = w;
  },
  generateKeypair: () => {
    if (!assertReady())
      return new Error(
        "Wallet not connected or initialized. Run connect() and await initialize() first."
      );
    let keypair = wasmWallet.generate_ed25519_keypair();
    let publicKey = keypair.public();
    let secretKey = keypair.secret();
    return { publicKey, secretKey };
  },
  sign: async (data2, dataLayout = {}) => {
    await assertWallet();
    let pre_name = DEFAULT_NAME;
    if (!pre || !pre_name || !pre.get(pre_name))
      return new Error("No signer available.");
    const methodName = "ed25519.sign";
    let confirmed = await getConfig().confirm(methodName, {
      data: data2,
      dataLayout
    });
    if (!confirmed)
      return false;
    const signature2 = pre.get(pre_name).sign(new Uint8Array(data2));
    return signature2;
  },
  verify: (public_key, message, signature2, opts = { pre_name: DEFAULT_NAME, dataLayout: {} }) => {
    const verified = wallet.verify(
      new Uint8Array(public_key),
      new Uint8Array(message),
      new Uint8Array(signature2)
    );
    return verified;
  },
  didProvider: async () => {
  }
};
const STAY_CONNECTED = "STAY_CONNECTED";
new TextDecoder();
let connected = false;
let config = {};
const setConfig = (key3, value) => {
  config[key3] = value;
};
const getConfig = () => {
  return config;
};
const handlers = {
  setConfig,
  getConfig,
  config,
  ed25519,
  arweaveWalletAPI,
  proxcryptor,
  connect: async (origin) => {
    const config2 = getConfig();
    if (!typeof config2.confirm === "function")
      return new Error(
        "User must provide a confirm function to the handler using setConfig(confirmFn) "
      );
    try {
      const confirmed = sessionStorage.getItem(STAY_CONNECTED) == "true" || config2.confirm("connect", { origin });
      if (!confirmed)
        return new Error(`User disallowed connection from origin ${origin}`);
      connected = true;
    } catch (error3) {
    }
  },
  stayConnected: () => {
    window.sessionStorage.setItem(STAY_CONNECTED, "true");
  },
  getPublicKey: (pre_name = DEFAULT_NAME) => {
    return proxcryptor.getPublicKey(pre_name);
  }
};
var MessageType;
(function(MessageType2) {
  MessageType2["Call"] = "call";
  MessageType2["Reply"] = "reply";
  MessageType2["Syn"] = "syn";
  MessageType2["SynAck"] = "synAck";
  MessageType2["Ack"] = "ack";
})(MessageType || (MessageType = {}));
var Resolution;
(function(Resolution2) {
  Resolution2["Fulfilled"] = "fulfilled";
  Resolution2["Rejected"] = "rejected";
})(Resolution || (Resolution = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["ConnectionDestroyed"] = "ConnectionDestroyed";
  ErrorCode2["ConnectionTimeout"] = "ConnectionTimeout";
  ErrorCode2["NoIframeSrc"] = "NoIframeSrc";
})(ErrorCode || (ErrorCode = {}));
var NativeErrorName;
(function(NativeErrorName2) {
  NativeErrorName2["DataCloneError"] = "DataCloneError";
})(NativeErrorName || (NativeErrorName = {}));
var NativeEventType;
(function(NativeEventType2) {
  NativeEventType2["Message"] = "message";
})(NativeEventType || (NativeEventType = {}));
const AutoSizer_svelte_svelte_type_style_lang = "";
function create_fragment$8(ctx) {
  let button;
  let button_class_value;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", button_class_value = (ctx[1] == "Yes" ? green : ctx[1] == "No" ? red : ctx[1] == "Connecting" ? yellow : blue) + " font-bold rounded shadow-md py-4 my-4 mx-2 px-6 w-fit");
      button.disabled = button_disabled_value = ctx[1] == "Connecting";
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(function() {
          if (is_function(ctx[0]))
            ctx[0].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[2],
            !current ? get_all_dirty_from_scope(ctx[2]) : get_slot_changes(default_slot_template, ctx[2], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && button_class_value !== (button_class_value = (ctx[1] == "Yes" ? green : ctx[1] == "No" ? red : ctx[1] == "Connecting" ? yellow : blue) + " font-bold rounded shadow-md py-4 my-4 mx-2 px-6 w-fit")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 2 && button_disabled_value !== (button_disabled_value = ctx[1] == "Connecting")) {
        button.disabled = button_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
let green = "bg-green-500 hover:bg-green-700 text-white";
let blue = "bg-blue-500 hover:bg-blue-700 text-white";
let red = "bg-red-500 hover:bg-red-700 text-white";
let yellow = "bg-yellow-500 hover:bg-yellow-700 text-white";
function instance$8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { clickHandler } = $$props;
  let { type } = $$props;
  $$self.$$set = ($$props2) => {
    if ("clickHandler" in $$props2)
      $$invalidate(0, clickHandler = $$props2.clickHandler);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [clickHandler, type, $$scope, slots];
}
class Button extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$8, create_fragment$8, safe_not_equal, { clickHandler: 0, type: 1 });
  }
}
const LUT_HEX_4b = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
const LUT_HEX_8b = new Array(256);
for (let n = 0; n < 256; n++) {
  LUT_HEX_8b[n] = `${LUT_HEX_4b[n >>> 4 & 15]}${LUT_HEX_4b[n & 15]}`;
}
const Clipboard_svelte_svelte_type_style_lang = "";
const get_default_slot_changes = (dirty) => ({ encoded: dirty & 4 });
const get_default_slot_context = (ctx) => ({ encoded: ctx[2] });
function fallback_block$1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    l(nodes) {
      t = claim_text(nodes, ctx[2]);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$7(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1;
  let t2;
  let div2;
  let span0;
  let t3;
  let span0_class_value;
  let t4;
  let span1;
  let t5;
  let span1_class_value;
  let t6;
  let span2;
  let t7;
  let span2_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], get_default_slot_context);
  const default_slot_or_fallback = default_slot || fallback_block$1(ctx);
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text("Same key, different format");
      t2 = space();
      div2 = element("div");
      span0 = element("span");
      t3 = text("Base64");
      t4 = space();
      span1 = element("span");
      t5 = text("Base58");
      t6 = space();
      span2 = element("span");
      t7 = text("Hex");
      this.h();
    },
    l(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div0 = claim_element(div4_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, "Same key, different format");
      div1_nodes.forEach(detach);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      span0 = claim_element(div2_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t3 = claim_text(span0_nodes, "Base64");
      span0_nodes.forEach(detach);
      t4 = claim_space(div2_nodes);
      span1 = claim_element(div2_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t5 = claim_text(span1_nodes, "Base58");
      span1_nodes.forEach(detach);
      t6 = claim_space(div2_nodes);
      span2 = claim_element(div2_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t7 = claim_text(span2_nodes, "Hex");
      span2_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      div4_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "flex-grow justify-self-auto");
      attr(div1, "class", "flex-none text-center");
      attr(span0, "class", span0_class_value = ctx[1] == "Base64" ? white : grey);
      attr(span1, "class", span1_class_value = ctx[1] == "Base58" ? white : grey);
      attr(span2, "class", span2_class_value = ctx[1] == "Hex" ? white : grey);
      attr(div2, "class", "flex-none text-center cursor-pointer select-none");
      attr(div3, "class", "flex-none flex flex-col justify-self-end bg-neutral-500/30 p-1 sm:p-2 rounded-lg");
      attr(div4, "class", "flex flex-col sm:flex-row leading-8");
    },
    m(target, anchor) {
      insert_hydration(target, div4, anchor);
      append_hydration(div4, div0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div0, null);
      }
      append_hydration(div4, t0);
      append_hydration(div4, div3);
      append_hydration(div3, div1);
      append_hydration(div1, t1);
      append_hydration(div3, t2);
      append_hydration(div3, div2);
      append_hydration(div2, span0);
      append_hydration(span0, t3);
      append_hydration(div2, t4);
      append_hydration(div2, span1);
      append_hydration(span1, t5);
      append_hydration(div2, t6);
      append_hydration(div2, span2);
      append_hydration(span2, t7);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[8]),
          listen(span1, "click", ctx[9]),
          listen(span2, "click", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 68)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 2 && span0_class_value !== (span0_class_value = ctx2[1] == "Base64" ? white : grey)) {
        attr(span0, "class", span0_class_value);
      }
      if (!current || dirty & 2 && span1_class_value !== (span1_class_value = ctx2[1] == "Base58" ? white : grey)) {
        attr(span1, "class", span1_class_value);
      }
      if (!current || dirty & 2 && span2_class_value !== (span2_class_value = ctx2[1] == "Hex" ? white : grey)) {
        attr(span2, "class", span2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
let white = " bg-white rounded-lg text-black font-semibold py-1 px-2 m-1 ";
let grey = " bg-gray-600 rounded-lg text-grey-dark font-semibold py-1 px-2 m-1 ";
function instance$7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { pubkey } = $$props;
  function bytesToBase64(b) {
    return toString$1(b, "base64pad");
  }
  function bytesToBase58(b) {
    return toString$1(b, "base58btc");
  }
  function bytesToHex(b) {
    return toString$1(b, "base16");
  }
  let selected = "Base64";
  let encoded = bytesToBase64(pubkey);
  const click_handler = () => {
    $$invalidate(2, encoded = bytesToBase64(pubkey));
    $$invalidate(1, selected = "Base64");
  };
  const click_handler_1 = () => {
    $$invalidate(2, encoded = bytesToBase58(pubkey));
    $$invalidate(1, selected = "Base58");
  };
  const click_handler_2 = () => {
    $$invalidate(2, encoded = bytesToHex(pubkey));
    $$invalidate(1, selected = "Hex");
  };
  $$self.$$set = ($$props2) => {
    if ("pubkey" in $$props2)
      $$invalidate(0, pubkey = $$props2.pubkey);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    pubkey,
    selected,
    encoded,
    bytesToBase64,
    bytesToBase58,
    bytesToHex,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class EncodingSelector extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { pubkey: 0 });
  }
}
const ListKeys_svelte_svelte_type_style_lang = "";
const GetKeys_svelte_svelte_type_style_lang = "";
const DefaultConfirmation_svelte_svelte_type_style_lang = "";
function create_default_slot_1$6(ctx) {
  let t;
  return {
    c() {
      t = text("Yes");
    },
    l(nodes) {
      t = claim_text(nodes, "Yes");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$6(ctx) {
  let t;
  return {
    c() {
      t = text("No");
    },
    l(nodes) {
      t = claim_text(nodes, "No");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function fallback_block(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let t1_value = ctx[0].method + "";
  let t1;
  let t2;
  let t3;
  let div1;
  let button0;
  let t4;
  let button1;
  let current;
  button0 = new Button({
    props: {
      type: "Yes",
      clickHandler: ctx[1],
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  button1 = new Button({
    props: {
      type: "No",
      clickHandler: ctx[2],
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text("\u26A0\uFE0F Authorize ");
      t1 = text(t1_value);
      t2 = text(" from your wallet?");
      t3 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "\u26A0\uFE0F Authorize ");
      t1 = claim_text(div0_nodes, t1_value);
      t2 = claim_text(div0_nodes, " from your wallet?");
      div0_nodes.forEach(detach);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button0.$$.fragment, div1_nodes);
      t4 = claim_space(div1_nodes);
      claim_component(button1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "svelte-jw03ri");
      attr(div1, "class", "submit svelte-jw03ri");
      attr(div2, "class", "attention svelte-jw03ri");
      attr(div3, "class", "svelte-jw03ri");
    },
    m(target, anchor) {
      insert_hydration(target, div3, anchor);
      append_hydration(div3, div2);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div0, t1);
      append_hydration(div0, t2);
      append_hydration(div2, t3);
      append_hydration(div2, div1);
      mount_component(button0, div1, null);
      append_hydration(div1, t4);
      mount_component(button1, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].method + ""))
        set_data(t1, t1_value);
      const button0_changes = {};
      if (dirty & 2)
        button0_changes.clickHandler = ctx2[1];
      if (dirty & 16) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4)
        button1_changes.clickHandler = ctx2[2];
      if (dirty & 16) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function create_fragment$6(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 7)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { props = { method: "", params: {} } } = $$props;
  let { handleConfirmed } = $$props;
  let { handleDenied } = $$props;
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("handleConfirmed" in $$props2)
      $$invalidate(1, handleConfirmed = $$props2.handleConfirmed);
    if ("handleDenied" in $$props2)
      $$invalidate(2, handleDenied = $$props2.handleDenied);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [props, handleConfirmed, handleDenied, slots, $$scope];
}
class DefaultConfirmation extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$6, create_fragment$6, safe_not_equal, {
      props: 0,
      handleConfirmed: 1,
      handleDenied: 2
    });
  }
}
const Connect_svelte_svelte_type_style_lang = "";
function create_default_slot_1$5(ctx) {
  let t;
  return {
    c() {
      t = text("Yes");
    },
    l(nodes) {
      t = claim_text(nodes, "Yes");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$5(ctx) {
  let div2;
  let div0;
  let t0;
  let t1_value = ctx[4].params.origin + "";
  let t1;
  let t2;
  let b;
  let t3;
  let t4;
  let t5;
  let div1;
  let button;
  let current;
  button = new Button({
    props: {
      type: "Yes",
      clickHandler: ctx[1].handleConfirm,
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text("\u26A0\uFE0F Allow ");
      t1 = text(t1_value);
      t2 = text(" to see your ");
      b = element("b");
      t3 = text("Public");
      t4 = text(" Key?");
      t5 = space();
      div1 = element("div");
      create_component(button.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "\u26A0\uFE0F Allow ");
      t1 = claim_text(div0_nodes, t1_value);
      t2 = claim_text(div0_nodes, " to see your ");
      b = claim_element(div0_nodes, "B", {});
      var b_nodes = children(b);
      t3 = claim_text(b_nodes, "Public");
      b_nodes.forEach(detach);
      t4 = claim_text(div0_nodes, " Key?");
      div0_nodes.forEach(detach);
      t5 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "svelte-as2cuw");
      attr(div1, "class", "submit svelte-as2cuw");
      attr(div2, "class", "attention svelte-as2cuw");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div0, t1);
      append_hydration(div0, t2);
      append_hydration(div0, b);
      append_hydration(b, t3);
      append_hydration(div0, t4);
      append_hydration(div2, t5);
      append_hydration(div2, div1);
      mount_component(button, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 16) && t1_value !== (t1_value = ctx2[4].params.origin + ""))
        set_data(t1, t1_value);
      const button_changes = {};
      if (dirty & 2)
        button_changes.clickHandler = ctx2[1].handleConfirm;
      if (dirty & 32) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(button);
    }
  };
}
function create_fragment$5(ctx) {
  let defaultconfirmation;
  let current;
  let defaultconfirmation_props = {
    props: ctx[0],
    $$slots: {
      default: [
        create_default_slot$5,
        ({ props: p }) => ({ 4: p }),
        ({ props: p }) => p ? 16 : 0
      ]
    },
    $$scope: { ctx }
  };
  defaultconfirmation = new DefaultConfirmation({ props: defaultconfirmation_props });
  ctx[2](defaultconfirmation);
  defaultconfirmation.$on("confirmed", ctx[3]);
  return {
    c() {
      create_component(defaultconfirmation.$$.fragment);
    },
    l(nodes) {
      claim_component(defaultconfirmation.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(defaultconfirmation, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const defaultconfirmation_changes = {};
      if (dirty & 1)
        defaultconfirmation_changes.props = ctx2[0];
      if (dirty & 50) {
        defaultconfirmation_changes.$$scope = { dirty, ctx: ctx2 };
      }
      defaultconfirmation.$set(defaultconfirmation_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(defaultconfirmation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(defaultconfirmation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[2](null);
      destroy_component(defaultconfirmation, detaching);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let defConf;
  function defaultconfirmation_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      defConf = $$value;
      $$invalidate(1, defConf);
    });
  }
  function confirmed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
  };
  return [props, defConf, defaultconfirmation_binding, confirmed_handler];
}
class Connect extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { props: 0 });
  }
}
async function deepHash(data2) {
  if (Array.isArray(data2)) {
    const tag2 = concatBuffers([
      stringToBuffer("list"),
      stringToBuffer(data2.length.toString())
    ]);
    return await deepHashChunks(data2, await crypto.subtle.digest("SHA-384", tag2));
  }
  const tag = concatBuffers([
    stringToBuffer("blob"),
    stringToBuffer(data2.byteLength.toString())
  ]);
  const taggedHash = concatBuffers([
    await crypto.subtle.digest("SHA-384", tag),
    await crypto.subtle.digest("SHA-384", data2)
  ]);
  return await crypto.subtle.digest("SHA-384", taggedHash);
}
async function deepHashChunks(chunks2, acc) {
  if (chunks2.length < 1) {
    return acc;
  }
  const hashPair = concatBuffers([acc, await deepHash(chunks2[0])]);
  const newAcc = await crypto.subtle.digest("SHA-384", hashPair);
  return await deepHashChunks(chunks2.slice(1), newAcc);
}
function concatBuffers(buffers) {
  let total_length = 0;
  for (let i = 0; i < buffers.length; i++) {
    total_length += buffers[i].byteLength;
  }
  let temp = new Uint8Array(total_length);
  let offset = 0;
  temp.set(new Uint8Array(buffers[0]), offset);
  offset += buffers[0].byteLength;
  for (let i = 1; i < buffers.length; i++) {
    temp.set(new Uint8Array(buffers[i]), offset);
    offset += buffers[i].byteLength;
  }
  return temp;
}
function b64UrlToString(b64UrlString) {
  let buffer2 = b64UrlToBuffer(b64UrlString);
  if (typeof TextDecoder == "undefined") {
    const TextDecoder2 = require("util").TextDecoder;
    return new TextDecoder2("utf-8", { fatal: true }).decode(buffer2);
  }
  return new TextDecoder("utf-8", { fatal: true }).decode(buffer2);
}
function bufferToString(buffer2) {
  if (typeof TextDecoder == "undefined") {
    const TextDecoder2 = require("util").TextDecoder;
    return new TextDecoder2("utf-8", { fatal: true }).decode(buffer2);
  }
  return new TextDecoder("utf-8", { fatal: true }).decode(buffer2);
}
function stringToBuffer(string2) {
  if (typeof TextEncoder == "undefined") {
    const TextEncoder2 = require("util").TextEncoder;
    return new TextEncoder2().encode(string2);
  }
  return new TextEncoder().encode(string2);
}
function stringToB64Url(string2) {
  return bufferTob64Url(stringToBuffer(string2));
}
function b64UrlToBuffer(b64UrlString) {
  return new Uint8Array(decode_1(b64UrlDecode(b64UrlString)));
}
function bufferTob64(buffer2) {
  return encode_1$1(new Uint8Array(buffer2));
}
function bufferTob64Url(buffer2) {
  return b64UrlEncode(bufferTob64(buffer2));
}
function b64UrlEncode(b64UrlString) {
  return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(b64UrlString) {
  b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
  let padding2;
  b64UrlString.length % 4 == 0 ? padding2 = 0 : padding2 = 4 - b64UrlString.length % 4;
  return b64UrlString.concat("=".repeat(padding2));
}
class BaseObject {
  get(field, options) {
    if (!Object.getOwnPropertyNames(this).includes(field)) {
      throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
    }
    if (this[field] instanceof Uint8Array) {
      if (options && options.decode && options.string) {
        return bufferToString(this[field]);
      }
      if (options && options.decode && !options.string) {
        return this[field];
      }
      return bufferTob64Url(this[field]);
    }
    if (options && options.decode == true) {
      if (options && options.string) {
        return b64UrlToString(this[field]);
      }
      return b64UrlToBuffer(this[field]);
    }
    return this[field];
  }
}
class Tag extends BaseObject {
  constructor(name2, value, decode5 = false) {
    super();
    this.name = name2;
    this.value = value;
  }
}
class Transaction extends BaseObject {
  constructor(attributes = {}) {
    super();
    this.format = 2;
    this.id = "";
    this.last_tx = "";
    this.owner = "";
    this.tags = [];
    this.target = "";
    this.quantity = "0";
    this.data_size = "0";
    this.data = new Uint8Array();
    this.data_root = "";
    this.reward = "0";
    this.signature = "";
    Object.assign(this, attributes);
    if (typeof this.data === "string") {
      this.data = b64UrlToBuffer(this.data);
    }
    if (attributes.tags) {
      this.tags = attributes.tags.map((tag) => {
        return new Tag(tag.name, tag.value);
      });
    }
  }
  addTag(name2, value) {
    this.tags.push(new Tag(stringToB64Url(name2), stringToB64Url(value)));
  }
  toJSON() {
    return {
      format: this.format,
      id: this.id,
      last_tx: this.last_tx,
      owner: this.owner,
      tags: this.tags,
      target: this.target,
      quantity: this.quantity,
      data: bufferTob64Url(this.data),
      data_size: this.data_size,
      data_root: this.data_root,
      data_tree: this.data_tree,
      reward: this.reward,
      signature: this.signature
    };
  }
  setOwner(owner) {
    this.owner = owner;
  }
  setSignature({
    id: id2,
    owner,
    reward,
    tags: tags2,
    signature: signature2
  }) {
    this.id = id2;
    this.owner = owner;
    if (reward)
      this.reward = reward;
    if (tags2)
      this.tags = tags2;
    this.signature = signature2;
  }
  async prepareChunks(data2) {
    if (!this.chunks && data2.byteLength > 0) {
      this.chunks = await generateTransactionChunks(data2);
      this.data_root = bufferTob64Url(this.chunks.data_root);
    }
    if (!this.chunks && data2.byteLength === 0) {
      this.chunks = {
        chunks: [],
        data_root: new Uint8Array(),
        proofs: []
      };
      this.data_root = "";
    }
  }
  getChunk(idx, data2) {
    if (!this.chunks) {
      throw new Error(`Chunks have not been prepared`);
    }
    const proof = this.chunks.proofs[idx];
    const chunk = this.chunks.chunks[idx];
    return {
      data_root: this.data_root,
      data_size: this.data_size,
      data_path: bufferTob64Url(proof.proof),
      offset: proof.offset.toString(),
      chunk: bufferTob64Url(data2.slice(chunk.minByteRange, chunk.maxByteRange))
    };
  }
  async getSignatureData() {
    switch (this.format) {
      case 1:
        let tags2 = this.tags.reduce((accumulator, tag) => {
          return concatBuffers([
            accumulator,
            tag.get("name", { decode: true, string: false }),
            tag.get("value", { decode: true, string: false })
          ]);
        }, new Uint8Array());
        return concatBuffers([
          this.get("owner", { decode: true, string: false }),
          this.get("target", { decode: true, string: false }),
          this.get("data", { decode: true, string: false }),
          stringToBuffer(this.quantity),
          stringToBuffer(this.reward),
          this.get("last_tx", { decode: true, string: false }),
          tags2
        ]);
      case 2:
        if (!this.data_root) {
          await this.prepareChunks(this.data);
        }
        const tagList = this.tags.map((tag) => [
          tag.get("name", { decode: true, string: false }),
          tag.get("value", { decode: true, string: false })
        ]);
        return await deepHash([
          stringToBuffer(this.format.toString()),
          this.get("owner", { decode: true, string: false }),
          this.get("target", { decode: true, string: false }),
          stringToBuffer(this.quantity),
          stringToBuffer(this.reward),
          this.get("last_tx", { decode: true, string: false }),
          tagList,
          stringToBuffer(this.data_size),
          this.get("data_root", { decode: true, string: false })
        ]);
      default:
        throw new Error(`Unexpected transaction format: ${this.format}`);
    }
  }
}
function winstonToAr(winstonString, { formatted = false, decimals = 12, trim: trim2 = true } = {}) {
  let number = stringToBigNum(winstonString, decimals).shiftedBy(-12);
  return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
}
function stringToBigNum(stringValue, decimalPlaces = 12) {
  return BigNum(stringValue, decimalPlaces);
}
const BigNum = (value, decimals) => {
  let instance2;
  try {
    instance2 = BigNumber$1.clone({ DECIMAL_PLACES: decimals });
  } catch (error3) {
    console.warn("Caught big num issues, try default", error3);
    instance2 = BigNumber$1.default.clone({ DECIMAL_PLACES: decimals });
  }
  return new instance2(value);
};
const ArweaveSign_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i].name;
  child_ctx[8] = list[i].val;
  return child_ctx;
}
function create_if_block(ctx) {
  let div3;
  let div0;
  let t0;
  let t1_value = ctx[0].method + "";
  let t1;
  let t2;
  let t3;
  let div1;
  let t4;
  let br0;
  let t5;
  let t6;
  let t7_value = ctx[3].quantity + "";
  let t7;
  let br1;
  let t8;
  let t9_value = ctx[3].reward + "";
  let t9;
  let t10;
  let t11_value = (winstonToAr(ctx[3].reward) * 100).toFixed(5) + "";
  let t11;
  let t12;
  let br2;
  let t13;
  let div2;
  let button0;
  let t14;
  let button1;
  let current;
  let each_value = ctx[4];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  button0 = new Button({
    props: {
      type: "Yes",
      clickHandler: ctx[1],
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  button1 = new Button({
    props: {
      type: "No",
      clickHandler: ctx[2],
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = text("\u26A0\uFE0F Attention! You are about to sign (");
      t1 = text(t1_value);
      t2 = text(") this Arweave transaction. Authorize to\r\n			proceed?");
      t3 = space();
      div1 = element("div");
      t4 = text("Tags:");
      br0 = element("br");
      t5 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = text("\r\n			Token transfer: ");
      t7 = text(t7_value);
      br1 = element("br");
      t8 = text("\r\n			One time storage Fee: ");
      t9 = text(t9_value);
      t10 = text(" (~$");
      t11 = text(t11_value);
      t12 = text(")");
      br2 = element("br");
      t13 = space();
      div2 = element("div");
      create_component(button0.$$.fragment);
      t14 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "\u26A0\uFE0F Attention! You are about to sign (");
      t1 = claim_text(div0_nodes, t1_value);
      t2 = claim_text(div0_nodes, ") this Arweave transaction. Authorize to\r\n			proceed?");
      div0_nodes.forEach(detach);
      t3 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t4 = claim_text(div1_nodes, "Tags:");
      br0 = claim_element(div1_nodes, "BR", {});
      t5 = claim_space(div1_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      t6 = claim_text(div1_nodes, "\r\n			Token transfer: ");
      t7 = claim_text(div1_nodes, t7_value);
      br1 = claim_element(div1_nodes, "BR", {});
      t8 = claim_text(div1_nodes, "\r\n			One time storage Fee: ");
      t9 = claim_text(div1_nodes, t9_value);
      t10 = claim_text(div1_nodes, " (~$");
      t11 = claim_text(div1_nodes, t11_value);
      t12 = claim_text(div1_nodes, ")");
      br2 = claim_element(div1_nodes, "BR", {});
      div1_nodes.forEach(detach);
      t13 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(button0.$$.fragment, div2_nodes);
      t14 = claim_space(div2_nodes);
      claim_component(button1.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "svelte-mhnubd");
      attr(div1, "class", "svelte-mhnubd");
      attr(div2, "class", "submit svelte-mhnubd");
      attr(div3, "class", "attention svelte-mhnubd");
    },
    m(target, anchor) {
      insert_hydration(target, div3, anchor);
      append_hydration(div3, div0);
      append_hydration(div0, t0);
      append_hydration(div0, t1);
      append_hydration(div0, t2);
      append_hydration(div3, t3);
      append_hydration(div3, div1);
      append_hydration(div1, t4);
      append_hydration(div1, br0);
      append_hydration(div1, t5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append_hydration(div1, t6);
      append_hydration(div1, t7);
      append_hydration(div1, br1);
      append_hydration(div1, t8);
      append_hydration(div1, t9);
      append_hydration(div1, t10);
      append_hydration(div1, t11);
      append_hydration(div1, t12);
      append_hydration(div1, br2);
      append_hydration(div3, t13);
      append_hydration(div3, div2);
      mount_component(button0, div2, null);
      append_hydration(div2, t14);
      mount_component(button1, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].method + ""))
        set_data(t1, t1_value);
      if (dirty & 16) {
        each_value = ctx2[4];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, t6);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      const button0_changes = {};
      if (dirty & 2)
        button0_changes.clickHandler = ctx2[1];
      if (dirty & 2048) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4)
        button1_changes.clickHandler = ctx2[2];
      if (dirty & 2048) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function create_each_block(ctx) {
  let li;
  let t0_value = ctx[7] + "";
  let t0;
  let t1;
  let t2_value = ctx[8] + "";
  let t2;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = text(":\r\n					");
      t2 = text(t2_value);
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t0 = claim_text(li_nodes, t0_value);
      t1 = claim_text(li_nodes, ":\r\n					");
      t2 = claim_text(li_nodes, t2_value);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(li, "class", null_to_empty(ctx[7].includes("App-Name") ? "bold" : "") + " svelte-mhnubd");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, t0);
      append_hydration(li, t1);
      append_hydration(li, t2);
    },
    p: noop$2,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("Yes");
    },
    l(nodes) {
      t = claim_text(nodes, "Yes");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$4(ctx) {
  let t;
  return {
    c() {
      t = text("No");
    },
    l(nodes) {
      t = claim_text(nodes, "No");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[3] && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[3])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let { handleConfirmed } = $$props;
  let { handleDenied } = $$props;
  console.log("Signing ", { params: props.params });
  const transaction2 = props.params;
  let tx = new Transaction(transaction2);
  let tags2 = tx.tags.map((tag) => ({
    name: tag.get("name", { decode: true, string: true }),
    val: tag.get("value", { decode: true, string: true })
  }));
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("handleConfirmed" in $$props2)
      $$invalidate(1, handleConfirmed = $$props2.handleConfirmed);
    if ("handleDenied" in $$props2)
      $$invalidate(2, handleDenied = $$props2.handleDenied);
  };
  return [props, handleConfirmed, handleDenied, transaction2, tags2];
}
class ArweaveSign extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$4, create_fragment$4, safe_not_equal, {
      props: 0,
      handleConfirmed: 1,
      handleDenied: 2
    });
  }
}
function create_default_slot_1$3(ctx) {
  let t;
  return {
    c() {
      t = text("Yes");
    },
    l(nodes) {
      t = claim_text(nodes, "Yes");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$3(ctx) {
  let t;
  return {
    c() {
      t = text("No");
    },
    l(nodes) {
      t = claim_text(nodes, "No");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$3(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button({
    props: {
      type: "Yes",
      clickHandler: ctx[0],
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  button1 = new Button({
    props: {
      type: "No",
      clickHandler: ctx[1],
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text("\u26A0\uFE0F Sign this transaction?");
      t1 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "\u26A0\uFE0F Sign this transaction?");
      div0_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button0.$$.fragment, div1_nodes);
      t2 = claim_space(div1_nodes);
      claim_component(button1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "flex-1");
      attr(div1, "class", "flex-1 p-4");
      attr(div2, "class", "flex flex-col bg-yellow-100 drop-shadow-lg rounded-sm w-auto m-4 p-6");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      mount_component(button0, div1, null);
      append_hydration(div1, t2);
      mount_component(button1, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & 1)
        button0_changes.clickHandler = ctx2[0];
      if (dirty & 32) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 2)
        button1_changes.clickHandler = ctx2[1];
      if (dirty & 32) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let { handleConfirmed } = $$props;
  let { handleDenied } = $$props;
  new TextDecoder();
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("handleConfirmed" in $$props2)
      $$invalidate(0, handleConfirmed = $$props2.handleConfirmed);
    if ("handleDenied" in $$props2)
      $$invalidate(1, handleDenied = $$props2.handleDenied);
  };
  return [handleConfirmed, handleDenied, props];
}
class Sign extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {
      props: 2,
      handleConfirmed: 0,
      handleDenied: 1
    });
  }
}
const Decrypt_svelte_svelte_type_style_lang = "";
function create_default_slot_1$2(ctx) {
  let t;
  return {
    c() {
      t = text("Yes");
    },
    l(nodes) {
      t = claim_text(nodes, "Yes");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$2(ctx) {
  let t;
  return {
    c() {
      t = text("No");
    },
    l(nodes) {
      t = claim_text(nodes, "No");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$2(ctx) {
  let div2;
  let div0;
  let t0;
  let t1_value = ctx[3].decode(ctx[0].params.tag) + "";
  let t1;
  let t2;
  let t3;
  let div1;
  let button0;
  let t4;
  let button1;
  let current;
  button0 = new Button({
    props: {
      type: "Yes",
      clickHandler: ctx[1],
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  button1 = new Button({
    props: {
      type: "No",
      clickHandler: ctx[2],
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text("\u26A0\uFE0F Decrypt ");
      t1 = text(t1_value);
      t2 = text("?");
      t3 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "\u26A0\uFE0F Decrypt ");
      t1 = claim_text(div0_nodes, t1_value);
      t2 = claim_text(div0_nodes, "?");
      div0_nodes.forEach(detach);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button0.$$.fragment, div1_nodes);
      t4 = claim_space(div1_nodes);
      claim_component(button1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "svelte-d4tl1x");
      attr(div1, "class", "submit svelte-d4tl1x");
      attr(div2, "class", "attention svelte-d4tl1x");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div0, t1);
      append_hydration(div0, t2);
      append_hydration(div2, t3);
      append_hydration(div2, div1);
      mount_component(button0, div1, null);
      append_hydration(div1, t4);
      mount_component(button1, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[3].decode(ctx2[0].params.tag) + ""))
        set_data(t1, t1_value);
      const button0_changes = {};
      if (dirty & 2)
        button0_changes.clickHandler = ctx2[1];
      if (dirty & 32) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4)
        button1_changes.clickHandler = ctx2[2];
      if (dirty & 32) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let { handleConfirmed } = $$props;
  let { handleDenied } = $$props;
  const decoder = new TextDecoder();
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("handleConfirmed" in $$props2)
      $$invalidate(1, handleConfirmed = $$props2.handleConfirmed);
    if ("handleDenied" in $$props2)
      $$invalidate(2, handleDenied = $$props2.handleDenied);
  };
  return [props, handleConfirmed, handleDenied, decoder];
}
class Decrypt extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {
      props: 0,
      handleConfirmed: 1,
      handleDenied: 2
    });
  }
}
const ReDecrypt_svelte_svelte_type_style_lang = "";
function create_default_slot_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("Yes");
    },
    l(nodes) {
      t = claim_text(nodes, "Yes");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$1(ctx) {
  let t;
  return {
    c() {
      t = text("No");
    },
    l(nodes) {
      t = claim_text(nodes, "No");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button({
    props: {
      type: "Yes",
      clickHandler: ctx[0],
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  button1 = new Button({
    props: {
      type: "No",
      clickHandler: ctx[1],
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text("\u26A0\uFE0F Allow this app to Decrypt data?");
      t1 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "\u26A0\uFE0F Allow this app to Decrypt data?");
      div0_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button0.$$.fragment, div1_nodes);
      t2 = claim_space(div1_nodes);
      claim_component(button1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "svelte-d4tl1x");
      attr(div1, "class", "submit svelte-d4tl1x");
      attr(div2, "class", "attention svelte-d4tl1x");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      mount_component(button0, div1, null);
      append_hydration(div1, t2);
      mount_component(button1, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & 1)
        button0_changes.clickHandler = ctx2[0];
      if (dirty & 16) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 2)
        button1_changes.clickHandler = ctx2[1];
      if (dirty & 16) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let { handleConfirmed } = $$props;
  let { handleDenied } = $$props;
  new TextDecoder();
  $$self.$$set = ($$props2) => {
    if ("handleConfirmed" in $$props2)
      $$invalidate(0, handleConfirmed = $$props2.handleConfirmed);
    if ("handleDenied" in $$props2)
      $$invalidate(1, handleDenied = $$props2.handleDenied);
  };
  return [handleConfirmed, handleDenied];
}
class ReDecrypt extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { handleConfirmed: 0, handleDenied: 1 });
  }
}
const TransformTagKey_svelte_svelte_type_style_lang = "";
function create_default_slot_1(ctx) {
  let t;
  return {
    c() {
      t = text("Yes");
    },
    l(nodes) {
      t = claim_text(nodes, "Yes");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot(ctx) {
  let t;
  return {
    c() {
      t = text("No");
    },
    l(nodes) {
      t = claim_text(nodes, "No");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment(ctx) {
  let div2;
  let div0;
  let t0;
  let t1_value = ctx[0].params.tag + "";
  let t1;
  let t2;
  let encodingselector;
  let t3;
  let div1;
  let button0;
  let t4;
  let button1;
  let current;
  encodingselector = new EncodingSelector({
    props: {
      pubkey: ctx[0].params.targetPublicKey
    }
  });
  button0 = new Button({
    props: {
      type: "Yes",
      clickHandler: ctx[1],
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  button1 = new Button({
    props: {
      type: "No",
      clickHandler: ctx[2],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text("\u26A0\uFE0F Grant Access to ");
      t1 = text(t1_value);
      t2 = text(" for\r\n		");
      create_component(encodingselector.$$.fragment);
      t3 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "\u26A0\uFE0F Grant Access to ");
      t1 = claim_text(div0_nodes, t1_value);
      t2 = claim_text(div0_nodes, " for\r\n		");
      claim_component(encodingselector.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button0.$$.fragment, div1_nodes);
      t4 = claim_space(div1_nodes);
      claim_component(button1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "break-all svelte-d4tl1x");
      attr(div1, "class", "submit svelte-d4tl1x");
      attr(div2, "class", "attention rounded-lg m-4 p-4 svelte-d4tl1x");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div0, t1);
      append_hydration(div0, t2);
      mount_component(encodingselector, div0, null);
      append_hydration(div2, t3);
      append_hydration(div2, div1);
      mount_component(button0, div1, null);
      append_hydration(div1, t4);
      mount_component(button1, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].params.tag + ""))
        set_data(t1, t1_value);
      const encodingselector_changes = {};
      if (dirty & 1)
        encodingselector_changes.pubkey = ctx2[0].params.targetPublicKey;
      encodingselector.$set(encodingselector_changes);
      const button0_changes = {};
      if (dirty & 2)
        button0_changes.clickHandler = ctx2[1];
      if (dirty & 32) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4)
        button1_changes.clickHandler = ctx2[2];
      if (dirty & 32) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(encodingselector.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(encodingselector.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(encodingselector);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { props } = $$props;
  let { handleConfirmed } = $$props;
  let { handleDenied } = $$props;
  new TextDecoder();
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("handleConfirmed" in $$props2)
      $$invalidate(1, handleConfirmed = $$props2.handleConfirmed);
    if ("handleDenied" in $$props2)
      $$invalidate(2, handleDenied = $$props2.handleDenied);
  };
  return [props, handleConfirmed, handleDenied];
}
class TransformTagKey extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance, create_fragment, safe_not_equal, {
      props: 0,
      handleConfirmed: 1,
      handleDenied: 2
    });
  }
}
let confirmationComponents = {
  Default: { component: DefaultConfirmation }
};
for (const [key3, value] of Object.entries(handlers)) {
  confirmationComponents[key3] = { component: DefaultConfirmation };
}
let customizedComponents = {
  connect: { component: Connect },
  ed25519: {
    sign: {
      component: Sign
    }
  },
  arweaveWalletAPI: {
    sign: {
      component: ArweaveSign
    }
  },
  proxcryptor: {
    selfDecrypt: {
      component: Decrypt
    },
    transformTagKey: {
      component: TransformTagKey
    },
    reDecrypt: {
      component: ReDecrypt
    }
  }
};
confirmationComponents = { ...confirmationComponents, ...customizedComponents };
const Confirmer_svelte_svelte_type_style_lang = "";
export {
  Arweave$1 as A,
  Button as B,
  EncodingSelector as E,
  MessageType as M,
  NativeEventType as N,
  Resolution as R,
  generateRsaJwk as a,
  getLoadedKeys as b,
  confirmationComponents as c,
  NativeErrorName as d,
  ErrorCode as e,
  generateMnemonic as g,
  handlers as h,
  loadSecrets as l
};
//# sourceMappingURL=Confirmer.svelte_svelte_type_style_lang-0b3ba63e.js.map
