import{N as w,M as E,R as $,a as v,E as A,h as x}from"./index-e98a3999.js";import{C as ne,I as te,g as re,b as oe,c as se,h as ie,l as ae}from"./index-e98a3999.js";import"./index-f765a89f.js";import"./preload-helper-cc76a931.js";const D=(e,t)=>{const n=[];let r=!1;return{destroy(o){r||(r=!0,t(`${e}: Destroying connection`),n.forEach(s=>{s(o)}))},onDestroy(o){r?o():n.push(o)}}},I=e=>(...t)=>{e&&console.log("[Penpal]",...t)},N=({name:e,message:t,stack:n})=>({name:e,message:t,stack:n}),K=e=>{const t=new Error;return Object.keys(e).forEach(n=>t[n]=e[n]),t},b=(e,t,n)=>{const{localName:r,local:o,remote:s,originForSending:i,originForReceiving:u}=e;let h=!1;const f=d=>{if(d.source!==s||d.data.penpal!==E.Call)return;if(u!=="*"&&d.origin!==u){n(`${r} received message from origin ${d.origin} which did not match expected origin ${u}`);return}const M=d.data,{methodName:p,args:a,id:g}=M;n(`${r}: Received ${p}() call`);const y=c=>l=>{if(n(`${r}: Sending ${p}() reply`),h){n(`${r}: Unable to send ${p}() reply due to destroyed connection`);return}const m={penpal:E.Reply,id:g,resolution:c,returnValue:l};c===$.Rejected&&l instanceof Error&&(m.returnValue=N(l),m.returnValueIsError=!0);try{s.postMessage(m,i)}catch(C){if(C.name===v.DataCloneError){const S={penpal:E.Reply,id:g,resolution:$.Rejected,returnValue:N(C),returnValueIsError:!0};s.postMessage(S,i)}throw C}};new Promise(c=>c(t[p].apply(t,a))).then(y($.Fulfilled),y($.Rejected))};return o.addEventListener(w.Message,f),()=>{h=!0,o.removeEventListener(w.Message,f)}};let j=0;const H=()=>++j,F=".",L=e=>e?e.split(F):[],V=e=>e.join(F),z=(e,t)=>{const n=L(t||"");return n.push(e),V(n)},O=(e,t,n)=>{const r=L(t);return r.reduce((o,s,i)=>(typeof o[s]>"u"&&(o[s]={}),i===r.length-1&&(o[s]=n),o[s]),e),e},k=(e,t)=>{const n={};return Object.keys(e).forEach(r=>{const o=e[r],s=z(r,t);typeof o=="object"&&Object.assign(n,k(o,s)),typeof o=="function"&&(n[s]=o)}),n},Y=e=>{const t={};for(const n in e)O(t,n,e[n]);return t},Q=(e,t,n,r,o)=>{const{localName:s,local:i,remote:u,originForSending:h,originForReceiving:f}=t;let d=!1;o(`${s}: Connecting call sender`);const M=a=>(...g)=>{o(`${s}: Sending ${a}() call`);let y;try{u.closed&&(y=!0)}catch{y=!0}if(y&&r(),d){const c=new Error(`Unable to send ${a}() call due to destroyed connection`);throw c.code=A.ConnectionDestroyed,c}return new Promise((c,l)=>{const m=H(),C=R=>{if(R.source!==u||R.data.penpal!==E.Reply||R.data.id!==m)return;if(f!=="*"&&R.origin!==f){o(`${s} received message from origin ${R.origin} which did not match expected origin ${f}`);return}const T=R.data;o(`${s}: Received ${a}() reply`),i.removeEventListener(w.Message,C);let P=T.returnValue;T.returnValueIsError&&(P=K(P)),(T.resolution===$.Fulfilled?c:l)(P)};i.addEventListener(w.Message,C);const S={penpal:E.Call,id:m,methodName:a,args:g};u.postMessage(S,h)})},p=n.reduce((a,g)=>(a[g]=M(g),a),{});return Object.assign(e,Y(p)),()=>{d=!0}},U=(e,t)=>{let n;return e!==void 0&&(n=window.setTimeout(()=>{const r=new Error(`Connection timed out after ${e}ms`);r.code=A.ConnectionTimeout,t(r)},e)),()=>{clearTimeout(n)}},_=(e,t,n,r)=>{const{destroy:o,onDestroy:s}=n;return i=>{if(!(e instanceof RegExp?e.test(i.origin):e==="*"||e===i.origin)){r(`Child: Handshake - Received SYN-ACK from origin ${i.origin} which did not match expected origin ${e}`);return}r("Child: Handshake - Received SYN-ACK, responding with ACK");const h=i.origin==="null"?"*":i.origin,f={penpal:E.Ack,methodNames:Object.keys(t)};window.parent.postMessage(f,h);const d={localName:"Child",local:window,remote:window.parent,originForSending:h,originForReceiving:i.origin},M=b(d,t,r);s(M);const p={},a=Q(p,d,i.data.methodNames,o,r);return s(a),p}},G=()=>{try{clearTimeout()}catch{return!1}return!0},J=(e={})=>{const{parentOrigin:t="*",methods:n={},timeout:r,debug:o=!1}=e,s=I(o),i=D("Child",s),{destroy:u,onDestroy:h}=i,f=k(n),d=_(t,f,i,s),M=()=>{s("Child: Handshake - Sending SYN");const a={penpal:E.Syn},g=t instanceof RegExp?"*":t;window.parent.postMessage(a,g)};return{promise:new Promise((a,g)=>{const y=U(r,u),c=l=>{if(!!G()&&!(l.source!==parent||!l.data)&&l.data.penpal===E.SynAck){const m=d(l);m&&(window.removeEventListener(w.Message,c),y(),a(m))}};window.addEventListener(w.Message,c),M(),h(l=>{window.removeEventListener(w.Message,c),l&&g(l)})}),destroy(){u()}}};class X{constructor(){}async init(t){return await J({methods:{...x,...t}}).promise}}export{ne as CONSTANTS,X as Connection,te as FrontEnd,re as generateMnemonic,oe as generateRsaJwk,se as getLoadedKeys,ie as handlers,ae as loadSecrets};
