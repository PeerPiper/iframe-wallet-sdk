{"version":3,"file":"index-e4a26495.js","sources":["../../../../../../node_modules/penpal/lib/createDestructor.js","../../../../../../node_modules/penpal/lib/createLogger.js","../../../../../../node_modules/penpal/lib/errorSerialization.js","../../../../../../node_modules/penpal/lib/connectCallReceiver.js","../../../../../../node_modules/penpal/lib/generateId.js","../../../../../../node_modules/penpal/lib/methodSerialization.js","../../../../../../node_modules/penpal/lib/connectCallSender.js","../../../../../../node_modules/penpal/lib/startConnectionTimeout.js","../../../../../../node_modules/penpal/lib/child/handleSynAckMessageFactory.js","../../../../../../node_modules/penpal/lib/child/connectToParent.js","../../../../../../src/lib/engine/functions/Connection.ts","../../../../../../src/lib/frontend/constants.js"],"sourcesContent":["export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (originForReceiving !== '*' &&\n                        event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","import { MessageType } from '../enums';\nimport connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles a SYN-ACK handshake message.\n */\nexport default (parentOrigin, serializedMethods, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    return (event) => {\n        let originQualifies = parentOrigin instanceof RegExp\n            ? parentOrigin.test(event.origin)\n            : parentOrigin === '*' || parentOrigin === event.origin;\n        if (!originQualifies) {\n            log(`Child: Handshake - Received SYN-ACK from origin ${event.origin} which did not match expected origin ${parentOrigin}`);\n            return;\n        }\n        log('Child: Handshake - Received SYN-ACK, responding with ACK');\n        // If event.origin is \"null\", the remote protocol is file: or data: and we\n        // must post messages with \"*\" as targetOrigin when sending messages.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n        const originForSending = event.origin === 'null' ? '*' : event.origin;\n        const ackMessage = {\n            penpal: MessageType.Ack,\n            methodNames: Object.keys(serializedMethods),\n        };\n        window.parent.postMessage(ackMessage, originForSending);\n        const info = {\n            localName: 'Child',\n            local: window,\n            remote: window.parent,\n            originForSending,\n            originForReceiving: event.origin,\n        };\n        const destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        const callSender = {};\n        const destroyCallSender = connectCallSender(callSender, info, event.data.methodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport { MessageType, NativeEventType } from '../enums';\nimport handleSynAckMessageFactory from './handleSynAckMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport startConnectionTimeout from '../startConnectionTimeout';\nconst areGlobalsAccessible = () => {\n    try {\n        clearTimeout();\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n};\n/**\n * Attempts to establish communication with the parent window.\n */\nexport default (options = {}) => {\n    const { parentOrigin = '*', methods = {}, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Child', log);\n    const { destroy, onDestroy } = destructor;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynAckMessage = handleSynAckMessageFactory(parentOrigin, serializedMethods, destructor, log);\n    const sendSynMessage = () => {\n        log('Child: Handshake - Sending SYN');\n        const synMessage = { penpal: MessageType.Syn };\n        const parentOriginForSyn = parentOrigin instanceof RegExp ? '*' : parentOrigin;\n        window.parent.postMessage(synMessage, parentOriginForSyn);\n    };\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            // Under niche scenarios, we get into this function after\n            // the iframe has been removed from the DOM. In Edge, this\n            // results in \"Object expected\" errors being thrown when we\n            // try to access properties on window (global properties).\n            // For this reason, we try to access a global up front (clearTimeout)\n            // and if it fails we can assume the iframe has been removed\n            // and we ignore the message event.\n            if (!areGlobalsAccessible()) {\n                return;\n            }\n            if (event.source !== parent || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.SynAck) {\n                const callSender = handleSynAckMessage(event);\n                if (callSender) {\n                    window.removeEventListener(NativeEventType.Message, handleMessage);\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        sendSynMessage();\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","import { connectToParent } from \"penpal\"\r\nimport { handlers } from \"../handlers/index\"\r\n\r\nexport class Connection {\r\n    constructor() {}\r\n\r\n    async init(optHandlers) {\r\n        const connection = connectToParent({\r\n            // Methods child is exposing to parent.\r\n            methods: {\r\n                ...handlers,\r\n                ...optHandlers,\r\n            },\r\n        })\r\n\r\n        const parent = await connection.promise\r\n        return parent\r\n    }\r\n}\r\n","export const CONSTANTS = {\r\n    OPENED_SIGNAL: \"OPENED\",\r\n    KEYS_SYNC: \"KEYS_SYNC\",\r\n    WINDOW_SYNC: \"WINDOW_SYNC\",\r\n    SAVED_KEYS: \"__SAVED_KEY\",\r\n    CLOSING: \"CLOSING\",\r\n}\r\n"],"names":["createDestructor","localName","log","callbacks","destroyed","error","callback","createLogger","debug","args","serializeError","name","message","stack","deserializeError","obj","deserializedError","key","connectCallReceiver","info","serializedMethods","local","remote","originForSending","originForReceiving","handleMessageEvent","event","MessageType","callMessage","methodName","id","createPromiseHandler","resolution","returnValue","Resolution","err","NativeErrorName","errorReplyMessage","resolve","NativeEventType","generateId","KEY_PATH_DELIMITER","keyPathToSegments","keyPath","segmentsToKeyPath","segments","createKeyPath","prefix","setAtKeyPath","subject","value","prevSubject","idx","serializeMethods","methods","flattenedMethods","deserializeMethods","connectCallSender","callSender","methodKeyPaths","destroyConnection","createMethodProxy","iframeRemoved","ErrorCode","reject","replyMessage","api","startConnectionTimeout","timeout","timeoutId","handleSynAckMessageFactory","parentOrigin","destructor","destroy","onDestroy","ackMessage","destroyCallReceiver","destroyCallSender","areGlobalsAccessible","connectToParent","options","handleSynAckMessage","sendSynMessage","synMessage","parentOriginForSyn","stopConnectionTimeout","handleMessage","Connection","optHandlers","handlers","CONSTANTS"],"mappings":"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"}