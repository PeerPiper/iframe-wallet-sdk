{"version":3,"file":"index-45ba8d67.js","sources":["../../../../../../node_modules/penpal/lib/createDestructor.js","../../../../../../node_modules/penpal/lib/createLogger.js","../../../../../../node_modules/penpal/lib/errorSerialization.js","../../../../../../node_modules/penpal/lib/connectCallReceiver.js","../../../../../../node_modules/penpal/lib/generateId.js","../../../../../../node_modules/penpal/lib/methodSerialization.js","../../../../../../node_modules/penpal/lib/connectCallSender.js","../../../../../../node_modules/penpal/lib/startConnectionTimeout.js","../../../../../../node_modules/penpal/lib/child/handleSynAckMessageFactory.js","../../../../../../node_modules/penpal/lib/child/connectToParent.js","../../../../../../src/lib/engine/functions/Connection.ts","../../../../../../src/lib/frontend/constants.js"],"sourcesContent":["export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (originForReceiving !== '*' &&\n                        event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","import { MessageType } from '../enums';\nimport connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles a SYN-ACK handshake message.\n */\nexport default (parentOrigin, serializedMethods, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    return (event) => {\n        let originQualifies = parentOrigin instanceof RegExp\n            ? parentOrigin.test(event.origin)\n            : parentOrigin === '*' || parentOrigin === event.origin;\n        if (!originQualifies) {\n            log(`Child: Handshake - Received SYN-ACK from origin ${event.origin} which did not match expected origin ${parentOrigin}`);\n            return;\n        }\n        log('Child: Handshake - Received SYN-ACK, responding with ACK');\n        // If event.origin is \"null\", the remote protocol is file: or data: and we\n        // must post messages with \"*\" as targetOrigin when sending messages.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n        const originForSending = event.origin === 'null' ? '*' : event.origin;\n        const ackMessage = {\n            penpal: MessageType.Ack,\n            methodNames: Object.keys(serializedMethods),\n        };\n        window.parent.postMessage(ackMessage, originForSending);\n        const info = {\n            localName: 'Child',\n            local: window,\n            remote: window.parent,\n            originForSending,\n            originForReceiving: event.origin,\n        };\n        const destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        const callSender = {};\n        const destroyCallSender = connectCallSender(callSender, info, event.data.methodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport { MessageType, NativeEventType } from '../enums';\nimport handleSynAckMessageFactory from './handleSynAckMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport startConnectionTimeout from '../startConnectionTimeout';\nconst areGlobalsAccessible = () => {\n    try {\n        clearTimeout();\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n};\n/**\n * Attempts to establish communication with the parent window.\n */\nexport default (options = {}) => {\n    const { parentOrigin = '*', methods = {}, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Child', log);\n    const { destroy, onDestroy } = destructor;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynAckMessage = handleSynAckMessageFactory(parentOrigin, serializedMethods, destructor, log);\n    const sendSynMessage = () => {\n        log('Child: Handshake - Sending SYN');\n        const synMessage = { penpal: MessageType.Syn };\n        const parentOriginForSyn = parentOrigin instanceof RegExp ? '*' : parentOrigin;\n        window.parent.postMessage(synMessage, parentOriginForSyn);\n    };\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            // Under niche scenarios, we get into this function after\n            // the iframe has been removed from the DOM. In Edge, this\n            // results in \"Object expected\" errors being thrown when we\n            // try to access properties on window (global properties).\n            // For this reason, we try to access a global up front (clearTimeout)\n            // and if it fails we can assume the iframe has been removed\n            // and we ignore the message event.\n            if (!areGlobalsAccessible()) {\n                return;\n            }\n            if (event.source !== parent || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.SynAck) {\n                const callSender = handleSynAckMessage(event);\n                if (callSender) {\n                    window.removeEventListener(NativeEventType.Message, handleMessage);\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        sendSynMessage();\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","import { connectToParent } from \"penpal\"\r\nimport { handlers } from \"../handlers/index\"\r\n\r\nexport class Connection {\r\n    constructor() {}\r\n\r\n    async init(optHandlers) {\r\n        const connection = connectToParent({\r\n            // Methods child is exposing to parent.\r\n            methods: {\r\n                ...handlers,\r\n                ...optHandlers,\r\n            },\r\n        })\r\n\r\n        const parent = await connection.promise\r\n        return parent\r\n    }\r\n}\r\n","export const CONSTANTS = {\r\n    OPENED_SIGNAL: \"OPENED\",\r\n    KEYS_SYNC: \"KEYS_SYNC\",\r\n    WINDOW_SYNC: \"WINDOW_SYNC\",\r\n    SAVED_KEYS: \"__SAVED_KEY\",\r\n    CLOSING: \"CLOSING\",\r\n}\r\n"],"names":["id","parent"],"mappings":"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"}