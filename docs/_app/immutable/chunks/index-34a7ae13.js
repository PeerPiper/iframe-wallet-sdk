import{N as M,M as E,R as N,a as K,E as A,h as Y}from"./Index-d2106f58.js";import{I as se,b as ie,g as ae,c as ce,h as de,l as le}from"./Index-d2106f58.js";import"./index-09de7b82.js";import"./events-24eb7459.js";import"./preload-helper-6b8a655d.js";import"./index-95820fb8.js";import"./index-6ab0de96.js";const F=(e,t)=>{const n=[];let r=!1;return{destroy(o){r||(r=!0,t(`${e}: Destroying connection`),n.forEach(s=>{s(o)}))},onDestroy(o){r?o():n.push(o)}}},_=e=>(...t)=>{e&&console.log("[Penpal]",...t)},T=({name:e,message:t,stack:n})=>({name:e,message:t,stack:n}),O=e=>{const t=new Error;return Object.keys(e).forEach(n=>t[n]=e[n]),t},k=(e,t,n)=>{const{localName:r,local:o,remote:s,originForSending:i,originForReceiving:u}=e;let m=!1;const p=d=>{if(d.source!==s||d.data.penpal!==E.Call)return;if(u!=="*"&&d.origin!==u){n(`${r} received message from origin ${d.origin} which did not match expected origin ${u}`);return}const S=d.data,{methodName:f,args:a,id:g}=S;n(`${r}: Received ${f}() call`);const y=c=>l=>{if(n(`${r}: Sending ${f}() reply`),m){n(`${r}: Unable to send ${f}() reply due to destroyed connection`);return}const h={penpal:E.Reply,id:g,resolution:c,returnValue:l};c===N.Rejected&&l instanceof Error&&(h.returnValue=T(l),h.returnValueIsError=!0);try{s.postMessage(h,i)}catch(w){if(w.name===K.DataCloneError){const R={penpal:E.Reply,id:g,resolution:N.Rejected,returnValue:T(w),returnValueIsError:!0};s.postMessage(R,i)}throw w}};new Promise(c=>c(t[f].apply(t,a))).then(y(N.Fulfilled),y(N.Rejected))};return o.addEventListener(M.Message,p),()=>{m=!0,o.removeEventListener(M.Message,p)}};let v=0;const x=()=>++v,D=".",I=e=>e?e.split(D):[],b=e=>e.join(D),V=(e,t)=>{const n=I(t||"");return n.push(e),b(n)},j=(e,t,n)=>{const r=I(t);return r.reduce((o,s,i)=>(typeof o[s]>"u"&&(o[s]={}),i===r.length-1&&(o[s]=n),o[s]),e),e},L=(e,t)=>{const n={};return Object.keys(e).forEach(r=>{const o=e[r],s=V(r,t);typeof o=="object"&&Object.assign(n,L(o,s)),typeof o=="function"&&(n[s]=o)}),n},H=e=>{const t={};for(const n in e)j(t,n,e[n]);return t},z=(e,t,n,r,o)=>{const{localName:s,local:i,remote:u,originForSending:m,originForReceiving:p}=t;let d=!1;o(`${s}: Connecting call sender`);const S=a=>(...g)=>{o(`${s}: Sending ${a}() call`);let y;try{u.closed&&(y=!0)}catch{y=!0}if(y&&r(),d){const c=new Error(`Unable to send ${a}() call due to destroyed connection`);throw c.code=A.ConnectionDestroyed,c}return new Promise((c,l)=>{const h=x(),w=C=>{if(C.source!==u||C.data.penpal!==E.Reply||C.data.id!==h)return;if(p!=="*"&&C.origin!==p){o(`${s} received message from origin ${C.origin} which did not match expected origin ${p}`);return}const $=C.data;o(`${s}: Received ${a}() reply`),i.removeEventListener(M.Message,w);let P=$.returnValue;$.returnValueIsError&&(P=O(P)),($.resolution===N.Fulfilled?c:l)(P)};i.addEventListener(M.Message,w);const R={penpal:E.Call,id:h,methodName:a,args:g};u.postMessage(R,m)})},f=n.reduce((a,g)=>(a[g]=S(g),a),{});return Object.assign(e,H(f)),()=>{d=!0}},G=(e,t)=>{let n;return e!==void 0&&(n=window.setTimeout(()=>{const r=new Error(`Connection timed out after ${e}ms`);r.code=A.ConnectionTimeout,t(r)},e)),()=>{clearTimeout(n)}},W=(e,t,n,r)=>{const{destroy:o,onDestroy:s}=n;return i=>{if(!(e instanceof RegExp?e.test(i.origin):e==="*"||e===i.origin)){r(`Child: Handshake - Received SYN-ACK from origin ${i.origin} which did not match expected origin ${e}`);return}r("Child: Handshake - Received SYN-ACK, responding with ACK");const m=i.origin==="null"?"*":i.origin,p={penpal:E.Ack,methodNames:Object.keys(t)};window.parent.postMessage(p,m);const d={localName:"Child",local:window,remote:window.parent,originForSending:m,originForReceiving:i.origin},S=k(d,t,r);s(S);const f={},a=z(f,d,i.data.methodNames,o,r);return s(a),f}},Q=()=>{try{clearTimeout()}catch{return!1}return!0},U=(e={})=>{const{parentOrigin:t="*",methods:n={},timeout:r,debug:o=!1}=e,s=_(o),i=F("Child",s),{destroy:u,onDestroy:m}=i,p=L(n),d=W(t,p,i,s),S=()=>{s("Child: Handshake - Sending SYN");const a={penpal:E.Syn},g=t instanceof RegExp?"*":t;window.parent.postMessage(a,g)};return{promise:new Promise((a,g)=>{const y=G(r,u),c=l=>{if(!!Q()&&!(l.source!==parent||!l.data)&&l.data.penpal===E.SynAck){const h=d(l);h&&(window.removeEventListener(M.Message,c),y(),a(h))}};window.addEventListener(M.Message,c),S(),m(l=>{window.removeEventListener(M.Message,c),l&&g(l)})}),destroy(){u()}}};class ne{constructor(){}async init(t){return await U({methods:{...Y,...t}}).promise}}const te={OPENED_SIGNAL:"OPENED",KEYS_SYNC:"KEYS_SYNC",WINDOW_SYNC:"WINDOW_SYNC",SAVED_KEYS:"__SAVED_KEY",CLOSING:"CLOSING"};export{te as CONSTANTS,ne as Connection,se as FrontEnd,ie as generateMnemonic,ae as generateRsaJwk,ce as getLoadedKeys,de as handlers,le as loadSecrets};
//# sourceMappingURL=index-34a7ae13.js.map
